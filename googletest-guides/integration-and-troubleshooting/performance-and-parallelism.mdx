---
title: "Performance Optimization and Running Tests in Parallel"
description: "Shares techniques for reducing test suite runtime, leveraging test parallelization, and optimizing test performance for large codebases. Targets advanced users aiming for scalable, fast CI workflows."
---

# Performance Optimization and Running Tests in Parallel

GoogleTest and GoogleMock offer advanced capabilities to help developers optimize test execution times, especially critical in large codebases and continuous integration (CI) pipelines. This guide shares practical techniques to reduce overall test suite runtime by leveraging test parallelization and performance tuning.

---

## Workflow Overview

### What This Guide Helps You Accomplish
- Understand strategies to scale GoogleTest and GoogleMock to large projects.
- Leverage parallel execution to reduce wall-clock time for running tests.
- Identify and apply best practices to optimize test performance.

### Prerequisites
- Familiarity with GoogleTest and GoogleMock basics, including writing and running tests.
- Your tests organized into suites, preferably in a way that supports independent execution.
- Access to continuous integration systems or local environments capable of parallel task execution.

### Expected Outcome
- A tested workflow for running large test suites faster by executing tests concurrently.
- Practical tips to eliminate bottlenecks and run tests efficiently.

### Time Estimate
- Setting up parallel test execution and optimization will vary from minutes (enabling simple parallelism) to hours (profiling and optimizing test dependencies).

### Difficulty Level
- Intermediate to Advanced

---

## Step-by-Step Instructions

### 1. Analyze Your Test Suite

- Break down your test suites and tests to ensure they are independent and side-effect free.
- Identify tests that are slow or resource-intensive.

### 2. Enable GoogleTest Parallel Execution

GoogleTest itself does not directly support parallel test execution inside one test binary. Use external tools or options to achieve parallelism:

- **Use gtest-parallel**: an external Python-based test runner designed to run tests in parallel processes.

  ```bash
  pip install gtest-parallel
  gtest-parallel path/to/your/test_binary
  ```

- **Split your tests into multiple binaries or shards** to run concurrently.
- Use your CI platformâ€™s parallel job support to execute shards in parallel.

### 3. Control Test Sharding Using Flags

GoogleTest supports test sharding with the following command-line flags:

- `--gtest_total_shards=N`
- `--gtest_shard_index=M`

These flags enable dividing the test suite into `N` parts and running part `M`.

#### Example:

```bash
./your_test_binary --gtest_total_shards=4 --gtest_shard_index=0  # run 0th shard
./your_test_binary --gtest_total_shards=4 --gtest_shard_index=1  # run 1st shard
# ... and so forth
```

Make sure each shard is run concurrently on separate machines or parallel threads/jobs.

### 4. Profile and Identify Bottlenecks

- Use the `--gtest_print_time` flag to see test execution times.

```bash
./your_test_binary --gtest_print_time
```

- Focus optimization effort on slow tests or test suites.

### 5. Optimize Test Performance

- **Avoid shared mutable state across tests** to enable reliable parallel execution.
- **Reduce dependency on external resources** where possible or mock them out.
- **Use lightweight mock objects** with GoogleMock to decouple and speed up tests.

### 6. Configure GoogleMock Verbosity to Aid Optimization

Increase verbosity for detailed mock call tracing if needed:

```bash
./your_test_binary --gmock_verbose=info
```

This reveals mock interactions and helps identify unexpected overhead.

### 7. Parallel Tests with Multiple Threads (Advanced)

- GoogleTest supports multithreading internally with suitable thread-safe code.
- Use internal utilities such as `ThreadWithParam` (used in stress tests) to simulate concurrent test workloads.

> Note: Run your test code in a single thread while letting tested code use multiple threads for easier debugging.

### 8. Adjust Mocking Policies for Performance

- Use `NiceMock` to suppress warnings on uninteresting calls, reducing noise when running in parallel.
- Use `StrictMock` cautiously as it might make tests brittle and harder to parallelize.

### 9. Verify Test Integrity After Parallelization

- Use GoogleTest summaries and failure reports to ensure no flakiness or race conditions remain.
- Run multiple iterations to validate stability.

---

## Examples & Code Samples

### Sample Command to Run Tests with Sharding:
```bash
./test_binary --gtest_total_shards=8 --gtest_shard_index=3
```

### Using gtest-parallel to Run Tests in Parallel:
```bash
pip install gtest-parallel

gtest-parallel ./test_binary
```

### Using GoogleMock NiceMock to Reduce Verbose Warnings:
```cpp
#include <gmock/gmock.h>
using ::testing::NiceMock;

class MockFoo {
 public:
  MOCK_METHOD(void, Bar, (int), ());
};

NiceMock<MockFoo> mock_foo;
EXPECT_CALL(mock_foo, Bar(5));
```

### Profiling Test Times:
```bash
./test_binary --gtest_print_time
```

---

## Troubleshooting & Tips

### Common Issues
- **Tests fail intermittently or in parallel runs but pass serially:**
  - Check for shared mutable state causing race conditions.
  - Ensure thread safety in test fixture setup and tear down.

- **Test shards yield different results or flaky tests:**
  - Ensure deterministic ordering or independence.
  - Verify proper use of sharding flags.

- **Uninteresting mock warnings flood output:**
  - Use `NiceMock` to silence irrelevant warnings.
  - Explicitly add expected calls or suppress messages selectively.

### Best Practices
- Write tests that don't depend on order or global state.
- Use mocks to isolate external dependencies.
- Profile before optimizing to identify true bottlenecks.
- Run tests repeatedly under parallel and serial to catch flakiness early.

### Performance Considerations
- Avoid expensive setup/tear down in tests.
- Cache shared heavy resources where safe.
- Use lightweight mock objects and minimize complex matchers when unnecessary.

### Alternative Approaches
- Consider running tests in containers or sandboxed environments if dependencies conflict.
- Use custom test runners if using build systems like Bazel that support parallelism natively.

---

## Next Steps & Related Content

- Learn how to write efficient mocks in the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html).
- Deepen understanding of mock object behaviors in [Mocking Policies and Behaviors](https://google.github.io/googletest/googletest/advanced-mocking/mocking-policies-and-behaviors.html).
- Explore test suite organization in the [GoogleTest Primer](https://google.github.io/googletest/primer.html).
- Check integration tips in [Platforms and Build Systems](https://google.github.io/googletest-guides/integration-and-troubleshooting/platforms-and-build-systems.html).

---