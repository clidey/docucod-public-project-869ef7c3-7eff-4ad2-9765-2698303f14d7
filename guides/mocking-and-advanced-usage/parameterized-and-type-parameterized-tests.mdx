---
title: "Parameterized and Type-Parameterized Tests"
description: "Learn how to write tests that run over a range of input data (parameterized tests) or over multiple data types (type-parameterized tests). This guide illustrates patterns for maximizing test reuse and reducing redundancy with real examples."
---

# Parameterized and Type-Parameterized Tests

Learn how to write tests that run over a range of input data (parameterized tests) or over multiple data types (type-parameterized tests). This guide illustrates patterns for maximizing test reuse and reducing redundancy with real examples.

---

## Overview

GoogleTest offers powerful mechanisms to reuse test logic across multiple input values or data types without duplicating code:

- **Value-Parameterized Tests** allow defining a test once and running it with various parameter values.
- **Type-Parameterized Tests** enable writing test logic once that applies to multiple C++ types.
- **Type-Parameterized (Typed) Tests** differ slightly from typed tests by allowing the test pattern to be defined separately and instantiated with any type list later, supporting modular design.

These features can dramatically reduce boilerplate and improve coverage via data-driven testing.

---

## Value-Parameterized Tests

### Purpose

To test the same logic over different values without writing separate test cases for each.

### Before You Begin

- Define a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.
- Ensure that the fixture and parameter types are properly copyable.

### Writing Value-Parameterized Tests

1. **Define Fixture:**

```cpp
class MyValueTest : public testing::TestWithParam<int> {
  // Implement fixture members as needed
};
```

2. **Define Parameterized Test:**

```cpp
TEST_P(MyValueTest, HandlesValues) {
  int param = GetParam();
  EXPECT_TRUE(SomeFunction(param));
}
```

3. **Instantiate Test Suite:**

Create an instantiation with parameter values using generators in the `testing` namespace.

```cpp
INSTANTIATE_TEST_SUITE_P(ExampleInstantiation, MyValueTest,
                         testing::Values(1, 2, 3));
```

Or use container-based generators:

```cpp
const int arr[] = {4, 5, 6};
INSTANTIATE_TEST_SUITE_P(ValuesInExample, MyValueTest, testing::ValuesIn(arr));
```

### Common Parameter Generators

| Generator               | Description                                                        |
|-------------------------|--------------------------------------------------------------------|
| `Range(begin, end [, step])`   | Generates values from `begin` up to but not including `end` with optional step (default 1). |
| `Values(v1, v2, ..., vN)`      | Yields the listed values explicitly.                            |
| `ValuesIn(container)`/`ValuesIn(begin, end)` | Takes values from a container or iterator range.             |
| `Bool()`                  | Generates `false` and `true`.                                   |
| `Combine(g1, g2, ..., gN)`    | Generates tuples from the Cartesian product of multiple generators. |

### Accessing Parameters

Inside your test, use `GetParam()` to access the current parameter value.

### Parameter Naming

You can provide a custom naming function to suffix test names based on parameters for readability:

```cpp
INSTANTIATE_TEST_SUITE_P(
  CustomNames, MyValueTest, testing::Values(1, 2, 3),
  [](const testing::TestParamInfo<int>& info) {
    return "Param_" + std::to_string(info.param);
  });
```

---

## Typed Tests

### Purpose

To verify that multiple types conform to the same behavior without duplicating test logic per type.

### About

Typed tests repeat the same tests for a known fixed list of types defined at compile time.

### Steps to Write Typed Tests

1. **Define a Template Fixture:**

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  // Define typed test fixture members
  T value_{};
};
```

2. **Define a Type List:**

```cpp
using MyTypes = ::testing::Types<int, char, unsigned int>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write Typed Tests Using `TYPED_TEST`:**

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam{});
}
```

4. **Compile and Run:** Tests will be executed for each type in `MyTypes`.

### Optional: Custom Type Naming

To generate human-readable type suffixes in test names, define a `NameGenerator` class with a static template `GetName(int)` method:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same_v<T, int>) return "int";
    if (std::is_same_v<T, char>) return "char";
    // Add more as needed
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Notes

- Inside tests, access the type with the special identifier `TypeParam`.
- Use `this->` to access members when inside test bodies due to C++ scoping rules.

---

## Type-Parameterized (Type-Parameterized) Tests

### Purpose

To define test suite patterns independent of the types tested. Types may be supplied and instantiated later, even multiple times, allowing modular reusable test suites.

### How It Differs from Typed Tests

- Typed tests require the type list at definition time.
- Type-parameterized tests defer knowing types until instantiation.

### Steps to Write Type-Parameterized Tests

1. **Define the Template Fixture:**

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // Fixture members
};
```

2. **Declare a Type-Parameterized Test Suite:**

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define Type-Parameterized Tests:**

```cpp
TYPED_TEST_P(MyTypeParamTest, DoesThing) {
  EXPECT_EQ(0, TypeParam());
}
```

4. **Register Tests:**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesThing);
```

5. **Instantiate the Suite with Types:**

```cpp
using ImplTypes = ::testing::Types<short, long>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, MyTypeParamTest, ImplTypes);
```

### Custom Type Naming

Similar to typed tests, you can provide a custom name generator class when instantiating:

```cpp
class MyNameGen {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same_v<T, short>) return "short";
    if (std::is_same_v<T, long>) return "long";
  }
};

INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, MyTypeParamTest, ImplTypes, MyNameGen);
```

---

## Best Practices and Tips

- Avoid underscores (`_`) in test suite and test names to prevent naming conflicts.
- When using typed and type-parameterized tests, be explicit and consistent with naming for clarity.
- Use custom name generators for readability when test types or parameter values are complex.
- Always instantiate your parameterized or typed tests. Omitting instantiation causes failures in the `GoogleTestVerification` suite.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you intentionally omit instantiations for some test suites.

---

## Troubleshooting

### Common Issues

- **Tests Not Running:** Ensure that value-parameterized or type-parameterized tests are *instantiated* with `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` macros; otherwise, tests won't run.
- **Naming Collisions:** Avoid underscores and ensure unique names for fixtures and tests to prevent runtime errors.
- **Accessing Parameters:** When using typed tests, remember to access fixture members through `this->` due to C++ template name lookup rules.
- **Custom Parameter Names Not Appearing:** Verify your name generator functions are correctly provided and that generated names are valid C++ identifiers without spaces.

---

## Examples

### Value-Parameterized Test Example

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Typed Test Example

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {
 public:
  T value_ = T{};
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, DefaultIsZero) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class StackTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(StackTest);

TYPED_TEST_P(StackTest, IsEmptyInitially) {
  Stack<TypeParam> stack;
  EXPECT_TRUE(stack.empty());
}

REGISTER_TYPED_TEST_SUITE_P(StackTest, IsEmptyInitially);

using IntFloatTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyStackTests, StackTest, IntFloatTypes);
```

---

## Next Steps

- Explore [GoogleTest Primer](primer.md) for foundational concepts.
- Deepen your understanding with the [Advanced Topics guide](advanced.md).
- Familiarize with [Assertion Reference](reference/assertions.md) for writing better assertions.
- Review [Organizing and Running Test Suites](guides/core-testing-workflows/organizing-and-running-test-suites) for execution strategies.
- Learn about [Mocking with GoogleMock](guides/mocking-and-advanced-usage/mocking-with-gmock) to isolate dependencies in tests.

---

## References

- [GoogleTest Primer](primer.md)
- [Testing Reference](reference/testing.md)
- [Advanced GoogleTest Topics](advanced.md)
- [Testing FAQ](faq.md)

---

## Summary

This guide explains how to leverage GoogleTest's parameterized and type-parameterized tests to write concise, reusable test suites. By defining tests once and running them across a variety of input values or types, users gain comprehensive coverage with less code and clearer maintenance. Examples illustrate typical usage patterns, and tips help avoid common pitfalls.


