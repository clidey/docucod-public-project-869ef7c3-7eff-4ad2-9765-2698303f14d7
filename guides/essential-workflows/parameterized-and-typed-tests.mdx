---
title: "Parameterized and Typed Tests"
description: "Learn to create flexible, reusable tests that run across different input data and types. Covers value-parameterized and type-parameterized tests, including patterns for scaling test coverage efficiently."
---

# Parameterized and Typed Tests

Learn to create flexible, reusable tests that run across different input data and types. This guide covers both value-parameterized and type-parameterized tests, providing patterns for efficiently scaling test coverage.

---

## Overview

### What You Will Achieve
By following this guide, you will:
- Write tests that run multiple times with different input data, reducing redundant code.
- Create type-parameterized tests that verify behavior across different data types.
- Understand how to organize parameterized tests for maintainability and clarity.

### Prerequisites
- Basic familiarity with GoogleTest and writing simple test cases.
- Environment set up for building and running GoogleTest-based tests.
- Understanding of C++ templates and test fixtures.

### Expected Outcome
After completing this guide, you will be able to write robust parameterized tests that cover more scenarios systematically and have clear, maintainable test code.

### Time Estimate
15-30 minutes depending on your familiarity with templates and GoogleTest.

### Difficulty Level
Intermediate

---

## Value-Parameterized Tests

Value-parameterized tests allow a test case to be instantiated multiple times with different input values provided externally. This helps cover multiple cases without duplicating code.

### Step 1: Define a Parameterized Test Fixture
Create a test fixture class deriving from `::testing::TestWithParam<T>`, where `T` is the type of the parameter.

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // Optionally override SetUp() and TearDown()
};
```

### Step 2: Write Tests Using the Parameter
Inside the test body, use `GetParam()` to access the test parameter.

```cpp
TEST_P(MyParamTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

### Step 3: Instantiate the Test Case with Values
Use `INSTANTIATE_TEST_SUITE_P` to create instances of the test with various parameter values.

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers,
    MyParamTest,
    ::testing::Values(2, 4, 6, 8));
```

You can pass any iterable or generator as parameters such as `Values`, `Range`, or `Combine` for tuples.

### Example
```cpp
class IsPrimeTest : public ::testing::TestWithParam<int> {};

TEST_P(IsPrimeTest, CheckPrime) {
  int n = GetParam();
  EXPECT_TRUE(IsPrime(n));
}

INSTANTIATE_TEST_SUITE_P(
    PrimeNumbers,
    IsPrimeTest,
    ::testing::Values(2, 3, 5, 7, 11, 13));
```

<Check>
Make sure that the parameter type matches exactly in `TestWithParam<T>`. If you need to pass multiple parameters, use `std::tuple` or aggregate structs.
</Check>

---

## Typed Tests

Typed tests enable running the same test logic on different types, e.g., to verify a template class under multiple instantiations.

### Step 1: Define a Typed Test Fixture
Declare a template test fixture class template inheriting from `::testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // Common setup for type T
};
```

### Step 2: Declare the Test Suite and Write Tests
Use `TYPED_TEST_SUITE` to declare the list of types your tests will run against.
Write tests using `TYPED_TEST` macro instead of `TEST` or `TEST_F`.

```cpp
using MyTypes = ::testing::Types<int, long, unsigned>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Use it to avoid warnings
  SUCCEED();  // Just check it compiles and constructs.
}
```

### Example
```cpp
template <typename T>
class Stack {
 public:
  void Push(const T&);
  void Pop();
  T Top() const;
};

template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using StackTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(StackTest, StackTypes);

TYPED_TEST(StackTest, InitiallyEmpty) {
  EXPECT_THROW(this->stack_.Top(), std::out_of_range);
}
```

<Note>
Typed tests focus only on the type; no input parameters are passed. For multiple parameters combined with types, consider value-parameterized typed tests.
</Note>

---

## Best Practices for Parameterized and Typed Tests

- **Keep Test Logic Independent:** Your test logic should be independent from the parameters or types to maximize reuse.
- **Use Descriptive Instantiation Names:** In `INSTANTIATE_TEST_SUITE_P`, pick meaningful prefixes describing what the parameters represent.
- **Combine Matchers and Parameters:** When parameters become complex (e.g., structs or tuples), carefully unpack and match only what is needed.
- **Retire Expectations:** Use `.RetiresOnSaturation()` on expectations within repetitive sequences to avoid sticky expectations causing false failures.
- **Use Sequences for Ordered Calls:** When order matters, wrap expectations in `InSequence` blocks.

---

## Advanced Patterns

### Using Tuples for Multiple Parameters
Parameterized tests can take tuples as parameters to pass multiple values:

```cpp
class MultipleParamTest : public ::testing::TestWithParam<std::tuple<int, char>> {};

TEST_P(MultipleParamTest, TestCase) {
  int a = std::get<0>(GetParam());
  char b = std::get<1>(GetParam());
  // Test with a, b
}

INSTANTIATE_TEST_SUITE_P(
    ComboTests,
    MultipleParamTest,
    ::testing::Values(std::make_tuple(1, 'a'), std::make_tuple(2, 'b')));
```

### Typed Test with Type Aliases
You can alias complex types to simplify readability in typed tests.

---

## Troubleshooting

### Common Issues and Solutions

| Problem                          | Cause                                           | Solution                                        |
|---------------------------------|-------------------------------------------------|------------------------------------------------|
| Test instantiation fails to compile | Parameter type mismatch                          | Verify that the type passed to `TestWithParam<T>` or `TYPED_TEST_SUITE` matches test parameter type exactly |
| Unexpected test failures on repeated calls | Expectations are "sticky" by default causing upper bound violation | Use `.RetiresOnSaturation()` or organize calls in `InSequence` blocks |
| Confusing test names in output  | Lack of descriptive prefixes in instantiation   | Use meaningful prefix names in `INSTANTIATE_TEST_SUITE_P` |
| Ambiguous overload in typed tests | Multiple overloads cause ambiguity              | Specify a mock interface or use `using` declarations to clarify |

<Warning>
Expectations in parameterized tests must be set before running tests. Do not set expectations or call mocks outside test setups to avoid undefined behavior.
</Warning>

---

## Examples

### Value-Parameterized Test Example
```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, HandlesEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

### Typed Test Example
```cpp
template <typename T>
class MathTest : public ::testing::Test {};

using MathTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MathTest, MathTypes);

TYPED_TEST(MathTest, CanMultiplyByTwo) {
  TypeParam value = 3;
  TypeParam result = value * 2;
  EXPECT_EQ(result, 6);
}
```

### Composite Parameterized and Typed Tests
You can combine typed and value parameters using custom tuple parameters or writing separate test suites.

---

## Summary

This guide demonstrated how to effectively use GoogleTest's parameterized and typed test features to create reusable and scalable test suites across various input values and types. By adopting these techniques, you can significantly improve test coverage while keeping your codebase clean and maintainable.


---

## Next Steps & Related Content

- Explore the [Writing Your First Test](../getting-started/first-test-validation/writing-running-first-test) guide to establish foundational testing skills.
- Learn [Basic Mocking with GoogleMock](../guides/getting-started/basic-mocking) to complement parameterized tests with mock objects.
- Study the [Using Assertions Effectively](../guides/essential-workflows/using-assertions) document to write powerful test assertions within your parameterized tests.
- Review the [Test Discovery and Execution](../guides/essential-workflows/test-discovery-execution) for best practices on running parameterized and typed tests within your CI/CD pipelines.


---

## References

- [gMock for Dummies](../docs/gmock_for_dummies.md) — Understand basic mocking concepts.
- [Mocking Reference](../docs/reference/mocking.md) — Detailed API and macros for mocking.
- [Actions Reference](../docs/reference/actions.md) — How to influence mock behavior.
- [gMock Cookbook](../docs/gmock_cook_book.md) — Practical recipes for advanced mocking.


---

## Additional Tips

<Tip>
Remember that parameterized and typed tests help you express many tests succinctly. Start with small parameter sets and types, then scale up as needed.
</Tip>

<Tip>
Use meaningful parameter names and clear test names when instantiating suites; it improves test reports and debugging efficiently.
</Tip>

<Tip>
When combining multiple parameters, consider using tuples or structs for better readability and ease of access inside tests.
</Tip>

---

For more information, visit:
- [GoogleTest Official Site](https://google.github.io/googletest/)
- [GoogleMock Cheatsheet](../docs/gmock_cheat_sheet.md)


<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "docs/gmock_for_dummies.md"}, {"path": "docs/gmock_cheat_sheet.md"}, {"path": "docs/reference/mocking.md"}, {"path": "docs/reference/actions.md"}, {"path": "docs/gmock_cook_book.md"}]} />
