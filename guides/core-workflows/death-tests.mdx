---
title: "Using Death Tests Safely and Effectively"
description: "A hands-on overview of writing and structuring death tests to verify that code exits or fails under specific error conditions. Learn best practices to ensure death tests are robust, reliable, and cross-platform."
---

# Using Death Tests Safely and Effectively

## Overview

Death tests are a powerful way to verify that your code properly terminates or fails under expected error conditions. This guide provides practical instructions and best practices for writing robust and reliable death tests using GoogleTest. You will learn how to structure death tests, configure them for thread safety and cross-platform compatibility, and avoid common pitfalls.

---

## 1. Understanding Death Tests

### What are Death Tests?

Death tests check that certain code paths cause your program to terminate (crash, exit with an error, or be killed by a signal) in an expected way. They are particularly useful for verifying assertion failures, fatal errors, or other conditions that require the program to stop immediately.

### Why Use Death Tests?

- Ensure that your safety checks and assertions trigger when expected.
- Verify that your program fails fast to avoid further damage or undefined behavior.
- Increase confidence in handling invalid or dangerous inputs gracefully.

### When to Use Death Tests

- To confirm that invalid API usage triggers `assert()` or other precondition checks.
- To verify that misuse of resources results in the process terminating safely.
- To check that fatal signal handlers or system-level failures occur as expected.

---

## 2. Prerequisites

Before writing death tests, ensure:

- Your test environment supports death tests (`GTEST_HAS_DEATH_TEST` must be true).
- Your test program is invoked with a path containing at least one path separator (e.g., `./my_test` or `/usr/bin/my_test`), required for the "threadsafe" style.
- You understand how to write basic GoogleTest tests and assertions.
- You have a proper setup for thread management if using multithreaded tests.

---

## 3. Death Test Styles

GoogleTest supports two death test execution styles controlled by the `--gtest_death_test_style` flag:

| Style       | Description                                                        | When to Use                             |
|-------------|--------------------------------------------------------------------|---------------------------------------|
| `fast`      | Child process immediately executes death test code after fork().   | Use for faster tests, single-threaded.|
| `threadsafe`| Child process re-executes the test binary, running only the death test. | Use when multithreaded environment or thread safety matters. |

The default style is `fast`, but `threadsafe` is more robust in multithreaded programs. On Windows, death tests are always `threadsafe`.

### How to Set the Style

You can set the style globally before your tests run:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  GTEST_FLAG_SET(death_test_style, "threadsafe");
  return RUN_ALL_TESTS();
}
```

Or locally within individual tests:

```cpp
TEST(MyDeathTest, ThreadSafeStyle) {
  GTEST_FLAG_SET(death_test_style, "threadsafe");
  ASSERT_DEATH(SomeFunctionThatDies(), "expected error message");
}
```

---

## 4. Writing Basic Death Tests

### Macros to Use

- `ASSERT_DEATH(statement, matcher)`: A fatal assertion that `statement` causes termination with stderr matching `matcher`.
- `EXPECT_DEATH(statement, matcher)`: Like `ASSERT_DEATH` but nonfatal (allows test to continue).
- `ASSERT_EXIT(statement, predicate, matcher)`: Asserts process exits with status matching `predicate` and stderr matching `matcher`.
- `EXPECT_EXIT(statement, predicate, matcher)`: Like `ASSERT_EXIT` but nonfatal.
- `EXPECT_DEBUG_DEATH` / `ASSERT_DEBUG_DEATH`: Like `EXPECT_DEATH` / `ASSERT_DEATH` but only active in debug mode.

### Example 1: Check that a function causes the program to die

```cpp
TEST(ServerDeathTest, InvalidPort) {
  ASSERT_DEATH(server.SendMessage(56, "Hello"), "Invalid port number");
}
```

### Example 2: Repeated death tests inside loops

```cpp
TEST(RequestProcessorDeathTest, InvalidRequests) {
  for (int i = 0; i < 5; ++i) {
    EXPECT_DEATH(server.ProcessRequest(i), "Invalid request .* in ProcessRequest()") 
        << "Failed on request " << i;
  }
}
```

### Example 3: Assert specific exit code with stderr match

```cpp
TEST(ProcessExitDeathTest, NormalExit) {
  ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), "Exiting");
}
```

### Exit Status Predicate Helpers

GoogleTest provides built-in predicate classes for exit codes:

- `::testing::ExitedWithCode(int exit_code)`: Matches exit with exact code.
- `::testing::KilledBySignal(int signal_number)`: Matches termination by signal (not on Windows).

---

## 5. Understanding the Death Test Execution Flow

When a death test macro is executed, GoogleTest:

1. Checks that only a single thread is active; warns otherwise.
2. Forks (or uses clone/process spawn) a child process.
3. The child process runs the death test logic.
4. Child process exits with a status code.
5. The parent process collects child's stderr output and exit status.
6. The parent matches stderr output against the provided matcher and exit status against the expected predicate.
7. Test passes or fails accordingly.

<Tip>
Be aware that all side effects of the tested code happen *only* in the child process. Changes to shared data or resource deallocation won’t be observed by the parent.
</Tip>

---

## 6. Best Practices for Death Tests

### 6.1. Naming

Name your test suites with a `*DeathTest` suffix to help GoogleTest run them early and warn about threading risks.

```cpp
class FooDeathTest : public testing::Test { ... };

TEST_F(FooDeathTest, DiesOnBadInput) { ... }
```

If you use the same fixture for normal and death tests, create an alias:

```cpp
using FooDeathTest = FooTest;
```

### 6.2. Avoid Multiple Threads When Possible

Forking in a multithreaded context can cause deadlocks or undefined behavior. Try to reduce active threads before running death tests.

### 6.3. Beware of Side Effects

Since death test statements run in a subprocess, any side effects (e.g., dynamic memory frees) won’t be visible to the parent. This can cause false positives in memory leak detectors.

### 6.4. Use Proper Regex Patterns

The matcher for stderr output supports:

- **POSIX Extended Regex** on UNIX/Linux
- A **limited regex subset** on Windows/macOS

Unsupported features on Windows include:

- Alternation (`x|y`)
- Grouping (`(xy)`)
- Character classes (`[xy]`)
- Repetition counts (`x{m,n}`)

Keep your regex patterns simple and compatible to avoid run-time failures.

### 6.5. Place Only One Death Test per Line

Multiple death test macros on the same line cause compilation errors; keep one per line.

### 6.6. Avoid `return` or Exception in Death Test Statements

The death test statement should *not* contain `return` statements or uncaught exceptions, as they cause the death test to fail.

To verify functions that may throw, use exception assertions separately.

### 6.7. Use `EXPECT_DEBUG_DEATH` Wisely

`EXPECT_DEBUG_DEATH` runs assertion checks only in debug mode. In opt (release) mode, the statement executes normally. Use it for functions that intentionally die only in debug builds.

Example:

```cpp
EXPECT_DEBUG_DEATH(SomeDebugOnlyFailingFunction(), "failure message");
```

---

## 7. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Death Tests">
<Accordion title="Death Test Fails Because Statement Does Not Die">
Sometimes the statement under test doesn’t terminate the process as expected.

- Confirm that the tested code calls `exit()`, `_Exit()`, raises a signal, or causes an assertion failure.
- Avoid code paths that simply return normally or throw exceptions.
</Accordion>
<Accordion title="Regular Expression Matching Failed">
The matcher regex might fail due to using unsupported regex constructs.

- Simplify the regex, avoiding alternations, grouping, and character classes on Windows/macOS.
- Use literal patterns where possible.
- Test your regex against the actual stderr output.
</Accordion>
<Accordion title="Death Test Timing Out or Hanging">
Forking from a multithreaded process may cause deadlocks.

- Reduce the number of active threads before the death test.
- Switch to `threadsafe` death test style if needed.
- Avoid signal handlers or global state that may deadlock.
</Accordion>
<Accordion title="Test Fails but The Error Message is Missing or Incomplete">
Captured stderr may not contain expected output due to buffering or logging issues.

- Ensure that logs and output are flushed before the program exits.
- Use `fflush(stderr)` or similar where applicable.
</Accordion>
</AccordionGroup>

---

## 8. Advanced Usage Tips

### Streaming Messages into Death Tests

You can add custom failure messages using streaming syntax:

```cpp
EXPECT_DEATH({ DoSomethingDangerous(); }, "ERROR") << "Additional context: " << var;
```

### Using Compound Statements

Death tests allow blocks of code inside braces:

```cpp
ASSERT_DEATH({
  int x = 5;
  FunctionThatFails(x);
}, "fail message");
```

### Using Predicates with `ASSERT_EXIT` and `EXPECT_EXIT`

More control of exit codes lets you write:

```cpp
EXPECT_EXIT(FunctionThatExitsNormally(), testing::ExitedWithCode(0), "Success");
```

or use custom predicates:

```cpp
bool KilledBySIGHUP(int exit_code) {
  return WIFSIGNALED(exit_code) && WTERMSIG(exit_code) == SIGHUP;
}
EXPECT_EXIT(FunctionThatHangsUp(), KilledBySIGHUP, "Hanging up!");
```

### Integrating with Thread-Safe Death Tests

GoogleTest optionally uses `clone()` on Linux to create more thread-safe death tests than `fork()`.

- Disable this with the flag `--gtest_death_test_use_fork=true` if your environment or tools (like Valgrind) don’t support `clone()`.
- The `threadsafe` style is recommended for environments where threads may be active before your death test.

---

## 9. Summary

Death tests are essential to confirm that your applications fail fast and fail safe. Using GoogleTest's death test macros with suitable styles, you can write tests that verify your program terminates on invalid conditions, helping prevent bugs and security issues.

Stay mindful of thread safety, side effects, and regex limitations, and choose your death test style based on your environment. Employ detailed error messages and predicate assertions to ensure clarity and precision in your test failures.

By following this guide's best practices, you will write maintainable, reliable, and cross-platform death tests effectively.

---

## 10. Related Documentation and Resources

- [GoogleTest Primer](primer.md): Learn the basics of test writing.
- [Assertions Reference](reference/assertions.md#death): Detailed info on death test assertions.
- [Advanced Guide: Death Tests](advanced.md#death-tests): In-depth explanation of death test mechanics.
- [Core Concepts and Terminology](overview/concepts-architecture-terminology/core-concepts-terminology.mdx): Understand GoogleTest vocabulary.
- [Using Death Tests Safely and Effectively](guides/core-workflows/death-tests): A complementary guide with workflows.

---

## Appendix: Regular Expression Syntax Supported in Death Tests

| Expression | Meaning                                           |
|------------|--------------------------------------------------|
| `c`        | Matches literal character `c`                     |
| `\d`      | Matches any decimal digit                          |
| `\D`      | Matches any non-decimal digit                      |
| `\f`      | Matches form feed `\f`                            |
| `\n`      | Matches newline `\n`                              |
| `\r`      | Matches carriage return `\r`                      |
| `\s`      | Matches ASCII whitespace including `\n`          |
| `\S`      | Matches any non-whitespace character               |
| `\t`      | Matches tab `\t`                                  |
| `\v`      | Matches vertical tab `\v`                         |
| `\w`      | Matches letter, underscore or digit                |
| `\W`      | Matches any non-`\w` character                     |
| `\c`      | Matches a punctuation literal                       |
| `.`        | Matches any character except `\n`                  |
| `A?`       | Matches 0 or 1 occurrences of `A`                   |
| `A*`       | Matches 0 or more occurrences of `A`                |
| `A+`       | Matches 1 or more occurrences of `A`                |
| `^`        | Matches string start (not line start)               |
| `$`        | Matches string end (not line end)                   |
| `xy`       | Matches `x` followed by `y`                         |

---

## Example: Writing a Death Test

```cpp
#include <gtest/gtest.h>

// Function expected to die when input is zero.
void MustNotBeZero(int x) {
  if (x == 0) {
    fprintf(stderr, "Input cannot be zero!\n");
    abort();
  }
}

TEST(MustNotBeZeroDeathTest, DiesOnZeroInput) {
  ASSERT_DEATH(MustNotBeZero(0), "Input cannot be zero");
}

TEST(MustNotBeZeroDeathTest, DoesNotDieOnNonZero) {
  // This test verifies the function does not die for valid input.
  MustNotBeZero(5);
}
```

This example shows a simple death test verifying that passing zero causes the program to abort, and the error message contains the expected text.

---