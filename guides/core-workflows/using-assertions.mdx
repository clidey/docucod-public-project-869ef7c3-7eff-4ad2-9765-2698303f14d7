---
title: "Using Assertions Effectively"
description: "Learn to leverage GoogleTest's rich set of assertions for validating conditions, checking for exceptions, and handling fatal/non-fatal failures. Includes practical examples and best practices for clear, actionable testing outcomes."
---

# Using Assertions Effectively

Learn to leverage GoogleTest's rich set of assertions for validating conditions, checking for exceptions, and handling fatal/non-fatal failures. Includes practical examples and best practices for clear, actionable testing outcomes.

---

## Overview

Assertions are the core of GoogleTest, enabling you to validate conditions during test execution. GoogleTest provides a comprehensive and expressive set of assertion macros designed to fit a variety of testing needs—from simple Boolean checks to complex predicates, floating-point comparisons, exception capturing, and more.

This guide will help you effectively use assertions to write clear, robust, and informative tests.

---

## 1. Core Assertion Types

GoogleTest's assertions come in pairs, differing in how they handle failures:

- **`EXPECT_*` assertions**: Generate **nonfatal failures**. Test continues after the failure.
- **`ASSERT_*` assertions**: Generate **fatal failures**. Abort the current function immediately.

Choose `EXPECT_*` when you want to continue testing even if a condition fails, and `ASSERT_*` when continuing after failure does not make logical sense (e.g., when further test code depends on a condition).

### Examples

```cpp
// Nonfatal check: test continues after failure
EXPECT_EQ(foo.size(), expected_size) << "Size mismatch detected.";

// Fatal check: test aborts if condition is false
ASSERT_NE(ptr, nullptr) << "Pointer must not be null";
```

---

## 2. Using Boolean Assertions

### `EXPECT_TRUE(condition)` and `ASSERT_TRUE(condition)`
Verify that a condition is true.

### `EXPECT_FALSE(condition)` and `ASSERT_FALSE(condition)`
Verify that a condition is false.

They accept either Boolean expressions or `AssertionResult` values.

### Best Practice

Instead of writing complex Boolean expressions in `EXPECT_TRUE()`, consider:

- Using predicate assertions that print better failure messages.
- Writing predicates returning `testing::AssertionResult` (see Section 3).

### Example

```cpp
EXPECT_TRUE(IsPrime(n));
EXPECT_FALSE(vector.empty());
```

On failure, GoogleTest shows the condition and actual Boolean value.

---

## 3. Predicate Assertions for Enhanced Feedback

When you want to verify complex conditions and get meaningful failure diagnostic messages, predicate assertions are your solution.

### Using a Boolean Predicate Function: `EXPECT_PRED*()`

GoogleTest provides `EXPECT_PRED1`, `EXPECT_PRED2`, ... for predicates that return `bool`.

```cpp
bool IsEven(int n) { return n % 2 == 0; }
...
EXPECT_PRED1(IsEven, x);
EXPECT_PRED2(AreEqual, a, b);
```

Failure message shows argument values automatically:

```
IsEven(x) evaluates to false, where
x evaluates to 3
```

### Using a Predicate Returning `AssertionResult`: `EXPECT_PRED_FORMAT*()`

To produce even richer messages, write predicates returning `testing::AssertionResult`:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess() << n << " is even";
  else return testing::AssertionFailure() << n << " is odd";
}
```

Use it in assertions:

```cpp
EXPECT_PRED_FORMAT1(IsEven, x);
```

When it fails, GoogleTest outputs:

```
Value of: IsEven(x)
  Actual: false (3 is odd)
Expected: true
```

This method provides the clearest failure diagnostics.

### Tips
- Predicate-format functions accept expression text and values for better messages.
- Can handle arguments not streamable directly.

---

## 4. Binary Comparison Assertions

GoogleTest supports relational assertions comparing two values, producing detailed failure messages if they don't match.

| Assertion       | Meaning                             |
|-----------------|-----------------------------------|
| `EXPECT_EQ`     | Verifies equality (`==`)           |
| `EXPECT_NE`     | Verifies inequality (`!=`)         |
| `EXPECT_LT`     | Verifies less than (`<`)           |
| `EXPECT_LE`     | Verifies less or equal (`<=`)      |
| `EXPECT_GT`     | Verifies greater than (`>`)        |
| `EXPECT_GE`     | Verifies greater or equal (`>=`)   |

Fatal variants: `ASSERT_EQ`, `ASSERT_NE`, etc.

### Notes
- For pointers, `EXPECT_EQ` compares memory addresses. To compare C strings by content use the string assertions (Section 5).
- Arguments are evaluated exactly once.

### Example

```cpp
EXPECT_EQ(x, y) << "x and y must be equal";
ASSERT_LT(value, limit) << "value is too large";
```

---

## 5. String Assertions

For comparing C-style strings by content, use:

| Assertion             | Meaning                               |
|-----------------------|-------------------------------------|
| `EXPECT_STREQ`        | Verifies strings are equal           |
| `EXPECT_STRNE`        | Verifies strings are not equal       |
| `EXPECT_STRCASEEQ`    | Case-insensitive equality            |
| `EXPECT_STRCASENE`    | Case-insensitive inequality          |

Fatal variants: `ASSERT_STREQ`, etc.

Supports `const char*`, `wchar_t*` wide strings (converted internally to UTF-8 for messages).

### Example

```cpp
EXPECT_STREQ(actual_c_str, expected_c_str);
ASSERT_STRNE(incorrect_c_str, expected_c_str);
```

Use these for strings to avoid pointer equality pitfalls common with `EXPECT_EQ`.

---

## 6. Floating-Point Comparisons

Due to rounding and representation errors, `EXPECT_EQ` is unsuitable for floating-point values. Instead, use:

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`: checks float approximate equality (within 4 ULPs).
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`: checks double approximate equality.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`: checks the difference against a specified absolute error.

### Example

```cpp
EXPECT_FLOAT_EQ(3.14f, calculated_value);
ASSERT_NEAR(measured, expected, 0.01);
```

---

## 7. Exception Assertions

Use these assertions to verify that a statement throws or does not throw exceptions (requires exceptions enabled in your build).

| Assertion              | Description                                  |
|------------------------|----------------------------------------------|
| `EXPECT_THROW(stmt, ExceptionType)`   | Verifies statement throws exception type     |
| `EXPECT_ANY_THROW(stmt)`               | Verifies statement throws any exception      |
| `EXPECT_NO_THROW(stmt)`                | Verifies statement does not throw             |

Fatal variants: `ASSERT_THROW`, `ASSERT_ANY_THROW`, `ASSERT_NO_THROW`.

### Example

```cpp
EXPECT_THROW(ThrowAnInteger(), int);
ASSERT_NO_THROW(ExecuteSafeCode());
```

For compound statements, wrap in braces:

```cpp
EXPECT_NO_THROW({
  int n = 5;
  DoSomething(n);
});
```

---

## 8. Catching Failures in Subroutines

**Common Pitfall:** `ASSERT_*` failures abort only the current void-returning function, not the whole test. If a fatal assertion is inside a helper function returning non-void, the test continues after the function returns, which can cause crashes or undefined behavior.

### Solutions:

### a) Use `ASSERT_NO_FATAL_FAILURE` / `EXPECT_NO_FATAL_FAILURE`

Wrap calls to subroutines to check that the subroutine generated no fatal failures:

```cpp
ASSERT_NO_FATAL_FAILURE(Subroutine());
```

If the subroutine has fatal failures, the assertion reports failure and helps prevent further undefined behavior.

### b) Check `HasFatalFailure()`

Manually check after calling the subroutine:

```cpp
Subroutine();
if (testing::Test::HasFatalFailure()) return;  // Abort test early
```

This simulates exceptions’ early abort behavior.

### c) Convert fatal failures into exceptions with a custom listener

Define a listener that throws an exception on fatal failures, causing test abortion:

```cpp
class ThrowListener : public testing::EmptyTestEventListener {
  void OnTestPartResult(const testing::TestPartResult& result) override {
    if (result.fatally_failed()) throw std::runtime_error("Assertion failed");
  }
};

// Add the listener during test setup
```

This allows using `ASSERT_*` in void and non-void functions but is an advanced technique.

---

## 9. Explicit Success and Failure

Sometimes you need to explicitly mark success or failure, regardless of a condition.

- `SUCCEED()`: Generates success (for documentation or when a test passes a certain point).
- `FAIL()`: Generates a fatal failure immediately aborting the current function.
- `ADD_FAILURE()`: Generates nonfatal failure allowing test execution to continue.

### Example

```cpp
if (unexpected_condition) {
  FAIL() << "Unexpected state encountered!";
}
```

---

## 10. Logging Additional Information with `RecordProperty`

You can attach key/value properties to tests for richer reporting (e.g., for custom XML reports).

Usage (inside tests or setups):

```cpp
RecordProperty("KeyName", "Value");
RecordProperty("IntValue", 123);
```

### Notes
- Keys must not conflict with reserved keys such as `name`, `status`, `time`, `classname`, etc.
- Calls in tests appear in `<testcase>` in XML; in `SetUpTestSuite`/`TearDownTestSuite` appear in `<testsuite>`, and outside tests in `<testsuites>`.

---

## 11. Best Practices & Common Pitfalls

- Use `EXPECT_*` when you want to continue testing after failures.
- Use `ASSERT_*` when continuing is unsafe or illogical.
- Avoid complex expressions inside assertions; factor them into predicates.
- Prefer predicate-format assertions returning `AssertionResult` for clearer failures.
- Use string assertions for C string comparisons.
- Be careful with fatal assertions in helper functions returning non-void.
- Use `SCOPED_TRACE` when calling subroutines to add context to failure messages.
- Stream custom failure messages with `<<` for more detail.

---

## 12. Practical Examples

### Simple assertion example

```cpp
TEST(FactorialTest, HandlesZero) {
  EXPECT_EQ(Factorial(0), 1);
  ASSERT_GT(Factorial(5), 0);
}
```

### Predicate assertion example

```cpp
testing::AssertionResult IsPositive(int n) {
  if (n > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is not positive";
}

TEST(NumberTest, PositiveCheck) {
  EXPECT_PRED_FORMAT1(IsPositive, some_value);
}
```

### Exception assertion example

```cpp
TEST(ExceptionTest, ThrowsOutOfRange) {
  EXPECT_THROW({ vec.at(100); }, std::out_of_range);
}
```

### No fatal failure check example

```cpp
void Subroutine() {
  ASSERT_NE(ptr, nullptr);  // May abort current function
}

TEST(MyTest, SubroutineCheck) {
  EXPECT_NO_FATAL_FAILURE(Subroutine());
}
```

---

## 13. Troubleshooting Assertion Failures

### Common Issues

- **Assertion macros cause build errors:** Likely invalid usage; ensure arguments are valid and properly typed.
- **Fatal assertions in non-void functions:** Causes compiler errors or unexpected behavior; use nonfatal assertions or `ASSERT_NO_FATAL_FAILURE`.
- **Pointers compared with `EXPECT_EQ`:** Use string assertions for C strings.
- **Expect failures when using macros inside assertions:** Use explicit casts or predicate wrappers.

### Tips

- Stream additional diagnostics for clarity.
- Use `SCOPED_TRACE` to identify invocation context in nested calls.
- Check for correct capitalization: `SetUp()` not `Setup()`.

---

## 14. Next Steps & Related Content

- Explore [GoogleTest Primer](primer.md) for foundational concepts.
- Dive into [Advanced Topics](advanced.md#using-assertions) for detailed assertion usage.
- Learn about [Predicate Assertions](advanced.md#predicate-assertions).
- Review the [Assertions Reference](reference/assertions.md) for complete macro listing.
- Understand [Exception Assertions](reference/assertions.md#exceptions) for exception handling.
- Read [Global Set-Up and Tear-Down](advanced.md#global-set-up-and-tear-down) to manage shared resources.

---

## 15. Summary

GoogleTest provides a wide array of assertion macros tailored to different testing needs: from simple Boolean checks to sophisticated predicate assertions and exception verifications. Proper use of assertion macros enables informative, robust tests with clear failure reports. This guide empowers you to choose and apply assertions effectively for reliable and maintainable C++ tests.

---