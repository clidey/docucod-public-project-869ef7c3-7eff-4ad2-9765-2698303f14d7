---
title: "Parameterized and Type-Parameterized Test Strategies"
description: "Shows how to expand your test coverage with parameterized tests and type-parameterized tests, making it simple to validate functions across a range of values and types. Real coding examples illustrate the creation and execution of these powerful XUnit patterns."
---

# Parameterized and Type-Parameterized Test Strategies

Expand your test coverage with parameterized tests and type-parameterized tests in GoogleTest. These powerful XUnit testing patterns make it simple to validate functions across a variety of values and types without duplicating test code.

---

## Overview

Parameterized tests let you run the same test logic with different input values. Type-parameterized tests enable running the same tests across multiple types, ensuring broad validation of templated code or interface implementations.

This guide shows you how to create, instantiate, and execute these tests effectively using clear examples and best practices.

---

## Value-Parameterized Tests

### What Are They?
Value-parameterized tests allow you to run the same test logic multiple times with different input values, without rewriting the test multiple times.

### When to Use
- Testing multiple inputs against the same behavior
- Testing code influenced by flags or configurations
- Testing different implementations provided as parameters

### How to Write Value-Parameterized Tests

1. **Define a Fixture Class**

   Derive your fixture from `testing::TestWithParam<T>`, where `T` is the parameter type. For example:

   ```cpp
   class FooTest : public ::testing::TestWithParam<int> {
     // Optional setup/teardown or other member functions
   };
   ```

2. **Write Parameterized Tests Using `TEST_P` Macro**

   Define your test bodies with `TEST_P`, using `GetParam()` to get the current parameter:

   ```cpp
   TEST_P(FooTest, HandlesPositiveInput) {
     int param = GetParam();
     EXPECT_GT(param, 0);
   }
   ```

3. **Instantiate Test Suite with Input Values Using `INSTANTIATE_TEST_SUITE_P`**

   Use built-in parameter generators like `Values`, `Range`, `ValuesIn`, or `Combine`:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       PositiveInts, FooTest, testing::Values(1, 2, 3, 5, 8));
   ```

4. **Optional: Custom Test Naming**

   You can specify a custom naming function for parameter suffixes to produce readable test names:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       NamedGroup, FooTest, testing::Values(1, 2, 3),
       [](const testing::TestParamInfo<FooTest::ParamType>& info) {
         return "Param" + std::to_string(info.param);
       });
   ```

### Parameter Generators Supported

| Generator         | Description                                  |
|-------------------|----------------------------------------------|
| `Range(begin, end[, step])` | Generates values from begin to end (exclusive), stepping by step (default 1).
| `Values(v1, v2, ..., vN)`   | Generates values explicitly listed.
| `ValuesIn(container)`        | Generates values from elements of a container or array.
| `Bool()`                    | Generates `false` and `true`.
| `Combine(g1, g2, ..., gN)`  | Produces the Cartesian product of multiple generators (tuples).

### Example

```cpp
class AnimalTest : public ::testing::TestWithParam<const char*> {};

TEST_P(AnimalTest, IsNotNullOrEmpty) {
  const char* animal = GetParam();
  EXPECT_NE(nullptr, animal);
  EXPECT_STRLEN_GT(animal, 0);
}

INSTANTIATE_TEST_SUITE_P(
    CommonAnimals, AnimalTest, testing::Values("cat", "dog", "bird"));
```

Tests will run with each animal string parameter.

### Common Pitfalls
- Always instantiate every `TEST_P` suite with `INSTANTIATE_TEST_SUITE_P` unless marked with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Parameter generators are evaluated during GoogleTest initialization, so parameter-dependent runtime state must be accessible then.
- Test names generated must contain only alphanumeric characters and underscores.

---

## Typed Tests

### What Are They?
Typed tests execute the same tests across a fixed list of types known at compile time.

### When to Use
- You want to repeat the same set of tests for multiple types.
- The types are known during test suite implementation.
- You have templated code and want to verify for various type instantiations.

### How to Write Typed Tests

1. **Define a Typed Test Fixture Class Template**

   Derive from `testing::Test`:

   ```cpp
   template <typename T>
   class NumericTest : public ::testing::Test {
    public:
     T value_ = 0;
   };
   ```

2. **List the Types Using `::testing::Types`**

   ```cpp
   using MyTypes = ::testing::Types<int, double, long>;
   TYPED_TEST_SUITE(NumericTest, MyTypes);
   ```

3. **Define Tests Using `TYPED_TEST` Macro**

   Use the special identifier `TypeParam` inside tests to refer to the current type:

   ```cpp
   TYPED_TEST(NumericTest, DefaultIsZero) {
     TypeParam value = this->value_;
     EXPECT_EQ(value, TypeParam(0));
   }
   ```

### Optional: Custom Type Names

You can specify custom type name suffixes by providing a name generator class with a `static std::string GetName<T>(int index)`:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, long>) return "long";
  }
};

TYPED_TEST_SUITE(NumericTest, MyTypes, MyTypeNames);
```

### Example

```cpp
template <typename T>
class MathTest : public ::testing::Test {
 public:
   T value_ = 42;
};

using MyTypes = ::testing::Types<int, float>;
TYPED_TEST_SUITE(MathTest, MyTypes);

TYPED_TEST(MathTest, ValueIsCorrect) {
  EXPECT_EQ(this->value_, TypeParam(42));
}
```

### Best Practices
- Use typed tests when your test logic strongly depends on the type involved.
- Visit members of your test fixture with `this->` as required by C++.
- Use custom type naming to generate readable output if you want.

---

## Type-Parameterized Tests

### What Are They?
Type-parameterized tests are abstract test patterns defined without a fixed type list, which you can instantiate multiple times with different type lists, potentially in separate translation units.

### When to Use
- You want to share a set of test templates across multiple type collections.
- You need flexible instantiation of tests possibly in multiple source files.
- Designing interfaces or concepts with multiple implementations.

### How to Write Type-Parameterized Tests

1. **Define a Test Fixture Template**

   ```cpp
   template <typename T>
   class ContainerTest : public ::testing::Test {};
   ```

2. **Declare a Type-Parameterized Test Suite Template Without Specifying Types Yet:**

   ```cpp
   TYPED_TEST_SUITE_P(ContainerTest);
   ```

3. **Define Tests Using `TYPED_TEST_P` Macro:**

   ```cpp
   TYPED_TEST_P(ContainerTest, IsEmptyInitially) {
     EXPECT_TRUE(this->empty());
   }

   TYPED_TEST_P(ContainerTest, CanAddAndRemove) {
     this->addValue(TypeParam{});
     EXPECT_FALSE(this->empty());
   }
   ```

4. **Register the Test Names:**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyInitially, CanAddAndRemove);
   ```

5. **Instantiate the Tests with Type Lists:**

   ```cpp
   using MyContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
   INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainerTypes);
   ```

### Optional: Custom Type Names

Same as typed tests, you can supply a name generator.

### Example

```cpp
// Define the fixture template and tests
template <typename T>
class MyAbstractContainerTest : public ::testing::Test {
  // ... fixture members ...
};

TYPED_TEST_SUITE_P(MyAbstractContainerTest);

TYPED_TEST_P(MyAbstractContainerTest, IsDefaultEmpty) {
  EXPECT_TRUE(TypeParam().empty());
}

TYPED_TEST_P(MyAbstractContainerTest, CanInsertAndFind) {
  TypeParam container;
  container.insert(container.begin(), 42);
  EXPECT_EQ(*container.begin(), 42);
}

REGISTER_TYPED_TEST_SUITE_P(MyAbstractContainerTest, IsDefaultEmpty, CanInsertAndFind);

// Instantiate in a .cc file or separately
using TestTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(Inst, MyAbstractContainerTest, TestTypes);
```

### Notes
- Must register all test names with `REGISTER_TYPED_TEST_SUITE_P` before instantiation.
- Can instantiate the suite multiple times, with different type sets.

---

## Tips & Best Practices

- **Distinct Names:** Always provide unique instantiation names for parameterized tests to avoid conflicts.
- **Parameter Naming:** Provide custom parameter name generation functions for clarity in test results output.
- **Minimize Side Effects:** Parameter generator expressions should not rely on mutated state that isnâ€™t available at initialization.
- **Use Consistent Fixture Access:** For type-parameterized tests, use `this->` to access fixture members.
- **Separate Declaration and Instantiation for Abstract Tests:** Put test logic in headers and instantiate in separate source files.

---

## Troubleshooting Common Issues

- **Missing Instantiation Errors:** If you define `TEST_P` tests but forget to instantiate using `INSTANTIATE_TEST_SUITE_P`, tests will fail with missing definitions. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress if intentionally uninstantiated.
- **Invalid Test Names:** Names must not include underscores or special characters that interfere with macro-generated names.
- **Dangling References in Converters:** Avoid dangling references when using `ConvertGenerator` with temporary objects by ensuring lifetimes are managed appropriately.

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [INSTANTIATE_TEST_SUITE_P](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TYPED_TEST_SUITE & TYPED_TEST](reference/testing.md#TYPED_TEST_SUITE)
- [TYPED_TEST_SUITE_P & TYPED_TEST_P](reference/testing.md#TYPED_TEST_SUITE_P)

---

## References & Examples

- Sample of value-parameterized test: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)
- Sample of typed test: [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)
- Sample of type-parameterized test: [sample6_unittest.cc (typed test patterns)](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)

---

Ready to scale your tests? Harness the power of parameterization and templates to reduce duplication and increase test clarity and coverage.