---
title: "Parameterized Tests: Value and Type"
description: "Learn to create parameterized tests using GoogleTest, including both value- and type-parameterized approaches. Covers typical use cases for broad test coverage with minimal code duplication."
---

# Parameterized Tests: Value and Type

## Overview

Parameterized tests are a powerful GoogleTest feature that enables you to write scalable tests by running the same test logic over multiple sets of data or types. By using value-parameterized or type-parameterized tests, you can achieve broad test coverage with minimal code duplication and maintain clearer, more maintainable testing code.

This guide focuses explicitly on creating, defining, and instantiating parameterized tests using GoogleTest's facilities for both value and type parameters.

---

## 1. Value-Parameterized Tests

Value-parameterized tests let you test functions or classes with different values without writing multiple test cases. This approach is ideal when your test logic remains constant, but the inputs change.

### Workflow Overview

- **Intent**: Use the same test case to run against different input values.
- **Prerequisites**: Knowledge of basic GoogleTest test fixture classes.
- **Outcome**: Tests automatically generated and run for each specified parameter value.
- **Difficulty**: Intermediate
- **Time Estimate**: 10-15 minutes to write and instantiate your first value-parameterized test.

### Steps to Create Value-Parameterized Tests

<Steps>
<Step title="Define a Test Fixture Using `TestWithParam<T>` or `Test` + `WithParamInterface<T>`">
Declare a class derived from `testing::TestWithParam<T>` where `T` is the parameter type (any copyable type). You can also separate the inheritance hierarchically by inheriting from `testing::Test` and `testing::WithParamInterface<T>`.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional: setup and tear-down code
};
```

This fixture gives you access to `GetParam()` to fetch the current test parameter.
</Step>

<Step title="Define Tests Using the `TEST_P` Macro">
Write tests within your fixture using `TEST_P` instead of `TEST_F` or `TEST`. Inside these tests, call `GetParam()` to get the parameter.

```cpp
TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}
```
</Step>

<Step title="Instantiate the Test Suite Using `INSTANTIATE_TEST_SUITE_P`">
At global or namespace scope, instantiate your parameterized test suite with parameters using one of GoogleTest's parameter generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveInts, FooTest, testing::Values(1, 2, 3));
```

The first argument, "PositiveInts", uniquely identifies this instantiation and prefixes the test suite name in output.
</Step>
</Steps>

### Parameter Generators

GoogleTest provides several parameter generator functions, returning sequences of values:

| Generator         | Description                                                    |
|-------------------|----------------------------------------------------------------|
| `Range(start, end[, step])` | Generates sequential values starting at `start` up to but not including `end`, optionally stepping by `step`.
| `Values(v1, v2, ..., vN)`    | Yields the explicitly listed values.
| `ValuesIn(container_or_iterators)` | Produces values from a C-style array, STL container, or iterator range.
| `Bool()`                     | Generates Boolean values `false` and `true`.
| `Combine(g1, g2, ..., gN)`   | Generates tuples representing the Cartesian product of parameters given by the individual generators.

### Customizing Test Names

By default, test names use the `PrintToString` formatter to create suffixes based on parameter values. For better clarity, especially with complex types or strings, provide a custom name generator:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values( ... ),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "TestName_" + std::to_string(info.index);
    });
```

Make sure the generated names are unique and only contain alphanumeric characters or underscores.

<Note>
Test names with spaces, dashes, or special characters are invalid and will cause test registration failures.
</Note>

### Example: Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

This creates four tests: `EvenNumbers/IsEvenTest.CheckEven/0`, `.../1`, etc., each checking different even numbers.

---

## 2. Type-Parameterized Tests

Type-parameterized tests allow you to run the same test logic over a list of types. This is ideal for validating template classes and functions across various type instantiations.

### Workflow Overview

- **Intent**: Run a test suite over multiple types without manual duplication.
- **Prerequisites**: Familiarity with C++ templates and basic GoogleTest syntax.
- **Outcome**: Multiple test suites generated, one per type.
- **Difficulty**: Advanced
- **Time Estimate**: 15–30 minutes to create and instantiate.

### Steps to Create Typed Tests

<Steps>
<Step title="Define a Class Template Fixture Derived from `testing::Test`">
Create a fixture template parameterized by `typename T`:

```cpp
template <typename T>
class FooTypedTest : public testing::Test {
public:
  T value_{};  // example
};
```
</Step>

<Step title="Define the List of Types to Test Against">
Use `testing::Types<T1, T2, ..., Tn>` to list types.

```cpp
using MyTypes = testing::Types<int, double, char>;
```
</Step>

<Step title="Associate the Type List to the Fixture Using `TYPED_TEST_SUITE`">
Bind the types to the test fixture:

```cpp
TYPED_TEST_SUITE(FooTypedTest, MyTypes);
```
</Step>

<Step title="Define Tests Using `TYPED_TEST` Macro">
Define typed tests using `TYPED_TEST`. Use the special identifier `TypeParam` in your tests to refer to the current type:

```cpp
TYPED_TEST(FooTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  EXPECT_TRUE(true); // sample assertion
}
```
</Step>
</Steps>

---

## 3. Type-Parameterized Test Suites (Abstract Tests)

When you want to reuse a test suite pattern to be instantiated by others multiple times with different types (usually in separate translation units), use type-parameterized tests (also known as abstract tests).

### Key Differences to Typed Tests

- Defined with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` macros.
- Tests must be registered with `REGISTER_TYPED_TEST_SUITE_P` listing test names.
- Instantiated later using `INSTANTIATE_TYPED_TEST_SUITE_P`, with a unique prefix, test suite name, and type list.

### Steps to Create Type-Parameterized Tests

<Steps>
<Step title="Declare Type-Parameterized Test Suite">
```cpp
template <typename T>
class FooAbstractTest : public testing::Test { ... };

TYPED_TEST_SUITE_P(FooAbstractTest);
```
</Step>

<Step title="Define Tests with `TYPED_TEST_P`">
```cpp
TYPED_TEST_P(FooAbstractTest, DoesSomething) {
  TypeParam x = 0;
  EXPECT_EQ(x, 0);
}
```
</Step>

<Step title="Register Tests">
Use `REGISTER_TYPED_TEST_SUITE_P` to register the test names.​

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooAbstractTest, DoesSomething);
```
</Step>

<Step title="Instantiate Tests">
Instantiate the suite with types, giving a unique prefix to distinguish.

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooAbstractTest, MyTypes);
```
</Step>
</Steps>

---

## 4. Best Practices and Tips

- **Parameter Names**: Always provide meaningful and valid parameter name functions to avoid name collisions or invalid test names.
- **Parameter Types**: Ensure parameter types are copyable and properly printable with either `PrintToString` or a custom `PrintTo` overload.
- **Avoid Side Effects**: Parameter generators are evaluated during test initialization (`InitGoogleTest`), so avoid side effects or runtime state dependencies that might cause inconsistencies.
- **Complex Parameters**: Use `Combine()` to test combinations of parameters effectively.
- **Custom Types**: Use `ConvertGenerator()` when your parameter type needs explicit construction or conversion from generated values.
- **Suppress Uninstantiated Errors**: If declaring parameterized tests without instantiation (e.g., in shared headers), use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors.

---

## 5. Troubleshooting Common Issues

- **No Tests Run**: Check if `INSTANTIATE_TEST_SUITE_P` has been called for all `TEST_P` fixtures. Forgetting instantiation causes silent empty test cases.

- **Invalid Test Names**: Generated test names must only contain alphabets, digits, or underscores. Use a custom name generator to fix names containing spaces or special characters.

- **Dangling References in Lambdas**: When using `ConvertGenerator` with lambdas that take parameters like `std::string_view`, ensure lifetime of referenced strings is safe to avoid dangling references.

- **Type Conversion Errors**: If parameter types are not implicitly convertible, use `ConvertGenerator<T>` with a converting callable.

- **Compilation Errors in Type-Parameterized Tests**: Verify that all tests are registered with `REGISTER_TYPED_TEST_SUITE_P` before instantiation.

- **Test Filtering Issues**: Use the full test name (including instantiation prefix) with `--gtest_filter` to select parameterized tests.

---

## 6. Additional Resources

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) — foundational knowledge on writing tests.
- [Assertions Reference](reference/assertions.md) — for validations and error handling.
- [Parameterized & Typed Tests API Reference](https://google.github.io/googletest/reference/testing.html#INSTANTIATE_TEST_SUITE_P) — official API documentation.
- [Google Mocking Guide](guides/core-workflows/mocking-with-gmock) — for mocks combined with parameterized tests.
- Sample tests in the [googletest repo](https://github.com/google/googletest/tree/main/googletest/samples) to see parameterized tests in action.

---

You now have the complete walkthrough to leverage GoogleTest's parameterized testing capabilities, enabling efficient and expressive testing for various data configurations and type abstractions.