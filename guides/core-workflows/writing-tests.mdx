---
title: "Writing and Running Tests"
description: "This guide shows how to structure and write unit tests in GoogleTest, use assertions, organize tests into suites, and execute them. It covers core test macros and basic usage patterns to help you quickly validate code and adopt a test-driven workflow."
---

# Writing and Running Tests

This guide shows you how to effectively write and execute unit tests using GoogleTest. You will learn how to structure tests, organize them into test suites, apply assertions to validate logic, and run tests efficiently to support a test-driven development workflow.

---

## 1. Understanding GoogleTest Test Structure

### Test Suites and Tests

GoogleTest organizes tests in **test suites** (also known as test cases). Each test suite contains one or more **tests** — individual test functions that GoogleTest runs.

- **Test Suite**: A group of related tests, often sharing common setup or purpose.
- **Test**: A single verification point that checks a particular behavior or condition.

### Key Test Macro Primitives

GoogleTest provides several macros to define tests:

- `TEST(TestSuiteName, TestName)`
  - Defines a basic test named `TestName` in `TestSuiteName`.
  - Both identifiers must be valid C++ identifiers and avoid underscores due to naming restrictions.

- `TEST_F(TestFixtureName, TestName)`
  - Defines a test named `TestName` using a test fixture class `TestFixtureName`.
  - Test fixtures allow sharing common setup/teardown code.

- `TEST_P(TestFixtureName, TestName)`
  - Defines a parameterized test that will run with different parameters.

### Naming Restrictions

For robustness, avoid using underscores (`_`) in test suite and test names because GoogleTest reserves underscores for internal use. See the [FAQ on naming](https://github.com/google/googletest/blob/main/docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore) for details.

---

## 2. Writing Your First Test

### Basic Test Using `TEST`

Start by writing simple tests that check functions or logic.

```cpp
#include <gtest/gtest.h>

// A simple function to test
int Add(int x, int y) {
  return x + y;
}

// Define a test suite and a test
TEST(MathTest, AdditionWorks) {
  EXPECT_EQ(Add(2, 3), 5);  // Passes if Add(2,3) == 5
  EXPECT_NE(Add(2, 2), 5);  // Passes if Add(2,2) != 5
}
```

### Running Tests

Compile your test program with the GoogleTest framework and run the executable. `RUN_ALL_TESTS()` runs all tests and returns 0 if all pass.

```cpp
int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

### Understanding Test Results

- A passing test shows `[  PASSED  ]` with the test suite and test name.
- A failing test shows `[  FAILED  ]` and failure details including expected and actual values.

---

## 3. Using Test Fixtures with `TEST_F`

When your tests require shared setup or teardown logic, use **test fixtures**.

### Defining a Test Fixture

```cpp
class MyFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Code here runs before each test
    value_ = 42;
  }

  void TearDown() override {
    // Code here runs after each test
  }

  int value_;
};
```

### Writing Tests with Fixtures

```cpp
TEST_F(MyFixture, HasCorrectValue) {
  EXPECT_EQ(value_, 42);
}

TEST_F(MyFixture, CanModifyValue) {
  value_ = 100;
  EXPECT_EQ(value_, 100);
}
```

Each `TEST_F` creates a fresh instance of the fixture and automatically calls `SetUp()` before and `TearDown()` after the test body.

---

## 4. Organizing and Running Tests

### Filtering Tests

Run only a subset of tests that match patterns using the `--gtest_filter` flag:  

```sh
./my_test --gtest_filter=MathTest.*
```

Runs all tests in the `MathTest` suite.

### Disabling Tests

Prefix test or test suite names with `DISABLED_` to disable them temporarily:

```cpp
TEST(MathTest, DISABLED_FlakyTest) {
  ...
}
```

Disabled tests are compiled but not run unless you specify `--gtest_also_run_disabled_tests`.

### Repeating and Shuffling

- `--gtest_repeat=N`: Repeat all tests N times to catch flaky behavior.
- `--gtest_shuffle`: Run tests in random order to detect dependencies.

### Listing Tests

Use `--gtest_list_tests` to view all test suites and tests without executing them.

---

## 5. Writing Parameterized Tests with `TEST_P` and Instantiating

Parameterized tests allow running the same test logic with different input values.

### Defining a Parameterized Test

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {};

TEST_P(MyParamTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}
```

### Instantiating Tests with Parameters

Use `INSTANTIATE_TEST_SUITE_P` with parameter generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, MyParamTest,
    ::testing::Values(2, 4, 6, 8));
```

This creates individual tests `EvenNumbers/MyParamTest.IsEven/0`, etc.

### Parameter Generators

- `Values(v1, v2, ...)`: Define explicit values.
- `ValuesIn(container)`: Use values from containers or arrays.
- `Range(begin, end, step)`: Values from begin (inclusive) to end (exclusive).
- `Bool()`: `false` and `true`.
- `Combine(...)`: Cartesian product for multiple parameters.

### Customizing Test Names

Specify a naming function to generate more meaningful test names.

```cpp
INSTANTIATE_TEST_SUITE_P(
  Named, MyParamTest,
  ::testing::Values(1, 2, 3),
  [](const ::testing::TestParamInfo<int>& info) {
    return "Number_" + std::to_string(info.param);
  });
```

---

## 6. Advanced Test Features

### Using `SetUpTestSuite()` and `TearDownTestSuite()`

For actions needed once for an entire test suite (expensive resources), add static methods in your fixture:

```cpp
class MyFixture : public ::testing::Test {
 public:
  static void SetUpTestSuite() {
    shared_resource_ = new Resource();
  }
  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  static Resource* shared_resource_;
};

Resource* MyFixture::shared_resource_ = nullptr;
```

GoogleTest calls these before the first and after the last test in the suite.

### Skipping Tests at Runtime

Use `GTEST_SKIP()` inside a test or fixture setup to skip tests conditionally.

```cpp
GTEST_SKIP() << "Skipping this test because X is not supported";
```

### Catching Failures in Subroutines

If functions called inside tests contain `ASSERT_*()`, the test continues even if the assertion fails. To propagate fatal failures:

- Use `ASSERT_NO_FATAL_FAILURE(function_call());`
- Check `if (HasFatalFailure()) return;` after the call.
- Use custom listeners to throw exceptions on failure.

### Accessing the Current Test Name

Retrieve info about the running test from:

```cpp
const testing::TestInfo* test_info =
    testing::UnitTest::GetInstance()->current_test_info();
if (test_info) {
  std::cout << "Running test " << test_info->test_suite_name()
            << "." << test_info->name() << std::endl;
}
```

---

## 7. Best Practices and Troubleshooting

- Always use `RUN_ALL_TESTS()` return value as program return value.
- Avoid mixing different fixture classes in the same test suite.
- For flaky tests, use `--gtest_repeat` and `--gtest_shuffle`.
- Use meaningful assertions; prefer predicate assertions or custom messages.
- Disable legacy API use as it is deprecated (`TestCase` → `TestSuite`).
- Use `SCOPED_TRACE` or `ScopedTrace` to annotate failures inside subroutines.

---

## 8. Example: Parameterized Test

```cpp
#include <gtest/gtest.h>

class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

Run this test to execute the same logic for multiple parameter values, improving test coverage without duplicating code.

---

### References

- [Testing Reference: TEST, TEST_F, TEST_P, INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md)
- [Advanced Topics: Writing Value-Parameterized and Typed Tests](docs/advanced.md#value-parameterized-tests)
- [FAQ: Naming Conventions and Common Pitfalls](docs/faq.md)
- [Getting Started: Write and Run Your First Test](getting-started/basic-setup-first-test/write-first-test.md)

---

## Additional Tools

### Handling Assertions in Subroutines

Use `SCOPED_TRACE` to add contextual information to assertion failures in nested calls:

```cpp
void CheckValue(int n) {
  SCOPED_TRACE("In CheckValue");
  EXPECT_EQ(n, 42);
}

TEST(MyTest, Example) {
  CheckValue(43);  // Failure message will include "In CheckValue".
}
```

### Using Event Listeners

GoogleTest supports custom event listeners to hook into test run events for custom logging or reporting.

Example minimal listener skeleton:

```cpp
class MyListener : public testing::EmptyTestEventListener {
  void OnTestStart(const testing::TestInfo& test_info) override {
    std::cout << "Starting test " << test_info.name() << std::endl;
  }
};
```

Add to the listener list:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  testing::UnitTest::GetInstance()->listeners().Append(new MyListener);
  return RUN_ALL_TESTS();
}
```

---

This guide equips you with the necessary patterns to write robust, maintainable, and efficient test code using GoogleTest, whether simple or parameterized, plain or fixture-based, while facilitating productive test execution and diagnostics.