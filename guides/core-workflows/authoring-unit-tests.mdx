---
title: "Writing Your First Unit Tests"
description: "A step-by-step guide to authoring unit tests for C++ code using GoogleTest. Learn the core testing macros, structuring test cases, using assertions, and best practices for naming and organizing your own test files."
---

# Writing Your First Unit Tests

A step-by-step guide to authoring unit tests for C++ code using GoogleTest. Learn the core testing macros, structuring test cases, using assertions, and best practices for naming and organizing your own test files.

---

## 1. Understanding the Basics of Unit Testing with GoogleTest

### What You Will Achieve
By following this guide, you will be able to write your very first unit tests using GoogleTest macros, organize your tests in suites, use assertions to validate behavior, and structure test files effectively.

### Prerequisites
- Your environment set up with GoogleTest libraries installed and linked.
- Basic knowledge of C++ programming.
- An existing C++ function or class you want to test.

### Why Write Unit Tests?
Unit tests verify small units of your code independently and ensure correctness. GoogleTest simplifies this by:
- Automatically registering and running your tests.
- Providing detailed failure reports.
- Supporting test suites for better organization.

---

## 2. Writing Your First Test: A Simple Example

The fundamental GoogleTest macro for defining a test is `TEST(SuiteName, TestName)`. The `SuiteName` groups related tests, and `TestName` identifies this particular test.

```cpp
#include <gtest/gtest.h>

// Function to test:
int Factorial(int n) {
  if (n <= 1) return 1;
  return n * Factorial(n - 1);
}

// Test suite for Factorial function
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(5), 120);
}
```

- `EXPECT_EQ` asserts equality but lets the test continue if the assertion fails.
- Tests in the same `FactorialTest` suite share a logical grouping.

Run the tests using `RUN_ALL_TESTS()` typically from your `main` function.

---

## 3. Using Assertions Effectively

Assertions verify the expected behavior of your code. GoogleTest provides many macros; the simplest are:

- `EXPECT_*` macros generate non-fatal failures and continue running the test.
- `ASSERT_*` macros generate fatal failures and abort the current test, useful when continuing doesn’t make sense.

### Example: Assertions

```cpp
TEST(VectorTest, SizeComparison) {
  std::vector<int> v1 = {1, 2, 3};
  std::vector<int> v2 = {4, 5, 6};

  ASSERT_EQ(v1.size(), v2.size()) << "Vectors must be the same size";
  for (size_t i = 0; i < v1.size(); ++i) {
    EXPECT_EQ(v1[i], v2[i]) << "Mismatch at index " << i;
  }
}
```

- Use `ASSERT_` if you must abort (e.g., size mismatch prevents safe indexing).
- Use `EXPECT_` to collect multiple errors in one test run.

### Best Practice
Append custom failure messages with `<<` to provide context.

---

## 4. Sharing Common Setup with Test Fixtures

When multiple tests need the same setup data or objects, use test fixtures to avoid duplication.

### How to Write a Test Fixture

1. Define a class derived from `testing::Test`.
2. Add your shared data as members.
3. Use the constructor or override `SetUp()` for initialization.
4. Use `TearDown()` for cleanup if needed.
5. Write your tests with `TEST_F(FixtureClassName, TestName)`.

### Example:

```cpp
class QueueTest : public ::testing::Test {
 protected:
  Queue<int> empty;
  Queue<int> one_element;
  Queue<int> two_elements;

  QueueTest() {
    one_element.Enqueue(42);
    two_elements.Enqueue(1);
    two_elements.Enqueue(2);
  }
};

TEST_F(QueueTest, StartsEmpty) {
  EXPECT_EQ(empty.size(), 0);
}

TEST_F(QueueTest, EnqueueAndDequeue) {
  one_element.Dequeue();
  EXPECT_EQ(one_element.size(), 0);

  two_elements.Dequeue();
  EXPECT_EQ(two_elements.size(), 1);
}
```

Each test operates on a fresh fixture instance ensuring isolation.

---

## 5. Writing Clear and Maintainable Tests

### Naming Conventions
- Test suite names and test names should be descriptive and follow C++ identifier rules.
- Avoid underscores; use camel case or Pascal case.

Example:
`TEST(NetworkClientTest, HandlesTimeout)`

### Organizing Tests
- Group tests logically by functionality or class.
- Place related tests in the same source file when practical.

### File Structure
- Use `.cc` or `.cpp` suffixes.
- Keep mocks, fixtures, and tests close to the related modules.

### Best Practices
- Write one assertion per expected behavior.
- Use test names to clearly describe the expected behavior.
- Avoid testing multiple concepts in a single test.

---

## 6. Running Your Tests

Standard approach is to use the `main` function provided by GoogleTest (`gtest_main`) which automatically calls `RUN_ALL_TESTS()`.

If you write your own `main`:

```cpp
int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- Initializes the framework.
- Runs all registered tests.
- Returns zero if all succeed.

---

## 7. Tips and Common Pitfalls

| Tip                                              | Description                                                                           |
|--------------------------------------------------|---------------------------------------------------------------------------------------|
| Use `EXPECT_*` vs `ASSERT_*` wisely               | Use `ASSERT_*` to prevent undefined behavior when continuing makes no sense.          |
| Group tests in suites logically                    | Makes your tests easier to navigate and maintain.                                    |
| Add meaningful failure messages                    | Helps debugging failures quickly.                                                    |
| Isolate tests independently                         | Each test should be independent to avoid flaky tests.                               |
| Avoid side effects in tests                         | Don’t rely on global or external state that tests share implicitly.                  |

### Common Pitfalls
- Forgetting to `#include <gtest/gtest.h>`.
- Naming clashes or invalid test names.
- Using `TEST()` when `TEST_F()` is needed for fixtures.
- Not handling pointers carefully (e.g., in assertions).

---

## 8. Next Steps & Resources

### What to Explore Next
- Writing and running your first test with build tools (CMake, Bazel).
- Mocking dependencies with GoogleMock to isolate units.
- Advanced assertions and parameterized tests.

### Related Documentation
- [GoogleTest Primer](https://google.github.io/googletest/primer.html)
- [Mocking with GoogleMock](https://google.github.io/googletest/gmock_for_dummies.html)
- [Assertions Reference](../api_reference/test_framework_api/assertions)

### Sample Code
Explore sample tests in the `googletest/samples` directory in the repository.

---

## Appendix: Full Minimal Test Example

```cpp
#include <gtest/gtest.h>

// Function under test
int Add(int a, int b) {
  return a + b;
}

// Test Suite
TEST(AdditionTest, HandlesPositiveNumbers) {
  EXPECT_EQ(Add(1, 2), 3);
}

TEST(AdditionTest, HandlesZero) {
  EXPECT_EQ(Add(0, 0), 0);
  EXPECT_EQ(Add(0, 2), 2);
}

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

Running this produces a simple report of test success or failure.


---

<Note>
Remember: Writing unit tests incrementally and early will save debugging time later. Start simple and evolve your tests as your codebase grows.
</Note>
