---
title: "Getting Started with GoogleTest"
description: "A hands-on walkthrough introducing GoogleTest, covering setup, writing your first tests, and running your test suite successfully. Focuses on accelerating initial onboarding for new users, highlighting core concepts and immediate value."
---

# Getting Started with GoogleTest

Welcome to a hands-on guide designed to get you quickly productive with GoogleTest. This walkthrough will cover setting up your environment, writing your very first tests, and running your entire test suite successfully. Our goal is to accelerate your onboarding by focusing on core concepts, immediate value, and practical examples.

---

## 1. Overview: What You'll Achieve

### Task Description
This guide helps you start testing your C++ code using GoogleTest by:
- Configuring your project environment
- Writing simple but effective tests
- Building and running your tests to verify behavior

### Prerequisites
- Basic knowledge of C++ programming
- Access to a compatible development environment with C++17 support
- Compiler and build system configured for your platform
- GoogleTest sources or installed package available

### Expected Outcome
After completing this guide, you will be able to:
- Integrate GoogleTest into your build
- Write independent tests using GoogleTest macros
- Run tests and interpret output
- Troubleshoot basic issues related to test execution

### Time Estimate
Approximately 15-30 minutes

### Difficulty Level
Beginner-friendly

---

## 2. Step-by-Step Instructions

### Step 1: Prepare Your Environment

1. Ensure your compiler supports C++17 standard (e.g., GCC ≥ 7, MSVC ≥ 2017).
2. Obtain GoogleTest source code or install it via your package manager.
3. Configure your build system (e.g., CMake) to include GoogleTest headers and libraries.

<Tip>
If you use CMake, GoogleTest can be added as a subdirectory or found via `find_package`. Refer to the "Installation (CMake, Bazel, Manual)" guide for detailed setup instructions.
</Tip>

### Step 2: Write Your First Simple Test

Start with the simplest form of test:

```cpp
#include <gtest/gtest.h>

// Basic test case checking a function returns the expected value
int Factorial(int n) {
    return (n <= 1) ? 1 : n * Factorial(n - 1);
}

TEST(FactorialTest, HandlesZeroInput) {
    EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
    EXPECT_EQ(Factorial(1), 1);
    EXPECT_EQ(Factorial(2), 2);
    EXPECT_EQ(Factorial(3), 6);
    EXPECT_EQ(Factorial(8), 40320);
}
```

This example shows:
- `TEST(test_suite_name, test_name)` macro to define tests
- Use of `EXPECT_EQ` assertion to verify values

<Tip>
Avoid underscores in test suite or test names when possible, as recommended for clarity.
</Tip>

### Step 3: Use Test Fixtures for Repeated Setup

When multiple tests share the same data or setup, define a test fixture:

```cpp
class QueueTest : public ::testing::Test {
 protected:
  QueueTest() {
    // Setup code executed before each test
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  // Objects to be used in tests
  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);  // Stops test if nullptr
  EXPECT_EQ(*n, 1);
  delete n;
}
```

Key points:
- Define fixture by subclassing `testing::Test`
- Use `TEST_F` macro to tie tests to the fixture
- Define `SetUp()` and `TearDown()` methods if extra setup or cleanup is needed

### Step 4: Build and Run Your Test Program

1. Build your test binaries linking against GoogleTest (either `gtest` or `gtest_main`).
2. Run the test executable.
3. Observe the textual output that indicates successes, failures, and timing.

Typical command (CMake example):

```bash
mkdir build
cd build
cmake ..
make
./your_test_executable
```

The test output will look like:

```
[==========] Running 2 tests.
[ RUN      ] FactorialTest.HandlesZeroInput
[       OK ] FactorialTest.HandlesZeroInput (0 ms)
[ RUN      ] FactorialTest.HandlesPositiveInput
[       OK ] FactorialTest.HandlesPositiveInput (0 ms)
[==========] 2 tests ran.
[  PASSED  ] 2 tests.
```

### Step 5: Interpret Testing Results

- `OK` means the test passed
- Any assertion failures will be printed with file and line number
- Use failures to debug unexpected behavior

<Tip>
Use `ASSERT_*` macros to abort a test immediately upon failure when continuing is impossible or would cause crashes.
</Tip>

---

## 3. Practical Example: Writing, Building, Running

```cpp
// File: example_test.cpp
#include <gtest/gtest.h>

int Sum(int a, int b) {
  return a + b;
}

TEST(SumTest, HandlesPositive) {
  EXPECT_EQ(Sum(1, 2), 3);
}

TEST(SumTest, HandlesNegative) {
  EXPECT_EQ(Sum(-1, -2), -3);
}
```

Build (assuming GoogleTest is installed and CMakeLists.txt is configured):

```bash
cmake .
make
./example_test
```

Output:
```
[ RUN      ] SumTest.HandlesPositive
[       OK ] SumTest.HandlesPositive (0 ms)
[ RUN      ] SumTest.HandlesNegative
[       OK ] SumTest.HandlesNegative (0 ms)
[==========] 2 tests ran.
[  PASSED  ] 2 tests.
```

---

## 4. Troubleshooting & Best Practices

### Common Issues

- **Nothing happens when you run tests:** Ensure you call `testing::InitGoogleTest(&argc, argv);` before `RUN_ALL_TESTS()` in your `main()`.
- **Tests not discovered or run due to filters:** Check the `--gtest_filter` flag or command-line arguments.
- **Setup or teardown methods not called:** Remember that `SetUp()` and `TearDown()` must be spelled exactly so (not `Setup()`). Also, test fixture constructors cannot use assertions.
- **Linker errors:** Verify GoogleTest is correctly linked in your build system.

### Best Practices

- Use `EXPECT_*` for nonfatal assertions; use `ASSERT_*` only when the test cannot proceed on failure.
- Group related tests into suites with meaningful names reflecting your code structure.
- Make tests independent; avoid shared state that can cause flaky behavior.
- Use test fixtures to share setup code but remember each test runs in a fresh fixture instance.

<Tip>
Use the built-in GoogleTest flags such as `--gtest_list_tests` to list all tests, `--gtest_repeat` to run tests multiple times, and `--gtest_output=xml` to generate reports.
</Tip>

---

## 5. Next Steps & Related Resources

- Proceed to [Writing Your First Test](../getting-started/first-test-execution-validation/writing-your-first-test) for a detailed tutorial.
- Explore [Building and Running Tests](../getting-started/first-test-execution-validation/building-running-tests) for integrating with CMake and Bazel.
- Consult the [GoogleTest Primer](../docs/primer.md) to deepen your foundational knowledge.
- Learn about mocks in [Using Mocks in C++ Tests](../guides/core-workflows/using-mocks-in-tests) to test dependent components.
- Review [Feature Summary](../overview/feature-overview/feature-summary) for an overview of GoogleTest capabilities.

---

## Summary Diagram: Basic Test Workflow

```mermaid
flowchart TD
  Start([Start Testing]) --> SetupEnv[Prepare Environment]
  SetupEnv --> WriteTests[Write TEST or TEST_F]
  WriteTests --> Build[Build Test Binary]
  Build --> Run[Run Tests with RUN_ALL_TESTS()]
  Run --> Results{Tests Passed?}
  Results -->|Yes| Success([All Tests Passed])
  Results -->|No| Fail([Fix and Debug Failures])
  Fail --> WriteTests
```

This diagram illustrates the iterative nature of testing—writing tests, running them, and debugging failures until your code behaves as expected.

---

# Appendix: Minimal main() Example

If you need to write your own `main()` function:

```cpp
#include <gtest/gtest.h>

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);  // Initialize GoogleTest with arguments
  return RUN_ALL_TESTS();                // Run all tests and return status
}
```

<Tip>
Most users should link with the convenient `gtest_main` library, which provides a default main(). Only write your own if you need custom setup.
</Tip>
