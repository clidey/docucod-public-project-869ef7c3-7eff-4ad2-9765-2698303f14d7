---
title: "Parameterized and Typed Tests"
description: "Guides users through writing tests that automatically run across sets of values or types, thereby maximizing test coverage. Covers core concepts, setup, practical examples, and when to use each approach effectively."
---

# Parameterized and Typed Tests

GoogleTest enables you to maximize your test coverage without duplicating code through **parameterized** and **typed** tests. These features allow you to write tests once and run them automatically across multiple data values or C++ types. This guide walks you through everything you need to know to write these tests effectively.

---

## 1. Understanding Parameterized and Typed Tests

### What Are Parameterized Tests?

Parameterized tests let you run the same test logic with different input values or parameters. This eliminates repetitive test code when you want to verify behavior for multiple data points.

### What Are Typed Tests?

Typed tests extend the idea to running the same test logic for multiple C++ types. You define test fixtures templated on a type and instantiate them for a set of types, ensuring your code works correctly with those types.

### When to Use Parameterized vs. Typed Tests

- Use **parameterized tests** when testing the behavior of functions or classes across a range of input values.
- Use **typed tests** when validating generic code or templates for multiple data types.

---

## 2. Parameterized Tests: Setup and Usage

### Workflow Overview

- **Task Description:** Write repeatable tests that receive various values as input without duplicating test code.
- **Prerequisites:** 
  - Familiarity with GoogleTest `TEST_P` and test fixtures.
  - Basic understanding of template-based test systems.
- **Expected Outcome:** You will define a parameterized test fixture that accesses parameters and instantiate it with sets of values to run tests automatically for each parameter.
- **Time Estimate:** 10–15 minutes
- **Difficulty Level:** Intermediate

### Step-by-Step Instructions

<Steps>
<Step title="Define the Parameterized Fixture">
Create a test fixture inheriting from `testing::TestWithParam<T>`, where `T` is the type of the input parameter.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
 // You can add helper methods or members here.
};
```

This class allows access to the parameter via the `GetParam()` method.
</Step>

<Step title="Write Parameterized Tests">
Use `TEST_P` instead of `TEST` or `TEST_F` to write tests that use the parameterized fixture.

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(param >= 0);
}
```
</Step>

<Step title="Instantiate the Test Suite">
Use `INSTANTIATE_TEST_SUITE_P` to define the actual parameter values or sequences the tests will run against.

```cpp
INSTANTIATE_TEST_SUITE_P(
  MyValues,
  FooTest,
  testing::Values(1, 2, 3, 4)
);
```

This instantiates the `FooTest` test suite with parameters 1, 2, 3, and 4.
</Step>

<Step title="Run Tests">
Build and run your test executable as usual. GoogleTest will run all instantiated tests.
</Step>
</Steps>

### Examples

```cpp
class IntParamTest : public ::testing::TestWithParam<int> {};

TEST_P(IntParamTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(0, n % 2);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IntParamTest, testing::Values(2, 4, 6, 8));
```

This runs the `IsEven` test four times with the parameters provided.

### Parameter Generators

You can use several built-in parameter generators:

| Generator            | Description                                   |
|----------------------|-----------------------------------------------|
| `Values(...)`        | Enumerate discrete values.                    |
| `ValuesIn(container)`| Provide values from a container or array.    |
| `Range(start, end [, step])` | Generate ranges of values.              |
| `Bool()`             | Generate `false` and `true`.                   |
| `Combine(...)`       | Cartesian product of multiple generators.     |

### Custom Naming for Parameterized Tests

By default, test names include the parameter index. To generate descriptive suffixes based on parameter values, provide a custom naming functor or lambda to `INSTANTIATE_TEST_SUITE_P`. The function should accept a `TestParamInfo<T>` and return a string:

```cpp
INSTANTIATE_TEST_SUITE_P(
  CustomNames,
  FooTest,
  testing::Values(1, 2),
  [](const testing::TestParamInfo<FooTest::ParamType>& info) {
    return "Param_" + std::to_string(info.index);
  }
);
```

---

## 3. Typed Tests: Setup and Usage

### Workflow Overview

- **Task Description:** Write type-driven tests that run the same test logic for each type in a list.
- **Prerequisites:** 
  - Understanding of C++ templates and GoogleTest test fixtures.
- **Expected Outcome:** You will create a typed test fixture template and associate a list of types to be instantiated for automatic testing.
- **Time Estimate:** 15–20 minutes
- **Difficulty Level:** Intermediate

### Step-by-Step Instructions

<Steps>
<Step title="Define a Typed Test Fixture Template">
Define a class template deriving from `testing::Test`. Include members or typedefs as needed.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```
</Step>

<Step title="Associate Types with the Fixture">
Declare a `using` alias or typedef for the list of types, then call `TYPED_TEST_SUITE` to bind the list to the fixture.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>

<Step title="Define Typed Tests">
Write typed tests with `TYPED_TEST`. Inside, use `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam t{};
  (void)t; // silence unused variable warning
  SUCCEED();
}
```
</Step>

<Step title="Run Your Tests">
Build and run. Each typed test is run once per type in your list.
</Step>
</Steps>

### Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
 protected:
  T container_;
};

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

GoogleTest runs `IsEmptyInitially` twice, once for `std::vector<int>` and once for `std::list<int>`.

---

## 4. Type-Parameterized Tests (Advanced)

Type-parameterized tests allow you to define a test pattern separated from the type list. You register tests first, then instantiate later. This is useful for reusable, abstract test suites.


### Workflow Summary

- Define a test fixture template.
- Use `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` to define a type-parameterized test suite and tests.
- Register your test names with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate the test suite with `INSTANTIATE_TYPED_TEST_SUITE_P` and your type list.

### Example

```cpp
template <typename T>
class FooTest : public testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, DoesSomething) {
  TypeParam value{};
  EXPECT_TRUE(SomeProperty(value));
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesSomething);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

---

## 5. Practical Tips and Common Pitfalls

- **No underscore in test suite or test names:** Avoid using `_` in `TestSuiteName` or `TestName` to prevent internal class naming conflicts (see [FAQ on underscores](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)).

- **Accessing Parameters:** Always use `GetParam()` inside parameterized tests to access the test parameter.

- **Public `SetUpTestSuite` for Parameterized Tests:** If your parameterized test fixture defines `SetUpTestSuite` or `TearDownTestSuite`, mark them `public` rather than `protected`.

- **Duplicate Instantiation Errors:** All tests defined by `TEST_P` or `TYPED_TEST_P` **must** be instantiated via `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTestName);` to suppress errors if intentional.

- **Custom Parameter Names:** Use custom name generators for better test output when parameters are complex.

- **Avoid Side Effects in Parameters:** Test parameters should be immutable or carefully managed to avoid unexpected interactions.

- **Typed and Type-Parameterized Tests Are Compile-Time:** They require the list of types available at compile time.

---

## 6. Troubleshooting

### Test Not Running

- Verify the parameterized test is instantiated correctly with `INSTANTIATE_TEST_SUITE_P`.
- Ensure the parameter generator generates non-empty sequences.

### Duplicate Tests

- All parameterized tests must be instantiated before running tests.
- Suppress false positives in abstract tests with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

### Compilation Errors

- `TYPED_TEST` and `TYPED_TEST_SUITE` require valid template code and non-empty test names.
- Avoid underscores in test suite and test names.

### Test Name Strange Formatting

- Use custom parameter name generators if automatic names are insufficient.

---

## 7. Next Steps & Related Content

- Explore [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) in the Advanced GoogleTest Topics for more detailed use cases.
- Learn about [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests) for in-depth examples.
- See the [Test Macros and Test Suites](../api-reference/core-testing-apis/test-macros-suites) API Reference.
- Combine your knowledge with the [Assertions and Matchers](../guides/core-workflows/assertions-matchers) guide to write robust tests.

---

## 8. Additional Examples

### Defining and Instantiating Value-Parameterized Tests

```cpp
class IntTest : public ::testing::TestWithParam<int> {};

TEST_P(IntTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveInts, IntTest, testing::Values(1, 2, 3));
```

### Defining Typed Tests

```cpp
template <typename T>
class MathTest : public testing::Test {
protected:
  T a_ = 1;
  T b_ = 2;
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MathTest, MyTypes);

TYPED_TEST(MathTest, Add) {
  EXPECT_EQ(this->a_ + this->b_, 3);
}
```

### Defining Type-Parameterized Tests

```cpp
template <typename T>
class AbstractTest : public testing::Test {};

TYPED_TEST_SUITE_P(AbstractTest);

TYPED_TEST_P(AbstractTest, IsZeroInitial) {
  TypeParam val{};
  EXPECT_EQ(val, 0);
}

REGISTER_TYPED_TEST_SUITE_P(AbstractTest, IsZeroInitial);

using TypesToTest = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(Instantiation, AbstractTest, TypesToTest);
```

---

## References

- [Official GoogleTest Advanced Guide: Parameterized Tests](../advanced.md#value-parameterized-tests)
- [GoogleTest Primer](../guides/getting-started/primer-overview)
- [Test Macros and Suites](../api-reference/core-testing-apis/test-macros-suites)
- [Assertions and Matchers](../guides/core-workflows/assertions-matchers)
- [FAQ: Parameterized Tests](../faq.md#value--and-type-parameterized-tests-common-questions)

---