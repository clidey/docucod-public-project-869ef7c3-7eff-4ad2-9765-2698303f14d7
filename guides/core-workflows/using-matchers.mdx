---
title: "Using and Customizing Matchers"
description: "An in-depth guide to using built-in matchers for expressive tests and customizing your own matchers for specific types or behaviors."
---

# Using and Customizing Matchers

This guide provides a practical and in-depth look at GoogleTest's built-in matchers for crafting expressive tests, and demonstrates how you can define your own custom matchers tailored to specific types or behaviors.

---

## 1. Overview

### What This Guide Helps You Accomplish
- Understand and use Google's rich set of built-in matchers for argument validation in tests.
- Learn how to combine, customize, and create new matchers for specific testing needs.
- Gain practical techniques to write clear, maintainable, and expressive test assertions.

### Prerequisites
- Familiarity with C++ and basic GoogleTest test writing.
- GoogleTest (and optionally GoogleMock) properly installed and configured.
- Understanding of `EXPECT_CALL`, `ON_CALL`, and mock objects if using mocks.

### Expected Outcome
By the end of this guide, you will be confident in selecting and customizing matchers for any argument validation scenario in your tests, from simple equality to complex composite or polymorphic checks.

### Time Estimate
Approximately 15-25 minutes, depending on your familiarity with testing concepts.

### Difficulty Level
Intermediate: Useful for users who have written basic tests and want to extend their match validation capabilities.

---

## 2. Using Built-in Matchers

GoogleTest provides numerous built-in matchers that can be used with `EXPECT_CALL`, `EXPECT_THAT`, and related macros to precisely express the expectations on function arguments.

### Common Built-in Simple Matchers
- `_`: Wildcard matcher that accepts any value of any type.
- `Eq(value)`: Matches if the argument is equal to `value`.
- `Ne(value)`: Matches if the argument is not equal to `value`.
- Comparison matchers: `Lt(value)`, `Le(value)`, `Gt(value)`, `Ge(value)` for less than, less or equal, greater than, and greater or equal respectively.

### Special Pointer Matchers
- `IsNull()`: Matches any null pointer (raw or smart).
- `NotNull()`: Matches any non-null pointer.
- `Pointee(matcher)`: Matches a pointer whose pointee matches `matcher`. Automatically fails if the pointer is null.

### String Matchers
- `StrEq(str)`, `StrNe(str)`: String equality and inequality, considering embedded nulls.
- `StrCaseEq(str)`, `StrCaseNe(str)`: Case-insensitive string equality and inequality.
- `HasSubstr(substring)`: Matches any string containing the substring.
- `StartsWith(prefix)`, `EndsWith(suffix)`: Matches a string starting or ending with the given substring.
- `MatchesRegex(regex)`: Matches string exactly matching the regular expression.
- `ContainsRegex(regex)`: Matches string containing a match of the regular expression.

### Composite Matchers
- `AllOf(m1, m2, ...)`: Matches if all the sub-matchers match.
- `AnyOf(m1, m2, ...)`: Matches if any sub-matcher matches.
- `Not(matcher)`: Matches if the sub-matcher does not match.

### Container Matchers
- `ElementsAre(...)`: Matches a container containing exactly the given elements in order.
- `UnorderedElementsAre(...)`: Matches a container containing the given elements in any order.
- `Contains(element_matcher)`: Matches a container containing at least one element matching `element_matcher`.
- `SizeIs(matcher)`: Matches a container whose size matches the matcher.

### Field and Property Matchers
- `Field(&Class::field, matcher)`: Matches an object whose field matches the matcher.
- `Property(&Class::property, matcher)`: Matches an object whose zero-argument const member method returns a value matching the matcher.

### Tuple and Pair Matchers
- `Pair(m1, m2)`: Matches a `std::pair` where the first element matches `m1` and the second matches `m2`.
- `Key(matcher)`: Matches a pair or map element whose `first` matches `matcher`.
- `FieldsAre(m1, m2, ...)`: Matches aggregates or tuples where each field matches the corresponding matcher.

### Polymorphic Matchers
Many built-in matchers are polymorphic, meaning they work with various compatible types. For example, `Eq(42)` can match an `int`, `double`, or other implicitly convertible types.

### Example: Using Matchers in an EXPECT_CALL
```cpp
using ::testing::_;  // wildcard matcher
using ::testing::Gt; // greater-than matcher
using ::testing::Return;

class MockMyClass {
 public:
  MOCK_METHOD(int, Compute, (int size), ());
};

TEST(MyTest, UsesMatchers) {
  MockMyClass mock;

  // Expect Compute() called with any int greater than 5, returning 10.
  EXPECT_CALL(mock, Compute(Gt(5))).WillOnce(Return(10));

  int result = mock.Compute(10);  // Matches
  EXPECT_EQ(result, 10);
}
```

---

## 3. Customizing and Creating Your Own Matchers

GoogleTest allows creating your own matchers for advanced scenarios where built-in matchers don't suffice.

### 3.1 Defining Simple Custom Matchers Using `MATCHER` Macros

GoogleTest provides macros that help write concise custom matchers with automatic descriptions.

#### Example: Basic Matcher
```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

// Usage:
EXPECT_THAT(value, IsEven());
```

This matcher matches any integral type `arg` where `arg % 2 == 0`.

#### Example: Matcher with Custom Description and Explanation
```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  if (arg % divisor == 0) return true;
  *result_listener << "the remainder is " << (arg % divisor);
  return false;
}

// Usage:
EXPECT_THAT(value, IsDivisibleBy(3));
```
If the match fails, it will provide helpful information about the remainder.

### 3.2 Parameterized Matchers with `MATCHER_P`, `MATCHER_P2`, ...

Matchers can take parameters to customize their matching logic:
```cpp
MATCHER_P(InRange, range, "") {
  return arg >= range.first && arg <= range.second;
}

EXPECT_THAT(x, InRange(std::make_pair(5, 10)));
```

### 3.3 Implementing Matcher Interfaces Directly

For full control (and sometimes better compiler errors), implement the `MatcherInterface<T>`. It requires implementing:
- `bool MatchAndExplain(T x, MatchResultListener* listener) const` — performs the match and optionally streams explanation.
- `void DescribeTo(std::ostream* os) const` — describes what the matcher does.
- `void DescribeNegationTo(std::ostream* os) const` — describes negation (optional, but highly recommended).

An associated factory function returns a `Matcher<T>` constructed from your implementation.

### 3.4 Polymorphic Matchers

Polymorphic matchers can match values of various types by templating `MatchAndExplain`. Use `MakePolymorphicMatcher` to create an object that converts to a matcher of any appropriate type.

Example:
```cpp
class NotNullMatcher {
 public:
  template <typename T>
  bool MatchAndExplain(const T* p, MatchResultListener*) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}

// Usage
EXPECT_CALL(mock, Foo(NotNull()));
```

### 3.5 Composite Matchers

You can create matchers that contain other matchers as parameters and delegate evaluation and description logic.

### 3.6 Best Practices for Custom Matchers
- Ensure matchers are **pure functions** without side effects to allow repeated evaluation safely.
- Provide meaningful `DescribeTo` and `DescribeNegationTo` methods for clear test failure messages.
- Use `MatchResultListener` to stream additional match explanations for users.

---

## 4. Practical Tips and Common Pitfalls

### Sharing Matchers
Matchers are lightweight objects internally holding shared pointers to matcher implementations. It's efficient and recommended to store complex matchers in variables and reuse them instead of recreating.

### Using Matchers as Predicates
Wrap matchers in `Matches()` to use them as predicates in STL algorithms or other places expecting unary predicates.

### Matching Move-Only Types
Matchers and matchers in `EXPECT_CALL` typically copy their parameters. When matching move-only types, use `std::ref` to wrap arguments to match by reference carefully.

### Composition with Logical Operators
Use `AllOf()`, `AnyOf()`, and `Not()` to build complex logical matcher expressions.

### Diagnosing Matching Failures
Run tests with higher verbosity (`--gmock_verbose=info`) to see detailed matcher match logs and explanations.

### When to Create Custom Matchers
Create them when the built-in matchers don't express the invariant or condition naturally, or when failure explanation clarity is important.

---

## 5. Summary

GoogleTest’s matcher framework offers a powerful and expressive way to verify arguments in tests. Utilize built-in matchers for common scenarios and create custom matchers for domain-specific validations. Always focus on clarity and maintainability in your matcher use.

---

## 6. Additional Resources and Next Steps

- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) — Comprehensive list of all built-in matchers.
- [Writing Powerful Assertions](../core-workflows/writing-assertions) — Further detail on assertions integrating matchers.
- [Mocking Best Practices](../core-workflows/mocking-best-practices) — How to effectively use matchers with mocks.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Recipes including custom matcher creation.
- [Macros: MATCHER, MATCHER_P](https://google.github.io/googletest/reference/matchers.html#custom-matchers) — In-depth macro usage.
- [Using and Customizing Matchers (this page)](/guides/core-workflows/using-matchers)

----

<Tip>
Use descriptive matcher expressions to make failures easy to understand and tests easier to maintain.
</Tip>

<Note>
Custom matchers enhance test expressiveness but maintain purity and clear descriptions to avoid brittle tests.
</Note>