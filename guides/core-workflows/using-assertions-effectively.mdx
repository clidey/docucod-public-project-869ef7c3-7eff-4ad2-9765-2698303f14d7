---
title: "Using Assertions Effectively"
description: "Detailed guide to GoogleTest's powerful assertion macros, including equality, inequality, exceptions, and custom assertions. Learn how to write precise, expressive tests, and understand the difference between fatal and non-fatal failures."
---

# Using Assertions Effectively

Harness the full power of GoogleTest's assertion macros to write precise, clear, and expressive tests. This guide explains how to use various assertion types, including equality, inequality, exceptions, and custom assertions. Learn how to distinguish between fatal and non-fatal failures to write robust test code that matches your desired validation flow.

---

## 1. Introduction to Assertions

Assertions in GoogleTest verify that your code behaves as expected during test execution. They come in two main flavors:

- **Non-fatal assertions (`EXPECT_` macros):** Allow the test function to continue running after failure.
- **Fatal assertions (`ASSERT_` macros):** Immediately abort the current test function on failure.

Use non-fatal assertions when you want all checks in a test to run independently and report failures collectively. Use fatal assertions when continuing execution after a failure would be pointless or cause crashes.

> For example, validating a pointer before dereferencing it should use a fatal assertion.

---

## 2. Assertion Types and Usage

### 2.1 Boolean Conditions

Use these when you need to test simple true/false expressions.

```cpp
EXPECT_TRUE(condition);   // Passes if 'condition' is true.
ASSERT_FALSE(flag);       // Fails fatally if 'flag' is true.
```


### 2.2 Equality and Inequality Comparisons

Most commonly used assertions test equality or inequality between two values.

| Assertion    | Meaning                          | Notes                                   |
|--------------|---------------------------------|-----------------------------------------|
| `EXPECT_EQ(a, b)` | Checks if `a == b`                | Pointer equality if `a` and `b` are pointers. Use `EXPECT_STREQ` for C strings. |
| `ASSERT_NE(a, b)` | Checks if `a != b`                | Same notes as above.                     |
| `EXPECT_LT(a, b)` | Checks if `a < b`                 | Useful for ordered values.               |
| `EXPECT_LE(a, b)` | Checks if `a <= b`                |                                         |
| `EXPECT_GT(a, b)` | Checks if `a > b`                 |                                         |
| `EXPECT_GE(a, b)` | Checks if `a >= b`                |                                         |


> **Important:**
> - For C-style string comparisons, use dedicated assertions: `EXPECT_STREQ`, `EXPECT_STRNE`, `EXPECT_STRCASEEQ`, and `EXPECT_STRCASENE`.


### 2.3 Explicit Success and Failure

Sometimes your test logic requires explicitly marking success or failure:

```cpp
SUCCEED();  // Mark a checkpoint in the test that always passes.
FAIL() << "This line failed because of X reason";  // Immediate fatal failure.
ADD_FAILURE() << "Non-fatal failure, continue running.";
```

This allows tests with conditional logic to be more descriptive and manageable.

### 2.4 Floating Point Comparisons

Due to rounding issues, always use specialized floating-point assertions instead of `EXPECT_EQ`:

```cpp
EXPECT_FLOAT_EQ(val1, val2);   // For float values with ~4 ULP tolerance.
EXPECT_DOUBLE_EQ(val1, val2);  // For double values with ~4 ULP tolerance.
EXPECT_NEAR(val1, val2, abs_error);  // For absolute error bounds.
```

Use these for reliable floating-point tests that won't fail due to minimal rounding differences.

### 2.5 Exception Assertions

Verify that your code throws or does not throw expected exceptions:

```cpp
EXPECT_THROW(statement, ExceptionType);    // Fails if statement doesn't throw that exception.
EXPECT_ANY_THROW(statement);                // Fails if no exception is thrown.
EXPECT_NO_THROW(statement);                 // Fails if any exception is thrown.
```

> You may wrap multiple statements inside `{}` to test compound behavior.

---

## 3. Using Matchers with `EXPECT_THAT`

GoogleTest supports expressive value verification with [matchers](reference/matchers.md). The `EXPECT_THAT()` macro pairs a value with a matcher to verify complex conditions.

```cpp
EXPECT_THAT(my_string, StartsWith("Hello"));
EXPECT_THAT(my_vector, ElementsAre(1, 2, 3));
ASSERT_THAT(result, AllOf(Gt(5), Lt(10)));
```

Matchers allow readable and powerful assertions that generate clear failure messages.

---

## 4. Writing Effective Assertions

### 4.1 Choose Assertion Type by Intent

- Use `EXPECT_` when you want to continue the test even if the condition fails, allowing multiple checks in one function.
- Use `ASSERT_` when failing the condition should abort the test immediately (e.g., input validation).

### 4.2 Prefer More Specific Assertions

Whenever possible, use the most specific assertion macro that clearly expresses the intent. For example, use `EXPECT_STREQ` for C strings instead of generic equality `EXPECT_EQ`.

### 4.3 Stream Descriptive Messages

Augment assertions with custom failure messages using the `<<` operator:

```cpp
EXPECT_EQ(result, expected) << "Calculation failed for input " << input_value;
```

This improves diagnosis when failures occur.

### 4.4 Avoid Side Effects in Assertions

Because assertions may evaluate their arguments once or more, ensure the parameters and expressions do not have side effects that affect program behavior.

### 4.5 Use Predicate Assertions for Complex Logic

When checking complex conditions with predicates or functions, use `EXPECT_PRED*` or `EXPECT_PRED_FORMAT*` macros for clear failure messages.

---

## 5. Common Assertion Patterns

### 5.1 Checking Pointer Validity

```cpp
ASSERT_NE(ptr, nullptr) << "Pointer should never be null here.";
EXPECT_THAT(ptr, NotNull());
```

### 5.2 Verifying Container Contents

```cpp
EXPECT_THAT(vector, ElementsAre(1, 2, 3));
EXPECT_THAT(map, UnorderedElementsAre(Pair("foo", 42), Pair("bar", 17)));
```

### 5.3 Expecting Exceptions

```cpp
EXPECT_THROW({ DoSomethingThatThrows(); }, std::runtime_error);
```

---

## 6. Troubleshooting Assertions

### 6.1 Common Pitfalls

- **Using ASSERT_ and then dereferencing invalid pointers:** Fatal failures abort the function, but if the failure is non-fatal, it proceeds with invalid state.
- **Misusing `EXPECT_EQ` on C strings:** Does pointer equality, not value equality. Use `EXPECT_STREQ` instead.
- **Side-effects in assertion expressions:** You might get confusing test behaviors.

### 6.2 Debugging Failing Assertions

- Run tests with verbose output.
- Add descriptive messages to understand failing conditions.
- Use `--gtest_break_on_failure` to stop tests at first failure.

---

## 7. Advanced Assertion Usage

### 7.1 Custom Assertion Macros

Define your own macros to wrap repetitive assertion patterns:

```cpp
#define EXPECT_STATUS_OK(status) EXPECT_EQ(status.code(), 0) << status.message()
```

### 7.2 Predicate-Format Assertions

Provide rich diagnostic info by implementing predicate-formatters and using `EXPECT_PRED_FORMAT*` macros.

### 7.3 Leveraging Assertions in Parameterized Tests

Use assertions inside parameterized tests to verify varied inputs systematically.

---

## 8. Summary

GoogleTest's assertion macros empower you to verify virtually any condition in your code with clarity and precision. Understanding when to use fatal vs. non-fatal assertions, how to employ matchers for expressive tests, and best practices for writing and debugging assertions leads to robust, maintainable tests.

Explore related content to deepen your test-writing skills and mastery of GoogleTest assertions.

---

## Related Links

- [Assertions Reference](../reference/assertions.md)
- [Matchers Reference](../reference/matchers.md)
- [Writing Your First Test](../../getting-started/first-test-validation/writing-your-first-test)
- [Using Assertions Effectively](./using-assertions-effectively)
