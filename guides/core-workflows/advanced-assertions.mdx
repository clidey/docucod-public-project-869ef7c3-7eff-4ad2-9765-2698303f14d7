---
title: "Mastering Assertions and Matchers"
description: "How to use and combine advanced assertions, custom matchers, and predicate checks to write expressive, robust, and maintainable tests."
---

# Mastering Assertions and Matchers

Harness the full power of GoogleTest's assertion macros, predicate checks, and matchers, enabling you to write clear, expressive tests that deliver insightful failure messages. This guide will equip you with practical knowledge to combine built-in assertions, custom predicates, and rich matchers, transforming your testing experience.

---

## 1. Understanding Assertions in GoogleTest

Assertions are the core means to verify code behavior in tests. GoogleTest provides two main categories:

- **EXPECT_** macros: Report failures but allow tests to continue.
- **ASSERT_** macros: Report failures and abort the current test function.

All assertions support streaming custom failure messages using `<<`, which can include variables and expressions for rich diagnostics.

### Core Assertion Categories

- **Boolean Assertions**:
  - `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
  - `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

- **Comparison Assertions**:
  - `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
  - `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`
  - `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
  - `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
  - `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
  - `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

- **String Assertions (C-strings and wide strings)**:
  - `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)` for equality
  - `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)` for inequality
  - `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)` case-insensitive equality
  - `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)` case-insensitive inequality

- **Floating-Point Assertions:**
  - `EXPECT_FLOAT_EQ()` / `ASSERT_FLOAT_EQ()` for approximate equality within 4 ULPs
  - `EXPECT_DOUBLE_EQ()` / `ASSERT_DOUBLE_EQ()`
  - `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`

- **Exception Assertions:**
  - `EXPECT_THROW(statement, exception_type)`
  - `EXPECT_ANY_THROW(statement)`
  - `EXPECT_NO_THROW(statement)`

- **Death Assertions:**
  - `EXPECT_DEATH(statement, regex)`
  - `EXPECT_EXIT(statement, predicate, regex)`

---

## 2. Using Predicate Assertions for Complex Conditions

When simple Boolean assertions don't provide sufficient diagnostics, predicate assertions enable you to write custom predicates or predicate-formatters that output detailed failure information.

### Predicate Assertions

These macros check a predicate function that returns `bool`:

- `EXPECT_PRED1(pred, val1)`, `EXPECT_PRED2(pred, val1, val2)`, ... up to 5 args
- `ASSERT_PRED1`, `ASSERT_PRED2`, ...

Arguments are always evaluated exactly once.

#### Usage Example:

```cpp
// Predicate to check if two integers are mutually prime.
bool MutuallyPrime(int m, int n) { ... }

EXPECT_PRED2(MutuallyPrime, a, b);  // passes
EXPECT_PRED2(MutuallyPrime, b, c);  // fails with args and values printed
```

> If using overloaded or templated functions, explicitly cast for correct macro expansion:

```cpp
EXPECT_PRED1(static_cast<bool(*)(int)>(IsPositive), 5);
EXPECT_PRED1(IsNegative<int>, -5);
```


### Predicate-Format Assertions

For even finer control over failure message formatting, use Predicate-Format assertions. Here, the predicate function returns `testing::AssertionResult`, allowing you to specify detailed success/failure messages.

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)` ... to 5 args
- `ASSERT_PRED_FORMAT1`, ...

Each `pred_formatter` has signature:

```cpp
testing::AssertionResult PredicateFormatter(const char* expr1, ..., T1 val1, ...);
```

#### Usage Example:

```cpp
// Checks if integers are mutually prime with a detailed failure message.
testing::AssertionResult AssertMutuallyPrime(const char* m_expr, const char* n_expr, int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << m_expr << " and " << n_expr << " (" << m << " and " << n << ") are not mutually prime.";
}

EXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);  // passes
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c);  // fails with custom message
```

---

## 3. Combining Assertions with Matchers

GoogleTest integrates tightly with gMock matchers, enabling you to write expressive assertions that read like natural language and deliver rich failure diagnostics.

Use `EXPECT_THAT(value, matcher)` and `ASSERT_THAT(value, matcher)` to assert that `value` satisfies the specified matcher.

### Examples:

```cpp
// Verifying string properties
EXPECT_THAT(foo_string, ::testing::StartsWith("Hello"));
EXPECT_THAT(bar_string, ::testing::MatchesRegex("Line \\d+"));

// Combining matchers for numeric ranges
EXPECT_THAT(value, ::testing::AllOf(::testing::Gt(5), ::testing::Lt(10)));
```

Matchers can be combined, nested, and user-defined; see the [Matchers Reference](reference/assertions.md#EXPECT_THAT) for full details.

---

## 4. Best Practices and Tips

- **Choose `EXPECT_` when you want to collect multiple errors in a single test run and `ASSERT_` when failure should halt the current function immediately.**

- **Use predicate-format assertions to improve failure message clarity for complex conditions or when operands do not support streaming.**

- **Always evaluate assertion arguments exactly once to avoid side-effects duplication.** GoogleTest macros guarantee this.

- **When writing death tests, prefix your test suite name with `*DeathTest` to ensure correct test ordering and thread safety.**

- **Avoid mixing `TEST()` and `TEST_F()` in the same test suite; all tests in a suite must use the same fixture type.**

- **Use `SCOPED_TRACE` to add contextual traces to assertions inside helper functions or loops, clarifying failure locations.**

- **Stream custom failure messages with `<<` to provide actionable diagnostics.**

- **For floating-point comparisons, prefer `EXPECT_FLOAT_EQ`/`EXPECT_DOUBLE_EQ` over bare equality to avoid false negatives due to rounding. Use `EXPECT_NEAR` for approximate checks with explicit error bounds.**

- **Record additional test properties with `RecordProperty()` to capture metadata for output reports (e.g., max iterations, inputs).**

- **Use `HasFatalFailure()` or `ASSERT_NO_FATAL_FAILURE()` in helper functions to catch propagated fatal failures and stop further execution if needed.**

---

## 5. Common Pitfalls and Troubleshooting

- **Using fatal assertions in constructor or destructor functions is prohibited and will cause compile errors. Use `SetUp()` / `TearDown()` instead.**

- **Predicate assertion macros may require explicit function pointer casts for templated or overloaded predicates.**

- **Placing multiple death tests on the same source line can break compilation; place each on a separate line.**

- **Expectations in Death Tests should avoid freeing memory or cleaning shared resources because the parent process does not observe side-effects in the child process.**

- **Disabled tests (names starting with `DISABLED_`) are compiled but not run; to include them, use the `--gtest_also_run_disabled_tests` flag.**

- **If no tests run despite being linked, ensure your test suffixes and instantiations are correct and that test registration occurs before `RUN_ALL_TESTS()`.**

---

## 6. Practical Code Examples

### Writing a Predicate Function for `EXPECT_PRED2`

```cpp
// Check if two integers are coprime.
bool MutuallyPrime(int m, int n) {
    // ...implementation...
}

TEST(NumberTheoryTest, CheckMutuallyPrime) {
  int a = 3, b = 4, c = 10;
  EXPECT_PRED2(MutuallyPrime, a, b);  // succeeds
  EXPECT_PRED2(MutuallyPrime, b, c);  // fails, prints actual values
}
```

### Writing a Predicate-Formatter for `EXPECT_PRED_FORMAT2`

```cpp
#include <gtest/gtest.h>

using ::testing::AssertionFailure;
using ::testing::AssertionResult;
using ::testing::AssertionSuccess;

// Predicate-formatter for checking sum positivity.
testing::AssertionResult AssertSumPositive(const char* e1, const char* e2, int v1, int v2) {
  if (v1 + v2 > 0)
    return AssertionSuccess();
  else
    return AssertionFailure() << e1 << " + " << e2 << " is expected to be positive, but evaluates to " << (v1 + v2) << ".";
}

TEST(MathTest, SumPositivity) {
  EXPECT_PRED_FORMAT2(AssertSumPositive, 2, 3);  // passes
  EXPECT_PRED_FORMAT2(AssertSumPositive, -5, 2);  // fails with custom message
}
```

### Using Matchers with `EXPECT_THAT`

```cpp
#include <gmock/gmock.h>

using ::testing::HasSubstr;
using ::testing::StartsWith;

TEST(StringTest, MatchersUsage) {
  std::string s = "Hello, world!";
  EXPECT_THAT(s, StartsWith("Hello"));  // passes
  EXPECT_THAT(s, HasSubstr("world"));  // passes
  EXPECT_THAT(s, HasSubstr("bye"));    // fails
}
```

---

## 7. Next Steps & Related Resources

- Explore the [Assertions Reference](reference/assertions.md) for a complete list and details of assertion macros.
- Dive into the [GoogleTest Primer](docs/primer.md) to master basics and foundational concepts.
- Learn about [Parameterized and Typed Tests](overview/core-concepts/parameterized-and-type-tests.mdx) to write scalable tests.
- See [Advanced GoogleTest Topics](docs/advanced.md) for tricks on custom predicates and exception handling.
- Integrate GoogleMock matchers for expressive mocks and assertions.
- Discover best practices in the [Test Organization](guides/core-workflows/test-organization.mdx) and [Advanced Assertions](guides/core-workflows/advanced-assertions.mdx) guides.

---

*Master your test suite with precise assertions and expressive matchers, making testing a powerful tool for code quality.*

---