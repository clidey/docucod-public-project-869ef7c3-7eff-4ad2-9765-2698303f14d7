---
title: "Using Death Tests and Error Handling"
description: "A practical guide to verifying correct crash/error handling with death tests, fatal and non-fatal failures, and reliable fault detection."
---

# Using Death Tests and Error Handling

A practical guide to verifying correct crash/error handling with death tests, fatal and non-fatal failures, and reliable fault detection.

---

## Workflow Overview

### What This Guide Helps You Accomplish

This guide empowers you to reliably test and verify code that is expected to terminate ("die") under specific conditions — such as failed assertions, fatal errors, or process aborts. It covers constructing death tests with GoogleTest macros like `EXPECT_DEATH` and `ASSERT_DEATH`, understanding fatal vs non-fatal failures, and how to handle error detection gracefully.

### Prerequisites

- GoogleTest installed and properly integrated in your C++ project.
- Basic familiarity with writing test cases using GoogleTest macros (`TEST`, `ASSERT_`, `EXPECT_`) and handling assertions.
- Understanding the difference between fatal and non-fatal failures.
- Knowledge of exceptions in C++ (for related exception assertions).

### What You Will Achieve

- Mastery of death testing techniques that verify process-terminating code.
- Ability to write tests that confirm the program crashes or exits as expected.
- Understanding death test macros including `EXPECT_DEATH`, `ASSERT_DEATH`, `EXPECT_EXIT`.
- Skills to detect and handle fatal and non-fatal failures effectively.
- Awareness of special flags and behaviors affecting death tests such as thread safety.

### Time Estimate

About 20–30 minutes to read through, practice examples, and apply death test principles in your tests.

### Difficulty Level

Intermediate to Advanced — understanding process behavior and testing for program termination requires careful handling.

---

## Step-by-Step Instructions

### 1. Understanding Death Tests and Purpose

Death tests verify that a given statement or function causes the program to terminate as expected. This is critical when testing code that triggers fatal errors or asserts.

### 2. Using Death Test Macros

GoogleTest provides the following core macros to write death tests:

- `ASSERT_DEATH(statement, regex)`
- `EXPECT_DEATH(statement, regex)`
- `ASSERT_EXIT(statement, predicate, regex)`
- `EXPECT_EXIT(statement, predicate, regex)`
- Others: `EXPECT_DEATH_IF_SUPPORTED`, `EXPECT_DEBUG_DEATH`, `ASSERT_DEBUG_DEATH`

**How to use:**

```cpp
TEST(MyDeathTest, VerifiesCrash) {
  ASSERT_DEATH({ FunctionToTest(); }, "expected error message regex");
}

// Verify normal exit with Expected exit code and match stderr
TEST(MyDeathTest, VerifiesExit) {
  EXPECT_EXIT(NormalExitFunction(), ::testing::ExitedWithCode(0), "Success");
}
```

- The `statement` can be a single statement or a compound statement within `{}`.
- The death test runs the code in a child process.
- The `regex` is a string or matcher specifying the expected error message output on `stderr`.
- The predicate in `ASSERT_EXIT` / `EXPECT_EXIT` is a function/functor that checks the exit code.

### 3. Choosing Between Fatal and Non-Fatal Macros

- Use `ASSERT_` macros when you want the test to abort immediately on failure.
- Use `EXPECT_` macros if you want the test function to continue after a failure.

### 4. Handling Thread Safety in Death Tests

- By default, GoogleTest offers two death test styles controlled by the `--gtest_death_test_style` flag:
  - "fast": Child process runs the test immediately after `fork()`.
  - "threadsafe": Child process re-executes the test binary with extra flags to run only the death test.

- "threadsafe" style is recommended when your tests run in a multi-threaded environment to avoid deadlocks.

To set death test style programmatically:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

### 5. Best Practices for Writing Death Tests

- Name test suites containing death tests with the suffix `DeathTest` to ensure they run first.
- Avoid placing multiple death test assertions on the same source code line.
- Avoid fatal assertions inside non-void-returning functions used within death test statements.
- Streams passed to death test macros are treated as regex by default for matching error output.
- Ensure side effects inside death test code are minimal, as the code runs in a separate process.

### 6. Detecting Fatal vs Non-Fatal Failures

- `FAIL()` and `ASSERT_*` generate *fatal* failures that abort the current test function.
- `ADD_FAILURE()` and `EXPECT_*` generate *non-fatal* failures that allow the test to continue.

### 7. Writing Exception Assertions (Related)

GoogleTest provides the following macros to assert exception behavior:

- `EXPECT_THROW(statement, exception_type)`
- `ASSERT_THROW(statement, exception_type)`
- `EXPECT_NO_THROW(statement)`
- `ASSERT_NO_THROW(statement)`
- `EXPECT_ANY_THROW(statement)`
- `ASSERT_ANY_THROW(statement)`

These are useful for verifying exception handling as distinct from death tests.

### 8. Using `SCOPED_TRACE` for Context in Failures

When assertions occur inside common subroutines, `SCOPED_TRACE` helps by attaching contextual messages to failures, improving diagnostics.

Example:

```cpp
SCOPED_TRACE("In complex helper");
EXPECT_TRUE(CheckCondition());
```

### 9. Recording Test Properties During Tests

You can record custom key-value properties in tests or test suites using:

```cpp
::testing::Test::RecordProperty("PropertyKey", "PropertyValue");
```

This data appears in generated XML and JSON reports.

---

## Examples & Code Samples

### Basic Death Test Example

```cpp
TEST(MyDeathTest, DiesWithErrorMessage) {
  // Verify that calling Foo crashes and prints "Invalid parameter".
  ASSERT_DEATH({ Foo(-1); }, "Invalid parameter");
}
```

### Death Test with Compound Statement

```cpp
TEST(MyDeathTest, ComplexCondition) {
  ASSERT_DEATH({
    int x = 42;
    Bar(x);
  }, "Assertion failed");
}
```

### Using `EXPECT_EXIT` with Exit Status Check

```cpp
bool ExitedWithZero(int status) {
  return ::testing::ExitedWithCode(0)(status);
}

TEST(MyDeathTest, ExitsCleanly) {
  EXPECT_EXIT(CleanExitFunction(), ExitedWithZero, "Completed successfully");
}
```

### Testing Exception Throwing

```cpp
TEST(ExceptionTest, ThrowsExpected) {
  EXPECT_THROW(ThrowingFunction(), std::runtime_error);
  EXPECT_NO_THROW(SafeFunction());
}
```

### Using `SCOPED_TRACE` for Tracing Failures in Loops

```cpp
for (int i = 0; i < 5; ++i) {
  SCOPED_TRACE(testing::Message() << "Iteration: " << i);
  EXPECT_TRUE(CheckValue(i));
}
```

---

## Troubleshooting & Tips

### Common Issues

- **Death test did not die:** Occurs when the tested code returns normally or completes without terminating. Ensure the code intentionally aborts or crashes.
- **Error message mismatch:** If the stderr output doesn't match the regex provided, the death test fails. Verify the regex pattern matches the expected error message.
- **Multiple threads warning:** Death tests are unsafe when multiple threads are running. Consider using the 'threadsafe' death test style.
- **Multiple death tests on the same line:** Leads to compilation errors. Place each death test on a separate line.
- **Fatal assertions in non-void functions:** Fatal assertions abort only the current function; avoid in non-void-return type for death test statements.

### Best Practices

- Use the recommended `DeathTest` suffix for test suites to prioritize execution appropriately.
- Prefer `ASSERT_DEATH` when you want immediate abortion on failure.
- Use `EXPECT_DEATH` if you want to continue subsequent tests despite failure.
- Use custom predicates with `EXPECT_EXIT` and `ASSERT_EXIT` for precise control over exit codes.
- Stream error messages for more descriptive failure reports.
- When testing with mocks inside death tests, consider `Mock::AllowLeak` to avoid false leak failures.

### Performance Considerations

- Use "fast" death test style when thread safety is not a concern — it has less overhead.
- Use "threadsafe" style when testing multi-threaded code for robust test results, but expect longer durations due to re-execution of binaries.

### Alternative Approaches

- For code throwing exceptions, use the exception assertion macros instead of death tests.
- Use predicate-formatter assertions for complex predicate validation with custom messages.

---

## Next Steps & Related Content

- Explore [Death Assertions](reference/assertions.md#death) for detailed macro descriptions.
- Learn about [Exception Assertions](reference/assertions.md#exceptions) for throwing/non-throwing behavior.
- Understand best practices for [Assertions and Matchers](overview/core-concepts/assertions-and-matchers) to extend test expressiveness.
- Check out the [GoogleMock Cookbook](guides/core-workflows/mocking-scenarios) for advanced mocking along with death tests.
- Review the [Advanced GoogleTest Topics](docs/advanced.md#death-tests) for complementary insights.
- Use [SCOPED_TRACE](docs/advanced.md#using-assertions-in-sub-routines) for improved test failure diagnostics.
- For setup issues related to death tests, see [Troubleshooting Common Setup Issues](getting-started/troubleshooting-resources/troubleshooting-common-issues).

---

<AccordionGroup title="Death Test Macros Quick Reference">
<Accordion title="ASSERT_DEATH and EXPECT_DEATH">

Use these to verify that a statement causes the process to terminate with nonzero exit status and produces error output matching a regex or matcher:

```cpp
ASSERT_DEATH(statement, regex);
EXPECT_DEATH(statement, regex);
```

Difference: `ASSERT_DEATH` aborts the current test on failure, `EXPECT_DEATH` continues.

</Accordion>
<Accordion title="ASSERT_EXIT and EXPECT_EXIT">

Use these to verify process termination with specific exit status and error output:

```cpp
ASSERT_EXIT(statement, predicate, regex);
EXPECT_EXIT(statement, predicate, regex);
```

Here, `predicate` tests specific exit code or signal.

</Accordion>
<Accordion title="EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED">

These macros perform the same as `EXPECT_DEATH` and `ASSERT_DEATH` when death tests are supported, and do nothing (except warning) otherwise. Helps portability.

</Accordion>
<Accordion title="EXPECT_DEBUG_DEATH and ASSERT_DEBUG_DEATH">

They run death tests in debug builds; in release builds the statement is executed without aborting.

</Accordion>
</AccordionGroup>

<Tip>
Always test death code with a regex pattern that matches the actual output; bare string arguments are treated as regex for convenience. Use gMock matchers for more control.
</Tip>

<Warning>
Avoid running death tests with multiple death test statements on the same line as this results in compilation errors.
</Warning>

<Note>
Death tests fork or spawn child processes; side effects in these processes will not affect the parent process and may cause memory leak detectors to report false positives if resources are released only in the death test process.
</Note>

---

## Additional Resources and Links

- [GoogleTest Assertions Reference](reference/assertions.md#death)
- [GoogleTest Advanced Topics](docs/advanced.md#death-tests)
- [GoogleMock Cookbook for Mocking Scenarios](guides/core-workflows/mocking-scenarios)
- [Troubleshooting Common Setup Issues](getting-started/troubleshooting-resources/troubleshooting-common-issues)
- [GoogleTest Overview](overview/product-intro/about-googletest)
- [Writing Your First Test](guides/getting-started/writing-first-test)

