---
title: "Parameterized and Typed Tests"
description: "Step-by-step instructions on creating value- and type-parameterized tests to reduce duplication and increase test coverage, including best practices for cross-platform and generic code."
---

# Parameterized and Typed Tests

GoogleTest offers powerful features called parameterized and typed tests to help you write concise, flexible, and maintainable test code. These tests reduce duplication by allowing you to reuse the same test logic over multiple data inputs or types, dramatically increasing test coverage with minimal effort.

---

## Understanding Parameterized and Typed Tests

Both mechanisms let you run the same test logic multiple times, but they differ in intent and usage:

- **Value-Parameterized Tests** run the same test with different *values* as parameters.
- **Typed Tests** run the same test with different *types*.
- **Type-Parameterized Tests** are a more flexible variation allowing you to define abstract test patterns and instantiate them with different types later.

These approaches enable you to write generalized tests that are instantiated as many times as necessary by GoogleTest, improving code reuse and test completeness.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to define a test fixture class parameterized by values, then instantiate that test with various parameters.

### When to Use

- Testing code behavior with various inputs.
- Comparing different implementations where different constructor parameters or factory functions are needed.
- Data-driven testing scenarios.

### How to Write Value-Parameterized Tests

<Steps>
<Step title="Define the Test Fixture">
Create a fixture class derived from `::testing::TestWithParam<T>`, where `T` is the parameter type you will pass.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // Usual setup & members
};
```

You can also combine with inherited fixtures by multiple inheritance:

```cpp
class BaseFixture : public testing::Test {};
class DerivedValueTest : public BaseFixture, public testing::WithParamInterface<std::string> {};
```
</Step>

<Step title="Write Tests with `TEST_P`">
Define each test with the `TEST_P` macro. Inside the test, access the parameter with `GetParam()`:

```cpp
TEST_P(MyValueTest, ProcessesParameter) {
  int param = GetParam();
  EXPECT_GT(param, 0);
  // Test logic with param
}
```
</Step>

<Step title="Instantiate the Test Suite">
Use `INSTANTIATE_TEST_SUITE_P` to instantiate your test suite with specific parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
  SampleValues, MyValueTest, testing::Values(1, 2, 3, 42));
```

This creates four tests named:

- `SampleValues/MyValueTest.ProcessesParameter/0` for parameter 1,
- `SampleValues/MyValueTest.ProcessesParameter/1` for parameter 2, etc.

You can use other generators like `Range()`, `ValuesIn()`, `Bool()`, and `Combine()` to create parameter sequences.

To provide custom test name suffixes, supply a name generator functor or lambda as the last argument.

</Step>
</Steps>

### Example

```cpp
class FooTest : public ::testing::TestWithParam<std::string> {};

TEST_P(FooTest, LengthIsNonZero) {
  EXPECT_GT(GetParam().size(), 0);
}

INSTANTIATE_TEST_SUITE_P(
  SampleStrings, FooTest, testing::Values("abc", "def", "ghi"));
```

This will run the same test for three string values.

### Best Practices

- Declare `SetUpTestSuite()` and `TearDownTestSuite()` as **public** when used in parameterized fixtures.
- Ensure parameters are copyable and safely managed if pointers are used.
- Provide meaningful names for each instantiation to improve test reports.
- Avoid overly large parameter lists to maintain test execution speed.

---

## Typed Tests

Typed tests let you run the same test logic on a list of types. Each instantiation uses the type as a template parameter.

### When to Use

- Testing different implementations of an interface that are instantiated by default constructor (or similar uniform methods).
- Validating type properties, concepts or templates against multiple types.

### How to Write Typed Tests

<Steps>
<Step title="Define the Test Fixture Template">
Define a class template fixture parameterized by a type, derived from `::testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // Members using T
};
```
</Step>

<Step title="Associate a Type List">
Define a type list using `::testing::Types` and associate it with your fixture using `TYPED_TEST_SUITE`:

```cpp
using MyTypes = ::testing::Types<int, bool>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>

<Step title="Define Typed Tests Using `TYPED_TEST`">
Write your tests with the `TYPED_TEST` macro, using `TypeParam` to refer to the current type parameter.

```cpp
TYPED_TEST(MyTypedTest, ExampleTest) {
  TypeParam value = 0;
  EXPECT_EQ(value, TypeParam{});
}
```
</Step>
</Steps>

### Example

```cpp
template <typename T>
class TypedTestFixture : public ::testing::Test {
 public:
  T value_ = T();
};

typedef ::testing::Types<int, bool> MyTypes;
TYPED_TEST_SUITE(TypedTestFixture, MyTypes);

TYPED_TEST(TypedTestFixture, DefaultConstructible) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```

### Best Practices

- Use typed tests when all types can be constructed and tested similarly.
- Typed tests provide default output showing which type failed to speed debugging.
- Use typed tests to verify template code and generic interfaces.
- You must know the full list of types at the point of test definition.

---

## Type-Parameterized Tests

This is an extension of typed tests allowing you to declare abstract test suites without specifying types upfront, then register and instantiate them multiple times with different type lists.

### When to Use

- Defining reusable test patterns for interfaces or concepts.
- Libraries that provide abstract tests for different user types.

### How to Write and Use

<Steps>
<Step title="Define the Fixture Template">
Write a fixture template derived from `::testing::Test` (like typed tests).

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {};
```
</Step>

<Step title="Declare Test Suite with `TYPED_TEST_SUITE_P">
Declare it as a type-parameterized suite:

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

Then write test patterns using `TYPED_TEST_P`.

```cpp
TYPED_TEST_P(MyTypeParamTest, TestBehavior) {
  TypeParam v = TypeParam();
  EXPECT_TRUE(...);
}
```
</Step>

<Step title="Register Tests">
Register the tests by name with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestBehavior);
```
</Step>

<Step title="Instantiate Suite with Types">
Instantiate the suite for a list of types with `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = ::testing::Types<int, bool>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, MyTypeParamTest, MyTypes);
```
</Step>
</Steps>

### Example

```cpp
template <typename T>
class TypeParameterizedTestSuite : public ::testing::Test {};

TYPED_TEST_SUITE_P(TypeParameterizedTestSuite);

TYPED_TEST_P(TypeParameterizedTestSuite, TestFunctionality) {
  TypeParam v = TypeParam();
  EXPECT_TRUE(...);
}

REGISTER_TYPED_TEST_SUITE_P(TypeParameterizedTestSuite, TestFunctionality);

typedef ::testing::Types<int, bool> MyTypes;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, TypeParameterizedTestSuite, MyTypes);
```

### Best Practices

- Use type-parameterized tests to create flexible reusable tests.
- Register all test patterns before instantiating the suite.
- Choose unique prefixes for each instantiation to distinguish tests.

---

## Common Considerations and Tips

- **Avoid underscores in test suite and test names**: Underscores in names can cause collisions due to internal naming conventions and reserved patterns. Refer to the [FAQ on naming](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore) for details.

- **Output clarity**: Typed tests include the type name in output, making failures easier to diagnose. Value-parameterized tests show iteration indices; add custom parameter name generators for better readability.

- **Execution isolation**: Each test instance runs in a dedicated fixture object to isolate state changes and prevent side effects.

- **Instantiations must appear in global or namespace scope** because the parameter generation occurs during GoogleTest initialization.

- **Constructors and setup**: Avoid fatal assertions in constructors; prefer `SetUp()`. Also, fixtures for parametrized tests require **public** `SetUpTestSuite()` and `TearDownTestSuite()` when used.

- **Parameter types**: Choose types that are copyable and printable by GoogleTest or provide custom printers (`PrintTo`, `AbslStringify`) for complex types.

- **Combining generators and custom converters**: Use `testing::Combine()`, `testing::ConvertGenerator()`, and function/lambda converters to build complex parameter combinations or transform parameter types.

---

## Summary

GoogleTest's parameterized and typed tests provide scalable ways to run the same test logic over multiple values and types, reducing duplication and improving coverage.

This page has provided detailed step-by-step instructions, code examples, and best practices on:

- Writing **Value-Parameterized Tests** (`TEST_P`, `INSTANTIATE_TEST_SUITE_P`)
- Writing **Typed Tests** (`TYPED_TEST`, `TYPED_TEST_SUITE`)
- Using **Type-Parameterized Tests** (`TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, `INSTANTIATE_TYPED_TEST_SUITE_P`)

For even more advanced usage, including custom naming, abstract tests, and parameter generators, consult the related guides and [Advanced GoogleTest Topics](../advanced.md).

---

## References and Further Reading

- [GoogleTest Primer](../primer.md) for basics on writing tests
- [Advanced GoogleTest Topics: Parameterized Tests](../advanced.md#value-parameterized-tests) for extended details
- [Testing Reference: Parameterized and Typed Tests](../reference/testing.md#parameterized-and-typed-tests) for API and macros
- [GoogleTest FAQ](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore) on naming conventions
- Sample tests in `googletest/test` directory for practical examples

---

## Troubleshooting

<AccordionGroup title="Common Issues With Parameterized and Typed Tests">
<Accordion title="Tests Not Running or Reporting Failures">
- Check that you have instantiated the test suites correctly.
- Verify that you use `TEST_P` with parameterized fixtures and `TYPED_TEST` only with typed fixtures.
- Confirm that the parameterized suite is not missing `INSTANTIATE_TEST_SUITE_P`.
- For type-parameterized, ensure all tests are registered with `REGISTER_TYPED_TEST_SUITE_P`.
</Accordion>
<Accordion title="Disallowed Underscores in Test and Suite Names">
- GoogleTest forbids underscores at the beginning or end of test suite or test names and recommends no underscores at all.
- Rename tests to remove or relocate underscores to the middle if necessary.
- See the FAQ section for detailed rationale.
</Accordion>
<Accordion title="Custom Parameter Name Generation Issues">
- If test names have invalid characters, parameter name generator functions must sanitize or map parameters to alphanumeric strings.
- Use `testing::PrintToStringParamName` or write a custom functor or lambda.
</Accordion>
<Accordion title="Compiler Errors in Typed Tests">
- Make sure your compiler supports C++17 or later.
- Confirm you are using valid C++ type lists and template usages.
- Check for typos in macro usage.
</Accordion>
</AccordionGroup>

---

## Code Example: Complete Value-Parameterized Test

```cpp
#include <gtest/gtest.h>

class RangeTest : public ::testing::TestWithParam<int> {};

TEST_P(RangeTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(
    Positives, RangeTest, testing::Values(1, 2, 3, 10, 100));

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

This example tests multiple positive integer parameters in one concise suite.


## Code Example: Typed Test Suite

```cpp
#include <gtest/gtest.h>

template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_{};
};

typedef ::testing::Types<int, bool> MyTypes;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultInitialized) {
  EXPECT_EQ(this->value_, TypeParam{});
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```


## Code Example: Type-Parameterized Test Pattern

```cpp
#include <gtest/gtest.h>

template <typename T>
class MyTypeParamTest : public ::testing::Test {
 public:  
  void Helper() { /* ... */ }
};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, DoesThing) {
  this->Helper();
  EXPECT_TRUE(true);
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesThing);

typedef ::testing::Types<int, bool> MyTypes;
INSTANTIATE_TYPED_TEST_SUITE_P(MyTests, MyTypeParamTest, MyTypes);

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

## Visual Summary

```mermaid
graph TD
  subgraph Value-Parameterized Tests
    A[Define Fixture: TestWithParam<T>] --> B[Write TEST_P tests accessing GetParam()]
    B --> C[Instantiate with INSTANTIATE_TEST_SUITE_P & param generators]
  end

  subgraph Typed Tests
    D[Define Fixture Template<class T>] --> E[Associate type list with TYPED_TEST_SUITE]
    E --> F[Write TYPED_TEST using TypeParam]
  end

  subgraph Type-Parameterized Tests
    G[Define Fixture Template<class T>] --> H[Declare type-parameterized suite with TYPED_TEST_SUITE_P]
    H --> I[Write TYPED_TEST_P tests]
    I --> J[Register tests with REGISTER_TYPED_TEST_SUITE_P]
    J --> K[Instantiate with INSTANTIATE_TYPED_TEST_SUITE_P & type list]
  end

  Value-Parameterized Tests -->|Focus on values| L[Efficient testing of multiple data inputs]
  Typed Tests -->|Focus on types| L
  Type-Parameterized Tests -->|Flexible & reusable| L

```

---

For more examples, see:

- [`sample6_unittest.cc`](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc) for typed tests
- [`sample7_unittest.cc`](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) for value-parameterized tests

---

## Debugging Tips

- Use descriptive parameter naming via the `name_generator` argument to `INSTANTIATE_TEST_SUITE_P` for easier failure identification.
- Avoid modifying shared state in fixtures that can leak into other tests.
- Remember that each parameterized test runs in a fresh fixture instance.
- Use `SCOPED_TRACE` to add context within parameterized tests.

---

<Check>
Remember: Always return the result of `RUN_ALL_TESTS()` from your `main()` function to correctly indicate test success or failure.
</Check>

---

## Summary

Parameterized and typed tests in GoogleTest empower you to run extensive testing scenarios with minimal code duplication. Value-parameterized tests vary input data; typed and type-parameterized tests vary the tested type. By mastering these techniques, you'll write highly scalable, maintainable, and expressive tests.
