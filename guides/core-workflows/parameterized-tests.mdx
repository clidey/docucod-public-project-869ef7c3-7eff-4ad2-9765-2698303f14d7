---
title: "Parameterized and Typed Tests"
description: "Shows how to use value- and type-parameterized tests to write more concise and exhaustive test suites for reusable components, with tradeoffs and real-world patterns."
---

# Parameterized and Typed Tests

## Overview

This guide explains how to write concise and exhaustive test suites for reusable components using value-parameterized and type-parameterized tests in GoogleTest. These powerful testing techniques reduce code duplication, increase test coverage, and promote test reusability across different data inputs and types.

By mastering parameterized and typed tests, you'll be able to design tests that cover many scenarios efficiently while retaining clarity and maintainability. You'll also learn about trade-offs and real-world usage patterns.

---

## 1. Value-Parameterized Tests

### What Are Value-Parameterized Tests?

Value-parameterized tests run the same test logic multiple times with different parameter values. This eliminates repetitive test code and ensures broader input coverage.

They are ideal for testing functions or classes that behave differently based on input values, such as:

- Testing algorithms with various data inputs
- Validating functions that depend on configuration flags
- Testing multiple implementations that require different construction parameters

### Prerequisites

- Define or include a test fixture class specifically for value-parameterized tests.
- Your fixture must inherit from `testing::TestWithParam<T>`, where `T` is your parameter type.

### Steps to Write Value-Parameterized Tests

1. **Define the Fixture Class:**

   Derive from `testing::TestWithParam<T>`. You can add members and setup logic as with other fixtures.

   ```cpp
   class MyTestSuite : public ::testing::TestWithParam<int> {
     // Optional: add members and methods
   };
   ```

2. **Write Parameterized Tests Using `TEST_P`:**

   Inside the test, retrieve the parameter with `GetParam()`. Write your test logic using this parameter.

   ```cpp
   TEST_P(MyTestSuite, HandlesVariousValues) {
     int param = GetParam();
     EXPECT_TRUE(FunctionUnderTest(param));
   }
   ```

3. **Instantiate the Tests With Parameters Using `INSTANTIATE_TEST_SUITE_P`:**

   Use built-in parameter generators or your own containers to specify the parameters.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       SampleParameters,
       MyTestSuite,
       testing::Values(1, 2, 3));
   ```

4. **Run Tests:**

   Run `RUN_ALL_TESTS()` as usual; GoogleTest will run the test for each parameter.

### Parameter Generators

GoogleTest provides several generators to create parameter sequences:

| Generator          | Description                                                |
|--------------------|------------------------------------------------------------|
| `Range(start, end)`    | Generates sequence from `start` to `end - 1` with step 1   |
| `Values(v1, v2, ...)`  | Generates from explicit values                              |
| `ValuesIn(container)`  | Generates from any iterable container                       |
| `Bool()`               | Generates `false` and `true`                               |
| `Combine(g1, g2, ...)` | Generates Cartesian product of multiple generators          |
| `ConvertGenerator`     | Converts generated values using a cast or callable        |

For example, combining multiple generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedParams,
    MyTestSuite,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Customizing Test Naming

You can supply a function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P` to customize test names that appear in test reports and filtering. By default, GoogleTest generates numeric suffixes.


### Best Practices

- Use value-parameterized tests when behaviors depend mainly on input values.
- Keep parameter types copyable; beware of pointer lifetimes.
- Use `EXPECT_*` assertions inside parameterized tests to continue running for all parameters.

### Common Pitfalls

- Forgetting to instantiate a `TEST_P` with `INSTANTIATE_TEST_SUITE_P` causes failing tests in the `GoogleTestVerification` suite.
- Custom test name functions must only produce names with alphanumeric characters and underscores.

<Note>
Remember to avoid underscores (`_`) in test suite and test case names to prevent name mangling conflicts as described in our FAQ.
</Note>

---

## 2. Typed Tests

### What Are Typed Tests?

Typed tests enable repeating the *same* test logic over a given list of types. They verify interface conformity or behavior consistency across different types without rewriting test logic.

Ideal when:
- Testing multiple implementations of an interface
- Validating that various container or numeric types behave as expected

### Prerequisites

- Define a fixture class template parameterized by a type `T` that derives from `testing::Test`.
- Create a type list using `testing::Types<...>`.

### How to Write Typed Tests

1. **Define the Fixture Class Template:**

   ```cpp
   template <typename T>
   class MyTypedTest : public ::testing::Test {
    public:
     T value_ = T();
     // Optional static/shared members
   };
   ```

2. **Register the Type List With `TYPED_TEST_SUITE`:**

   Example:

   ```cpp
   using MyTypes = ::testing::Types<int, double, std::string>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Define Tests Using `TYPED_TEST`:**

   Inside the test, reference `TypeParam` as the test type parameter. Access members via `this->` or `TestFixture::`.

   ```cpp
   TYPED_TEST(MyTypedTest, InitializationWorks) {
     TypeParam val = this->value_;
     EXPECT_TRUE(IsValid(val));
   }
   ```

4. **Run Tests:**

   Tests run for each type in the registered list.


### Customizing Type Names

`TYPED_TEST_SUITE` accepts an optional third argument to specify a class that defines a templated static method `GetName(int)` to provide custom type-based test suite name suffixes.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## 3. Type-Parameterized Tests

### What They Are

Type-parameterized tests are like typed tests, but with the key difference that the list of types can be declared later and instantiated multiple times across compilation units. Useful for interface/interface-conformance testing where tests are defined once and instantiated as needed.

### How to Write Them

1. **Define Your Fixture Template:**

   ```cpp
   template <typename T>
   class MyTypeParamTest : public ::testing::Test {};
   ```

2. **Declare the Type-Parameterized Test Suite With `TYPED_TEST_SUITE_P`:**

   ```cpp
   TYPED_TEST_SUITE_P(MyTypeParamTest);
   ```

3. **Define Parameterized Tests With `TYPED_TEST_P`:**

   ```cpp
   TYPED_TEST_P(MyTypeParamTest, DoesXyz) {
     TypeParam value{};
     EXPECT_TRUE(DoSomething(value));
   }
   ```

4. **Register the Tests Using `REGISTER_TYPED_TEST_SUITE_P`:**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesXyz);
   ```

5. **Instantiate Tests With `INSTANTIATE_TYPED_TEST_SUITE_P`:**

   ```cpp
   using MyTypes = ::testing::Types<int, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTypeParamTest, MyTypes);
   ```


### Use Cases

- Defining abstract tests for an interface or concept
- Testing multiple implementations without rewriting tests

---

## 4. Practical Examples

### Value-Parameterized Test Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

int Factorial(int n);  // Function under test

TEST_P(FactorialTest, ComputesCorrectly) {
  int n = GetParam();
  int expected = ...;  // define expected factorial value
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(
    ValidInputs,
    FactorialTest,
    testing::Values(0, 1, 2, 3, 8));
```

### Typed Test Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T zero() { return T(0); }
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, ZeroIsZero) {
  EXPECT_EQ(this->zero(), TypeParam{});
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, StartsEmpty) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, StartsEmpty);

using MyContainers = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```

---

## 5. Tradeoffs and Tips

### Value-Parameterized Tests

- Keep parameters simple and copyable for ease of use.
- Use `Combine` to test multiple variables simultaneously.
- Beware that large parameter lists increase test run time.
- Provide meaningful test names using name generators.

### Typed Tests

- Suited for type-based polymorphism testing.
- Provide custom type names for clearer reporting.
- May require more setup but yield insightful type coverage.

### Type-Parameterized Tests

- Offer maximum flexibility for library authors.
- Can be instantiated in different binaries, promoting code reuse.

### Common Tips

- Avoid underscores in test and suite names.
- Use fixture setup and teardown to keep tests independent.
- Use `EXPECT_*` assertions over `ASSERT_*` when feasible to allow comprehensive error reporting.

---

## 6. Troubleshooting Common Issues

- **Test Not Running:** Ensure you instantiate value-parameterized tests properly with `INSTANTIATE_TEST_SUITE_P`.
- **Name Conflicts:** Do not use underscores in test and suite names.
- **Parameter Lifetime:** For pointer parameters, make sure the objects they point to live throughout test execution.
- **Conversion Errors:** When parameter types differ, use `ConvertGenerator` with a conversion function.
- **Compilation Errors:** Check your fixture class has a default constructor and correctly inherits from testing base classes.

---

## 7. Additional Resources

- [Value-Parameterized Tests section in Advanced Guide](advanced.md#value-parameterized-tests)
- [Typed Tests section in Advanced Guide](advanced.md#typed-tests)
- [Type-Parameterized Tests section in Advanced Guide](advanced.md#type-parameterized-tests)
- [`INSTANTIATE_TEST_SUITE_P` macro details](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [Typed Tests (`TYPED_TEST`) details](reference/testing.md#TYPED_TEST)

---