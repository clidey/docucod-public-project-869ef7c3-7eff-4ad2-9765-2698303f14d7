---
title: "Parameterized and Typed Tests"
description: "Learn how to create tests that automatically run on multiple input values and types. This page walks through value-parameterized and type-parameterized test patterns, demonstrating their use in increasing coverage while reducing duplication."
---

# Parameterized and Typed Tests

## Overview

This guide helps you create tests that automatically run over multiple input values and types, enabling broader coverage with less repetitive code. It focuses on two main techniques:

- Value-Parameterized Tests: Running the same test logic over a range of input values.
- Type-Parameterized Tests: Running the same test logic for different types.

By mastering these test patterns, you can write concise, maintainable, and powerful test suites that validate behavior comprehensively.

### Prerequisites

- Familiarity with basic googletest test cases.
- Understanding of mock objects and `EXPECT_CALL` usage.
- A working development environment configured with GoogleTest and GoogleMock (see setup guides).

### Expected Outcome

After following this guide, you will be able to:

- Define value-parameterized tests using test fixtures.
- Implement type-parameterized tests to verify template code.
- Use gMock matchers and actions effectively with param tests.

### Time Estimate

Around 10-20 minutes to grasp core concepts and set up simple examples.

### Difficulty Level

Intermediate: Requires knowledge of test fixtures and C++ templates.

---

## Creating Value-Parameterized Tests

Parameterized tests allow you to run the same test logic multiple times with different input values. This helps increase test coverage without duplicating code.

### Defining the Test Fixture

First, create a test fixture class inheriting from `::testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
#include <gtest/gtest.h>

class MyParamTest : public ::testing::TestWithParam<int> {
 // Optional setup/teardown
};
```

### Writing Tests Using the Parameter

Within the test body, access the test parameter with `GetParam()`.

```cpp
TEST_P(MyParamTest, HandlesEvenNumbers) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

### Instantiating the Test Suite with Values

Use `INSTANTIATE_TEST_SUITE_P` (or `INSTANTIATE_TEST_CASE_P` in older gtest versions) to specify the parameter values.

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers,
    MyParamTest,
    ::testing::Values(2, 4, 6, 8));
```

The above will run `HandlesEvenNumbers` test four times, each with one of the specified values.

### Example

```cpp
class IsPrimeTest : public ::testing::TestWithParam<int> {};

TEST_P(IsPrimeTest, CheckPrimality) {
  int n = GetParam();
  bool is_prime = /* your predicate */;
  EXPECT_TRUE(is_prime);
}

INSTANTIATE_TEST_SUITE_P(Primes, IsPrimeTest,
                         ::testing::Values(2, 3, 5, 7, 11, 13));
```

### Tips

- Use `::testing::ValuesIn()` to instantiate from a container.
- Combine with gMock expectations inside the test for behavior validation.

---

## Creating Type-Parameterized Tests

Type-parameterized tests enable the same test logic to validate behavior for multiple types, especially useful for template classes/functions.

### Defining a Typed Test Case

Declare a fixture class template deriving from `::testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // test setup
};
```

Register the test types:

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

Define tests using the `TYPED_TEST` macro within this suite:

```cpp
TYPED_TEST(MyTypedTest, DefaultConstructorWorks) {
  TypeParam obj;
  // Check something about obj
  EXPECT_TRUE(/* condition */);
}
```

### Example

```cpp
template <typename T>
class Stack {
 public:
  void Push(const T& value);
  T Pop();
  bool IsEmpty() const;
};

template <typename T>
class StackTest : public ::testing::Test {};

using StackTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(StackTest, StackTypes);

TYPED_TEST(StackTest, IsInitiallyEmpty) {
  Stack<TypeParam> stack;
  EXPECT_TRUE(stack.IsEmpty());
}
```

### Notes

- Use `TypeParam` to refer to the current type in tests.
- Fixture setup can depend on the type.
- You can write multiple `TYPED_TEST`s per test suite.

---

## Combining Parameterized Tests with gMock

You can put mock objects inside your parameterized fixtures to verify interactions across the different test inputs.

### Example

```cpp
class MyServiceTest : public ::testing::TestWithParam<int> {
 protected:
  MockDependency mock_dep;
};

TEST_P(MyServiceTest, UsesDependencyCorrectly) {
  int param = GetParam();
  EXPECT_CALL(mock_dep, Process(param)).Times(1);
  MyService service(&mock_dep);
  service.Run(param);
}

INSTANTIATE_TEST_SUITE_P(Parameters, MyServiceTest, ::testing::Values(1, 2, 3));
```

---

## Troubleshooting & Common Pitfalls

- **Compiling Errors Due to Commas in Parameter Types:**
  Wrap complex parameter types in extra parentheses or use type aliases to avoid macro parsing issues.

- **Order of `EXPECT_CALL` Matters:**
  When multiple expectations match, the later declared takes precedence.

- **Missing Virtual Destructor:**
  Always ensure interfaces have virtual destructors to avoid undefined behavior when mocking.

- **Misunderstanding Cardinality Inference:**
  If you use `WillOnce` but omit `Times()`, the number of `WillOnce`s infers the number of expected calls.

- **Const Method Mocking:**
  Add `(const, override)` to `MOCK_METHOD` declarations for const methods.

- **Parameterless EXPECT_CALL on Overloaded Methods:**
  This is a compilation error; specify parameters to disambiguate overload.

- **Testing with Move-Only Types:**
  Use lambdas in `WillOnce`/`WillRepeatedly` to return fresh instances.

---

## Tips and Best Practices

- Use parameterized tests to remove duplication and expand coverage inexpensively.
- Prefer type-parameterized tests for template-heavy code to ensure correctness across types.
- Use descriptive test and instantiation names to clarify test reports.
- Combine with gMock expectations/actions for richer, behavior-driven tests.
- Use sequences and partial ordering (`InSequence`, `.After()`) to control call order when necessary.

---

## Next Steps & Related Content

- Explore the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for technique recipes.
- Read the [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) for detailed API.
- Learn about [Matchers](https://google.github.io/googletest/reference/matchers.html) and [Actions](https://google.github.io/googletest/reference/actions.html).
- Try writing tests combining mocks with parameterized inputs.
- Consult the [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) for beginner tutorials.

---

# Quick Example Summary

```cpp
// Example value-parameterized test
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesCorrectly) {
  int n = GetParam();
  EXPECT_GE(factorial(n), 1);
}

INSTANTIATE_TEST_SUITE_P(IntegerTests, FactorialTest, ::testing::Values(1, 2, 3, 5, 8));

// Example type-parameterized test
template <typename T>
class NumericTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, SupportsAddition) {
  TypeParam a = 1;
  TypeParam b = 2;
  EXPECT_EQ(a + b, 3);
}
```

---