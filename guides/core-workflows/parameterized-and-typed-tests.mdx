---
title: "Parameterized and Type-Parameterized Tests"
description: "Implement value and type-parameterized tests to increase coverage and reduce duplication. This guide walks through real examples and shows how to structure tests for maximum maintainability."
---

# Parameterized and Type-Parameterized Tests

## Overview

This guide teaches you how to use value-parameterized and type-parameterized tests in GoogleTest to increase test coverage and reduce code duplication. Parameterized tests let you run the same test logic with different input values or types, helping you maintain concise, maintainable, and scalable test suites.

## Prerequisites

- Familiarity with writing basic tests using GoogleTest (`TEST`, `TEST_F`).
- GoogleTest library properly installed and configured in your C++ project.
- Basic understanding of C++ templates and test fixtures.

## Expected Outcome

By following this guide, you will be able to:
- Define value-parameterized tests that run over multiple parameter values.
- Define typed tests that run over a list of types defined at compile-time.
- Define type-parameterized tests that allow test logic reuse with types specified later.
- Instantiate parameterized tests using built-in parameter generators.
- Customize test naming for clearer output.

## Time Estimate

About 20–30 minutes to understand concepts and write practical example test cases.

## Difficulty Level

Intermediate—requires some familiarity with templates and GoogleTest fixture usage.

---

## 1. Value-Parameterized Tests

### Purpose
Test the same behavior across varying input values without duplicating code.

### How It Works
You define a test fixture class template that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type. Then, you define tests with `TEST_P` macros, referring to the current test parameter via `GetParam()`. Finally, use `INSTANTIATE_TEST_SUITE_P` to supply parameter values.

### Step-by-Step Guide

#### Step 1: Define a Fixture Class
```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional SetUp, TearDown, and member data
};
```
Here `int` is the type of parameter values.

#### Step 2: Define Parameterized Tests
```cpp
TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

TEST_P(FooTest, IsNonNegative) {
  int value = GetParam();
  EXPECT_GE(value, 0);
}
```

#### Step 3: Instantiate the Test Suite with Parameters
```cpp
INSTANTIATE_TEST_SUITE_P(PositiveEvenNumbers, FooTest, testing::Values(2, 4, 6, 8));

// Or use other generators
const int nums[] = {0, 1, 2, 3};
INSTANTIATE_TEST_SUITE_P(ZeroToThree, FooTest, testing::ValuesIn(nums));
```

#### Result
Tests named `PositiveEvenNumbers/FooTest.IsEven/0`, etc., will run with each parameter, providing detailed output.

#### Tips
- Use `testing::Range()`, `testing::Values()`, `testing::ValuesIn()`, `testing::Bool()`, or `testing::Combine()` functions to generate test parameters.
- You can provide a custom test name generator as the last argument to `INSTANTIATE_TEST_SUITE_P` for readable test names.

#### Common Pitfalls
- Forgetting to instantiate test suites leads to runtime errors.
- Using underscores in test suite or test names is discouraged.
- `TEST_P` macros require the test fixture to inherit from `TestWithParam`.

<Note>
Parameterized tests are powerful for data-driven testing, but avoid creating overly complex parameter combinations that make debugging difficult.
</Note>

---

## 2. Typed Tests

### Purpose
Verify that multiple types conform to the same interface or behavior using the same test code.

### How It Works
You define a templated fixture class derived from `testing::Test`. Then, define a type list with `testing::Types<...>`. Associate this list with your fixture using `TYPED_TEST_SUITE`. Finally, define tests with `TYPED_TEST` macros that use `TypeParam` to refer to the current type.

### Step-by-Step Guide

#### Step 1: Define a Fixture Template
```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_;
  // Optional common setup or data
};
```

#### Step 2: Define a List of Types
```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```

#### Step 3: Associate Types with the Test Suite
```cpp
TYPED_TEST_SUITE(FooTest, MyTypes);
```

#### Step 4: Define Typed Tests
```cpp
TYPED_TEST(FooTest, ValueIsDefaultConstructed) {
  TypeParam val = this->value_;
  // The value_ will be initialized by your fixture's constructor
  (void)val;  // Use val as needed
}

TYPED_TEST(FooTest, CanAssign) {
  TypeParam val;
  val = TypeParam();
  SUCCEED();
}
```

#### Result
Test runs are repeated once for each type in `MyTypes`. GoogleTest will print test suite names showing the type being tested.

#### Tips
- Use names for types in `TYPED_TEST_SUITE` when readability is important.
- Typed test fixtures share static members across all type instantiations.

<Note>
All tests under `TYPED_TEST_SUITE` are compiled and linked for every listed type, increasing compilation time. List only types you intend to test.
</Note>

---

## 3. Type-Parameterized Tests

### Purpose
Define abstract test behaviors parameterized by types but leave type lists to be specified and instantiated later—ideal for reusable libraries or interface conformance checks.

### How It Works
The test suite is defined with special macros ending in `_P`, marking it as type-parameterized but NOT yet instantiated. Test definitions use `TYPED_TEST_P`. You register tests with `REGISTER_TYPED_TEST_SUITE_P`. Then in any translation unit, you instantiate the suite with types you want using `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Step-by-Step Guide

#### Step 1: Define Templated Test Fixture
```cpp
template <typename T>
class FooTest : public testing::Test {
  // ...
};
```

#### Step 2: Declare Type-Parameterized Test Suite
```cpp
TYPED_TEST_SUITE_P(FooTest);
```

#### Step 3: Define Tests with `TYPED_TEST_P`
```cpp
TYPED_TEST_P(FooTest, DefaultConstructible) {
  TypeParam value{};
  (void)value;
}

TYPED_TEST_P(FooTest, SizeZeroInitially) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}
```

#### Step 4: Register Your Tests
```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DefaultConstructible, SizeZeroInitially);
```

#### Step 5: Instantiate the Suite with Types Elsewhere
```cpp
using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

#### Result
The registered tests will run once per type in `MyTypes`. You can instantiate the same suite multiple times with different type lists, even across translation units.

#### Tips
- Use this pattern to define abstract tests for interface conformance.
- You can instantiate the same suite multiple times with different types.
- Register all the named tests before instantiating.

<Warning>
Failure to `REGISTER_TYPED_TEST_SUITE_P` all tests declared with `TYPED_TEST_P` will cause runtime errors.
</Warning>

---

## 4. Parameter Generators

GoogleTest includes several built-in generators to supply parameters for value-parameterized tests:

- `Range(start, end[, step])`: Values starting from `start` up to but not including `end`, incremented by `step`.
- `Values(v1, v2, ..., vN)`: Explicit enumeration.
- `ValuesIn(container)`: Parameters from arrays or STL containers.
- `Bool()`: Yields `false` and `true`.
- `Combine(g1, g2, ..., gN)`: Cartesian product of multiple generators.
- `ConvertGenerator<T>(generator, func)`: Converts parameter types.

### Example: Combining Generators
```cpp
INSTANTIATE_TEST_SUITE_P(
    AnimalVariations, AnimalTest,
    testing::Combine(
        testing::Values("cat", "dog"),
        testing::Values(BLACK, WHITE)));
```

This produces tests for all animal-color combinations.

### Custom Test Naming
You can provide a naming function or functor as the last argument in `INSTANTIATE_TEST_SUITE_P` to customize test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite, testing::Values(1, 2),
    [](const testing::TestParamInfo<MyTestSuite::ParamType>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

Names must only contain alphanumeric characters or underscores.

---

## 5. Practical Examples

### Value-Parameterized Test for Even Numbers
```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, IsEvenTest,
    testing::Values(2, 4, 6, 8, 10));
```

### Typed Test Example
```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T value_ = T();
};

using NumericTypes = ::testing::Types<int, double, float>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(TypeParam(), this->value_);
}
```

### Type-Parameterized Test Using Registration
```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
}

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed, InitialSizeIsZero);

using MyContainers = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```

---

## 6. Troubleshooting & Tips

### Common Issues
- **Tests not running:** Check that you have instantiated your parameterized test suites.
- **Runtime errors about uninstantiated tests:** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);` if you intentionally do not instantiate.
- **Naming conflicts or invalid characters:** Avoid underscores and special characters in TestSuite and Test names.
- **Parameters not applied:** Remember parameter generators are evaluated during `InitGoogleTest()`, not at instantiation.

### Best Practices
- Use parameterized tests to reduce duplication and improve test clarity.
- Prefer `ValuesIn` with STL containers over manually enumerating parameters.
- Provide meaningful parameter and type names to make test reports readable.
- Do not overload parameter lists with too many values — keep each parameter set manageable.

### Performance Considerations
- Each parameterized instantiation creates a separate test, so large value/type lists increase compilation time and test runtime.
- Balance thoroughness with practical test suite size.

### Alternative Approaches
- Use typed tests when testing multiple types with the same logic known upfront.
- Use type-parameterized to separate test logic and type specification.

---

## 7. Next Steps & Related Content

- [Using Assertions and Matchers](../../guides/core-workflows/using-assertions-and-matchers) to write expressive test conditions.
- [Writing Your First Test](../../guides/getting-started/writing-your-first-test) for basic test setup.
- [Organizing Test Suites](../../guides/core-workflows/organizing-test-suites) to better structure complex tests.
- [Mocking Techniques and Patterns](../../guides/core-workflows/mocking-techniques-and-patterns) for integrating mocks in parameterized tests.

---

Understanding and applying parameterized and type-parameterized tests will dramatically improve your test coverage while keeping your codebase clean and maintainable. This guide walks you through the lifecycle from defining fixtures to instantiating with parameters, accompanied by practical examples and tips for success.
