---
title: "Parameterized & Type-Parameterized Tests"
description: "Unlock broader test coverage by running the same tests across multiple values or data types. This page demonstrates how to set up, write, and run parameterized and type-parameterized tests in GoogleTest."
---

# Parameterized & Type-Parameterized Tests

Unlock broader test coverage by running the same tests across multiple values or data types. This guide teaches you how to set up, write, and run parameterized and type-parameterized tests using GoogleTest, enabling efficient testing of functions, classes, or algorithms over multiple inputs.

---

## 1. Overview of Parameterized Tests

### What Are Parameterized Tests?
Parameterized tests allow you to run the same test logic repeatedly with different input values, minimizing code duplication and improving coverage.

### Prerequisites
- Basic understanding of GoogleTest usage
- GoogleTest included and set up in your project

### Expected Outcome
You will be able to create tests that iterate over multiple sets of input data and define type-parameterized tests that work across several data types.

### Time Estimate
Approximately 15-30 minutes to write and understand basic parameterized tests.

### Difficulty Level
Beginner to Intermediate

---

## 2. Writing Value-Parameterized Tests

Value-parameterized tests run the same test logic repeatedly with different values.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a test fixture class that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture members and setup if needed
};
```

This fixture will be used to define tests that receive parameters of type `int`.
</Step>

<Step title="Create Parameterized Test Cases with TEST_P">
Write test cases using `TEST_P` instead of `TEST` or `TEST_F`. Access the parameter inside the test using `GetParam()`.

```cpp
TEST_P(FooTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

Each instance of this test will be executed with a different integer value.
</Step>

<Step title="Instantiate the Test Suite with Test Values">
Use `INSTANTIATE_TEST_SUITE_P` to specify input values for the test suite.

```cpp
INSTANTIATE_TEST_SUITE_P(Numbers, FooTest, testing::Values(1, 2, 3, 5, 8));
```

This generates one test instance per value.
</Step>
</Steps>

### Example

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEvenness) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8, 10));
```

### Tips & Pitfalls

- Use containers, arrays, and ranges to provide large or dynamic data sets.
- Use `ValuesIn()` to instantiate from an STL container or array.
- Be cautious about parameter value types matching the fixture template.

---

## 3. Combining Multiple Parameter Generators

Use `Combine()` to generate Cartesian products of multiple parameter lists.

### How It Works

`Combine(gen1, gen2)` produces all combinations of values from `gen1` and `gen2`.

### Example

```cpp
class PairTest : public ::testing::TestWithParam<std::tuple<int, char>> {};

TEST_P(PairTest, CheckSum) {
  int i;
  char c;
  std::tie(i, c) = GetParam();
  // Use i and c in test...
}

INSTANTIATE_TEST_SUITE_P(CombinedParams, PairTest, 
  testing::Combine(testing::Values(1, 2), testing::Values('a', 'b')));
```

This instantiates tests for all pairs: (1,'a'), (1,'b'), (2,'a'), (2,'b').

---

## 4. Customizing Parameter Names

By default, GoogleTest creates test names by appending the parameter index.

### Custom Name Generator

You can supply a function or functor to `INSTANTIATE_TEST_SUITE_P` to generate more descriptive test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedInstantiation, FooTest, 
  testing::Values(10, 100, 1000),
  [](const testing::TestParamInfo<FooTest::ParamType>& info) {
    return "Val" + std::to_string(info.param);
  });
```

### Notes

- The generated test names must contain only alphanumeric characters or underscores.
- Useful for improving test output readability.

---

## 5. Overview of Type-Parameterized Tests

Type-parameterized tests run the same test logic across multiple data types. This is useful to verify template code and generic interfaces.

### Defining Typed Tests

1. Define a template fixture class derived from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value;
};
```

2. Specify the list of types to test using `testing::Types`.

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write tests using `TYPED_TEST` where `TypeParam` refers to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  (void)val;  // Use val
  SUCCEED();
}
```

---

## 6. Writing Type-Parameterized Tests: Step-by-Step

<Steps>
<Step title="Define a Template Test Fixture">
Create a test fixture class template accepting a type parameter.

```cpp
template <typename T>
class CommonTest : public testing::Test {
  // Optional shared setup and members
};
```
</Step>

<Step title="Associate Types with the Test Suite">
Use `TYPED_TEST_SUITE` to bind the fixture to a list of types.

```cpp
using TestTypes = testing::Types<int, char, float>;
TYPED_TEST_SUITE(CommonTest, TestTypes);
```
</Step>

<Step title="Write Typed Tests">
Define tests using `TYPED_TEST`. Use `TypeParam` to refer to the type.

```cpp
TYPED_TEST(CommonTest, IsDefaultInitialized) {
  TypeParam val{};
  // Validate val
  EXPECT_TRUE(val == val);
}
```
</Step>

<Step title="Run the Tests">
Compile and run your tests as usual. GoogleTest will instantiate tests for all types.
</Step>
</Steps>

---

## 7. Advanced: Type-Parameterized Tests with Custom Names

You can provide custom type name suffixes using a class with a `GetName` template:

```cpp
class TypedTestNames {
 public:
  template <typename T>
  static std::string GetName(int i) {
    if (std::is_same<T, int>::value) return "Int" + std::to_string(i);
    if (std::is_same<T, char>::value) return "Char" + std::to_string(i);
  }
};

TYPED_TEST_SUITE(CommonTest, TestTypes, TypedTestNames);
```

This helps produce readable and meaningful test suite names.

---

## 8. Best Practices & Common Pitfalls

- Use parameterized tests to avoid test duplication and improve coverage.
- Typed tests are critical for template-heavy codebases to ensure type correctness.
- Name your test instantiations clearly for easy debugging.
- Avoid mixing typed tests and value-parameterized tests unintentionally â€” they serve different purposes.

---

## 9. Troubleshooting

### Issue: Tests not running or recognized

- Verify `INSTANTIATE_TEST_SUITE_P` is called; the framework relies on this to generate instances.
- Check parameter types match fixture template parameters.
- Confirm no conflicting test names or missing unique prefixes.

### Issue: Test names cause compiler errors

- Avoid underscores in test suite and test names as GoogleTest reserves `_` for internal use.

### Issue: Parameters not passed correctly

- Use `GetParam()` inside `TEST_P` tests to access the current test value.
- Use `TypeParam` inside `TYPED_TEST` tests to access the current type.

---

## 10. Next Steps

- Explore [Value-Parameterized Tests](docs/reference/testing.md#TEST_P) for more advanced parameter generation.
- Learn about [Typed Tests](docs/reference/testing.md#TYPED_TEST) in deeper detail.
- Combine param and typed tests for rich coverage of both input values and types.
- Use custom name generator functions for improved test output clarity.

---

## 11. Resources

- [Typed Tests & Type-Parameterized Tests Reference](docs/reference/testing.md#TYPED_TEST_SUITE)
- [Value-Parameterized Tests Reference](docs/reference/testing.md#TEST_P)
- [gMock Cookbook](docs/gmock_cook_book.md) for mocking related advanced usage
- [GoogleTest Primer](docs/primer.md) for initial learning

---

### Summary Diagram: Parameterized Test Flow

```mermaid
flowchart TD
  Start([Start Testing]) --> DefineFixture[TestFixture Class Derived from TestWithParam]
  DefineFixture --> WriteTEST_P[Test(s) Using TEST_P and GetParam()]
  WriteTEST_P --> Instantiate[Use INSTANTIATE_TEST_SUITE_P with Values() / ValuesIn() etc]
  Instantiate --> RunTests[Run Tests with Different Parameters]

  RunTests --> End([End Testing])

  subgraph Typed Test Flow
    DefineTypedFixture[Define Template TestFixture Derived from testing::Test]
    DefineTypedFixture --> BindTypes[TYPED_TEST_SUITE with Types list]
    BindTypes --> WriteTYPED_TEST[Define TYPED_TEST Using TypeParam]
    WriteTYPED_TEST --> RunTypedTests[Run Tests For Each Type]
  end

  Start --> DefineTypedFixture

  classDef startend fill:#bbf,stroke:#333,stroke-width:2px;
  class Start,End startend;
```
