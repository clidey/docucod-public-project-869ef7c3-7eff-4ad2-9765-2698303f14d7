---
title: "Parametrized and Type-Parameterized Testing"
description: "Follow practical guides for writing value- and type-parameterized tests, using them for code coverage with minimal duplication. Demonstrates patterns for reusable, extensible test suites across varying data values and types."
---

# Parametrized and Type-Parameterized Testing

GoogleTest allows you to write reusable, extensible test suites that run your tests over different values and types without duplicating code. This guide focuses specifically on the *Parametrized and Type-Parameterized Testing* features of the framework, showing how you can write tests once and run them multiple times with diverse data or types.

---

## 1. Understanding Value-Parameterized Tests

### What They Are
Value-parameterized tests enable you to run the same test logic with different input values. Instead of writing multiple tests for each input, you define a test fixture that accepts a parameter and then generate tests programmatically over a set of values.

### Key Concepts
- **Test Fixture**: Derive from `testing::TestWithParam<T>`, where `T` is the type of parameter for your tests.
- **Test Definition**: Use `TEST_P(fixture_name, test_name)` macro for each test that uses a parameter.
- **Instantiation**: Use `INSTANTIATE_TEST_SUITE_P(prefix, fixture_name, generator, optional_name_generator)` to define which values to use and to assign names.

### Steps to Create Value-Parameterized Tests

<Steps>
<Step title="Define a Parameterized Fixture">
Create a test fixture class derived from `testing::TestWithParam<T>`. Implement any setup or helper functions needed.
```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // Optional: Setup code
};
```
</Step>
<Step title="Create Parameterized Tests">
Define tests using `TEST_P` instead of `TEST` or `TEST_F`. Inside, use `GetParam()` to access the parameter value.
```cpp
TEST_P(MyParamTest, IsPositive) {
  int val = GetParam();
  EXPECT_GT(val, 0);
}
```
</Step>
<Step title="Instantiate with Parameter Values">
Use `INSTANTIATE_TEST_SUITE_P` to instantiate the tests over a sequence of values. GoogleTest provides generators like `Values()`, `Range()`, `ValuesIn()`, `Bool()`, `Combine()`, and `ConvertGenerator()`.

Example with explicit values:
```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,
    MyParamTest,
    ::testing::Values(1, 2, 3, 10, 100));
```
</Step>
</Steps>

### Parameter Generators Explained
- **Range(start, end [, step])**: Yields a sequence `{start, start + step, ...}` excluding `end`.
- **Values(v1, v2, ..., vN)**: Explicit listed values.
- **ValuesIn(container or begin, end)**: From containers or iterator ranges.
- **Bool()**: `{false, true}`.
- **Combine(gen1, gen2, ...)**: Cartesian product of generators producing `std::tuple`s.
- **ConvertGenerator<T>(gen, func?)**: Converts generated parameters to another type, optionally with a transformer function.

### Naming Parameterized Tests
By default, GoogleTest names tests with indices. You can supply an optional name generator function or functor as the last argument of `INSTANTIATE_TEST_SUITE_P` which receives the parameter and returns a `std::string` used to suffix test names.

Example:
```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames,
    MyParamTest,
    ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
``` 

### Practical Tip
Declare `SetUpTestSuite()` and `TearDownTestSuite()` as **public** if you use them with value-parameterized tests to avoid access issues.


---

## 2. Typed Tests

### What They Are
Typed tests allow you to run the same test logic over a predetermined list of types keeping your code DRY and making your test coverage type-safe. You write a test fixture *template* class parameterized on a type and GoogleTest automatically instantiates tests for each type in the list.

### Key Components
- **Test Fixture Template**: Template class deriving from `::testing::Test`.
- **Type List**: Use `::testing::Types<T1, T2, ...>` to define the list of types.
- **Macro to Associate**: `TYPED_TEST_SUITE(fixture_class, type_list)`
- **Test Macro**: `TYPED_TEST(fixture_class, test_name)` defines the typed tests.

### Steps to Write Typed Tests

<Steps>
<Step title="Define Fixture as a Template Class">
```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
  MyTypedTest() : value_() {}
  // Optional: helper functions, typedefs etc.
};
```
</Step>
<Step title="Create a Type List and Register">
```cpp
using MyTypes = ::testing::Types<int, char, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write Typed Test Cases">
Inside typed tests, use `TypeParam` to refer to the current type.
```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```
</Step>
</Steps>

### Custom Type Names
You can provide a custom name generator by defining a class with a static template method `GetName(int)` that returns a string for each type index and passing it as the third parameter to `TYPED_TEST_SUITE`.

Example:
```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, char>::value) return "Char";
    if (std::is_same<T, double>::value) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

This improves test output readability.

---

## 3. Type-Parameterized Tests (Type-Parameterized Test Suites)

### What They Are
Type-parameterized tests provide a flexible way to define test patterns that can be instantiated later with any types. Unlike typed tests which require the type list at definition, these tests allow for reusable patterns, enabling separate test definition and instantiation - helpful when writing abstract test suites for interfaces or concepts.

### Key Concepts
- **Fixture Template Class**: A class template derived from `::testing::Test`.
- **Declaring Parameterized Test Suite**: Use `TYPED_TEST_SUITE_P(fixture_class)`.
- **Defining Test Templates**: Use `TYPED_TEST_P(fixture_class, test_name)` for test definitions.
- **Registering Tests**: Use `REGISTER_TYPED_TEST_SUITE_P(fixture_class, test_names...)`.
- **Instantiating**: Use `INSTANTIATE_TYPED_TEST_SUITE_P(prefix, fixture_class, Types, optional_naming)`.

### Workflow for Type-Parameterized Tests

<Steps>
<Step title="Declare Type-Parameterized Test Suite">
```cpp
TYPED_TEST_SUITE_P(MyTestPattern);
```
</Step>
<Step title="Define Tests with `TYPED_TEST_P`">
Inside tests, refer to the current type as `TypeParam`.

```cpp
TYPED_TEST_P(MyTestPattern, ExampleTest) {
  TypeParam value{};
  EXPECT_EQ(value, TypeParam());
}
```
</Step>
<Step title="Register Tests">
List all your tests to be part of the suite.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTestPattern, ExampleTest, AnotherTest);
```
</Step>
<Step title="Instantiate Tests">
Instantiate your test pattern with any type list.

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyTestPattern, MyTypes);
```
</Step>
</Steps>

### Custom Type Names
Custom type names can also be provided at instantiation time as an optional parameter, similarly to typed tests.

---

## 4. Examples

### Example: Value-Parameterized Test Fixture

```cpp
#include <gtest/gtest.h>

class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, HandlesEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0) << n << " is not even";
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers,
    IsEvenTest,
    ::testing::Values(2, 4, 6, 8, 10));
```

When run, `HandlesEvenNumbers` will be tested with 2, 4, 6, 8, and 10.

### Example: Typed Test

```cpp
#include <vector>
#include <list>
#include <gtest/gtest.h>

template <typename T>
class ContainerTest : public ::testing::Test {
 public:
  void AddElement(const T& elem) {
    container_.push_back(elem);
  }

  size_t Size() const {
    return container_.size();
  }

 protected:
  T container_;
};

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, IsInitiallyEmpty) {
  EXPECT_EQ(0u, this->Size());
}

TYPED_TEST(ContainerTest, CanAddElements) {
  this->AddElement(42);
  EXPECT_EQ(1u, this->Size());
}
```

This test suite will run the same tests for `std::vector<int>` and `std::list<int>`.

### Example: Type-Parameterized Test Suite

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T Add(T a, T b) { return a + b; }
};

TYPED_TEST_SUITE_P(NumericTest);

TYPED_TEST_P(NumericTest, AdditionIsCommutative) {
  TypeParam a = 1;
  TypeParam b = 2;
  EXPECT_EQ(this->Add(a, b), this->Add(b, a));
}

REGISTER_TYPED_TEST_SUITE_P(NumericTest, AdditionIsCommutative);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, NumericTest, MyTypes);
```

---

## 5. Troubleshooting & Best Practices

### Common Issues
- **Test names with underscores**: Avoid underscores in test suite or test names as they can cause errors or unexpected behavior.
- **SetUpTestSuite() and TearDownTestSuite() visibility**: Ensure these are public if used with parameterized tests.
- **Mismatched fixture types in test suites**: All tests in the same test suite must use the same fixture class.
- **Uninstantiated tests**: Every `TEST_P` or typed test suite must be instantiated or opt-in suppression via `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

### Best Practices
- Use **typed tests** when you know the types to be tested at definition time.
- Use **type-parameterized tests** for reusable abstract test patterns that can be instantiated with various types later.
- Use **value-parameterized tests** when the test runs over varying runtime values.
- Prefer custom test name generators to produce more descriptive test output.
- Use `SCOPED_TRACE` for better diagnostics in subroutines common to multiple tests.

### Performance Considerations
Reusing resources across tests is possible with `SetUpTestSuite()` and `TearDownTestSuite()`, but be careful about side effects. Each test runs in isolation with a fresh fixture instance.

---

## 6. Further Reading and Next Steps

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [GoogleTest Primer](docs/primer.md)
- [Testing Reference - INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [GoogleTest FAQ on Typed vs. Value-Parameterized Tests](docs/faq.md#I-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-Should-I-use-typed-tests-or-value-parameterized-tests)

---

## Source and Samples

You can explore the following source files in the GoogleTest repository for real-world usage and tests:

- [googletest/test/gtest-typed-test_test.cc (Typed and Type-Parameterized Tests)](https://github.com/google/googletest/blob/main/googletest/test/gtest-typed-test_test.cc)
- [googletest/test/googletest-param-test-test.cc (Value-Parameterized Tests)](https://github.com/google/googletest/blob/main/googletest/test/googletest-param-test-test.cc)
- [googletest/include/gtest/gtest-param-test.h (Header for Param Tests)](https://github.com/google/googletest/blob/main/googletest/include/gtest/gtest-param-test.h)
- [googletest/include/gtest/gtest-typed-test.h (Header for Typed and Type-Parameterized Tests)](https://github.com/google/googletest/blob/main/googletest/include/gtest/gtest-typed-test.h)

---

<Tip>
When starting out, prefer writing value-parameterized tests if your tests vary over inputs. For testing multiple types, try typed tests if the type list is known early, or type-parameterized tests for reusable template suites. Use named instantiations to improve test clarity.
</Tip>