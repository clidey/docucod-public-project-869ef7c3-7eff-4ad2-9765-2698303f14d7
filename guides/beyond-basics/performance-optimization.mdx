---
title: "Optimizing Test Performance and Scalability"
description: "Practical techniques for maintaining fast, scalable test suites. Covers test sharding, parallel execution, minimizing test flakiness, and profiling common bottlenecks in large projects."
---

# Optimizing Test Performance and Scalability

GoogleTest empowers you to write fast, scalable test suites that grow with your projects. This guide lays out practical techniques to maintain high performance in large codebases by leveraging test sharding, parallel execution, and strategies for minimizing flakiness. It also helps you profile tests, identify bottlenecks, and apply best practices to keep your feedback loop short and reliable.

---

## 1. Understanding Test Sharding

### What Is Test Sharding?
Test sharding breaks your entire test suite into separate partitions (shards) that can run independently—often on different machines or containers—to reduce overall test runtime.

### Why shard tests?
- **Scale horizontally**: Run multiple shards concurrently to leverage distributed environments.
- **Maintain isolation**: Each shard runs a distinct subset without overlap.
- **Speed-up feedback**: Parallel execution yields faster results, critical for large test suites.

### How to use GoogleTest sharding
Set the following environment variables when invoking the test binary:

| Variable          | Description                                  |
|-------------------|----------------------------------------------|
| `GTEST_TOTAL_SHARDS` | Total number of shards to split the tests across |
| `GTEST_SHARD_INDEX`  | Zero-based index of the shard to run on the current machine |

Example:

```bash
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=2
./my_test_binary
```

This runs the third shard (index 2) in a total of 4 shards. GoogleTest ensures that all tests are divided evenly and uniquely across shards.

<Check>
Make sure that the `GTEST_TOTAL_SHARDS` is set consistently across all machines running shards and that `GTEST_SHARD_INDEX` values are unique within `[0, GTEST_TOTAL_SHARDS - 1]`.
</Check>

## 2. Enabling Parallel Test Execution

### Why parallelize?
Parallel execution across CPU cores or test runners minimizes elapsed time.

### Methods for parallelism
- **Test-level parallelism**: Run individual test cases concurrently.
- **Shard-level parallelism**: Run shards independently in parallel across machines.

### Configuring parallelism
GoogleTest itself does not provide direct support for multi-threaded test execution but is designed to cooperate well with continuous integration and build systems that manage parallelism (e.g., Bazel, CMake with `ctest -j`, or custom runners).

### Best practices
- Ensure all tests are independent and free from global state dependencies.
- Avoid resource contention (files, databases, network ports).
- Use [test fixtures](primer.md#same-data-multiple-tests) carefully to avoid shared mutable state.

<Tip>
When integrating GoogleTest with build systems, configure test runners to utilize `--gtest_shuffle` to randomize test order. This helps detect order-dependent flakiness early.
</Tip>

## 3. Minimizing Test Flakiness

Flaky tests are nondeterministic tests that sometimes fail without code changes. They erode confidence and slow development.

### Common causes of flakiness
- Relying on shared global or static state.
- Timing issues or concurrency races.
- Interaction with external systems (network, databases).
- Test order dependencies.

### Strategies to reduce flakiness
- Isolate tests with fixtures and fresh test instances.
- Avoid dependencies on real external services; use mocking (see [mocking basics](guides/getting-started/mocking-basics.md)).
- Employ death tests and error assertions judiciously to catch improper states early.
- Use `--gtest_repeat` flag to repeat flaky tests many times until failure is reproducible.
- Use `SCOPED_TRACE` and rich failure messages to diagnose flaky failures.

## 4. Profiling and Identifying Bottlenecks

### Why profile?
With large suites, it’s imperative to find slow tests or resource bottlenecks.

### Profiling techniques
- Enable `--gtest_print_time=1` to report test durations.
- Use external profilers or timing tools during test runs.
- Separate slow tests with naming conventions or custom flags.

### Practical steps
1. Run tests with verbose timing output:

   ```bash
   ./my_test_binary --gtest_print_time=1
   ```

2. Identify slow tests from output.
3. Inspect test implementation for:
   - Expensive setup or teardown.
   - Use of real I/O or network operations.
   - Heavy computations.

4. Refactor tests:
   - Use shared fixtures for expensive setup (`SetUpTestSuite`).
   - Mock out costly dependencies.
   - Split large tests into smaller, focused tests.

<Tip>
Consider grouping slow tests into separate test suites so they can be isolated and run less frequently or on dedicated hardware.
</Tip>

## 5. Best Practices and Tips for Large Projects

- **Use test fixtures wisely:** Share common expensive setup only when states truly can be reused without affecting isolation.
- **Name tests and test suites meaningfully:** Helps group, filter, and shard tests effectively.
- **Avoid test interdependencies:** Each test must be independently runnable.
- **Prefer automated test runners with support for sharding and parallelism.**
- **Continuously monitor flaky tests:** Either fix or quarantine.
- **Keep tests small and focused:** Smaller tests are less expensive and easier to diagnose.

## 6. Troubleshooting Common Performance Issues

<AccordionGroup title="Common Test Performance Issues">  
<Accordion title="Test Slowdowns Due to Shared Resources">
If your tests use shared resources such as files or databases, contention can significantly slow down tests.

**Solution:**
- Use in-memory or mocked substitutes when possible.
- Isolate resource usage where unavoidable.
- Clean up resources between tests.
</Accordion>
<Accordion title="Unexpected Test Serialization">
If you observe tests running one after another even when parallelism is enabled, some tests might be relying on global state or introduced global locks.

**Solution:**
- Audit shared states and locks.
- Use GoogleTest's `--gtest_shuffle` flag to detect unexpected dependencies.
</Accordion>
<Accordion title="High Test Flakiness Reducing Throughput">
Flaky tests that intermittently fail cause time-consuming repeated runs.

**Solution:**
- Use `--gtest_repeat` to identify and isolate flaky tests.
- Enhance tests with mock controls and explicit state resets.
</Accordion>
</AccordionGroup>

## 7. Next Steps & Related Documentation

- Explore [Test Discovery and Build Integration](guides/getting-started/test-discovery-setup.md) to learn about integrating GoogleTest with build tools that offer advanced parallel test execution.
- Learn advanced mocking techniques in [Mocking Masterclass](guides/mocking-masterclass/custom-matchers-mocks.md) to speed up tests by injecting efficient fakes and mocks.
- Explore [Parametrized and Typed Tests](guides/writing-effective-tests/parameterized-typed-tests.md) to scale coverage while avoiding duplicate code.
- Review [Sharding and Selective Test Execution](faq/performance-optimization/using-parallel-or-selective-test-execution.md) for more details on running specific tests efficiently.

---

### Additional Resources

- [GoogleTest Primer](primer.md) – Foundation for writing good tests.
- [GoogleMock Cookbook](gmock_cook_book.md) – For reducing test overhead with mocking.
- [Advanced GoogleTest](advanced.md) - For handling complex test scenarios and fine control over test execution.
- [Troubleshooting Common Setup Issues](getting-started/first-test-experience/troubleshooting-common-issues.md) for setup and execution problems.


## Conclusion

By applying sharding, parallel execution, and mitigating flaky tests, you ensure your test suite remains fast, reliable, and scalable—helping your team catch regressions quickly and maintain a productive development environment.
