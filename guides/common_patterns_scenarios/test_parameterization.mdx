---
title: "Parameterizing Tests: Values and Types"
description: "Describes step-by-step how to write tests that iterate over multiple data values or types, using GoogleTest's value- and type-parameterized tests. Includes usage patterns and when to apply each."
---

# Parameterizing Tests: Values and Types

## Overview

GoogleTest enables you to write flexible and reusable tests by running the same test logic against multiple input values or types. This page guides you through creating parameterized tests that iterate over various data values (value-parameterized tests) and types (typed tests), explaining when to apply each, how to define them, and how to instantiate tests with different parameters.

---

## 1. Value-Parameterized Tests

### Purpose

Value-parameterized tests let you write a test once and run it multiple times with different input values. This is useful for verifying your code against a range of inputs without duplicating test code.

### Prerequisites

- Familiarity with writing basic GoogleTest tests using `TEST` or `TEST_F`.
- Your test fixture must inherit from `::testing::TestWithParam<T>`, where `T` is the parameter type.

### Expected Outcome

You will create test suites that automatically run once per parameter value, improving test coverage while reducing code duplication.

### Time Estimate

15-30 minutes

### Difficulty Level

Intermediate

### Step-by-Step Instructions

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a fixture class inheriting from `::testing::TestWithParam<T>`. Replace `T` with the type of data you want to pass into your tests. This class behaves like any test fixture and can hold setup or helper functions.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // Optional: setup, teardown, or members here
};
```
</Step>

<Step title="Write Parameterized Tests Using `TEST_P`">
Use `TEST_P` macro instead of `TEST` or `TEST_F` to define individual tests that will run for each parameter value. Access the parameter inside the test using `GetParam()`.

```cpp
TEST_P(MyValueTest, HandlesPositiveIntegers) {
  int param = GetParam();
  EXPECT_GT(param, 0);
  // Your test code that uses param
}
```
</Step>

<Step title="Instantiate the Test Suite with Parameter Sets">
Use `INSTANTIATE_TEST_SUITE_P` to specify which values your parameterized tests will run over. Several generators are available:

- `Values(...)`: Specifies explicit values.
- `ValuesIn(container)`: Uses values from a container or array.
- `Range(begin, end[, step])`: Generates a sequence from begin to end - 1.
- `Bool()`: Generates `false` and `true`.
- `Combine(...)`: Creates Cartesian products of multiple generators.

Example instantiation:

```cpp
INSTANTIATE_TEST_SUITE_P(PositiveIntegers, MyValueTest, Values(1, 2, 3));
```

Or using a container:

```cpp
int values[] = {4, 5, 6};
INSTANTIATE_TEST_SUITE_P(ArrayValues, MyValueTest, ValuesIn(values));
```
</Step>

<Step title="Run Your Tests">
Build and run your test binary as usual. GoogleTest will discover the instantiated parameterized tests and run each variant with the set parameters.

You will see test names with appended indices indicating parameter instances.

```console
PositiveIntegers/MyValueTest.HandlesPositiveIntegers/0
PositiveIntegers/MyValueTest.HandlesPositiveIntegers/1
PositiveIntegers/MyValueTest.HandlesPositiveIntegers/2
```
</Step>
</Steps>

### Practical Tips & Best Practices

- Use descriptive instantiation prefixes for clarity when multiple instantiations exist.
- Use `Combine()` to test all combinations of parameters when multiple independent variables affect the test.
- Supply a custom name generator function in `INSTANTIATE_TEST_SUITE_P` if default numeric suffixes are insufficient:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedInstantiation, MyValueTest, Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

- Avoid using raw pointers as parameters unless you carefully manage their lifetimes.

### Common Pitfalls

- Not instantiating the test suite with `INSTANTIATE_TEST_SUITE_P` leads to no tests being run.
- Duplicate parameter names cause registration errors; ensure parameter name suffixes are unique.
- Using invalid characters in custom test suffixes will cause failures.

---

## 2. Typed Tests and Type-Parameterized Tests

### Purpose

Typed tests and type-parameterized tests allow running the same test logic with different C++ types, useful for template code testing.

- **Typed Tests** require defining the list of types upfront.
- **Type-Parameterized Tests** support defining generic patterns instantiated with types later (including across translation units).

### Prerequisites

- Understanding of C++ templates.
- Ability to write test fixtures as class templates.

### Expected Outcome

You will write tests that validate your code against various types, improving template safety and behavior correctness.

### Time Estimate

30-45 minutes

### Difficulty Level

Advanced

### Step-by-Step Instructions

#### Typed Tests

1. Define a test fixture as a class template:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
};
```

2. Specify the list of types using `::testing::Types<...>`:

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write tests using `TYPED_TEST` macro. Inside the test, access the current type using `TypeParam`:

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value_;
  // test logic
}
```

4. Run tests normally. GoogleTest will run test versions for all types.

#### Type-Parameterized Tests

1. Define a test fixture template and declare test patterns with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`:

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, HasProperty) {
  // Use TypeParam here
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, HasProperty);
```

2. Instantiate the test suite with specific types and an instantiation name:

```cpp
using MyTypeList = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypeList);
```

3. Build and run tests; each type generates a test instance.

### Practical Tips & Best Practices

- Typed tests are simple and good when types are known early.
- Use type-parameterized tests when you want to define reusable test templates instantiated across translations units.
- Use custom name generators for descriptive test names.

### Common Pitfalls

- Forgetting to register tests with `REGISTER_TYPED_TEST_SUITE_P`.
- Confusing typed tests with value-parameterized tests (typed tests vary the type, value-parameterized tests vary the input data).

---

## 3. Parameter Generators for Value-Parameterized Tests

GoogleTest offers a rich set of built-in parameter generators to supply parameters for value-parameterized tests in `INSTANTIATE_TEST_SUITE_P`:

| Generator       | Description                                                                                            |
|-----------------|--------------------------------------------------------------------------------------------------------|
| `Range(start, end[, step])` | Generates a sequence `{start, start+step, ...}` up to but excluding `end`. Default `step` is 1.         |
| `Values(v1, v2, ..., vN)`    | Generates explicit values `{v1, v2, ..., vN}`.                                                     |
| `ValuesIn(container)`        | Generates values from a container (C-style array, STL container, or iterator range `[begin, end)`).   |
| `Bool()`                    | Generates boolean values `{false, true}`.                                                           |
| `Combine(g1, g2, ..., gN)`  | Generates the Cartesian product of multiple generators producing `std::tuple<T1, T2, ..., TN>` values. |
| `ConvertGenerator<T>(g)`    | Converts parameters generated by `g` into type `T` using `static_cast` or a custom callable.          |

### Usage Examples

- **Range Example:**

```cpp
INSTANTIATE_TEST_SUITE_P(NumberRange, MyTest, Range(1, 5));
```

Runs tests with values 1, 2, 3, 4.

- **Combine Example:**

```cpp
INSTANTIATE_TEST_SUITE_P(Combos, MyTest, 
    Combine(Values(1, 2), Bool()));
```

Runs tests with parameters `(1, false)`, `(1, true)`, `(2, false)`, `(2, true)`.

- **ConvertGenerator Example:**

```cpp
struct ParamType {
  std::string name;
  int id;
  ParamType(std::tuple<std::string, int> t) : name(std::get<0>(t)), id(std::get<1>(t)) {}
};

INSTANTIATE_TEST_SUITE_P(
    Converted, MyTest,
    ConvertGenerator<ParamType::TupleT>(
        Combine(Values(std::string("cat"), std::string("dog")), Values(1, 2))));
```

This converts tuples into `ParamType` objects.

---

## 4. Customizing Parameterized Test Names

By default, parameterized tests get a numeric suffix representing parameter index. You can supply custom naming functions to make test output more readable and informative.

### How to Customize

Provide a function, functor, or lambda to `INSTANTIATE_TEST_SUITE_P` as the last argument. It must accept a `testing::TestParamInfo<ParamType>` parameter and return a valid string:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams, MyTest,
    Values(10, 20, 30),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

The generated tests will have suffixes like `Val10`, `Val20`, etc.

### Restrictions

- Names must contain only ASCII alphanumeric characters and underscores.
- Names must be unique within the same instantiation.
- Avoid invalid or duplicate names to prevent registration failures.

### Tips

- Use descriptive, unique names to ease test filtering and debugging.
- For complex types, implement a suitable conversion function or overload `operator<<` to provide readable names.

---

## 5. Troubleshooting

<AccordionGroup title="Common Issues When Parameterizing Tests">
<Accordion title="Tests Are Not Running After Definition">
Make sure you **instantiate** your parameterized test suite with `INSTANTIATE_TEST_SUITE_P`. Without instantiation, tests will not be registered or run.
</Accordion>

<Accordion title="Duplicate or Invalid Parameter Names">
If you supply a custom naming function, ensure all generated names are unique and valid. Avoid spaces, dashes, or special characters except underscore. Duplicate names cause test registration failures.
</Accordion>

<Accordion title="Parameter Lifetime and Pointer Parameters">
Be cautious when using raw pointers in parameters. GoogleTest does not manage their lifespan. Use smart pointers or value types to avoid dangling references.
</Accordion>

<Accordion title="Conversion Errors with `ConvertGenerator`">
Verify the conversion function is correct and that the generated types are convertible to your fixture's parameter type. If you use a lambda, specify the generated type explicitly if necessary to avoid dangling references or incorrect conversions.
</Accordion>
</AccordionGroup>

---

## 6. Next Steps & Resources

- Explore the [GoogleTest Primer](../primer.md) to strengthen foundational testing skills.
- Learn about [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests) for more advanced usage.
- Refer to the [Testing Reference: TEST_P and INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md#TEST_P) for detailed API descriptions.
- Check out sample tests like `samples/sample7_unittest.cc` and `samples/sample8_unittest.cc` for practical examples.
- Review [Best Practices for Test Naming](../guides/common_patterns_scenarios/test_parameterization.md#naming) to improve maintainability.

---

## 7. Summary Diagram of Parameterized Test Workflow

```mermaid
flowchart TD
  A[Define Fixture Inheriting TestWithParam] --> B[Write Parameterized Tests with TEST_P]
  B --> C[Choose Parameter Generator (Values, Range, Combine, ...)]
  C --> D[Instantiate Test Suite via INSTANTIATE_TEST_SUITE_P]
  D --> E[Run Tests Automatically for Each Parameter]
  E --> F[Review Results and Debug]

  subgraph Parameter Generators
    C1[Values()] --> C
    C2[ValuesIn()] --> C
    C3[Range()] --> C
    C4[Bool()] --> C
    C5[Combine()] --> C
    C6[ConvertGenerator()] --> C
  end

  style A fill:#f9f,stroke:#333,stroke-width:2px
  style B fill:#bbf,stroke:#333,stroke-width:2px
  style C fill:#fbf,stroke:#333,stroke-width:2px
  style D fill:#bfb,stroke:#333,stroke-width:2px
  style E fill:#ffb,stroke:#333,stroke-width:2px
  style F fill:#fbb,stroke:#333,stroke-width:2px
```
