---
title: "Parameterizing Your Tests (Values & Types)"
description: "Walks through implementing both value-parameterized and type-parameterized tests. Presents real use cases, how to test across multiple inputs and types, and how to interpret parameterized test outputs."
---

# Parameterizing Your Tests (Values & Types)

## Overview

This guide walks you through how to implement **parameterized tests** in GoogleTest, focusing on both **value-parameterized** and **type-parameterized** testing. Parameterized tests allow you to run the same test logic over various input values or types, improving test coverage and reducing code duplication.

You'll learn practical use cases, how to set up tests across different inputs or types, and how to interpret the test outputs generated by parameterized runs.

---

## 1. Value-Parameterized Tests: Testing Across Multiple Inputs

### What They Are

Value-parameterized tests let you write tests that run once for each test parameter value. This is useful when you want to verify your code against a variety of inputs without writing repetitive test functions.

### Prerequisites
- A test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.
- Understanding of how to write standard tests using `TEST_F`.

### Expected Outcome
By the end, you will be able to write flexible tests that execute once per parameter value and see clearly labeled results for each parameter.

### Time Estimate
10-20 minutes to write, instantiate, and run simple parameterized tests.

### Difficulty Level
Intermediate.

### How to Write Value-Parameterized Tests

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a fixture class inheriting from `testing::TestWithParam<T>`. The type `T` represents the parameter passed to each test iteration. You can implement usual fixture members here.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional: SetUp, TearDown, utility methods
};
```
</Step>
<Step title="Write Parameterized Test Cases Using TEST_P">
Write test cases like normal, but use the `TEST_P` macro. Access the current parameter with the `GetParam()` method inside your test.

```cpp
TEST_P(FooTest, IsEven) {
  int param = GetParam();
  EXPECT_EQ(param % 2, 0);
}
```
</Step>
<Step title="Instantiate the Test Suite with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to specify parameter values or sequences for the test suite.

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers,
    FooTest,
    ::testing::Values(2, 4, 6, 8));
```

GoogleTest will run `FooTest.IsEven` once for each of these parameter values.
</Step>
</Steps>

### Parameter Generators

GoogleTest provides several helpful parameter generators inside the `testing` namespace:

- `Range(start, end [, step])`: Generates a range of values from `start` up to but not including `end`, optionally stepping by `step`.
- `Values(v1, v2, ..., vN)`: Explicitly lists the values.
- `ValuesIn(container)`: Uses values from a container or iterator range.
- `Bool()`: Produces `[false, true]`.
- `Combine(g1, g2, ..., gN)`: Produces the Cartesian product of multiple generators as tuples.
- `ConvertGenerator<T>(gen)` or `ConvertGenerator(gen, func)`: Converts generated parameters to a specific type via static cast or a provided converter.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    TestRange,
    FooTest,
    testing::Range(1, 10, 2));  // Runs with 1, 3, 5, 7, 9
```

### Customizing Test Names for Parameters

By default, parameterized tests are named with their instantiation prefix, test suite name, test name, and a numeric index. You can customize the generated test name suffixes using an optional fourth argument to `INSTANTIATE_TEST_SUITE_P` â€” a function or functor that accepts a `testing::TestParamInfo<T>` and returns a `std::string`.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams,
    FooTest,
    testing::Values("cat", "dog"),
    [](const testing::TestParamInfo<const char*>& info) {
      return std::string(info.param);
    });
```

### Important Notes and Best Practices

- The fixture class must have `SetUpTestSuite` and `TearDownTestSuite` declared public to work with `TEST_P`.
- All tests defined by `TEST_P` for a fixture require at least one instantiation via `INSTANTIATE_TEST_SUITE_P`, or else GoogleTest will report a failing test named `GoogleTestVerification`.
- Multiple instantiations of the same fixture class with different parameters can coexist with unique prefixes.
- Keep parameter types copyable. For raw pointers, you manage lifetime.

### Sample Full Example

```cpp
class StringTest : public ::testing::TestWithParam<const char*> {};

TEST_P(StringTest, IsNotEmpty) {
  EXPECT_GT(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(
    BasicStrings,
    StringTest,
    testing::Values("foo", "bar", "baz"));
```

This defines a test suite running the same test three times with parameters "foo", "bar", and "baz".


## 2. Typed Tests: Testing Across Multiple Types

### What They Are

Typed tests allow you to run the same test logic with different types. This lets you validate that code behaves correctly regardless of the type instantiated, especially useful for template-heavy or generic code.

### Prerequisites
- Define a class template test fixture derived from `testing::Test`.
- A list of types to test instantiated using `::testing::Types<..>`.

### Expected Outcome
You will define tests that run once per each type in the provided type list, with test output clearly indicating the types under test.

### Time Estimate
15-30 minutes for basic to moderate complexity.

### How to Write Typed Tests

<Steps>
<Step title="Define a Fixture Class Template">
Create a template test fixture derived from `testing::Test`. Implement any helper methods or members needed.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  void SetUp() override {}
  // ...
};
```
</Step>
<Step title="Define Type List for Testing">
Use a `using` declaration with `testing::Types<>` to specify the types you'll test.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```
</Step>
<Step title="Associate the Type List with the Fixture">
Use `TYPED_TEST_SUITE` macro to connect the fixture and the type list.

```cpp
TYPED_TEST_SUITE(FooTest, MyTypes);
```
</Step>
<Step title="Write Typed Test Cases Using TYPED_TEST">
Define your tests using `TYPED_TEST`, where inside the test you can use `TypeParam` to refer to the current instantiated type.

```cpp
TYPED_TEST(FooTest, CheckDefaultConstructible) {
  TypeParam instance{};
  SUCCEED();  // Just verifying it compiles and runs.
}
```
</Step>
</Steps>

### Customizing Type Names

You can provide an optional third argument to `TYPED_TEST_SUITE` to specify a class with a static template method `GetName(int)` that generates readable and unique names for each type instantiation.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>()) return "Int";
    if (std::is_same<T, double>()) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### Notes and Usage Tips

- Typed tests require the type list to be known at compile time.
- Use `TypeParam` inside the test to refer to the current test type.
- Static members and typedefs inside your fixture are accessible using `TestFixture::` inside tests.
- You cannot mix typed tests and type-parameterized tests; they serve different use cases.

### Sample Full Example

```cpp
template <typename T>
class MathTest : public testing::Test {
 public:
  static T zero() { return T(0); }
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MathTest, NumericTypes);

TYPED_TEST(MathTest, IsZeroByDefault) {
  EXPECT_EQ(this->zero(), TypeParam());
}
```

The above runs the test `IsZeroByDefault` once for each numeric type.


## 3. Type-Parameterized Tests: Abstract Test Patterns for Types

### What They Are

Type-parameterized tests enable defining test patterns independently of the types to be tested. You register the tests without specifying the types initially, then instantiate the tests with different type lists later, even multiple times and across translation units.

This is particularly useful for interface compliance testing.

### Prerequisites
- Define a template test fixture derived from `testing::Test`.
- Use macros `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` to define parameterized tests.
- Register test names using `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Expected Outcome
Flexible reusable typed test patterns that can be instantiated multiple times with different types, ideal for libraries defining generic test behaviors.

### Time Estimate
20-40 minutes due to additional registration steps.

### How to Write Type-Parameterized Tests

<Steps>
<Step title="Define the Type-Parameterized Test Suite">
Declare fixture and use `TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class FooTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(FooTest);
```
</Step>
<Step title="Define Tests Using TYPED_TEST_P">
Write test patterns using `TYPED_TEST_P` macro, just like `TYPED_TEST`. Inside tests, use `TypeParam` and `TestFixture` appropriately.

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = TypeParam();
  SUCCEED();
}
```
</Step>
<Step title="Register Test Names">
Tell GoogleTest about the test names using `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah);
```
</Step>
<Step title="Instantiate Test Suite with Types">
Create an instance of the test suite with your desired types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```
</Step>
</Steps>

### Advanced Usage: Custom Naming

Like typed tests, an optional fourth argument to `INSTANTIATE_TYPED_TEST_SUITE_P` allows specifying a class with a static template `GetName(int)` function to produce readable type-based test names.

### Important Notes

- Separate registration and instantiation steps provide flexibility across multiple files.
- Test patterns can be instantiated multiple times with different prefixes.
- Registration of test names is mandatory before instantiation.

### Sample Example

```cpp
template <typename T>
class InterfaceTest : public testing::Test {};

TYPED_TEST_SUITE_P(InterfaceTest);

TYPED_TEST_P(InterfaceTest, SupportsCopy) {
  TypeParam a = TypeParam();
  TypeParam b = a;
  SUCCEED();
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, SupportsCopy);

using Implementations = ::testing::Types<ImplA, ImplB>;
INSTANTIATE_TYPED_TEST_SUITE_P(ImplTests, InterfaceTest, Implementations);
```


## 4. Interpreting Parameterized Test Outputs

GoogleTest automatically generates unique names for each test instantiation, combining the instantiation prefix, test suite name, test name, and parameter (or type) index. For instance:

```
MyInst/FooTest.DoesBlah/0
MyInst/FooTest.DoesBlah/1
```

These detailed names help you identify which parameter caused a failure.

Use `--gtest_filter` with these names to run specific parameterized tests.

---

## 5. Troubleshooting & Tips

### Common Issues
- **Tests not running:** Ensure you have instantiated your parameterized tests using `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`.
- **Duplicate test names:** Avoid underscores in test suite and test names, as GoogleTest reserves underscores for internal use. See the FAQ on test naming.
- **Dangling references:** When using `ConvertGenerator` with lambdas, ensure lifetimes of objects referenced by the parameters outlive the tests. Prefer explicit types where appropriate.
- **Test fixture constructor errors:** Parameterized fixtures must have a default constructor.

### Best Practices
- Choose between value-parameterized and typed tests based on whether you need to parameterize over input values or types.
- Use `Combine` to test multiple parameter dimensions simultaneously.
- Use custom name generators to create readable, descriptive test result names.
- Keep test parameter types simple and copyable to avoid lifetime and assignment issues.

---

## 6. Diagram: Parameterized Test Workflow

```mermaid
flowchart TD
  A[Define Test Fixture with Parameter] --> B{Is it Value-
Parameterized?}
  B -- Yes --> C[Inherit from TestWithParam<T>]
  B -- No --> D{Is it Typed or Type-Parameterized?}
  D -- Typed --> E[Define Template Fixture 
& Use TYPED_TEST_SUITE]
  D -- Type-Parameterized --> F[Define Template Fixture,
Use TYPED_TEST_SUITE_P,
REGISTER_TYPED_TEST_SUITE_P,
Instantiate later]

  C --> G[Define TEST_P cases using GetParam()]
  E --> H[Define TYPED_TEST cases using TypeParam]
  F --> I[Define TYPED_TEST_P cases,
Then REGISTER_TYPED_TEST_SUITE_P]

  G & H & I --> J[Instantiate Tests with parameter values or types]
  J --> K[Run Tests: One test per parameter or type]
  K --> L[View Parameterized Test Results with descriptive names]
```

---

## 7. Next Steps & Related Guides

- Explore the [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) and [Typed Tests](../advanced.md#typed-tests) sections in the Advanced Topics for deeper insights and examples.
- Review the [Testing Reference: Parameterized and Typed Tests](../api-reference/core-testing-apis/parameterized-and-typed-tests) page for API details.
- Check out the [GoogleTest FAQ](../faq.md) for naming guidelines and common pitfalls.
- When ready, learn about combining parameterized tests with mocking using the [Mocking Patterns Guide](../guides/common-workflows/mocking-patterns).

---

## References and External Links

- [GoogleTest Primer](primer.md)
- [Assertions Reference](reference/assertions.md)
- [Testing Reference](../api-reference/core-testing-apis/testing.md)
- [GoogleTest GitHub Repository](https://github.com/google/googletest)

---