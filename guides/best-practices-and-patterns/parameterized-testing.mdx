---
title: "Effective Parameterized and Typed Tests"
description: "Learn how to leverage value-parameterized and type-parameterized tests in GoogleTest to maximize coverage while minimizing boilerplate. This guide includes real-world examples for data-driven testing."
---

# Effective Parameterized and Typed Tests

## Overview

GoogleTest empowers you to run the same test logic with multiple input values or types without duplicating code. This guide focuses on leveraging value-parameterized and type-parameterized tests to maximize test coverage while minimizing boilerplate in your C++ projects.

These advanced testing patterns support data-driven testing and interface conformance verification, helping you build robust, maintainable, and flexible test suites.

---

## Value-Parameterized Tests

### What Are They?
Value-parameterized tests allow you to define a test once and run it multiple times with different inputs. This pattern suits scenarios where behavior varies based on parameters such as inputs, flags, or configurations.

### Prerequisites
- A fixture class derived from `::testing::TestWithParam<T>`, where `T` is the parameter type.
- GoogleTest initialized properly with `testing::InitGoogleTest`.

### How to Write Value-Parameterized Tests

1. **Define the Test Fixture:**

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // You can add members here if needed.
};
```

2. **Write Parameterized Tests Using `TEST_P`:**

```cpp
TEST_P(MyParamTest, HandlesVariousParameters) {
  int param = GetParam();
  EXPECT_TRUE(param >= 0);  // Example assertion
}
```

3. **Instantiate the Test Suite with Parameters:**

Use parameter generators from the `::testing` namespace such as `Values()`, `Range()`, `Combine()`, etc.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,
    MyParamTest,
    testing::Values(1, 2, 3, 5, 8));
```

You can instantiate the same test suite multiple times with different parameter sets using unique prefix names.

### Common Parameter Generators
| Generator          | Description                                                                       |
|--------------------|-----------------------------------------------------------------------------------|
| `Range(start, end)`| Generates values starting from `start` up to but not including `end`, step=1 by default.|
| `Values(v1, v2, ...)` | Generates a fixed list of values explicitly specified.                          |
| `ValuesIn(container)`| Generates values from an STL container, C array, or iterator range.             |
| `Bool()`            | Generates `{false, true}` values, useful for flag combinations.                 |
| `Combine(g1, g2, ...)` | Produces cartesian product of multiple generators, returning tuples.           |

### Using `GetParam()`
Inside your `TEST_P` body, call `GetParam()` to retrieve the current parameter instance.

### Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

// Test that factorial is non-negative
TEST_P(FactorialTest, NonNegative) {
  int n = GetParam();
  EXPECT_GE(Factorial(n), 0);
}

INSTANTIATE_TEST_SUITE_P(Checks, FactorialTest, testing::Values(0, 1, 2, 3, 4));
```

### Customizing Test Names
You can provide a name generator function or functor to generate readable test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
  CustomNames, FunctionTest,
  testing::Values(42, 99),
  [](const testing::TestParamInfo<int>& info) {
    return "Val_" + std::to_string(info.param);
  });
```

### Tips and Best Practices
- Use `Combine()` cautiously; the test count grows multiplicatively.
- Choose parameter types that are copyable and preferably lightweight.
- Name your instantiations clearly to distinguish different sets.
- Call `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if a suite is intentionally uninstantiated.

---

## Typed Tests

### What Are They?
Typed tests let you run the *same* test logic for multiple *types*. This is useful when verifying that different type implementations conform to the same behavioral contract or interface.

### Prerequisites
- Define a **test fixture class template** parameterized by the type.
- Declare the list of types ahead of time.

### How to Write Typed Tests

1. **Define the fixture class template:**

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
  // Optional shared resource
  static T* shared_;
};

template <typename T> T* MyTypedTest<T>::shared_ = nullptr;
```

2. **Define the list of types:**

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write typed tests using `TYPED_TEST`:**

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam obj;  // TypeParam represents the type
  EXPECT_EQ(obj, obj);  // Example assertion
}
```

### Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(TypeParam(), 0);
}
```

### Using Static Setup and Teardown
You can define `static void SetUpTestSuite()` and `static void TearDownTestSuite()` for per-suite resource management:

```cpp
template <typename T>
class CommonTest : public ::testing::Test {
 public:
  static void SetUpTestSuite() { shared_ = new T(5); }
  static void TearDownTestSuite() { delete shared_; shared_ = nullptr; }

  static T* shared_;
  T value_ = 1;
};

template <typename T> T* CommonTest<T>::shared_ = nullptr;
```

### Customizing Type Names
You can specify a `NameGenerator` class to generate readable test suite names:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, char>) return "Char";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Tips and Best Practices
- Use typed tests when implementations vary by type but share logic.
- Avoid heavy operations in constructors; prefer `SetUp()` if needed.
- When a test fails, the type name helps identify the problematic type.
- You must know all types at compile time.

---

## Type-Parameterized Tests (Advanced)

### What Are They?
They extend typed tests by decoupling test pattern definition and type list instantiation. You can define abstract tests and instantiate them multiple times with different type lists.

### Basic Workflow
1. Define test patterns with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`.
2. Register your test names using `REGISTER_TYPED_TEST_SUITE_P`.
3. Instantiate test suites with `INSTANTIATE_TYPED_TEST_SUITE_P`.


---

## Troubleshooting & Common Pitfalls

- **Test names with underscores:** Avoid underscores in test suite and test names; they can cause compile or runtime errors.
- **Default constructors required:** Fixtures must have default constructors.
- **Non-void functions:** Fatal assertions (`ASSERT_*`) can only be used inside `void` functions.
- **Uninstantiated parameterized tests:** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if a suite is intended to be uninstantiated.
- **Test order & dependencies:** Tests run independently; do not rely on specific execution orders or shared mutable state.

---

## Resources

- [GoogleTest Primer](primer.md#value-parameterized-tests) — Overview of parameterized tests
- [Advanced Guide](advanced.md#value-parameterized-tests) — Deep dive into parameterized and typed tests
- [Testing Reference](reference/testing.md#TEST_P) — API descriptions for value-parameterized tests
- [Testing Reference](reference/testing.md#TYPED_TEST_SUITE) — API descriptions for typed tests

---

## Summary

By mastering value-parameterized and typed tests, you harness GoogleTest’s power to test with versatile data inputs and diverse types efficiently. These patterns reduce redundant code, increase test coverage, and clarify your test intentions with meaningful parameters and type names.

Implement value-parameterized tests for data-driven scenarios and typed tests for verifying behaviors across multiple types. Combine this knowledge with GoogleTest’s rich assertions and fixtures to build high-quality, scalable test suites.