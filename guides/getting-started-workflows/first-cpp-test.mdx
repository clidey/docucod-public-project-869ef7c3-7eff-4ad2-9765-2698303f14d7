---
title: "Writing Your First Unit Test"
description: "A practical guide to creating, structuring, and running your first C++ unit test suite with GoogleTest. Cover typical test case setup, assertions, and best practices for test organization so users can see immediate value from adopting GoogleTest."
---

# Writing Your First Unit Test with GoogleTest

Welcome to your practical guide for creating and running your first C++ unit test suite using GoogleTest. This guide walks you through the simplest workflow: defining test cases, structuring tests for maintainability, using assertions, and running tests to see immediate value from adopting GoogleTest.

---

## 1. Workflow Overview

**Task Description:**
This guide helps you write your first GoogleTest unit test suite in C++. You will create simple tests, organize them logically into test suites, apply assertions to validate your code, and execute the tests using the framework’s built-in mechanisms.

**Prerequisites:**
- A working C++17 development environment.
- GoogleTest installed or integrated into your project (refer to the [Setup & Installation guides](/getting-started/setup-installation/installation-methods)).
- Basic familiarity with C++ syntax.

**Expected Outcome:**
You will have a working GoogleTest project containing multiple test cases, able to run tests with clear pass/fail reports.

**Time Estimate:** 15-30 minutes

**Difficulty Level:** Beginner

---

## 2. Step-by-Step Instructions

### Step 1: Include GoogleTest Header

Start by including the main GoogleTest header in your test source file. This provides all necessary declarations.

```cpp
#include <gtest/gtest.h>
```

### Step 2: Define Simple Tests Using `TEST()` Macro

The `TEST()` macro defines a test function. It takes two parameters:
- The **TestSuiteName** — the group of related tests.
- The **TestName** — the individual test identifier.

Both must be valid C++ identifiers without underscores.

For example, to test a simple factorial function:

```cpp
// Tests factorial of zero.
TEST(FactorialTest, HandlesZeroInput) {
    EXPECT_EQ(Factorial(0), 1);
}

// Tests factorial of positive numbers.
TEST(FactorialTest, HandlesPositiveInput) {
    EXPECT_EQ(Factorial(1), 1);
    EXPECT_EQ(Factorial(2), 2);
    EXPECT_EQ(Factorial(3), 6);
    EXPECT_EQ(Factorial(8), 40320);
}
```

### Step 3: Use Assertions to Validate Code

GoogleTest provides `EXPECT_*` and `ASSERT_*` macros:
- `EXPECT_*` macros record failures but continue running the test.
- `ASSERT_*` macros abort the current test function on failure.

Use `EXPECT_*` to detect multiple failures per test run, and `ASSERT_*` when further checks depend on earlier conditions.

Example:

```cpp
EXPECT_EQ(Factorial(3), 6); // Non-fatal failure, test continues if fails.
ASSERT_NE(pointer, nullptr);  // Fatal failure, test stops if fails.
```

### Step 4: Organize Reusable Test Code with Test Fixtures Using `TEST_F()`

If multiple tests share a common setup, define a test fixture class inheriting from `testing::Test`:

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Setup code executed before each test
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;  // Empty queue
  Queue<int> q1_;  // One element
  Queue<int> q2_;  // Two elements
};
```

Write tests using `TEST_F()` macro, which uses the fixture:

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

Each test runs with a fresh fixture instance, initialized in the fixture constructor or `SetUp()`.


### Step 5: Write the Test Main Function (If Needed)

Most users don't need their own `main()` as they link with `gtest_main`, but if needed, use this boilerplate:

```cpp
int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This initializes GoogleTest and runs all defined tests, outputting results and returning an appropriate status code.

### Step 6: Compile and Run Your Tests

- Make sure your build system links against GoogleTest (`gtest` or `gtest_main`).
- Compile the test executable.
- Run the binary; GoogleTest automatically discovers and runs all tests.

Example output snippet:

```
[ RUN      ] FactorialTest.HandlesZeroInput
[       OK ] FactorialTest.HandlesZeroInput (0 ms)
[ RUN      ] FactorialTest.HandlesPositiveInput
[       OK ] FactorialTest.HandlesPositiveInput (0 ms)
[==========] 2 tests from 1 test suite ran. (1 ms total)
[  PASSED  ] 2 tests.
```

---

## 3. Examples & Code Samples

### Minimal Complete Example

```cpp
#include <gtest/gtest.h>

int Factorial(int n) {
  if (n <= 1) return 1;
  return n * Factorial(n - 1);
}

TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(5), 120);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

### Using a Fixture with Shared Setup

```cpp
class MathTest : public testing::Test {
 protected:
  void SetUp() override {
    value_ = 42;
  }

  int value_;
};

TEST_F(MathTest, IsEven) {
  EXPECT_EQ(value_ % 2, 0);
}

TEST_F(MathTest, IsNotZero) {
  ASSERT_NE(value_, 0);
}
```

---

## 4. Troubleshooting & Tips

### Common Issues

- **Tests Not Detected or Run:** Ensure your test files are compiled and linked in your test executable. Also check that you call `InitGoogleTest()` before `RUN_ALL_TESTS()`.
- **Linker Errors:** Confirm that GoogleTest libraries (`gtest`, `gtest_main`) are linked properly. Use CMake’s `target_link_libraries()` or your build system’s equivalent.
- **Mixing `TEST()` and `TEST_F()`:** Use `TEST_F()` only if you have a fixture class defined. Otherwise, use `TEST()`.
- **Test Names with Underscores:** GoogleTest recommends avoiding underscores `_` in test and test suite names to prevent internal conflicts.

### Best Practices

- Write tests that are independent and do not rely on execution order.
- Use `EXPECT_*` broadly to maximize bug discovery per run, and `ASSERT_*` when failure aborts further meaningful checks.
- Organize tests into test suites that match your code structure for clarity and maintainability.
- Use fixtures (`TEST_F()`) to avoid repeating setup/teardown code.
- Link with `gtest_main` to avoid writing your own main unless custom setup/teardown is needed.

### Performance Tips

- Keep tests small and focused to improve feedback time.
- Share expensive setup in fixtures’ `SetUpTestSuite()` and `TearDownTestSuite()` if applicable (available via `static` functions in test fixtures).

### Alternative Approaches

- For advanced parameterized tests, explore `TEST_P()` and `INSTANTIATE_TEST_SUITE_P()` macros (see [Parameterized Tests](/guides/advanced-testing-patterns/parameterized-tests)).
- For mocking dependencies, refer to the GoogleMock integration guides.

---

## 5. Next Steps & Related Content

- Explore the [GoogleTest Primer](primer.md) for detailed foundational knowledge.
- Learn about [Assertions](reference/assertions.md) to use GoogleTest assertions more effectively.
- Dive into [Test Fixtures](primer.md#same-data-multiple-tests) for advanced test organization.
- See practical examples in the [Samples directory](https://github.com/google/googletest/tree/main/googletest/samples).
- After mastering basics, move on to [Building and Running Tests](/guides/getting-started-workflows/building-and-running-tests) for integrating tests into your CI pipeline.
- Explore [Mocking Basics](/guides/getting-started-workflows/mocking-basics) to understand how to mock complex dependencies.


---

## Appendix: Understanding the Test Lifecycle

```mermaid
flowchart TD
  Start([User writes test code with TEST or TEST_F]) --> Init[Call testing::InitGoogleTest()]
  Init --> RunTests[Invoke RUN_ALL_TESTS()]

  subgraph Execution of Each Test
    CreateFixture[Create fresh test fixture instance]
    SetupFixture[Call SetUp()]
    RunTestBody[Run test code inside TEST or TEST_F]
    TearDownFixture[Call TearDown()]
    DeleteFixture[Delete test fixture instance]
  end

  RunTests --> CreateFixture
  CreateFixture --> SetupFixture --> RunTestBody --> TearDownFixture --> DeleteFixture --> NextTest[Next Test or End]
  NextTest -->|More Tests| CreateFixture
  NextTest -->|No More Tests| Finish[Output summary and return]

  classDef flow fill:#cce5ff,stroke:#7ab8ff,stroke-width:2px;
  class Execution,Init,RunTests,CreateFixture,SetupFixture,RunTestBody,TearDownFixture,DeleteFixture,NextTest,Finish flow;
```

This illustrates how GoogleTest creates a new fixture for each test and runs setup, test, teardown sequentially.

---

## Additional Tips

- Avoid spelling `SetUp()` as `Setup()` to ensure the framework calls your setup function.
- Use `RUN_ALL_TESTS()` return value as your program exit code to correctly indicate pass/fail status.
- When diagnosing test failures, look at console output carefully — GoogleTest reports file names and line numbers.

---

For full API details, consult the [GoogleTest Testing Reference](reference/testing.md).

---

##### Source Code References
[Example Basic Test Sample](https://github.com/google/googletest/blob/main/googletest/samples/sample1_unittest.cc)

---