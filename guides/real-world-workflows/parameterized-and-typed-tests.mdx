---
title: "Parameterized and Typed Tests"
description: "Shows how to use value-parameterized and type-parameterized tests for systematic coverage of multiple inputs and data types in your test suites."
---

# Parameterized and Typed Tests

This guide shows you how to use value-parameterized and type-parameterized tests in GoogleTest to achieve systematic coverage of multiple inputs and data types in your test suites. These advanced testing techniques let you write more flexible, concise, and maintainable tests by running the same test logic over a variety of parameters or types.

---

## Workflow Overview

### What You Will Learn
- How to write **value-parameterized tests** that run the same test code for multiple input values.
- How to use **type-parameterized tests** to run tests across multiple C++ types without duplicating code.
- How to instantiate and name parameterized and typed tests for easy identification and filtering.

### Prerequisites
- Familiarity with GoogleTest basics, including how to write standard `TEST` and `TEST_F` tests.
- Basic understanding of C++ class templates and parameterized classes.
- GoogleTest installed and configured in your environment.

### Expected Outcome
By following this guide, you will:
- Create parameterized test fixtures that accept value or type parameters.
- Write test cases that access those parameters.
- Instantiate test suites with multiple parameters or types using GoogleTest macros.
- Customize test names for better readability and filtering.

### Time Estimate
~20-30 minutes, depending on your familiarity with templates and GoogleTest.

### Difficulty Level
Intermediate

---

## Part 1: Value-Parameterized Tests

Value-parameterized tests let you run the same test logic multiple times with different values, such as numbers, strings, or complex classes.

### How to Write Value-Parameterized Tests

1. Define a test fixture that inherits from `testing::TestWithParam<T>`, where `T` is the type of your parameter.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Fixture members here
};
```

2. Write your parameterized test cases using `TEST_P`. Within the test body, obtain the test parameter by calling `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}
```

3. Instantiate the test suite with specific parameter values using `INSTANTIATE_TEST_SUITE_P`. Use one of GoogleTest's parameter generators (`Values`, `ValuesIn`, `Range`, `Bool`, `Combine`) to supply the parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest, testing::Values("meeny", "miny", "moe"));
```

4. To run the tests, build and execute your test executable normally. GoogleTest will run the test suite once for each parameter.

### Parameter Generators

| Generator  | Description |
|------------|-------------|
| `Range(begin, end [, step])` | Produces values in a numeric range `[begin, end)` with optional step size. |
| `Values(v1, v2, ..., vN)`      | Produces explicitly specified values. |
| `ValuesIn(container)`           | Produces values from an array or STL container. |
| `Bool()`                      | Produces the sequence `{false, true}`. Useful for flag tests. |
| `Combine(g1, g2, ..., gN)`    | Produces Cartesian product tuples combining multiple generators. |

### Example: Simple Parameterized Test with Strings

```cpp
class StringTest : public testing::TestWithParam<const char*> {};

TEST_P(StringTest, IsNotEmpty) {
  EXPECT_GT(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(ValidStrings, StringTest, testing::Values("Hello", "World", "GoogleTest"));
```

The test suite `StringTest` will run 3 times, each with one of the strings supplied.

### Naming Parameterized Tests

- The first argument to `INSTANTIATE_TEST_SUITE_P` is a unique instantiation name.
- The generated test names include this instantiation name followed by the parameter index.
- You can supply a name generator function or functor to customize test suffixes.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Value" + std::to_string(info.param);
    });
```

### Important Tips and Pitfalls

- Place `INSTANTIATE_TEST_SUITE_P` at global or namespace scope, not inside functions.
- All tests defined with `TEST_P` must have corresponding instantiations or they will cause test failures unless `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` is used.
- Parameters must be copyable and their lifetimes safely managed.
- Use `GetParam()` to access current test's parameter inside each test.

---

## Part 2: Typed Tests

Typed tests repeat the same tests over a list of C++ types. This is particularly useful when you want to validate template classes or generic code.

### How to Write Typed Tests

1. Define a class template-based fixture derived from `testing::Test`:

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_{};
};
```

2. Define a type list using `testing::Types<T1, T2, ...>`:

```cpp
using MyTypes = testing::Types<int, double, std::string>;
```

3. Associate the type list to your fixture using `TYPED_TEST_SUITE`:

```cpp
TYPED_TEST_SUITE(FooTest, MyTypes);
```

4. Write typed tests using `TYPED_TEST`. Refer to the parameter type as `TypeParam`:

```cpp
TYPED_TEST(FooTest, HasDefaultValue) {
  // TypeParam is the current test type.
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());  // Default constructed is equal
}
```

5. Run your test executable normally; GoogleTest runs each typed test once per type.

### Example: Typed Test for Containers

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 protected:
  T container_;
};

using ContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

### Custom Type Names

You can provide a class with a templated static method to generate names for each type:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, std::string>) return "String";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

This will generate test suite names like `FooTest/Int`, `FooTest/Double`, etc.

---

## Part 3: Type-Parameterized Tests

Type-parameterized tests are a flexible variation where you define the test pattern first, then instantiate it with different types later, possibly in different translation units.

### Writing Type-Parameterized Tests

1. Define a template test fixture derived from `testing::Test`:

```cpp
template <typename T>
class FooTest : public testing::Test {};
```

2. Declare your type-parameterized test suite using `TYPED_TEST_SUITE_P`:

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. Write tests with `TYPED_TEST_P`, using `TypeParam` as the type parameter:

```cpp
TYPED_TEST_P(FooTest, DoesSomething) {
  TypeParam x{};
  EXPECT_TRUE(DoSomething(x));
}
```

4. Register all test names with `REGISTER_TYPED_TEST_SUITE_P`:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesSomething);
```

5. Instantiate with your desired types and a unique prefix using `INSTANTIATE_TYPED_TEST_SUITE_P`:

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, FooTest, MyTypes);
```

### Benefits
- Supports defining test patterns without knowing the exact types ahead.
- Allows multiple instantiations with different type lists.
- Enables reusable test libraries for interfaces or concepts.

### Example

```cpp
template <typename T>
class StackTest : public testing::Test {};

TYPED_TEST_SUITE_P(StackTest);

TYPED_TEST_P(StackTest, IsEmptyInitially) {
  TypeParam stack;
  EXPECT_TRUE(stack.empty());
}

REGISTER_TYPED_TEST_SUITE_P(StackTest, IsEmptyInitially);

using MyStackTypes = testing::Types<std::stack<int>, std::stack<double>>;
INSTANTIATE_TYPED_TEST_SUITE_P(StdStack, StackTest, MyStackTypes);
```

---

## Practical Tips

- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings when a parameterized test suite is defined but not instantiated.
- Parameter generators are evaluated at GoogleTest initialization time, not at compile or instantiation time.
- Instantiations can be done multiple times, even in different files.
- Use custom name generators to produce readable and filter-friendly test names.
- Always place `INSTANTIATE_*` macros at namespace or global scope.

---

## Troubleshooting

### Common Issues

- **Tests not running:** Ensure that your parameterized test is instantiated using `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`. Without instantiation, tests won't be created.
- **Compilation errors with templates:** Verify your fixture correctly inherits from the required GoogleTest base classes, i.e., `TestWithParam<T>` for value-parameterized tests or `testing::Test` for typed tests.
- **Ambiguous test names:** Always provide a unique instantiation name as the first argument to instantiation macros.
- **Invalid test names:** Names generated by custom name generators must only contain alphanumeric characters and underscores.

### Best Practice
- Write readable test names to quickly identify tests in output and filters.
- Use `Combine()` carefully to avoid exploding the number of test instances.
- Keep test parameters simple and copyable.

---

## Next Steps & Related Content

- Explore [Writing Your First Test](../guides/getting-started/writing-your-first-test) to strengthen foundational knowledge.
- Learn about [Mocking Best Practices](../guides/real-world-workflows/mocking-best-practices) for advanced test scenarios.
- Review [Assertions and Expectations](../api-reference/core-testing-api/assertions) to deepen assertion skills.
- Discover [Custom Matchers and Actions](../guides/real-world-workflows/custom-matchers-and-actions) for expressive tests.
- For integration tips, refer to the [CI Integration and Best Practices](../guides/advanced-and-integration-guides/ci-integration-and-best-practices).

---

## Summary
GoogleTest's parameterized and typed tests provide powerful tools for scalable, maintainable, and comprehensive test coverage across diverse values and types. By embracing these techniques, you reduce duplicated test code and increase confidence in your C++ codebases.

---

## References
- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [Parameter Generators API](../reference/testing.md#param-generators)
- GoogleTest Primer: [primer.md](../primer.md)

---

## Code Snippet Summary

```cpp
// 1. Define a parameterized test fixture
class FooTest : public testing::TestWithParam<int> {};

// 2. Write tests using TEST_P
TEST_P(FooTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

// 3. Instantiate with Values
INSTANTIATE_TEST_SUITE_P(EvenNumbers, FooTest, testing::Values(2, 4, 6));

// ---

// Typed tests example:
template <typename T>
class TypedFooTest : public testing::Test {
 public:
   T value_{};
};

using MyTypes = testing::Types<int, double>;
TYPED_TEST_SUITE(TypedFooTest, MyTypes);

TYPED_TEST(TypedFooTest, IsDefaultZero) {
  TypeParam zero{};
  EXPECT_EQ(this->value_, zero);
}

// ---

// Type-parameterized tests:
template <typename T>
class ParamFooTest : public testing::Test {};

TYPED_TEST_SUITE_P(ParamFooTest);

TYPED_TEST_P(ParamFooTest, DoesStuff) {
  TypeParam x{};
  EXPECT_TRUE(true); // Your test
}

REGISTER_TYPED_TEST_SUITE_P(ParamFooTest, DoesStuff);

using TypesList = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, ParamFooTest, TypesList);
```
