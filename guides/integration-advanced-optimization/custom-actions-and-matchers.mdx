---
title: "Defining Custom Actions and Matchers"
description: "A practical how-to on extending GoogleMock with your own actions and matchers to express complex testing logic. Step-by-step guide on implementing, registering, and applying custom behaviors in your tests."
---

# Defining Custom Actions and Matchers

Extend your testing power by creating custom actions and matchers in GoogleMock, expressing complex test behaviors and precise argument validations beyond the built-in facilities. This practical guide walks you through implementing, registering, and applying your own actions and matchers effectively.

---

## Overview

When the preset actions or matchers in GoogleMock do not suffice for your test's logic, custom actions and matchers unlock unparalleled flexibility. They allow you to model sophisticated behaviors and validate intricate argument requirements seamlessly within your tests.

This guide shows you:

- How to define new matchers with the convenient `MATCHER` macros or detailed interfaces.
- Techniques to parameterize matchers for dynamic behavior.
- Ways to implement custom actions using function objects, lambdas, or `ACTION` macros.
- Best practices for parameterized and polymorphic actions.


---

## Custom Matchers

Matchers check whether an argument to a mock method satisfies certain expectations. While GoogleMock offers many built-in matchers, custom matchers empower you to define domain-specific or advanced predicates.

### Quick Custom Matcher with `MATCHER`

Use the `MATCHER` macro for concise, readable matchers. Inside the macro body, refer to the value being matched as `arg`.

```cpp
MATCHER(IsEven, "Checks if a number is even") {
  return (arg % 2) == 0;
}
```

This allows usage like:

```cpp
EXPECT_CALL(mock, Foo(IsEven()));
```

The matcher automatically passes an argument when `true` and fails when `false`. You can customize the failure message by streaming to `result_listener`:

```cpp
MATCHER(IsPositive, "") {
  if (arg > 0) return true;
  *result_listener << "which is not positive";
  return false;
}
```

### Parametrized Matchers with `MATCHER_P`

For matchers that depend on parameters, use `MATCHER_P`:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  return arg % divisor == 0;
}
```

Use it like:

```cpp
EXPECT_CALL(mock, Bar(IsDivisibleBy(5)));
```

You can also use multiple parameters with `MATCHER_P2`, `MATCHER_P3`, etc.

### Advanced Matcher Classes

For complete control, define a matcher class implementing:

- `bool MatchAndExplain(const T& value, std::ostream* os) const`
- `void DescribeTo(std::ostream* os) const`
- `void DescribeNegationTo(std::ostream* os) const`

Then provide a factory function that returns `testing::Matcher<T>`:

```cpp
class IsMultipleOfMatcher {
 public:
  explicit IsMultipleOfMatcher(int factor) : factor_(factor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % factor_ == 0) return true;
    if (os) *os << n << " is not a multiple of " << factor_;
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is a multiple of " << factor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not a multiple of " << factor_;
  }

 private:
  int factor_;
};

inline ::testing::Matcher<int> IsMultipleOf(int factor) {
  return ::testing::MakeMatcher(new ::testing::MatcherInterface<int>(
      new IsMultipleOfMatcher(factor)));
}
```

### Polymorphic Matchers

Polymorphic matchers can adapt to match arguments of multiple types. To create one, make `MatchAndExplain` a template:

```cpp
template <typename T>
bool MatchAndExplain(const T& value, std::ostream* os) const {
  return value != nullptr;
}
```

Use `MakePolymorphicMatcher()` to wrap:

```cpp
PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

### Tips for Writing Matchers

- Matchers must be pure functions: no side effects.
- Keep descriptions human-friendly for clearer failure messages.
- Use `EXPECT_` assertions inside matchers to leverage GoogleTest's messaging.
- Use `SafeMatcherCast<T>(m)` to work with slightly mismatched argument types safely.

---

## Custom Actions

Actions define what happens when a mock function is called. To extend GoogleMock’s behavior, create your own actions.

### Simple Actions: Functors & Lambdas

Define actions as callable objects compatible with the mock function signature, and pass them directly to `WillOnce()` or `WillRepeatedly()`:

```cpp
struct IncrementBy {
  int n;
  int operator()(int x) const { return x + n; }
};

EXPECT_CALL(mock, Foo(_))
    .WillOnce(IncrementBy{5});
```

Lambdas also work directly:

```cpp
EXPECT_CALL(mock, Bar())
    .WillOnce([]() { return 42; });
```

### Multi-Action Sequences with `DoAll()`

Combine multiple actions so they all execute in order; return the result of the last action:

```cpp
EXPECT_CALL(mock, Func(_))
    .WillOnce(DoAll(
        SetArgPointee<0>(42),
        Return(true)));
```

### Defining New Actions with `ACTION` Macros

Legacy but useful, the `ACTION` macros let you define actions at namespace scope:

```cpp
ACTION(DoubleArg0) {
  return arg0 * 2;
}

EXPECT_CALL(mock, Foo(_))
    .WillOnce(DoubleArg0());
```

Parameterized versions:

```cpp
ACTION_P(Add, n) { return arg0 + n; }

EXPECT_CALL(mock, Foo(_))
    .WillOnce(Add(7));
```

Supports multiple parameters via `ACTION_P2`, `ACTION_P3`, etc.

### Polymorphic Actions

Use `MakePolymorphicAction()` to write actions usable with various mock function types:

```cpp
class ReturnSecondArg {
 public:
  template <typename Result, typename ArgumentTuple>
  Result Perform(const ArgumentTuple& args) const {
    return std::get<1>(args);
  }
};

PolymorphicAction<ReturnSecondArg> ReturnSecondArgument() {
  return MakePolymorphicAction(ReturnSecondArg());
}
```

Then:

```cpp
EXPECT_CALL(mock, Func(_, _))
    .WillOnce(ReturnSecondArgument());
```

### Invoking Functions or Methods

Use `Invoke()` or `InvokeWithoutArgs()` to forward calls to real functions or methods:

```cpp
EXPECT_CALL(mock, Foo(_))
    .WillOnce(Invoke(&MyFunction));
```

Invoke a method on an object with:

```cpp
EXPECT_CALL(mock, Bar(_))
    .WillOnce(Invoke(&obj, &MyClass::Method));
```

Invoke a callable passed as a mock function argument:

```cpp
EXPECT_CALL(mock, Baz(_, _))
    .WillOnce(InvokeArgument<1>(5));
```

### Ignoring Action Results

If an action returns a value but you need a void action, wrap with `IgnoreResult()`:

```cpp
EXPECT_CALL(mock, Foo(_))
    .WillOnce(IgnoreResult(Invoke(SomeFunction)));
```

### Selecting Arguments for Actions

Use `WithArg<N>(action)`, `WithArgs<N1, N2, ...>(action)`, or `WithoutArgs(action)` to adapt actions to subsets or absence of arguments.

### Tips for Actions

- Actions can hold state; reuse with care.
- Use `RetiresOnSaturation()` to disable sticky expectations when sequencing multiple behaviors.
- Use lambdas for quick custom behaviors.

---

## Practical Examples

### Custom Matcher Example

```cpp
MATCHER_P(IsMultipleOf, factor, "") {
  return (arg % factor) == 0;
}

EXPECT_CALL(mock, Foo(IsMultipleOf(3)));
```

### Custom Action Example

```cpp
ACTION_P(AddValue, n) {
  return arg0 + n;
}

EXPECT_CALL(mock, Calculate(_))
    .WillOnce(AddValue(10));
```

### Delegating Behavior to a Real Object Using Custom Actions

```cpp
class RealCalculator {
 public:
   int Add(int x, int y) { return x + y; }
};

class MockCalculator : public Calculator {
 public:
   MOCK_METHOD(int, Add, (int x, int y), (override));
   MockCalculator() {
     ON_CALL(*this, Add)
         .WillByDefault(Invoke(&real_, &RealCalculator::Add));
   }
 private:
   RealCalculator real_;
};
```


---

## Troubleshooting & Best Practices

- **Match Argument Types Exactly:** Use `SafeMatcherCast<T>(m)` to resolve type mismatches.
- **Keep Matchers Pure:** Avoid side effects in matchers to prevent flaky and unpredictable tests.
- **Avoid Overusing `EXPECT_CALL`:** Prefer `ON_CALL` for default behaviors when no strict expectation is needed.
- **Use `RetiresOnSaturation` To Manage Sticky Expectations:** Prevent unexpected failures due to sticky expectations when matching the same call repeatedly.
- **Consider Performance:** Complex custom actions can slow compilation; place large mock implementations in separate source files if so.
- **Use Existing Macros as Templates:** Refer to `MATCHER_P`, `ACTION_P`, and their variants for parameterized patterns.

---

## Next Steps & Related Resources

- To dive deeper into custom mock objects, explore the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html).
- For extensive matcher references, see the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html).
- Review the [Actions Reference](https://google.github.io/googletest/reference/actions.html) for a list of built-in actions and their usage.
- Learn more about setting call expectations and cardinalities in the [Mocking Reference](https://google.github.io/googletest/reference/mocking.html).

By mastering custom actions and matchers, you gain complete control over mock behavior and argument verification—essential for creating robust, maintainable unit tests tailored to your domain.
