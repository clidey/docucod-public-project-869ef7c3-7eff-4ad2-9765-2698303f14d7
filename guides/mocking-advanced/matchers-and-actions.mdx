---
title: "Using Matchers and Custom Actions"
description: "Techniques for leveraging GoogleMock's powerful matchers and writing custom actions for more flexible and readable expectations. Details on using built-in and user-defined matchers to cover real-world complexity."
---

# Using Matchers and Custom Actions

This guide helps you master GoogleMock's powerful matchers and custom actions, enabling you to write flexible, precise, and readable mock expectations. By understanding how to use built-in matchers, combine them effectively, and create custom actions, you will be able to handle complex test scenarios confidently.

---

## 1. Introduction to Matchers

Matchers allow you to specify criteria that function arguments must satisfy in your `EXPECT_CALL` and `ON_CALL` statements. They make expectations expressive and adaptable, going beyond simple equality.

### What are Matchers?

- **Matchers** test whether a given value meets specific criteria.
- You can use simple, built-in matchers like `_` (wildcard), `Eq()`, `Ge()`, and complex ones like `AllOf()`, `AnyOf()`, and `Field()`.

### Why Use Matchers?

Without matchers, you can only check for exact argument equality, which can lead to brittle tests.

### Example: Basic Matchers
```cpp
using ::testing::_;
using ::testing::Lt;
using ::testing::Return;

EXPECT_CALL(my_mock, SetPosition(_, _))
  .With(Lt())  // multi-argument matcher to ensure first arg < second
  .WillOnce(Return(true));
```

*Here, `SetPosition` is expected to be called with any two arguments where the first is less than the second.*

---

## 2. Writing Expectations Using Matchers

Matchers are core to specifying expectations in `EXPECT_CALL` and behaviors in `ON_CALL`.

### Using Matchers in `EXPECT_CALL`

```cpp
EXPECT_CALL(mock_obj, Foo(Lt(5), Eq("bar"), _));
```

- The first argument must be less than 5.
- The second argument must be equal to "bar".
- The third argument can be anything.

### Using the `.With()` Clause

Sometimes you want to match on the whole argument tuple rather than individual arguments:

```cpp
using ::testing::Lt;
using ::testing::AllOf;

EXPECT_CALL(mock_obj, Func(_, _))
    .With(AllOf(Lt(), Lt()));  // All args must be less than their counterparts
```

### Omitting Parameter Lists

If the method is not overloaded and you don't care about arguments, omit the parameter list:

```cpp
EXPECT_CALL(mock_obj, NonOverloadedMethod);
```

This expects `NonOverloadedMethod` to be called with any arguments.

### Combining Matchers

Build complex conditions using combiners:

```cpp
EXPECT_CALL(mock_obj, ProcessValue(AllOf(Gt(0), Lt(100))));

EXPECT_CALL(mock_obj, Func(AnyOf(Eq("yes"), Eq("no"))));
```

---

## 3. Creating Custom Matchers

When built-in matchers are insufficient, define your own for enhanced clarity and precision.

### Simple Custom Matcher Example

```cpp
MATCHER(IsDivisibleBy7, "") { return (arg % 7) == 0; }
```

Use in tests:

```cpp
EXPECT_CALL(mock_obj, ProcessValue(IsDivisibleBy7()));
```

If failure occurs, gMock prints:

```
Expected: is divisible by 7
Actual: 27 (the remainder is 6)
```

### Parameterized Matchers

Create matchers with parameters using the `MATCHER_P` macro:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") { return abs(arg) == value; }

EXPECT_CALL(mock_obj, Check(HasAbsoluteValue(10)));
```

### Best Practices for Custom Matchers

- Write clear `DescribeTo()` and `DescribeNegationTo()` methods for good error messages.
- Use `MatchAndExplain()` to provide detailed reasons for match failures.
- Ensure matchers are pure functions with no side effects.

---

## 4. Defining Custom Actions

Actions specify what a mock function should do when called. Beyond return values, actions can perform side effects, call other functions, or execute complex logic.

### Built-in Actions Overview

- `Return(value)`: Return a value from the mock method.
- `ReturnRef(variable)`: Return a reference to a variable.
- `ReturnPointee(ptr)`: Return the value pointed to by a pointer.
- `DoAll(a1, a2, ..., an)`: Perform multiple actions sequentially, returning the last action's result.
- `Invoke(callable)`: Call a function, method, lambda, or functor.
- `InvokeArgument<N>(args...)`: Call the N-th argument as a callable with supplied arguments.

### Writing an Action Using Lambdas or Functors

You can use any callable compatible with the mock method signature as an action:

```cpp
EXPECT_CALL(mock_obj, Func(_))
    .WillOnce([](int x) { return x * 2; });
```

### Combining Multiple Actions

Use `DoAll()` to perform several actions, useful when mocking methods with output parameters:

```cpp
EXPECT_CALL(mock_obj, Mutate(_))
    .WillOnce(DoAll(SetArgPointee<0>(5), Return(true)));
```

Here, the output argument is set to `5` and `true` is returned.

### Defining Legacy Actions with Macros

For advanced users, `ACTION`, `ACTION_P`, and `ACTION_TEMPLATE` macros let you define named actions.

Example:

```cpp
ACTION_P(Add, n) {
  return arg0 + n;
}
EXPECT_CALL(mock_obj, Func(_)).WillOnce(Add(5));
```

### Tips on Actions

- An action passed to `WillOnce()` may be a move-only callable.
- If an action has side effects or changes state, prefer lambdas or functors.
- Use `IgnoreResult()` to ignore return values when mixing void and non-void actions.

---

## 5. Practical Usage Patterns

### Delegating Calls to a Real or Fake Object

You can delegate mock method calls to existing implementations:

```cpp
ON_CALL(mock, DoThis).WillByDefault([&real_obj](int x) {
  return real_obj.DoThis(x);
});
```

### Calling Callable Arguments

Sometimes a mock method receives a callback as an argument. Use `InvokeArgument<N>()` to call it:

```cpp
EXPECT_CALL(mock, RegisterCallback(_))
    .WillOnce(InvokeArgument<0>(5));
```

This calls the first argument of the function with `5`.

### Selecting Specific Arguments

Use `WithArg<N>()` or `WithArgs<N1, N2>()` to call an action with selected arguments:

```cpp
EXPECT_CALL(mock, Foo(_, _, _))
    .WillOnce(WithArgs<0, 2>(Invoke(MyFunc)));
```

### Ignoring Uninteresting Calls

By default, calls to mock methods without expectations generate warnings. Use `NiceMock<T>` to suppress these.

---

## 6. Common Pitfalls and Best Practices

<Tip>
Avoid over-specifying expectations — be as general as possible to keep tests maintainable.
</Tip>

<Warning>
Do not set expectations after exercising the mock object; doing so leads to undefined behavior.
</Warning>

<Note>
Remember that `Return(value)` captures the value at expectation definition time, not call time — use `ReturnPointee()` for live values.
</Note>

<Check>
Use the `--gmock_verbose=info` flag during development to trace expectation matching and call behavior.
</Check>

---

## 7. Next Steps & Further Reading

- Explore the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for practical recipes.
- Read the [Matchers Reference](reference/mocking_api/matchers_reference.md) for an exhaustive list of built-in matchers.
- Review [Actions Reference](reference/mocking_api/mock_actions_and_return_values.md) for more on available actions.
- Learn about managing expectations and strictness in [Managing Call Counts and Mock Strictness](/guides/mocking-advanced/cardinalities-strictness).
- For full context, consult the [Mocking Reference](reference/mocking_api/expectations_and_behaviors.md).

---

## Code Examples Recap

```cpp
// Using a matcher to expect calls with specific arguments
EXPECT_CALL(mock_obj, Foo(Lt(10), Eq("bar"), _));

// Setting a default action with ON_CALL
ON_CALL(mock_obj, Bar(_)).WillByDefault(Return(42));

// Using a lambda as a custom action
EXPECT_CALL(mock_obj, Baz(_)).WillOnce([](int x) { return x * 2; });

// Combining multiple actions
EXPECT_CALL(mock_obj, Mutate(_))
    .WillOnce(DoAll(SetArgPointee<0>(5), Return(true)));

// Invoking a callable argument
EXPECT_CALL(mock_obj, RunCallback(_))
    .WillOnce(InvokeArgument<0>(10));

// A parameterized action defined using ACTION_P
ACTION_P(Add, n) { return arg0 + n; }
EXPECT_CALL(mock_obj, Compute(_)).WillOnce(Add(7));
```

---

Mastering matchers and actions will empower you to write highly effective and maintainable GoogleMock tests that precisely specify expected behavior while accommodating the complexity of real-world code.
