---
title: "Parameterized & Typed Tests"
description: "Guide to writing tests that run across multiple values or types, covering value- and type-parameterized testing mechanisms. Demonstrates how to reduce code duplication and improve test coverage through parameterization."
---

# Parameterized & Typed Tests

## Overview

Parameterized and typed tests are advanced testing features in GoogleTest that enable you to validate code behavior across multiple input values or types without duplicating test code. Leveraging these mechanisms improves test coverage and code maintainability by running the same test logic against a set of parameters or a set of types.

This guide focuses specifically on how to write, instantiate, and manage parameterized and typed tests using GoogleTest's API, demonstrating how to harness value-parameterized, type-parameterized, and typed tests effectively.

---

## Value-Parameterized Tests

### What They Are

Value-parameterized tests allow you to run the same test logic multiple times with different parameter values. This helps you reduce boilerplate code when verifying a function or class behavior across various inputs.

### How to Write Value-Parameterized Tests

1. **Define a Fixture Class:**

   Derive a test fixture from `::testing::TestWithParam<T>`, where `T` is the type of the parameter you want to test with. For example, testing with `const char*` parameters:

   ```cpp
   class FooTest : public ::testing::TestWithParam<const char*> {
     // You can add fixture setup if needed
   };
   ```

2. **Define TEST_P tests:**

   Use `TEST_P` macro to define test cases that will receive parameters for each instantiation:

   ```cpp
   TEST_P(FooTest, DoesBlah) {
     EXPECT_TRUE(foo.Blah(GetParam()));
   }

   TEST_P(FooTest, HasBlahBlah) {
     // Another parameterized test over the same parameters
   }
   ```

3. **Instantiate the Test Suite with Parameters:**

   Use `INSTANTIATE_TEST_SUITE_P` to specify the sets of parameters to run the tests against:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest,
                            Values("meeny", "miny", "moe"));
   ```

   This creates tests named like `InstantiationName/FooTest.DoesBlah/0` for "meeny" and so forth.

### Built-in Parameter Generators

GoogleTest provides these generators in the `testing` namespace to specify parameter sets:

- `Range(begin, end [, step])` — generates a sequence `{begin, begin+step, ...}` excluding `end`. Useful for numeric ranges.
- `Values(v1, v2, ..., vN)` — enumerates explicitly defined values.
- `ValuesIn(container)` — generates parameters from STL containers, C-style arrays, or iterator ranges.
- `Bool()` — yields values `{false, true}`.
- `Combine(g1, g2, ..., gN)` — generates the Cartesian product of multiple generators as tuples.

### Example: Value-Parameterized Test

```cpp
class MyTest : public ::testing::TestWithParam<int> {};

TEST_P(MyTest, PositiveValues) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}

INSTANTIATE_TEST_SUITE_P(MyValues, MyTest, Values(1, 2, 3, 5, 8, 13));
```

This runs `PositiveValues` tests with six integers.

### Customizing Test Names

You can provide a name generator function or functor to control test name suffixes:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyTest, Values(1, 2, 3),
    [](const testing::TestParamInfo<MyTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Best Practices and Tips

- Start with simple parameters using `Values` or `Range` generators.
- When combining multiple parameters, use `Combine` to explore all combinations.
- Use `ValuesIn` to feed test parameters from existing containers.
- Implement test fixtures carefully, ensuring thread-safety if needed.
- Avoid raw pointer parameters unless you are explicitly managing object lifetimes.

### Common Pitfalls

- Beware of dangling references when using `Values` with temporaries and lambdas for conversion.
- Ensure test names are unique and made of valid characters; custom name generators must respect this.
- Remember to instantiate every parameterized test suite or use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if intentionally uninstantiated.

---

## Typed Tests

### What They Are

Typed tests enable running the same test logic over a fixed list of types, allowing you to verify template classes or functions for multiple type instantiations.

Unlike value-parameterized tests, typed tests are parameterized over type parameters, not values.

### How to Write Typed Tests

1. **Define a Typed Test Fixture Template:**

   Create a template test fixture class parameterized by a type:

   ```cpp
   template <typename T>
   class FooTest : public ::testing::Test {
    public:
     T value_{};
   };
   ```

2. **Define a Type List:**

   Specify the list of types you want to test:

   ```cpp
   using MyTypes = ::testing::Types<char, int, unsigned int>;
   TYPED_TEST_SUITE(FooTest, MyTypes);
   ```

3. **Write Tests using TYPED_TEST:**

   Use `TYPED_TEST` macro to write tests that use the `TypeParam` type:

   ```cpp
   TYPED_TEST(FooTest, CanInitializeValue) {
     TypeParam val = this->value_;
     EXPECT_EQ(val, TypeParam());
   }
   ```

### Example: Typed Test

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T val_{};
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, MyTypes);

TYPED_TEST(NumericTest, ZeroValue) {
  EXPECT_EQ(TypeParam{}, this->val_);
}
```

This runs the test suite `NumericTest` for `int`, `float`, and `double`.

### Custom Type Names

You can customize the names of the instantiated test suites by providing a class with a static `GetName(int)` method:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same_v<T, int>) return "Int";
    if (std::is_same_v<T, float>) return "Float";
    return "Other";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### Important Notes

- Each type tested gets its own test suite instantiation.
- The `TypeParam` alias inside the tests refers to the current type parameter.
- Use `this->` to access non-static members of the test fixture inside typed tests.

---

## Type-Parameterized Tests

### What They Are

Type-parameterized tests allow you to define an abstract test pattern parameterized by type without specifying the type list upfront. You can register the test patterns first and instantiate them later with any types you want. This is useful for defining interface or concept tests that need to be reused across different implementations.

### How to Write Type-Parameterized Tests

1. **Define a Fixture Template:**

   ```cpp
   template <typename T>
   class FooTest : public ::testing::Test {
     // ...
   };
   ```

2. **Declare the Test Suite as Type-Parameterized:**

   Use `TYPED_TEST_SUITE_P` instead of `TYPED_TEST_SUITE`.

   ```cpp
   TYPED_TEST_SUITE_P(FooTest);
   ```

3. **Define Tests with `TYPED_TEST_P`:**

   ```cpp
   TYPED_TEST_P(FooTest, DoesSomething) {
     TypeParam val{};
     EXPECT_TRUE(val.IsValid());
   }

   TYPED_TEST_P(FooTest, HasProperty) {
     ...
   }
   ```

4. **Register Tests:**

   Register the tests for the suite:

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesSomething, HasProperty);
   ```

5. **Instantiate the Tests with Types:**

   Provide the list of types you want to test and instantiate:

   ```cpp
   using MyTypes = ::testing::Types<int, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
   ```

### Example: Type-Parameterized Test

```cpp
template <typename T>
class MyInterfaceTest : public ::testing::Test {
  // Abstract test pattern
};

TYPED_TEST_SUITE_P(MyInterfaceTest);

TYPED_TEST_P(MyInterfaceTest, TestBehavior) {
  TypeParam obj;
  EXPECT_TRUE(obj.IsValid());
}

REGISTER_TYPED_TEST_SUITE_P(MyInterfaceTest, TestBehavior);

using Implementations = ::testing::Types<MyType1, MyType2>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, MyInterfaceTest, Implementations);
```

### When to Use

- Writing tests for generic interfaces or concepts.
- Defining reusable test suites independent of type lists.
- Multiple instantiations with different type lists required.

---

## Summary of Macros and Functions

| Macro / Function               | Purpose                                                                                   |
|------------------------------|-------------------------------------------------------------------------------------------|
| `TEST_P`                     | Defines a value-parameterized test.                                                     |
| `INSTANTIATE_TEST_SUITE_P`   | Instantiates a value-parameterized test with parameters.                                |
| `TYPED_TEST_SUITE`           | Defines a typed test suite with type list.                                              |
| `TYPED_TEST`                 | Defines tests for typed test suites.                                                    |
| `TYPED_TEST_SUITE_P`         | Defines a type-parameterized test suite (without type list).                            |
| `TYPED_TEST_P`               | Defines tests in a type-parameterized test suite.                                       |
| `REGISTER_TYPED_TEST_SUITE_P`| Registers tests for a type-parameterized test suite.                                   |
| `INSTANTIATE_TYPED_TEST_SUITE_P` | Instantiates a type-parameterized test suite with the type list.                    |

---

## Troubleshooting & Tips

- **Uninstantiated Parameterized Tests:**
  If you define parameterized tests but don't instantiate them, GoogleTest will generate a failure. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTest)` if you intentionally want to suppress this.

- **Parameter Lifetimes:**
  When using complex parameters or string types, ensure that parameter objects outlive the test execution to avoid dangling references.

- **Naming Collisions:**
  Use unique instantiation prefixes in `INSTANTIATE_TEST_SUITE_P` to avoid test name collisions.

- **Custom Parameter Naming:**
  Custom parameter naming functions can help with report clarity but must return valid, unique identifiers.

- **Combining Parameters:**
  Use `Combine` to generate all parameter combinations to ensure thorough test coverage.

- **Choosing Between Typed and Type-Parameterized:**
  Typed tests require you to know all test types upfront; type-parameterized tests support more flexible reusable test definitions.

---

## Next Steps & Related Documentation

- **Writing Your First Unit Test**: Get started with basic tests — [Guide](https://example.com/guides/getting-started/first-unit-test)
- **Mocking Techniques & Best Practices**: Learn to combine mocking with parameterized tests — [Guide](https://example.com/guides/essential-testing-patterns/mocking-best-practices)
- **API Reference: Parameterized & Typed Tests**: Detailed API specs — [Reference](https://example.com/api-reference/core-testing-apis/parameterized-testing)
- **Advanced: Customizing Typed Test Names** and **Complex Parameter Generators**

For the code examples and more, consult the source header `gtest-param-test.h` and `gtest-typed-test.h` in the GoogleTest repository.

---

## Sample Code Snippets

### Basic Value-Parameterized Test
```cpp
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues, FooTest, Values(2, 4, 6, 8));
```

### Typed Test Example
```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsPositive) {
  EXPECT_GT(std::numeric_limits<TypeParam>::max(), 0);
}
```

### Type-Parameterized Test Example
```cpp
template <typename T>
class AbstractTest : public ::testing::Test {
  // Test pattern
};

TYPED_TEST_SUITE_P(AbstractTest);

TYPED_TEST_P(AbstractTest, Behavior) {
  TypeParam obj;
  EXPECT_TRUE(obj.IsValid());
}

REGISTER_TYPED_TEST_SUITE_P(AbstractTest, Behavior);

using TypesToTest = ::testing::Types<MyClassA, MyClassB>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, AbstractTest, TypesToTest);
```
