---
title: "Parameterized & Typed Tests"
description: "Unlock advanced test coverage by leveraging parameterized and type-parameterized tests. This guide demonstrates how to test code against multiple data sets and type variations efficiently."
---

# Parameterized & Typed Tests

Unlock advanced test coverage by leveraging parameterized and type-parameterized tests. This guide demonstrates how to test code against multiple data sets and type variations efficiently.

---

## 1. Understanding Parameterized & Typed Tests

### What This Guide Helps You Accomplish
This guide walks you through how to systematically test your code against _multiple input parameters_ and _various types_ without redundant code. By mastering parameterized tests and typed tests in GoogleTest, you can ensure your tests cover broader scenarios while minimizing maintenance overhead.

### Prerequisites
- Familiarity with basic GoogleTest test writing using `TEST` and `TEST_F` macros.
- Basic knowledge of C++ templates and type parameters.
- GoogleTest properly installed and set up in your development environment.

### Expected Outcome
After completing this guide, you will be able to:
- Write value-parameterized tests that run the same logic with different input data.
- Create typed test suites to run tests for multiple types seamlessly.
- Use type-parameterized tests to define abstract patterns of tests and instantiate them flexibly.

### Time Commitment
Approximately 15-30 minutes, depending on your familiarity.

### Difficulty Level
Intermediate

---

## 2. Value-Parameterized Tests: Testing Across Multiple Data Sets

Value-parameterized tests let you run the same test logic multiple times with different runtime values. This is ideal for testing functions or classes against multiple inputs efficiently.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Parameterized Fixture Class">
Create a test fixture class derived from `::testing::TestWithParam<T>`, where `T` is the type of your test parameters.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // You can define members here, if needed.
};
```

This fixture now supports parameter access via `GetParam()`.
</Step>

<Step title="Write Tests Using TEST_P Macro">
Write test cases with `TEST_P` (the "P" stands for parameterized). Inside each test, use `GetParam()` to access the current test parameter.

```cpp
TEST_P(FooTest, HandlesPositiveNumbers) {
  int n = GetParam();
  EXPECT_GT(n, 0);
}
```

You can write multiple `TEST_P` for a fixture, each accessing the parameters.
</Step>

<Step title="Instantiate the Test Suite with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to associate a unique instantiation name, the test suite name, and a generator to produce the parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveIntegers, FooTest, ::testing::Values(1, 2, 3, 4));
```

The `Values()` generator runs the test with each enumerated value.
</Step>

<Step title="Run Tests and Observe Parameterized Results">
When running your tests, each parameter will yield a separate test instance with a distinct name:

- `PositiveIntegers/FooTest.HandlesPositiveNumbers/0` uses parameter `1`
- `PositiveIntegers/FooTest.HandlesPositiveNumbers/1` uses parameter `2`

and so forth.
</Step>
</Steps>

### Parameter Generators Available
- `Values(...)` - Enumerate explicit parameter values.
- `Range(begin, end[, step])` - Produces sequence from `begin` to `end` (exclusive).
- `ValuesIn(container)` - Use a container or array for parameters.
- `Bool()` - Two boolean values `{false, true}`.
- `Combine(...)` - Cartesian product of multiple parameter generators.

### Customizing Parameter Names
To make test names more descriptive, provide a function or functor that maps test parameters to valid strings:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest, ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param" + std::to_string(info.param);
    });
```

### Practical Tips
- Declare `SetUpTestSuite()` and `TearDownTestSuite()` as `public` if you use them with `TEST_P` fixtures.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if your parameterized tests are not instantiated in some builds.

### Common Pitfalls
- Parameters that are non-copyable will not work.
- Ensure your parameter name generator produces valid, unique, underscore-free names.
- Remember that test order is undefined, so do not rely on test execution order.

---

## 3. Typed Tests: Testing Logic Across Multiple Types

Typed tests let you run the same test logic across different C++ types. This is valuable when you want to verify behavior for various template instantiations or implementations of an interface.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Class Template">
Create a fixture class template parameterized by a type `T`. Derive from `::testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_ = T();
};
```
</Step>

<Step title="Associate a Type List with the Fixture">
Define a type list of the types to test and associate it with the fixture via `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

You can also specify a custom name generator class as a third parameter.
</Step>

<Step title="Write Typed Tests with TYPED_TEST">
Define tests for the fixture using the `TYPED_TEST` macro. Use the special `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam n = this->value_;
  EXPECT_TRUE(sizeof(n) >= 0);  // Just an example
}
```

You can write multiple typed tests for the fixture.
</Step>

<Step title="Run Typed Tests and Inspect Results">
GoogleTest generates separate test suites, one per type, with names suffixed with the type name (or custom name generator output).

For example:

- `MyTypedTest<int>.IsDefaultConstructible`
- `MyTypedTest<double>.IsDefaultConstructible`
- `MyTypedTest<std::string>.IsDefaultConstructible`
</Step>
</Steps>

### Custom Type Naming
Create a class with a template static function `GetName(int)` to return human-friendly names for types.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, std::string>) return "String";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices
- Use typed tests when the tests differ only by type.
- Typed tests provide better test name output than value-parameterized tests for type-specific coverage.
- Avoid side effects across tests since different types instantiate separate fixtures.

---

## 4. Type-Parameterized Tests: Abstracting Typed Tests for Flexible Instantiation

Type-parameterized tests allow defining abstract test logic that can be instantiated with different type lists, possibly in different translation units.

This is helpful when:
- You define common requirements for types in a library.
- Users instantiate the tests for their custom types.

### Step-by-Step Instructions

<Steps>
<Step title="Define Fixture Class Template">
Define your type-parameterized test fixture class template just like typed tests.

```cpp
template <typename T>
class MyPatternTest : public ::testing::Test {
  // ...
};
```
</Step>

<Step title="Declare a Type-Parameterized Test Suite">
Use `TYPED_TEST_SUITE_P` instead of `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE_P(MyPatternTest);
```

This declares the test suite pattern but does not instantiate it yet.
</Step>

<Step title="Define Type-Parameterized Tests with TYPED_TEST_P">
Write tests using the `TYPED_TEST_P` macro.

```cpp
TYPED_TEST_P(MyPatternTest, DoesThing) {
  // Test using TypeParam
}

TYPED_TEST_P(MyPatternTest, HasProperty) {
  // Another test
}
```

</Step>

<Step title="Register the Tests">
Register the test names with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, DoesThing, HasProperty);
```

This step ensures test definitions are known before instantiation.
</Step>

<Step title="Instantiate the Test Suite with Type Lists">
Instantiate the pattern with specific types via `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using Implementations = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, MyPatternTest, Implementations);
```

You can instantiate multiple times with different type lists and different prefixes.
</Step>
</Steps>

### Example

```cpp
// Header (mypattern_test.h)

template <typename T>
class MyPatternTest : public ::testing::Test {
 public:
  void DoSomething() { /* ... */ }
};

TYPED_TEST_SUITE_P(MyPatternTest);

TYPED_TEST_P(MyPatternTest, DoesSomething) {
  TypeParam x = 0;
  this->DoSomething();
  EXPECT_EQ(x, 0);
}

TYPED_TEST_P(MyPatternTest, IsDefault) {
  EXPECT_EQ(TypeParam(), 0);
}

REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, DoesSomething, IsDefault);

// CPP file (mypattern_test.cc)

#include "mypattern_test.h"
using MyTypes = ::testing::Types<char, int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInsts, MyPatternTest, MyTypes);
```

### Notes
- `TYPED_TEST_SUITE_P` and `REGISTER_TYPED_TEST_SUITE_P` usually go in headers.
- `INSTANTIATE_TYPED_TEST_SUITE_P` usually goes in a source file.

---

## 5. Troubleshooting & Tips

- **Tests not discovered?** Ensure you have instantiated your parameterized or typed tests.
- **Duplicate test names?** Use custom naming generators to keep unique and valid names.
- **Compilation errors on types?** Your types must be default-constructible or support the operations used in fixtures.
- **Tests run multiple times?** Check for multiple instantiations with same prefix or type lists.
- **Avoid underscores** in test suite and test names to prevent GoogleTest name conflicts.

---

## 6. Next Steps & Related Content

- Explore [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for deep dive.
- Read about [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for advanced usage.
- Learn about [Specifying Names for Value-Parameterized Test Parameters](../advanced.md#specifying-names-for-value-parameterized-test-parameters) for custom naming.
- For example projects and comprehensive samples, see sample6_unittest.cc in GoogleTest source.
- For integrating tests into CI pipelines, consult the Continuous Integration Setup guides.

---

## 7. References

- GoogleTest Testing Reference on [Parameterized Tests](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- GoogleTest [Primer on Typed Tests](docs/primer.md#typed-tests)
- FAQ on test naming conventions and errors: [FAQ - Naming Tests](faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)

---

Unlock full testing power by mastering parameterized and typed tests. They help you write concise, reusable tests that thoroughly exercise your code with varying input and type scenarios.
