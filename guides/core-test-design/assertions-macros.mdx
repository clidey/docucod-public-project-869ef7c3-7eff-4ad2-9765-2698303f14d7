---
title: "Assertions, Macros & Expectations"
description: "Explore the wide variety of assertion macros and expectation patterns supported by GoogleTest, including equality, exceptions, fatal vs. non-fatal failures, and tips for structuring readable, actionable tests."
---

# Assertions, Macros & Expectations

Explore the wide variety of assertion macros and expectation patterns supported by GoogleTest, including equality, exceptions, fatal vs. non-fatal failures, and tips for structuring readable, actionable tests.

---

## 1. Understanding Assertions in GoogleTest

Assertions form the core of GoogleTest and enable you to verify conditions during test execution. Each assertion macro comes in two variants:

- **EXPECT_**: Generates a non-fatal failure and allows the test to continue.
- **ASSERT_**: Generates a fatal failure and aborts the current function immediately.

Both variants accept streaming of custom failure messages via `<<`, allowing detailed diagnostics.


## 2. Types of Assertions and When to Use Them

### Boolean Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

Use these to verify that a condition evaluates to true or false.

### Equality and Relational Assertions

These macros compare two values and print both the expressions and their actual values upon failure:

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`: Equality (`==`)
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`: Inequality (`!=`)
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`: Less than (`<`)
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`: Less or equal (`<=`)
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`: Greater than (`>`)
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`: Greater or equal (`>=`)


### String Comparisons

Specialized macros handle C-style strings for content comparison (not pointer equality):

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`: Strings are equal
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`: Strings not equal
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`: Case-insensitive equality
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`: Case-insensitive inequality

These also work with wide C strings (`wchar_t*`) transparently.


### Floating-Point Comparisons

Due to the imprecision of floating-point math, specialized macros use Units in the Last Place (ULPs) for approximate equality:

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)` for `float`
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)` for `double`

Additionally, to test if values are within an absolute error bound:

- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`


### Exception Assertions (Requires Exceptions Enabled)

Test that code throws or does not throw exceptions:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`

Supports testing compound statements.


### Predicate Assertions

For more complex conditions, predicate assertions provide better error messages:

- `EXPECT_PRED1(pred, val1)` ... `EXPECT_PRED5(pred, val1, ..., val5)`
- `EXPECT_PRED_FORMAT1(pred_formatter, val1)` ... `EXPECT_PRED_FORMAT5(..., val1, ..., val5)`

The predicate is a function or functor returning `bool` or `testing::AssertionResult` offering a detailed failure message. These allow tailored checks beyond built-in assertions.


### Explicit Success and Failure

- `SUCCEED()`: Generates a success mark (no visible output currently).
- `FAIL()`: Generates a fatal failure and aborts the current void-returning function.
- `ADD_FAILURE()`: Generates a non-fatal failure and continues.


### Skipping Tests

- `GTEST_SKIP()`: At runtime, skips the current test. Can be used inside test cases or test fixture setup/tear down.


## 3. Practical Usage and Best Practices

### Choosing Between EXPECT_ and ASSERT_

Use `EXPECT_*` macros where occasional failure can be tolerated and the test still produces useful results. Use `ASSERT_*` when further operations depend on the assertion's success (e.g., dereferencing a pointer after verifying it is not `nullptr`).

### Streaming Helpful Messages

Always provide contextual information with `<<` streaming on assertions, especially in loops or complex tests, to highlight the input that caused a failure.

### Predicate Assertions for Complex Logic

Implement predicate functions returning `AssertionResult` for complex verifications. This approach elegantly shows what went wrong with rich messages.

Example:

```cpp
// Predicate function with detailed messages
testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0)
    return testing::AssertionSuccess() << n << " is even";
  else
    return testing::AssertionFailure() << n << " is odd";
}

// Using predicate assertion
EXPECT_TRUE(IsEven(value));
```

Failure message example:

```
Value of: IsEven(value)
  Actual: false (3 is odd)
Expected: true
```


### Using Scoped Traces to Improve Diagnostics

When an assertion fails deep in a helper function called multiple times, use `SCOPED_TRACE()` to add contextual trace information that will be included with failure messages.

Example:

```cpp
SCOPED_TRACE("Checking iteration " << i);
helper(...);
```

This helps identify which iteration failed without cluttering assertion macros.


## 4. Common Pitfalls and Troubleshooting

### Fatal Assertions in Non-Void Functions

Fatal assertions like `ASSERT_*` and `FAIL()` can only be used in `void`-returning functions. Using them in non-void functions causes compilation errors such as `void value not ignored`.

To work around this, either:

- Change the function to return void and use out-parameters.
- Use non-fatal assertions like `ADD_FAILURE()` and `EXPECT_*` instead.


### Using Assertions in Constructors or Destructors

Fatal assertions are not allowed in constructors or destructors and will cause compilation errors. Instead, place initialization or cleanup checks in `SetUp()` and `TearDown()` methods.


### Disabled Tests

Prefix a test or test suite name with `DISABLED_` to exclude it from execution while keeping it compiled. Use temporarily to suppress failing tests but remember to fix and re-enable them.


### Ensuring Assertions are Evaluated Only Once

Arguments passed to assertions are evaluated exactly once. This guarantees no side effects from multiple evaluations but means you should not rely on side effects within assertion arguments.


## 5. Advanced Assertion Features

### Floating-Point Comparisons with ULP

GoogleTest compares floats and doubles using a tolerance in ULPs (Units in the Last Place) for better handling of floating-point precision.

### Expecting Failures in Subroutines

Use `ASSERT_NO_FATAL_FAILURE(statement)` or `EXPECT_NO_FATAL_FAILURE(statement)` to verify that `statement` doesn't generate fatal failures inside subroutines.

### Teaching GoogleTest to Print Your Types

Define `AbslStringify()` or `PrintTo()` in your types to produce readable failure messages. This customizes how GoogleTest prints values in assertion failures.


## 6. Sample Usage Examples

### Equality Comparison with Custom Message

```cpp
EXPECT_EQ(foo, bar) << "foo and bar should be equal";
```

### Exception Assertion

```cpp
ASSERT_THROW({
  SomeFunction();
}, std::runtime_error);
```

### Predicate Assertion with Detailed Explanation

```cpp
testing::AssertionResult IsPositive(int n) {
  if (n > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << "Value " << n << " is not positive";
}

EXPECT_TRUE(IsPositive(value));
```

### Skipping a Test

```cpp
TEST(MyTest, SkipIfNotSupported) {
  if (!IsSupported()) {
    GTEST_SKIP() << "Feature not supported on this platform.";
  }
  ...
}
```


## 7. Troubleshooting & Tips

### Test Reports Show Included Assertions

Use streaming messages to add context that will appear in failure reports and logs.

### Handling Flaky Tests

Use command line flags such as `--gtest_repeat=N` to rerun tests multiple times to catch intermittent failures.

### Avoid Mixing TEST and TEST_F in One Suite

All tests in the same suite must use the same fixture class. Mixing can cause assertions due to fixture inconsistencies.

### Use Disabled Tests with Caution

`DISABLED_` prefix disables tests without removal. Monitor and fix disabled tests regularly.


## 8. Next Steps

- Explore [Test Fixtures & Code Reuse](../core-test-design/test-fixtures-sharing-code) to leverage shared setup and teardown.
- Learn about [Parameterized & Typed Tests](../core-test-design/parameterized-typed-tests) for running tests with multiple inputs or types.
- For mocking, refer to [Intro to Mocking with GoogleMock](../mocking-advanced-techniques/intro-mocking).
- Review the [Assertions Reference](reference/assertions.md) for the full list of assertion macros and usage.


---

## References

- [GoogleTest Primer](docs/primer.md) - Foundational concepts and simple test examples.
- [Assertions Reference](reference/assertions.md) - Detailed API and usage of all assertion macros.
- [Advanced Topics](docs/advanced.md) - In-depth coverage including predicate assertions and death test assertions.
- [Writing Your First Test](guides/getting-started/writing-first-test) - Practical tutorial to get started.

---

## Practical Tips

> **Tip:** Use `ASSERT_*` for checks that must pass for the test to continue safely.

> **Tip:** Use `EXPECT_*` generally to allow multiple assertions to report failures.

> **Tip:** Stream detailed information into assertions for better failure clarity.

> **Pitfall:** Avoid fatal assertions in non-void functions or constructors/destructors.

> **Best Practice:** Use `SCOPED_TRACE()` for tracing failures in helper functions.

---

### End of Documentation
