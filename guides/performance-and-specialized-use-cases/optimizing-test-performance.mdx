---
title: "Optimizing Test Performance"
description: "Discover practical strategies for speeding up your test suite—covering parallel test execution, test filtering, and efficient test design. Learn to profile and tackle slow tests for CI environments and large codebases."
---

# Optimizing Test Performance

Improve the speed and responsiveness of your GoogleTest suites using proven strategies for parallel execution, test filtering, and efficient test design. This guide walks you through practical steps to profile, identify, and fix slow tests, especially important for continuous integration (CI) environments and large codebases.

---

## 1. Workflow Overview

### Task Description
This guide helps you accelerate the execution of your GoogleTest test suites by leveraging parallelism, filtering unwanted tests, and designing tests for efficiency. It also shows how to profile and address test bottlenecks.

### Prerequisites
- A working GoogleTest environment with tests compiled and runnable.
- Familiarity with running tests and basic GoogleTest command line flags.
- Access to your CI system or local environment where tests run.

### Expected Outcome
By following this guide, you will:
- Run tests in parallel to reduce overall elapsed time.
- Selectively execute tests to focus on relevant subsets.
- Detect and improve slow tests causing bottlenecks.
- Improve your CI pipeline speed and developer feedback loops.

### Time Estimate
Approximately 20-40 minutes, depending on test suite size and profiling complexity.

### Difficulty Level
Intermediate — requires comfort with command-line flags and test execution concepts.

---

## 2. Practical Strategies and Step-by-Step Instructions

### Step 1: Enable Parallel Test Execution
GoogleTest supports sharding tests across multiple processes or machines using the `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` environment variables.

#### Instructions:
1. Determine the number of parallel shards (machines or processes) you want to run.
2. For each shard, set:
   - `GTEST_TOTAL_SHARDS` to the total shard count.
   - `GTEST_SHARD_INDEX` to the shard's zero-based index.
3. Run the same test executable on each shard.

Example for 3 shards:
```sh
# Run on machine or process 0
GTEST_TOTAL_SHARDS=3 GTEST_SHARD_INDEX=0 ./your_test_binary

# Run on machine or process 1
GTEST_TOTAL_SHARDS=3 GTEST_SHARD_INDEX=1 ./your_test_binary

# Run on machine or process 2
GTEST_TOTAL_SHARDS=3 GTEST_SHARD_INDEX=2 ./your_test_binary
```

_Expected Result_: Each shard runs a disjoint subset of tests. Total time reduces roughly by the shard count, assuming balanced test distribution.

#### Best Practices:
- Balance shard counts according to available resources.
- Make sure tests are independently runnable for safe parallelization.

---

### Step 2: Use Test Filtering to Run Only Needed Tests
GoogleTest allows you to filter which test cases or individual tests to run, providing faster feedback by skipping unneeded tests.

#### Instructions:
1. Use the `--gtest_filter` flag or `GTEST_FILTER` environment variable.
2. Specify a colon-separated list of wildcard patterns (positive, optionally negative patterns).

Example:
```sh
./your_test_binary --gtest_filter=FastTests.*:-FastTests.FlakyExample
```

This runs all tests in the `FastTests` suite except `FastTests.FlakyExample`.

#### Expected Result:
Tests run faster by executing only targeted subsets.

#### Tips:
- Use `--gtest_list_tests` to preview available tests.
- Combine filters for complex patterns.

---

### Step 3: Profile Slow Tests
Identifying and optimizing slow tests is crucial to improving overall suite performance.

#### Instructions:
1. Enable detailed timing output in your test runs:
   - Use `--gtest_print_time=1` (default) to show execution time per test.
2. Generate XML or JSON test reports, which include per-test times:
   - Use `--gtest_output=xml:report.xml` or `--gtest_output=json:report.json`.
3. Use scripts or your test infrastructure to parse and list slowest tests.

#### Sample command:
```sh
./your_test_binary --gtest_output=xml:report.xml --gtest_print_time=1
```

#### Expected Result:
You get detailed timing information to spot slow tests.

---

### Step 4: Improve Test Design for Efficiency
Slow tests often come from inefficient setup, complex dependencies, or excessive resource allocation.

#### Recommendations:
- Use test fixtures wisely to reuse expensive setup with `SetUpTestSuite()` and `TearDownTestSuite()`.
- Avoid heavy IO or long waits within individual tests.
- Split overly complex or monolithic tests into smaller focused ones.
- Minimize global state changes that affect other tests.
- Consider mocking costly dependencies.

#### Example: Sharing Expensive Resources Across Tests
```cpp
class ExpensiveSetupTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    shared_resource_ = new ExpensiveResource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  static ExpensiveResource* shared_resource_;
};

ExpensiveResource* ExpensiveSetupTest::shared_resource_ = nullptr;
```

---

### Step 5: Combining Parallel Execution with Test Filtering
You can shard a filtered subset of tests to optimize CI runs.

#### Instructions:
1. Apply filtering via `--gtest_filter`.
2. Parallelize shards with `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` as above.

Example:
```sh
GTEST_TOTAL_SHARDS=4 GTEST_SHARD_INDEX=0 ./test --gtest_filter=Fast.*
```

---

## 3. Troubleshooting & Tips

### Common Issues

- **Unbalanced Shards**: Some shards may run slower if tests vary greatly in runtime.
  - _Solution_: Profile tests and manually group them to balance load.

- **Tests with Side Effects**: Shared state between tests may cause flaky behavior when parallelized.
  - _Solution_: Ensure tests are independent or use synchronization where necessary.

- **Disabled Tests Running Unexpectedly**: Check your `--gtest_filter` or `GTEST_ALSO_RUN_DISABLED_TESTS` flag.

- **No Tests Running**: Confirm your filters match test names exactly, and that tests are not disabled.

### Best Practices

- Regularly profile test suite timings.
- Prioritize fixing slow and flaky tests.
- Use `DISABLED_` prefix sparingly and remove once fixed.
- Use `SCOPED_TRACE()` for better diagnostics in complex tests.

### Performance Considerations

- Running tests with `--gtest_repeat` can help identify flaky or slow tests.
- Use sharding in CI pipelines to shorten feedback loops.

### Alternative Approaches

- Implement custom test runners or schedulers that enrich test reports or integrate with build systems.
- Use GoogleTest event listeners to gather execution metrics.

---

## 4. Next Steps & Related Content

- [Integrating with CI and Build Systems](guides/advanced-mocking-integrations/integrating-with-ci-and-build-systems) — for practical CI pipeline setups
- [Test Output and Reporting](guides/performance-and-specialized-use-cases/test-output-and-reporting) — detailed guidance on XML/JSON reports
- [Writing and Using Death Tests](guides/performance-and-specialized-use-cases/writing-and-using-death-tests) — advanced tests that may affect performance
- [Running Tests and Interpreting Results](guides/getting-started-core-workflows/running-tests-and-interpreting-results) — how to invoke tests and read results
- [GoogleTest Primer](docs/primer.md) — refresher on test writing

Ensure your test suite follows GoogleTest best practices to maximize speed and reliability.

---