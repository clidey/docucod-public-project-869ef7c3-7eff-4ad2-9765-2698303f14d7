---
title: "Optimizing Test Suite Performance"
description: "Get practical strategies for speeding up your tests: parallel execution, selective test running, managing large test suites, and diagnosing slow tests. Boost feedback cycles and foster rapid development with scalable test design."
---

# Optimizing Test Suite Performance

## Overview

This guide helps you accelerate the execution of your GoogleTest test suites by applying proven strategies. You will learn how to leverage parallel test execution, run selective test subsets, manage large and complex test suites, and pinpoint sources of slow tests. These approaches are essential to shortening feedback cycles and enabling rapid development iterations.

Before you begin, make sure you have your tests organized and running successfully as described in the [Running and Interpreting Your Tests](../guides/gtest-core-guides/running-tests.md) guide.

---

## 1. Speed Up Your Tests with Parallel Execution

Running tests serially can become a bottleneck as your suite grows. GoogleTest supports various ways to run tests in parallel, spreading workload across processor cores or machines.

### How to Enable Parallel Test Execution

1. **Use External Parallel Test Runners**: Tools like [`gtest-parallel`](https://github.com/GoogleCloudPlatform/gtest-parallel) allow tests to be distributed across CPU cores or machines.

2. **Leverage Sharding Environment Variables**:
   - Set `GTEST_TOTAL_SHARDS` to the total number of shards (parallel partitions).
   - Set `GTEST_SHARD_INDEX` to the zero-based index of the current shard.

GoogleTest will then run a distinct subset of tests on each shard, ensuring no overlap.

```bash
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=0  # On machine 1
./your_test_binary

export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=1  # On machine 2
./your_test_binary
```

3. **CI Integration**: Configure your continuous integration system to spawn multiple jobs with these environment variables set accordingly.

### Best Practices

- Ensure tests are independent and do not share mutable global state.
- Use `SetUpTestSuite()` and `TearDownTestSuite()` carefully to prepare and clean up shared resources.
- Avoid test interdependencies that could cause flaky failures when run in parallel.

---

## 2. Selective Test Execution

When developing or debugging, you may only want to run a subset of tests.

### Filtering Tests

Use GoogleTest's filtering capabilities via the `--gtest_filter` flag.

- Run tests from specific suites or tests:

  ```bash
  ./your_test_binary --gtest_filter=SomeTestSuite.*  # Runs all tests in SomeTestSuite
  ./your_test_binary --gtest_filter=SomeTestSuite.TestName  # Runs only this test
  ```

- Combine positive and negative filters with wildcards:

  ```bash
  ./your_test_binary --gtest_filter=*Feature*:*BugFix*  # Runs tests matching "Feature" or "BugFix"
  ./your_test_binary --gtest_filter=-*Flaky_*  # Skip all flaky tests prefixed with "Flaky_"
  ```

### Running Disabled Tests

By default, tests prefixed with `DISABLED_` are skipped.
Run them specifically with:

```bash
./your_test_binary --gtest_also_run_disabled_tests
```

### Tips for Naming

Avoid underscores in test suite or test names to ensure reliable filtering and test identification, per [FAQ: Why should test suite names and test names not contain underscore?](../docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)

---

## 3. Managing Large Test Suites

As your project grows, your test suite may become large and harder to manage and run efficiently.

### Organize Tests into Suites and Use Fixtures

- Group logically related tests into suites with shared fixtures.
- Use `SetUpTestSuite()` and `TearDownTestSuite()` to allocate expensive shared resources only once per suite instead of per test.

### Avoid Over-Specification in Mocks

- Use `ON_CALL()` rather than many `EXPECT_CALL`s for setting default mock behavior to reduce combinatorial explosion of expectations.
- Only specify expectations when you want to verify specific interactions.

### Enable Test Repetition and Shuffling

- Use `--gtest_repeat=N` to run tests multiple times for flakiness detection.
- Use `--gtest_shuffle` to uncover hidden dependencies between tests.

### Automate Performance Monitoring

Generate *XML* or *JSON* test reports to identify slow-running tests automatically:

```bash
./your_test_binary --gtest_output=xml:report.xml
```

Use this data to prioritize optimization efforts.

---

## 4. Diagnosing Slow Tests

Slow tests degrade the development experience. Use the following methods to find and fix them.

### Variable Timing Granularity

- Use high-resolution clocks inside your tests to measure and log individual test durations.
- Instrument key sections of tests or fixtures.

### Analyze the Test Execution Report

- GoogleTestâ€™s XML reports include per-test execution times.
- Sort tests by duration to identify outliers.

### Common Causes and Solutions

- **Expensive Setup/TearDown**: Use shared fixture setup with `SetUpTestSuite()`.
- **Heavy Dependencies**: Reduce or mock expensive I/O or external service calls.
- **Unnecessary Waiting or Sleeping**: Remove or mock timing dependencies.

### Tips

- Use `SCOPED_TRACE` to help localize performance bottlenecks inside complex tests.
- Break down large tests into smaller ones where feasible.

---

## Troubleshooting

### Parallel Test Flakiness

- Make sure no shared mutable state is accessed without synchronization.
- Avoid global state or make sure it is properly isolated per test.

### Unexpected Test Skips

- Verify your filters and sharding variables.
- Remember that `DISABLED_` prefixed tests will be skipped unless explicitly run.

### Compile or Link Errors During Optimization

- Confirm that your mock classes and test fixtures follow GoogleTest naming and usage guidelines.
- Ensure mocking macros such as `MOCK_METHOD` are correctly used, including wrapping argument types with commas in parentheses or aliases.

---

## Best Practices Summary

- Prefer test parallelization to maximize resource utilization.
- Keep tests independent, deterministic, and fast.
- Use filtering and sharding to focus test runs.
- Profile test runtimes routinely and address bottlenecks promptly.

For an in-depth look at optimizing large test suites, see the related guide [Integrating with CI & Test Runners](../guides/integration-and-best-practices/ci-and-test-runner-integration.md), and explore details on [Writing and Organizing Tests](../guides/gtest-core-guides/writing-tests.md) for structure best practices.

---

## Additional Resources

- [GoogleTest Primer](../docs/primer.md): Beginner-oriented intro to writing tests.
- [GoogleTest Advanced Topics](../docs/advanced.md): More advanced techniques including fixture sharing and death tests.
- [Mocking Reference](../docs/reference/mocking.md): Comprehensive mock usage and best practices.
- [GoogleTest FAQ](../docs/faq.md): Answers to common user questions.

---

## Example: Running Tests in Parallel Using Sharding

```bash
# On shard 0
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=0
./my_tests_binary

# On shard 1
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=1
./my_tests_binary

# On shard 2
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=2
./my_tests_binary
```

Each process runs a subset of tests, accelerating overall test duration in a CI environment.

---

## Example: Filtering to Run a Subset of Tests

```bash
# Runs all tests in the MathTest suite except the ones named Multiply
./my_tests_binary --gtest_filter=MathTest.*-MathTest.Multiply
```

Run this when you need quick focus on certain parts of your code.

---

## Example: Shared Setup for Expensive Resource

```cpp
class FooTest : public ::testing::Test {
protected:
  static ExpensiveResource* resource_;

  static void SetUpTestSuite() {
    resource_ = new ExpensiveResource();
  }

  static void TearDownTestSuite() {
    delete resource_;
    resource_ = nullptr;
  }
};
ExpensiveResource* FooTest::resource_ = nullptr;

TEST_F(FooTest, TestFeature) {
  EXPECT_TRUE(resource_->DoSomething());
}
```

This avoids recreating the resource for every test.
