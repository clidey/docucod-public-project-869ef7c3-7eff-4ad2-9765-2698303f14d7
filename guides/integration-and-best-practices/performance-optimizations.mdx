---
title: "Performance Optimization for Test Suites"
description: "Strategies for designing fast, efficient test suites in large codebases. Shares patterns for minimizing test overhead, leveraging test filters, parallel execution, and scaling GoogleTest and GoogleMock."
---

# Performance Optimization for Test Suites

Optimizing the performance of your test suites is crucial when working with large codebases and extensive test coverage. This guide provides practical strategies for designing fast, efficient GoogleTest and GoogleMock test suites, minimizing overhead, enabling scalable execution, and maintaining robustness as your project grows.

---

## 1. Overview of Test Suite Performance Optimization

### Why Optimize?
When working with extensive tests, slow test suites reduce developer productivity and prolong feedback cycles. Efficient test execution accelerates development, detection of regressions, and integration with Continuous Integration (CI) pipelines.

### What to Expect
This guide focuses on:

- Minimizing per-test overhead
- Leveraging test filters and selective execution
- Utilizing parallel and distributed testing
- Best practices for test and fixture design
- Practical tips for GoogleTest/GoogleMock specific optimizations

---

## 2. Minimize Test Overhead

### Favor Lightweight Test Fixtures

- **Keep fixtures lean:** Avoid expensive setup in constructors or `SetUp()` unless necessary.
- **Share expensive resources safely:** Use `SetUpTestSuite()` and `TearDownTestSuite()` for shared initialization and cleanup to amortize cost across tests.

Example:
```cpp
class ExpensiveResourceTest : public testing::Test {
 protected:
  static std::unique_ptr<Resource> shared_resource_;

  static void SetUpTestSuite() {
    shared_resource_ = std::make_unique<Resource>(...);
  }

  static void TearDownTestSuite() {
    shared_resource_.reset();
  }
};

std::unique_ptr<Resource> ExpensiveResourceTest::shared_resource_ = nullptr;
```

### Use Parameterized Tests Wisely

- Parameterized tests reduce duplication but might increase runtime if parameters expand excessively.
- Limit parameter sets to essential cases.
- Use custom name generators to improve test result readability.

---

## 3. Harness Test Filtering

### Run Only What You Need

- Use `--gtest_filter` to focus on relevant tests during development.
- Combine inclusion and exclusion patterns for granular control.

Example command line:
```
./my_test --gtest_filter=MySuite.*-MySuite.DisabledTests
```

### Benefits

- Reduces total execution time during iterative development.
- Speeds debugging by narrowing scope.

---

## 4. Parallelize and Distribute Test Execution

### GoogleTest Sharding

- Enable test sharding to run tests concurrently on multiple machines.
- Set environment variables:
  - `GTEST_TOTAL_SHARDS` - Total shards
  - `GTEST_SHARD_INDEX` - Current shard index

Example:
```bash
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=2
./my_test
```

### Running Tests in Parallel Locally

- Run multiple instances of your test binary in parallel with separate shard indices.
- Combine with `--gtest_filter` for more control.

### Considerations

- Sharded tests run mutually exclusive subsets.
- Death test suites (named `*DeathTest`) run first to avoid thread conflicts.

---

## 5. Test Ordering and Randomization

### Leverage Shuffling

- Use `--gtest_shuffle` to randomize test execution order.
- Helps detect hidden dependencies and order-related failures.

### Seed Control

- Use `--gtest_random_seed=SEED` to reuse specific orders when debugging failures.

### Practical Tips

- Combine `--gtest_repeat` with shuffling and filtering to stress test flaky issues.

---

## 6. Efficient Use of GoogleMock

### Avoid Unnecessary Mock Overhead

- Define default behaviors to reduce call expectations setup.
- Disable unnecessary strictness to avoid excessive failure checking.

### Reuse Test Fixtures with Common Mock Setup

- Place shared mock setup in base fixture classes or `SetUpTestSuite()` for reuse.
- Keep mock objects lightweight and reset their state appropriately.

---

## 7. Best Practices in Test Fixture Design

### Per-Test vs Per-Suite Setup

- **Per-Test Setup:** Use for mutable, isolated state.
- **Per-Suite Setup:** Use for expensive to create shared state.

### Avoid Global or Static State Mutations

- Mutable shared state leads to flaky and order-dependent tests.
- Use mechanisms like RAII and scoped mocks to isolate side effects.

### Use Value-Parameterized and Typed Tests Appropriately

- Avoid duplicating test logic.
- Explicitly instantiate test suites to prevent missing tests.

---

## 8. Profiling and Measuring Test Performance

### Measure Individual Test Runtime

- Use GoogleTest's `--gtest_print_time` to display timing.
- Collect detailed XML or JSON reports and parse for slow tests.

### Identify and Refine Bottlenecks

- Focus optimization efforts on tests or fixtures consuming the most time.
- Evaluate fixture setup and teardown cost.

---

## 9. Troubleshooting Common Performance Issues

<AccordionGroup title="Common Performance Issues and Solutions">
<Accordion title="Flaky Tests Due to Shared State">
Shared mutable state can cause tests to fail randomly and slow overall execution. Ensure tests reset state, or isolate shared resources with per-test fixture setup.
</Accordion>
<Accordion title="Long Setup and Teardown Times">
Use `SetUpTestSuite()` for one-time expensive setup and balance with memory consumption trade-offs.
</Accordion>
<Accordion title="Excessive Test Instantiations in Parameterized Tests">
Limit parameter value sets. Use custom name generators to maintain clarity.
</Accordion>
<Accordion title="Inefficient Mocking Overhead">
Avoid strict mocks for all calls unless needed. Reuse mocks and their setup.
</Accordion>
</AccordionGroup>

---

## 10. Summary Best Practices

- Design test fixtures to minimize redundant work.
- Use test filtering to speed up development iterations.
- Embrace sharding and parallel execution for large test suites.
- Monitor test times and profile for bottlenecks.
- Properly manage shared resources with `SetUpTestSuite()` and `TearDownTestSuite()`.
- Optimize mock usage to avoid unnecessary overhead.

---

## 11. Next Steps and Related Resources

- Explore the [GoogleTest Primer](primer.md) for foundational knowledge.
- Learn how to write [Parameterized and Typed Tests](guides/advanced-and-real-world/parameterized-tests.md) to reduce duplication.
- Get familiar with [Core Assertions & Best Practices](guides/getting-started/core-assertions-best-practices.md) to write efficient tests.
- Understand [Mocking Basics and Patterns](guides/advanced-and-real-world/mocking-basics-patterns.md) to optimize mocks.
- Integrate with CI pipelines using [Continuous Integration and Fast Feedback](guides/integration-and-best-practices/ci-best-practices.md).

---

## Appendix: Sample Sharding Setup

```bash
# Machine 0
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=0
./tests

# Machine 1
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=1
./tests

# Machine 2
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=2
./tests
```

---

## Appendix: Example Filter Usage

Run all tests in `FooTest` except `FooTest.Bar`:

```bash
./test_binary --gtest_filter=FooTest.*-FooTest.Bar
```

Run any tests containing "Null" or "Constructor":

```bash
./test_binary --gtest_filter=*Null*:*Constructor*
```

---

## Appendix: Using `SetUpTestSuite` Effectively

```cpp
class MyTest : public testing::Test {
 protected:
  static std::unique_ptr<HeavyResource> heavy_;

  static void SetUpTestSuite() {
    heavy_ = std::make_unique<HeavyResource>();
  }

  static void TearDownTestSuite() {
    heavy_.reset();
  }
};

std::unique_ptr<HeavyResource> MyTest::heavy_ = nullptr;

TEST_F(MyTest, FastTest) {
  EXPECT_TRUE(heavy_->IsReady());
}
```