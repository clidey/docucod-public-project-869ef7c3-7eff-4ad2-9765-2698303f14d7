---
title: "Performance and Scaling"
description: "Learn tips to optimize test execution speed, write efficient test code, and run large test suites at scale. This guide draws on real-world examples and Google best practices to help you maintain agile development without sacrificing quality."
---

# Performance and Scaling

Optimize your GoogleTest-based test suite to run faster and scale efficiently even with large or complex tests. This guide will walk you through proven techniques and best practices to improve test execution speed, reduce test overhead, and reliably run extensive test suites at scale.

---

## 1. Understanding Test Execution Performance

Performance matters when you have many tests or resource-intensive tests. Short feedback cycles keep development agile and encourage frequent testing.

### Why Performance Matters
- Accelerates the development cycle by reducing test feedback time.
- Enables regular execution of large test suites without delaying commits.
- Helps keep your CI/CD pipelines efficient.

### What Affects Test Performance?
- Test initialization and teardown overhead.
- Expensive setup shared across multiple tests.
- Number of test cases and their individual runtime.
- How tests manage resources and state.
- Parallel execution and sharding of tests.

<Tip>
Focus on reducing repeated expensive operations and use test fixture optimizations to ensure faster tests.
</Tip>

---

## 2. Best Practices for Writing Efficient Tests

Writing tests that run faster requires both code design and proper use of GoogleTest features.

### Share Expensive Resources with Test Fixtures
- Use `SetUpTestSuite()` and `TearDownTestSuite()` static methods to initialize and clean up expensive resources once per test suite instead of before each test.

```cpp
class MyFixture : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    resource_ = new ExpensiveResource();
  }
  static void TearDownTestSuite() {
    delete resource_;
    resource_ = nullptr;
  }

  static ExpensiveResource* resource_;
};

ExpensiveResource* MyFixture::resource_ = nullptr;

TEST_F(MyFixture, Test1) {
  ASSERT_TRUE(resource_->IsReady());
}
```

### Avoid Unnecessary Test Dependencies
- Write independent tests that don't rely on side effects from other tests.
- Isolate state so tests can run in parallel or shuffled order without affecting each other.

### Favor Non-Fatal Assertions When Possible
- Use `EXPECT_*` instead of `ASSERT_*` to allow multiple failures in one test, reducing the need to restart tests repeatedly.

### Use Parameterized Tests Wisely
- Parameterized tests (`TEST_P`, `INSTANTIATE_TEST_SUITE_P`) reduce duplicate code but be mindful of parameter set size to avoid explosion of tests.

### Minimize I/O and External Calls
- Mock dependencies to avoid slow calls or resource contention during tests.

<Tip>
Use the GoogleMock framework to isolate and speed up tests on code with external dependencies.
</Tip>

---

## 3. Running Tests at Scale

Scaling your test suite execution involves parallelization and resource management.

### Enable Test Sharding

GoogleTest supports running subsets (“shards”) of tests independently, distributing the execution across multiple machines or processes.

**How to use sharding:**
1. Set environment variables on each shard:
   - `GTEST_TOTAL_SHARDS` = total number of shards
   - `GTEST_SHARD_INDEX` = current shard index (0-based)
2. Run the full test binary on every shard. GoogleTest will automatically select which tests to run based on shard index.

Example: With 3 shards, set up the environment like so:

```bash
# Machine 0
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=0
./foo_test

# Machine 1
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=1
./foo_test

# Machine 2
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=2
./foo_test
```

This ensures tests run exactly once across all shards.

<Tip>
Avoid running death tests and other special test types inside shards to prevent unexpected failures.
</Tip>

### Shuffle Tests to Expose Order Dependencies

Enable test shuffling with `--gtest_shuffle` to randomize test execution order and detect inter-test dependencies which slow down debugging and reduce test reliability.

Use `--gtest_random_seed=SEED` to reproduce a specific shuffle order when failures are detected.

### Repeat Tests to Identify Flakiness

Use `--gtest_repeat=COUNT` to run tests multiple times and detect intermittent failures.

### Parallel Execution within Single Host

Though GoogleTest does not provide built-in concurrency for running tests in parallel threads, external tools and build systems can help:
- Use build systems with parallel test execution (e.g., Bazel, CTest with parallel jobs).
- Run multiple test binaries or shards in parallel to improve throughput.

### Thread Safety of GoogleTest

GoogleTest is thread-safe on platforms where threading support is enabled (e.g., Linux with pthreads). This enables some concurrent test usage:

- You can use GoogleMock concurrently in multiple threads safely.
- Avoid sharing mutable state between tests running in parallel.

See the [googletest/test/gtest_stress_test.cc](https://github.com/google/googletest/blob/main/googletest/test/gtest_stress_test.cc) for real-world examples of concurrent test usage.

---

## 4. Tips to Optimize GoogleTest Usage

### Use Filtering to Run Targeted Tests
- Use `--gtest_filter` to run specific subsets of tests.
- Combine filtering with sharding to speed selective parallel runs.

### Use `--gtest_fail_fast` to Stop After First Failure
This reduces wasted time during large test runs by aborting immediately on failure.

### Use the XML or JSON Output for Analysis
Enable `--gtest_output=xml:` or `--gtest_output=json:` to generate detailed reports that help identify performance bottlenecks and flaky tests.

### Disable Tests Temporarily with `DISABLED_` Prefix
If some tests are slow or flaky, disable them to improve the responsiveness of the test suite but remember to enable them again after fixing.

<Tip>
Regularly review disabled tests to maintain test coverage and quality.
</Tip>

---

## 5. Troubleshooting Performance Issues

### Common Problems and Solutions

| Problem                                    | Solution                                                            |
|--------------------------------------------|--------------------------------------------------------------------|
| Tests run slowly due to expensive setup    | Use test suite `SetUpTestSuite()` to share resource initialization  |
| Tests interfere with each other when run concurrently | Isolate test state and avoid shared mutable globals                |
| Flaky tests intermittently fail             | Use `--gtest_repeat` to detect and then isolate flaky tests         |
| Death tests cause hangs or slowdowns         | Run death tests in isolation or use faster death test style         |

### When Tests Are Not Being Sharded Properly
- Verify `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` settings.
- Ensure environment variables are set before running the test binary.
- Check for test IDs exceeding shard bounds.

### Performance Profiling
- Time tests to identify slow tests.
- Use GoogleTest's XML report `time` attributes to locate bottlenecks.
- Consider further code optimization or refactoring for slow tests.

---

## 6. Summary

Optimizing the performance and scalability of your GoogleTest suites enables rapid development cycles and reliable, comprehensive testing coverage even at scale. Use shared fixtures, selective filtering, sharding, test shuffling, and repeat runs to speed up testing and identify flaky or interdependent tests.

With careful test design and effective use of GoogleTest capabilities, you can maintain a robust test suite that scales gracefully with your project.

---

## 7. Next Steps & Further Reading

- [Writing Your First Test](../guides/getting-started-testing/writing-your-first-test.md) to start building tests.
- [Mocking Basics](../guides/getting-started-testing/mocking-basics.md) to speed up slow tests with mocks.
- [Sharding Tests for Parallel Execution](../faq/getting-started-faq/requirements-compatibility.md#distributing-test-functions-to-multiple-machines) to run tests on multiple hosts.
- [Test Failure and Debugging](../getting-started/troubleshooting-help/common-errors.md) for diagnosis and resolution tips.
- Explore source code examples in `googletest/test/gtest_stress_test.cc` and `googlemock/test/gmock_stress_test.cc` for concurrent test usage.


---

## References

- [GoogleTest Primer](../docs/primer.md) - foundational knowledge.
- [Advanced GoogleTest Topics](../docs/advanced.md) - for deep dives on patterns.
- [Testing Reference](../docs/reference/testing.md) - API usage details.
- [Supported Platforms & Environments](../overview/quick-start-integration/supported-platforms-environments.md) - ensure compatibility and environment-specific nuances.

---

## Example: Using `SetUpTestSuite()` to Speed Up Expensive Setup

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  static DatabaseConnection* db_connection_;

  static void SetUpTestSuite() {
    // Expensive connection setup runs once per test suite.
    db_connection_ = new DatabaseConnection("server_address");
  }

  static void TearDownTestSuite() {
    delete db_connection_;
    db_connection_ = nullptr;
  }

  void SetUp() override {
    // Prepare per-test state.
    db_connection_->BeginTransaction();
  }

  void TearDown() override {
    db_connection_->RollbackTransaction();
  }
};

DatabaseConnection* DatabaseTest::db_connection_ = nullptr;

TEST_F(DatabaseTest, TestInsert) {
  EXPECT_TRUE(db_connection_->Insert("some_data"));
}

TEST_F(DatabaseTest, TestUpdate) {
  EXPECT_TRUE(db_connection_->Update("some_data"));
}
```

This avoids recreating the database connection for each test, significantly improving speed.

---

## Example: Running Tests with Sharding

```bash
export GTEST_TOTAL_SHARDS=4
for i in {0..3}; do
  (
    export GTEST_SHARD_INDEX=$i
    ./my_test_binary
  ) &
done
wait
```

Tests are split across 4 shards and executed in parallel.

---

## Additional Diagnostic Tips

- Use `--gtest_print_time=1` to include per-test timing in output.
- Capture and analyze XML reports to identify slow tests or suites.
- Use `--gtest_fail_fast` during development to quickly detect failures.

<Tip>
If your test suite induces resource leaks when repeated, check that shared resources are correctly released in `TearDownTestSuite()`.
</Tip>
