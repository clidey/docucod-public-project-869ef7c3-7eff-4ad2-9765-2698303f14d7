---
title: "Cross-Platform Testing and Portability"
description: "Covers strategies for writing portable tests across different operating systems and hardware, including handling platform differences and portability utilities."
---

# Cross-Platform Testing and Portability

## Overview

This guide helps you write portable and reliable tests that run correctly across different operating systems and hardware platforms using GoogleTest and GoogleMock. It focuses on strategies to manage and handle platform-specific differences during testing while ensuring your mock-based tests remain maintainable and robust.

### Prerequisites

- A working GoogleTest/GoogleMock setup with your build system.
- Familiarity with basic test writing in GoogleTest and mock creation in GoogleMock.

### What You Will Achieve

- Understand how to write tests that are portable across platforms.
- Learn how GoogleMock supports platform portability.
- Gain practical techniques to handle platform-specific test variations.

### Time Estimate

Setting up and adapting your tests for portability may take a few hours depending on project complexity.

### Difficulty Level

Intermediate - assumes familiarity with writing GoogleMock mocks and tests.

## 1. Understanding Cross-Platform Challenges

Different operating systems and hardware architectures may vary in:

- Endianness
- File system paths and separators
- Available system calls and environment variables
- Compiler and runtime behavior
- Threading and synchronization mechanisms

These differences can cause tests that pass on one platform to fail or behave unexpectedly on another.

## 2. Strategies for Writing Portable Tests

### 2.1 Use GoogleMock Portability Utilities

GoogleMock includes internal portability headers (e.g., `gmock-port.h`) that abstract platform-specific details such as filesystem functions, environment variable access, and synchronization primitives. Although these are primarily for GoogleMock internals, their presence ensures that mocks and tests work seamlessly without requiring platform-specific changes.

### 2.2 Guard Platform-Specific Code

When your production code or tests contain platform-specific behavior, surround it with preprocessor conditionals guarding against unsupported platforms. For example:

```cpp
#ifdef GTEST_OS_WINDOWS
  // Windows-specific code
#else
  // POSIX or other platform code
#endif
```

Use GoogleTest's known predefined macros like `GTEST_OS_WINDOWS`, `GTEST_OS_LINUX`, or `GTEST_OS_MAC` for robust checks.

### 2.3 Abstract Environment and File System Dependencies

Interface your code and tests to interact via abstract interfaces for environment queries and file operations. This allows mocking those interfaces with GoogleMock and substituting platform-specific implementations for production.

### 2.4 Use GoogleMock’s Default Behaviors and Expectations

Set default expectations and behaviors using `ON_CALL` to define consistent mock method behaviors regardless of platform. Use `EXPECT_CALL` to verify essential cross-platform contracts remain intact.

Example:

```cpp
using ::testing::Return;
ON_CALL(mock_object, GetPlatformSpecificValue())
    .WillByDefault(Return(default_value));
EXPECT_CALL(mock_object, PerformAction()).Times(1);
```

### 2.5 Avoid Hardcoding Path or Environment Details in Tests

Use abstractions or test fixtures to inject platform-appropriate values. For example, use `GTEST_PATH_SEP_` from internal GoogleTest headers to get the platform’s path separator.

## 3. Handling Platform Differences with Matchers and Actions

GoogleMock's rich matcher and action framework lets you tailor your test expectations flexibly across different platforms.

- Use matchers to accept platform-dependent variations using wildcards `_` or conditional matchers like `AnyOf`, `Not`, etc.
- Use actions to define different behaviors on different platforms.

Example:

```cpp
using ::testing::_;  // matcher that accepts any argument
EXPECT_CALL(mock_file, Open(_))
    .WillOnce(Return(true));
```

Or for platform-dependent returns:

```cpp
if (isWindows) {
  ON_CALL(mock, GetTempDir()).WillByDefault(Return("C:\\Temp"));
} else {
  ON_CALL(mock, GetTempDir()).WillByDefault(Return("/tmp"));
}
```

## 4. Best Practices for Portable Tests

- **Separate platform-specific tests**: Use test filters or conditional compilation to run or exclude tests that are platform-specific.
- **Use `InitGoogleMock` correctly:**

  Initialize GoogleMock with the `InitGoogleMock()` function accepting `argc` and `argv` to properly parse any platform-specific flags.

- **Leverage sequences and ordering to handle asynchronous or timing differences across platforms.**

## 5. Troubleshooting Portable Tests

| Issue                             | Cause                                | Solution                                     |
|----------------------------------|------------------------------------|----------------------------------------------|
| Tests fail only on certain OS     | Platform-specific behaviors or APIs| Isolate platform code, mock or stub platform-specific calls|
| Environment variables missing     | Embedded or restricted environment  | Use mocks to simulate or abstract environment variables|
| Test flakiness on multiple platforms | Timing differences or race conditions | Use sequences and synchronization in mocks to order calls |

## 6. Example: Portable Mock of a File Interface

Imagine you have a file system interface with methods like `Open()`, `Delete()`, and `GetFileSize()`. Your tests need to verify behavior on both Windows and POSIX.

```cpp
class FileInterface {
 public:
  virtual ~FileInterface() {}
  virtual bool Open(const std::string& path) = 0;
  virtual bool Delete(const std::string& path) = 0;
  virtual size_t GetFileSize(const std::string& path) const = 0;
};

class MockFile : public FileInterface {
 public:
  MOCK_METHOD(bool, Open, (const std::string& path), (override));
  MOCK_METHOD(bool, Delete, (const std::string& path), (override));
  MOCK_METHOD(size_t, GetFileSize, (const std::string& path), (const, override));
};
```

In your cross-platform test setup, you can define different default behaviors:

```cpp
MockFile mock_file;
#ifdef GTEST_OS_WINDOWS
ON_CALL(mock_file, GetFileSize).WillByDefault(Return(1024));
#else
ON_CALL(mock_file, GetFileSize).WillByDefault(Return(2048));
#endif
```

This lets your tests adapt expectations to platform-specific conditions while verifying interactions.

## 7. Summary

Cross-platform testing is achievable with GoogleTest and GoogleMock by properly using portability macros, abstracting platform-specific code, setting flexible expectations, and writing robust mocks. The key is anticipating platform differences and using GoogleMock features to handle them smoothly.

---

## Resources & References

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) — Beginner-friendly intro and examples.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — In-depth recipes.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — Detailed macro and class usage.
- [Supported Platforms & Compatibility](../overview/integration-platforms/platform-support) — Platform-specific info.
- `gmock-port.h` and `gtest-port.h` — Internal portability layers used by GoogleMock and GoogleTest.

---

## Next Steps

- Explore [Mocking Best Practices](/guides/real-world-workflows/mocking-best-practices) to write maintainable cross-platform mocks.
- Review [CI Integration and Best Practices](/guides/advanced-and-integration-guides/ci-integration-and-best-practices) to automate cross-platform testing.
- Consider [Custom Matchers and Actions](/guides/real-world-workflows/custom-matchers-and-actions) to handle more complex platform-dependent conditions.

---

<Info>
GoogleMock internally handles platform portability using macros and conditional compilation, primarily abstracting away differences so users can focus on writing portable tests without deep platform-specific details.
</Info>