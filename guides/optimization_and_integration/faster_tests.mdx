---
title: "Speeding Up Test Execution"
description: "Actionable tips and configuration options to improve build and test speed, including parallel execution, minimizing dependencies, and selective test running."
---

# Speeding Up Test Execution

## Overview

This guide delivers actionable tips and configuration options to accelerate your GoogleTest and GoogleMock build and test processes. By leveraging parallel execution, minimizing dependencies, and selectively running tests, you can ensure faster feedback loops and more efficient test cycles.

---

## 1. Understanding Build and Test Speed Challenges

Long build and test times can hinder development velocity and reduce productivity. The primary factors that influence speed include:

- **Test Execution Parallelism:** Running tests concurrently to utilize CPU and machine resources
- **Dependency Minimization:** Reducing unnecessary build dependencies that trigger extensive recompilation
- **Selective Test Running:** Running only the tests relevant to recent changes instead of the entire suite

Optimizing these areas addresses common bottlenecks in both small and large test suites.

---

## 2. Parallel Test Execution

### What It Is

Parallel test execution implies running multiple test cases or suites simultaneously across multiple CPU cores or machines to reduce total test runtime.

### How to Enable

- **Using GoogleTest Flags:** GoogleTest supports parallel test execution with the `--jobs` flag (e.g., `--gtest_jobs=4`) to specify the number of concurrent test processes.
- **Build Systems:** Integrate parallel test execution with build systems (e.g., Bazel or CMake's `ctest`) that support parallel jobs.

### Best Practices

- Ensure tests are independent and do not share mutable global state to prevent flakiness when run concurrently.
- Make sure tests do proper setup and teardown to avoid interference.
- Monitor resource usage to avoid resource exhaustion when running too many tests in parallel.

### Example

```shell
./my_test_binary --gtest_repeat=1 --gtest_jobs=8
```

This command runs the test binary with up to 8 parallel workers.

---

## 3. Minimizing Dependencies to Speed Up Builds

### Why It Matters

Minimizing dependencies means only rebuilding tests or components that have changed or affected by changes, reducing unnecessary recompilations.

### Techniques

- **Forward Declarations:** Where possible, use forward declarations to avoid including heavy headers.
- **Pimpl Idiom:** Isolate implementation details to reduce recompilation impact.
- **Modularize Tests:** Group tests in appropriate logical units that depend only on relevant code.
- **Incremental Builds:** Use build systems that support incremental compilation and dependence tracking (e.g., Bazel).

### Tips

- Avoid including headers in test code unless strictly needed.
- Use mocking and stubbing to reduce dependencies on complicated or heavy components.

---

## 4. Selective Test Running

### What It Achieves

Selective test running executes only a subset of tests relevant to your recent changes, speeding up the test cycle by avoiding running the entire test suite.

### How to Use

- **Test Filters:** Use the `--gtest_filter` flag to run only tests matching specific patterns.
- **Tagged Tests:** Organize tests with namespacing or prefixes that allow easy filtering.
- **Integration with Version Control:** Automate selective runs based on changed files.

### Examples

- Run all tests matching `MyClass*`:
  ```shell
  ./my_test_binary --gtest_filter=MyClass*  
  ```

- Run specific test cases:
  ```shell
  ./my_test_binary --gtest_filter=MyClassTest.TestFunction
  ```

### Recommendations

- Adopt consistent naming conventions for test suites and cases to simplify filtering.
- Use tags or labels if your build or CI system supports it.

---

## 5. Additional Configuration Tips

### Test Caching

- Use test result caching if supported by your CI or build system to avoid re-running unchanged tests.

### Lightweight Test Fixtures

- Keep test fixtures minimal to speed up setup and teardown.
- Avoid heavy resource initialization in every test if possible.

### Mock Heavy Components

- Use mock classes to replace heavy components that slow down tests.
- Refer to [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#speed) for efficient mocking practices.

---

## 6. Common Pitfalls to Avoid

- Running tests that are not independent in parallel, which can cause flaky results.
- Over-specifying expectations that cause tests to be brittle and slower.
- Blindly adding expectations to suppress warnings, rather than using `NiceMock` or proper `ON_CALL` behaviors.

---

## 7. Troubleshooting Slow Tests

- Profile test runtime to identify slow tests.
- Check for unintended dependencies causing extra rebuilds.
- Use GoogleMockâ€™s `--gmock_verbose=info` to identify unexpected mock calls that might slow tests.

---

## 8. Next Steps

- Explore [Integrating with Continuous Integration (CI)](https://google.github.io/googletest/guides/getting_started/integrating_with_ci) to leverage parallelization in CI pipelines.
- Review the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for more mocking tips that help optimize tests.
- Read [GoogleTest Primer](https://google.github.io/googletest/docs/primer.html) for foundational testing practices.
- Consult the [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) for detailed mocking APIs.

---

## References

- [GoogleTest Primer](https://google.github.io/googletest/docs/primer.html)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html)
- [Integration & Ecosystem](https://google.github.io/googletest/overview/architecture-concepts/integration-ecosystem.html)

---