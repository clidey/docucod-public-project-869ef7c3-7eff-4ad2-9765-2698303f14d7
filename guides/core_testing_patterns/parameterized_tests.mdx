---
title: "Creating Value- and Type-Parameterized Tests"
description: "Explore how to write reusable tests that run with different input values or data types. Learn when to use parameterized tests, how to implement them using GoogleTest's macros, and see examples that streamline repetitive test logic."
---

# Creating Value- and Type-Parameterized Tests

Explore how to write reusable tests that run with different input values or data types. Learn when to use parameterized tests, how to implement them using GoogleTest's macros, and see examples that streamline repetitive test logic.

---

## Overview

### What Are Parameterized Tests?
Parameterized tests let you run the same test logic with different input values or types without duplicating code. They are invaluable when you want to verify that your code behaves correctly across a variety of inputs or implementations.

GoogleTest supports two main styles:

- **Value-Parameterized Tests:** Run tests repeatedly with different data values.
- **Type-Parameterized Tests:** Run the same tests using different types.

This guide focuses on how to create and utilize these tests effectively.

---

## Prerequisites

- Familiarity with basic GoogleTest test writing (`TEST`, `TEST_F`).
- Basic understanding of C++ templates and fixtures.
- GoogleTest properly installed and included via `#include <gtest/gtest.h>`.

---

## Expected Outcome

By completing this guide, you will be able to:

- Define value-parameterized test fixtures and instantiate them with custom data sets.
- Define typed test suites and instantiate them with type lists.
- Use macros like `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, and `TYPED_TEST` properly.
- Customize test name generation for clearer test output.

---

## Time Estimate

Allow about 20-40 minutes to practice creating both value- and type-parameterized tests.

---

## Difficulty Level

Intermediate â€“ requires understanding of test fixtures, templates, and GoogleTest macros.

---

# Value-Parameterized Tests

Value-parameterized tests let you run the same test case logic against multiple data inputs.

### 1. Define a Parameterized Fixture

Derive your fixture from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // You can implement fixture setup and utility members here.
};
```

> Tip: If you have a complex class hierarchy, inherit separately from `::testing::Test` and `::testing::WithParamInterface<T>`.

### 2. Write Tests Using `TEST_P`

Define test functions with the `TEST_P` macro inside the fixture, then use `GetParam()` to access the parameter.

```cpp
TEST_P(FooTest, IsValidInput) {
  EXPECT_TRUE(ValidateInput(GetParam()));
}

TEST_P(FooTest, HasCorrectLength) {
  EXPECT_GT(strlen(GetParam()), 3);
}
```

### 3. Instantiate the Test Suite with Data

Use `INSTANTIATE_TEST_SUITE_P` to provide specific parameter values using GoogleTest parameter generators:

- `Values(v1, v2, ...)`
- `ValuesIn(container)` or iterators
- `Range(begin, end [, step])`
- `Bool()`
- `Combine(g1, g2, ..., gN)` for Cartesian products

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(MeenyMinyMoe,
                         FooTest,
                         testing::Values("meeny", "miny", "moe"));

const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(Pets, FooTest, testing::ValuesIn(pets));
```

Tests will be named automatically as `InstantiationName/FooTest.TestName/i`, where `i` is the parameter index.

### 4. Optional: Customize Parameter Test Names

You can provide a custom name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Input_" + std::to_string(info.param);
    });
```

Names must be unique, non-empty, and contain only alphanumeric characters and underscores.

---

## Value-Parameterized Abstract Tests

You can define parameterized tests in a library (definition in a header and implementation in a source file) and instantiate them elsewhere. This pattern helps create reusable interface compliance tests.

Steps:

1. Define the fixture and `TEST_P` tests in a header and source file.
2. Instantiate using `INSTANTIATE_TEST_SUITE_P` in test driver code.

---

# Type-Parameterized Tests

Type-parameterized tests let you execute tests repeatedly with different types.

### 1. Define a Fixture Template

Create a class template inheriting from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  using List = std::list<T>;
  static T shared_;
  T value_ = T();
};
```

### 2. Define the List of Types

Use `testing::Types` to list your types.

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

You can also specify a custom name generator class with a static templated `GetName(int)` to produce type suffixes.

### 3. Write Tests with `TYPED_TEST`

Tests defined using `TYPED_TEST` will run once per type.

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  EXPECT_GT(values.size(), 0);
}

TYPED_TEST(FooTest, HasPropertyA) {
  EXPECT_TRUE(SomePropertyCheck<TypeParam>());
}
```

Here `TypeParam` is the current type.

---

# Type-Parameterized Abstract Tests

Type-parameterized tests can be defined separately and instantiated multiple times, optionally in different translation units. 

### Usage Pattern:

1. Use `TYPED_TEST_SUITE_P(FooTest)` to declare the suite.
2. Define tests with `TYPED_TEST_P(FooTest, TestName)`.
3. Register tests with `REGISTER_TYPED_TEST_SUITE_P(FooTest, TestName1, TestName2, ...)`.
4. Instantiate with

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiations, FooTest, MyTypes);
```

You can instantiate the suite as many times as you like with different type lists.

---

# Parameter Generators

GoogleTest provides several generators to create parameter ranges:

- `Range(start, end [, step])`: Sequence from `start` (inclusive) to `end` (exclusive) with optional step.
- `Values(v1, v2, ..., vN)`: Specific values.
- `ValuesIn(container)` / `ValuesIn(begin, end)`: Values from containers or iterator ranges.
- `Bool()`: Boolean {false, true}.
- `Combine(g1, g2, ..., gN)`: Cartesian product of multiple generators.
- `ConvertGenerator<T>(gen)` and `ConvertGenerator(gen, func)`: Cast or transform generated parameters to different types.

---

# Practical Example

```cpp
#include <gtest/gtest.h>

// Define a value-parameterized test fixture
class NumberTest : public testing::TestWithParam<int> {};

TEST_P(NumberTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers,
                         NumberTest,
                         testing::Values(2, 4, 6, 8));

// Define a typed test fixture template
template <typename T>
class MyContainerTest : public testing::Test {
 public:
  T value_{};
};

using ContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(MyContainerTest, ContainerTypes);

TYPED_TEST(MyContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->value_.empty());
}
```

---

# Troubleshooting & Tips

- **Parameter Type Must Be Copyable:** Ensure your parameter type supports copying for value-parameterized tests.
- **Unique Instantiation Names:** When using multiple `INSTANTIATE_TEST_SUITE_P` macros on the same fixture, each prefix must be unique.
- **Custom Names Must Be Valid:** Test parameter names generated by custom name generators must be alphanumeric or underscores.
- **Deferred Evaluation:** Parameter generators are evaluated during `InitGoogleTest()`, not at the instantiation line.
- **Raw Pointer Parameters:** Manage memory carefully when using raw pointers as test parameters.
- **Using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`:** Suppress the error if `TEST_P` tests are defined but not instantiated intentionally.

---

# Best Practices

- Use value-parameterized tests to cover multiple inputs with minimal code duplication.
- Use typed tests when the same test logic applies to many template types.
- Prefer `ValuesIn()` over manually listing individual values when testing with containers.
- Combine parameters carefully using `Combine()` for multi-dimensional coverage.
- Provide meaningful parameter names to improve test output clarity.

---

# Next Steps & Related Content

- Review [Value-Parameterized Tests section](../advanced.md#value-parameterized-tests) for deeper understanding.
- Understand [Typed Tests](../advanced.md#typed-tests) for type-based testing.
- Explore [Specifying Names for Value-Parameterized Tests](../advanced.md#specifying-names-for-value-parameterized-tests) for custom naming.
- See example source files `samples/sample7_unittest.cc` and `samples/sample6_unittest.cc` for complete usage.
- Check out the Testing Reference details on [`TEST_P`](reference/testing.md#TEST_P) and [`INSTANTIATE_TEST_SUITE_P`](reference/testing.md#INSTANTIATE_TEST_SUITE_P).

---

For source code examples and further technical details, visit the [GoogleTest GitHub repository](https://github.com/google/googletest).

---