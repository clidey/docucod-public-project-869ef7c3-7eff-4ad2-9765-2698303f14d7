---
title: "Creating and Using Mocks in Your Tests"
description: "Step-by-step guidance for writing and using mock objects, setting expectations, and asserting interactions. Includes examples on nice, strict, and naggy mocks and how to apply them in collaboration tests."
---

# Creating and Using Mocks in Your Tests

This guide provides comprehensive, step-by-step instructions for writing and utilizing mock objects in your C++ tests using GoogleMock (gMock). You'll learn how to define mock classes, create mock objects with varying strictness levels, set expectations, and verify interactions efficiently. Practical examples clarify the differences among nice, strict, and naggy mocks, and demonstrate their applications, especially in collaboration testing.

---

## 1. Understanding Mock Objects: What You Want to Achieve

Mocks help you isolate tested code by simulating dependencies. Your goal when creating mocks is to:

- Replace real dependencies with controllable objects.
- Specify how those mock objects should be called (what methods, how many times, with which arguments).
- Define what mock methods should return or do when called.
- Verify your code interacts with these mocks correctly during tests.

This page focuses solely on how to create and use mocks effectively in your test code.

### Prerequisites

Before you start:

- Have the gMock framework installed and properly set up in your project.
- Understand the interfaces of the classes or components you want to mock.
- Familiarity with C++11 or newer (required by gMock).

### Expected Outcome

By following this guide, you'll be able to:

- Define mock classes for your interfaces or classes.
- Create mock objects with different strictness behaviors (nice, naggy, strict).
- Set default behaviors and explicit expectations on mock method calls.
- Write tests that assert both the interactions and outcomes reliably.

### Time Estimate

Setting up your first mock and writing simple tests can take about 15-30 minutes. Mastery, especially with complex matchers and actions, will come with practice.

### Difficulty Level

Intermediate: assumes basic knowledge of C++, unit testing, and some understanding of mocking concepts.

---

## 2. Step-by-Step Guide to Creating and Using Mocks

### Step 1: Define Your Mock Class

You start by defining a mock class that inherits from the interface or base class you want to mock. Use the macro `MOCK_METHOD` to generate mock methods.

**Example:** Mocking a simple interface `Foo`

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() = default;
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};
```

**Tips:**
- Put all mock method definitions under `public:` regardless of base class accessibility.
- Include `const` and `override` qualifiers as appropriate.
- If mocking an overloaded method, mock all versions or bring base overloads into scope.

### Step 2: Choose Your Mock Strictness

Mocks vary in how they treat unexpected (uninteresting) calls. Pick the strictness level depending on your testing needs:

- **NaggyMock (default):** Warns when uninteresting calls occur.
- **NiceMock:** Suppresses warnings on uninteresting calls.
- **StrictMock:** Treats uninteresting calls as failures.

**Usage Example:**

```cpp
using ::testing::NiceMock;
using ::testing::NaggyMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_foo;      // Ignored uninteresting calls
NaggyMock<MockFoo> naggy_foo;    // Warns on uninteresting calls
StrictMock<MockFoo> strict_foo;  // Fails on uninteresting calls
```

You can construct these mocks with the same constructors as your mock class.

### Step 3: Set Default Behaviors with `ON_CALL`

Provide default behaviors for your mock methods. This means specifying what the mock should do when a method is called without explicit expectations.

```cpp
ON_CALL(nice_foo, GetSize()).WillByDefault(Return(42));
```

Default actions let tests continue gracefully when calls are not explicitly expected.

### Step 4: Set Explicit Expectations with `EXPECT_CALL`

Specify which calls you expect your code will make, how many times, with what arguments, and what they should return or do.

```cpp
EXPECT_CALL(nice_foo, Describe("test"))
    .Times(2)
    .WillRepeatedly(Return("mocked description"));
```

If the code under test doesn't satisfy these expectations, the test will fail with clear diagnostics.

### Step 5: Use Your Mock in Tests

Create your mocks and inject them into the code under test. Exercise your production functions and assert results as usual.

```cpp
TEST(MyTestSuite, TestFoo) {
  NiceMock<MockFoo> mock_foo;

  ON_CALL(mock_foo, GetSize()).WillByDefault(Return(10));
  EXPECT_CALL(mock_foo, Describe("hello")).WillOnce(Return("world"));

  MyProductionFunction(&mock_foo);
  // Verify assertions on results or side-effects
}
```

### Step 6: Verify Interactions Automatically

You donâ€™t usually need to explicitly verify your mocks. When mock objects go out of scope, GoogleMock checks all expectations. You can also force verification early:

```cpp
using ::testing::Mock;

Mock::VerifyAndClearExpectations(&mock_foo);
```

**Warning:** Do not set new expectations after verification.

---

## 3. Applying Different Mock Types in Collaboration Tests

When your tests involve multiple collaborating objects, choosing mock strictness affects resilience and debugging clarity.

- Use `NiceMock` to reduce noise when uninteresting calls are common and not problematic.
- Use `NaggyMock` during test development to catch unexpected calls and debug.
- Use `StrictMock` when you want to enforce precise interaction contracts and catch stray calls early.

**Scenario:** Testing a system with a `Database` interface mocked as `MockDatabase`.

```cpp
TEST(SystemTest, UsesStrictMockToEnforceCalls) {
  StrictMock<MockDatabase> mock_db;
  EXPECT_CALL(mock_db, Connect());
  EXPECT_CALL(mock_db, ExecuteQuery(_));

  system_under_test.RunQuery("SELECT * FROM users");
}
```

**Best Practice:** Begin with nice mocks during exploratory phases, then tighten with strict mocks as your tests mature.

---

## 4. Common Pitfalls and Troubleshooting

### Pitfall: Uninteresting Call Warnings

You might see warnings like `Uninteresting mock function call...` when calling a mock method without an explicit `EXPECT_CALL`.

**Solution:**

- Use `NiceMock` to suppress warnings if those uninteresting calls are acceptable.
- Or add a catch-all expectation:

```cpp
EXPECT_CALL(mock_foo, SomeMethod(_)).Times(::testing::AnyNumber());
```

### Pitfall: Unexpected Call Failures

Unexpected calls are always test failures.

**Solution:**

- Add expectations with appropriate matchers to cover all allowed calls.
- Use `Times(0)` to prohibit certain calls explicitly.

### Pitfall: Using `NiceMock` or `StrictMock` With Mock Classes Missing Virtual Destructors

Mock types like `NiceMock` and `StrictMock` rely on virtual destructors to work correctly.

**Solution:**

- Ensure your mocked classes have virtual destructors.

### Pitfall: Nested `NiceMock` or `StrictMock`

Nesting strictness modifiers (e.g., `NiceMock<StrictMock<MockFoo>>`) is unsupported and may behave unpredictably.

### Tip: Matching Overloaded Methods

Disambiguate overloads using matchers like `Const()` for const overloads or explicit matcher types.

---

## 5. Summary of Key Concepts

| Concept                | Description                                             |
| ---------------------- | ------------------------------------------------------- |
| Mock Class Definition  | Subclass interface using `MOCK_METHOD` macros          |
| Mock Types             | `NiceMock`, `NaggyMock`, `StrictMock` modify warnings / failures on uninteresting calls |
| Default Behaviors      | Set with `ON_CALL` to specify behavior for uninteresting calls |
| Expectations          | Declare with `EXPECT_CALL` to verify interactions       |
| Verification          | Automatic on mock destruction or explicit via `Mock::VerifyAndClearExpectations()` |

---

## 6. Additional Resources

- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) - Quick reference
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) - Detailed usage recipes
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) - Beginner friendly guide
- [Mocking Reference](../api-reference/mocking-and-matchers/mock-methods) - Complete API reference

---

## 7. Quick Code Example Putting It All Together

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

class Foo {
 public:
  virtual ~Foo() = default;
  virtual void DoThis() = 0;
  virtual int GetValue() const = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, DoThis, (), (override));
  MOCK_METHOD(int, GetValue, (), (const, override));
};

TEST(SampleTest, UsingNiceMock) {
  using ::testing::NiceMock;
  using ::testing::Return;

  NiceMock<MockFoo> mock_foo;

  ON_CALL(mock_foo, GetValue()).WillByDefault(Return(42));
  EXPECT_CALL(mock_foo, DoThis());

  mock_foo.DoThis();               // Verified call
  EXPECT_EQ(mock_foo.GetValue(), 42);  // Default action
}
```

This example sets up a `NiceMock` of `MockFoo`, specifies default behavior, expects a call, and runs assertions.

---

<Check>
Remember: Always define mocks for virtual interfaces with virtual destructors.
Use the appropriate mock strictness to balance test robustness and noise.
Set explicit expectations only for interactions you want to verify, and use `ON_CALL` for default behaviors.
</Check>
