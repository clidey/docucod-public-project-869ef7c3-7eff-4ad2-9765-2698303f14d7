---
title: "Death Tests, Fatal, and Non-Fatal Failures"
description: "Learn how to verify code that causes program termination and understand the differences between fatal and non-fatal failures in test design. Includes best practices and examples."
---

# Death Tests, Fatal, and Non-Fatal Failures

## Overview

This guide helps you verify that your code behaves correctly when it causes program termination and clarifies the critical differences between fatal and non-fatal failures in test design. You will learn how to write death tests to check that your programs exit or abort as expected, how to handle fatal and non-fatal assertions, and best practices for using these features effectively.


---

## 1. Understanding Death Tests

### What Are Death Tests?

Death tests are specialized tests that verify behavior when your code terminates unexpectedly, typically due to precondition failures, assertions, or unrecoverable errors. Unlike normal tests, death tests confirm that code crashes or exits with the expected error behavior.

### Why Use Death Tests?

- Validate that critical invariants cause program termination as designed.
- Detect when assertions and fatal checks properly abort execution.
- Ensure safety checks in your code actually fail fast in faulty conditions.

### Behavior of Death Tests

- Runs the test code in a separate process to isolate termination effects.
- Confirms that the process exits or aborts with a nonzero status.
- Matches `stderr` output against a provided pattern or regular expression.

### GoogleTest Death Test Macros

| Macro                 | Description                                           |
|-----------------------|-------------------------------------------------------|
| `EXPECT_DEATH`        | Verifies code causes death with matching output       |
| `ASSERT_DEATH`        | As above but aborts current test function on failure  |
| `EXPECT_EXIT`         | Verifies code exits with expected exit code and output|
| `ASSERT_EXIT`         | As above but aborts current test function on failure  |
| `EXPECT_DEATH_IF_SUPPORTED` | Runs death test if supported, else silently passes    |
| `EXPECT_DEBUG_DEATH`  | Runs death test only in debug mode                     |


---

## 2. Writing a Basic Death Test

### Example: Verifying a Crash with Message

```cpp
// Function that triggers a fatal check
void Foo(int* ptr) {
  ASSERT_NE(ptr, nullptr) << "Pointer must not be null.";
  *ptr = 123;
}

TEST(FooDeathTest, NullPointerCrashes) {
  EXPECT_DEATH(Foo(nullptr), "Pointer must not be null.");
}
```

### How It Works

- The macro `EXPECT_DEATH` spawns a child process to run the code block.
- It expects that the process terminates abnormally (non-zero exit).
- It verifies the error output contains the specified string or regex.


---

## 3. Fatal vs Non-Fatal Failures

### Definitions

- **Fatal Failure**: Causes the current test function to abort immediately.
  - Generated by assertion macros prefixed with `ASSERT_` (e.g., `ASSERT_TRUE`).
  - Useful when continuing makes no sense or risks crashing later tests.

- **Non-Fatal Failure**: Logs a failure but allows the current test to continue.
  - Generated by assertion macros prefixed with `EXPECT_` (e.g., `EXPECT_EQ`).
  - Helps collect multiple errors in one run.

### Important Rules

- Fatal assertions can only be used in `void`-returning functions.
- Using fatal assertions in constructors or destructors causes compilation errors.
- To abort a test early in non-void functions, use non-fatal assertions and return manually.

### When to Use Which

| Scenario                      | Use Fatal (`ASSERT_*`) | Use Non-Fatal (`EXPECT_*`) |
|------------------------------|-----------------------|---------------------------|
| Critical condition must hold before proceeding | ✅                    | ❌                         |
| Checking multiple independent assertions in one test | ❌                    | ✅                         |
| Skipping tests dynamically    | Use `GTEST_SKIP()`     | -                         |


---

## 4. Practical Steps to Write Death Tests

<Steps>
<Step title="Set Up Your Environment">
- Ensure your test framework supports death tests (`GTEST_HAS_DEATH_TEST`).
- For Windows, verify required system APIs (e.g., `CreateProcess`) are available.
</Step>
<Step title="Write the Death Test">
- Use `EXPECT_DEATH(statement, matcher)` or `ASSERT_DEATH(statement, matcher)`.
- Wrap compound statements in braces `{ }` when multiple lines are required.
- Provide a regex or a substring matcher for error matching.
</Step>
<Step title="Run and Validate">
- Run your tests normally.
- Confirm that the death test passes only if the program dies with matching error.
</Step>
<Step title="Test Different Scenarios">
- Test normal exit paths with `EXPECT_EXIT` or `ASSERT_EXIT`.
- Test that exceptions do not escape death tests if exceptions are enabled.
</Step>
</Steps>


---

## 5. Using ASSERT and EXPECT Macros with Failure Handling

### Example: Ensuring Non-Fatal Failures Do Not Abort Test

```cpp
TEST(ExampleTest, NonFatalCheck) {
  EXPECT_TRUE(IsValid(input)) << "Input is not valid";
  // Test continues even if above fails
  DoMoreChecks();
}
```

### Using Fatal Assertions for Early Exit

```cpp
void HelperFunction() {
  ASSERT_NE(ptr, nullptr);
  // Code here assumes ptr is valid
}

TEST(ExampleTest, FatalCheckStopsTest) {
  HelperFunction();
  // If assertion above fails, rest of this test will not be executed
}
```

### Important Note

Fatal assertions only abort the current function, not the entire test suite. Use `HasFatalFailure()` or `ASSERT_NO_FATAL_FAILURE` to control flow accordingly.


---

## 6. Advanced: Skipping Tests at Runtime

GoogleTest provides `GTEST_SKIP()` macro to conditionally skip tests with a message.

```cpp
TEST(SkipExample, SkipIfNeeded) {
  if (!IsDatabaseAvailable()) {
    GTEST_SKIP() << "Database not available, skipping test.";
  }
  // Test code runs only if skipped above
}
```

- `GTEST_SKIP()` acts like a fatal assertion by aborting the current test.
- Skipped tests do not count as failures.


---

## 7. Troubleshooting Common Death Test Issues

### Common Problems & Solutions

| Problem                           | Cause                            | Solution                                      |
|----------------------------------|---------------------------------|-----------------------------------------------|
| Test fails because code never dies | The code under test is not crashing or exiting | Verify that the test is correctly written and the exit condition is triggered
| Mismatch of expected stderr output | Provided regex or substring is wrong or incomplete | Check the expected error message carefully; use relaxed regex or substring matching
| Multiple death assertions on same line | Compiler error due to macro limitations | Place each death assertion on a separate line
| Death tests fail in multithreaded context | Issues with forking in threads | Use `death_test_style` flag to select "threadsafe" mode

### Best Practices

- Use clear and stable error messages to match in your death tests.
- Avoid modifying global state in death tests since child process runs separately.
- Run death tests early as they are slower due to process spawning.
- Name your test fixtures with `*DeathTest` suffix for improved isolation and ordering.


---

## 8. Example: Death Test with Detailed Explanation

```cpp
#include <gtest/gtest.h>

void TriggerFatalError(int n) {
  if (n == 0) {
    // This triggers failure and aborts.
    FAIL() << "n must not be zero";
  }
}

TEST(FatalFailureTest, DiesOnZero) {
  EXPECT_DEATH(
      {
        TriggerFatalError(0);
      },
      "n must not be zero");
}

TEST(FatalFailureTest, DoesNotDieOnNonZero) {
  // This test will pass normally.
  TriggerFatalError(5);
  SUCCEED();  // Explicit positive result.
}
```

- The `EXPECT_DEATH` macro runs the code block in a subprocess.
- It expects that the fatal failure message "n must not be zero" is output.
- The second test confirms safe behavior with `n != 0`.


---

## 9. Summary of Key Macros

| Macro                   | Use Case                                         | Behavior on Failure                    |
|-------------------------|-------------------------------------------------|--------------------------------------|
| `EXPECT_DEATH(stmt, regex)`    | Verify code dies and stderr matches regex       | Test failure if code doesn't die or output doesn't match
| `ASSERT_DEATH(stmt, regex)`    | Same as above; aborts test on failure            | Test aborted immediately         |
| `EXPECT_EXIT(stmt, predicate, regex)` | Verify exit status and output                 | Test failure if exit or output unexpected
| `ASSERT_EXIT(stmt, pred, regex)`       | Same as above; aborts test on failure      | Test aborted immediately         |
| `EXPECT_TRUE(cond)`              | Assert condition is true                         | Logs failure but continues       |
| `ASSERT_TRUE(cond)`              | Assert condition is true                         | Aborts current function          |
| `FAIL()`                       | Generate fatal failure                            | Aborts function immediately       |
| `ADD_FAILURE()`                 | Generate nonfatal failure                         | Logs failure, continues           |
| `GTEST_SKIP()`                 | Skip test at runtime                              | Aborts current test without failure   |


---

## 10. Additional Resources

- [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md)
- [Assertions Reference](https://github.com/google/googletest/blob/main/docs/reference/assertions.md)
- [Advanced GoogleTest Topics](https://github.com/google/googletest/blob/main/docs/advanced.md#death-tests)
- [gMock Cookbook Section on FAILURES](https://google.github.io/googletest/gmock_cook_book.html#knowing-when-to-expect-useoncall)


---