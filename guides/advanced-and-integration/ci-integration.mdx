---
title: "Continuous Integration and Test Automation"
description: "Best practices for integrating GoogleTest and GoogleMock into CI systems, including practical advice on reporting, failure detection, and parallelization."
---

# Continuous Integration and Test Automation with GoogleTest and GoogleMock

Integrating GoogleTest and GoogleMock into your Continuous Integration (CI) system is essential for maintaining software quality and ensuring rapid feedback during development. This guide focuses exclusively on best practices for embedding your GoogleTest/GoogleMock tests into CI workflows, covering setup strategies, reporting, handling failures, and parallelizing test runs effectively.

---

## 1. Overview of CI Integration with GoogleTest and GoogleMock

### What This Guide Helps You Accomplish

You will learn how to integrate your GoogleTest and GoogleMock-based test suites into a CI system, so your builds and tests run automatically on every code change. The guide covers practical techniques to ensure actionable test reporting, detect failures early, and speed up test execution through parallelization.

### Prerequisites

- A functioning GoogleTest or GoogleMock test suite successfully built and runnable locally.
- A CI environment or system (e.g., Jenkins, Travis CI, GitHub Actions, GitLab CI).
- Familiarity with your build system (CMake or Bazel) and command-line tooling.

### What You Will Achieve

- Reliable automated execution of tests within CI pipelines.
- Clear, comprehensive test reporting with failure detection.
- Efficient use of test parallelization to optimize CI run times.

### Time Estimate

- Setup and basic integration: 1–2 hours.
- Optimization and advanced test reporting: 2–4 hours depending on your CI complexity.

### Difficulty Level

Intermediate – basic familiarity with test execution and CI pipelines is assumed.

---

## 2. Embedding GoogleTest and GoogleMock Executions in CI

### Step 1: Build Your Tests in the CI Environment

Whether you use CMake or Bazel, your CI pipeline should compile and link your test binaries as part of the build step.

#### CMake Example

```bash
mkdir build && cd build
cmake .. -DCMAKE_CXX_STANDARD=17 -Dgtest_build_tests=ON -Dgmock_build_tests=ON
make -j$(nproc)
```

Ensure the build step completes successfully before proceeding.

#### Bazel Example

```bash
bazel build //...
```

### Step 2: Run Tests with CI-Friendly Reporting

GoogleTest produces human-readable output by default, but for CI systems it's critical to generate machine-readable reports.

#### Use XML Output

GoogleTest supports the `--gtest_output` flag to generate XML reports compatible with CI systems and test reporting plugins.

```bash
./my_test_binary --gtest_output=xml:report.xml
```

Configure your CI tool to collect and parse this `report.xml` file for detailed insights.

### Step 3: Detect and Act on Test Failures

Your test execution command should return non-zero exit codes on failures to trigger CI failures.

- Always run tests with `--gtest_break_on_failure=0` (default) unless debugging a specific test.
- Ensure your CI pipeline marks builds failed if tests fail or crash.

### Step 4: Parallelize Test Execution to Reduce CI Time

For large test suites, run tests in parallel to avoid bottlenecks.

#### Approaches:

- **CTest Parallelization:** If you use CTest, run tests via:

  ```bash
  ctest -j N --output-on-failure
  ```

  where `N` is the number of parallel jobs (cores).

- **GoogleTest Sharding:** When running a single test binary, use sharding flags:

  ```bash
  ./my_test_binary --gtest_total_shards=4 --gtest_shard_index=0
  ./my_test_binary --gtest_total_shards=4 --gtest_shard_index=1
  # ... execute shards 2 and 3 similarly
  ```

- **Multiple Test Binaries:** Split tests into multiple binaries and run concurrently in your CI tool.

### Step 5: Integrate with CI Build Scripts

Use your CI system’s scripting environment to orchestrate the build, test execution, report collection, and failure handling.

Example (bash snippet for CI):

```bash
set -e
mkdir build && cd build
cmake .. -Dgtest_build_tests=ON -Dgmock_build_tests=ON
make -j$(nproc)
ctest -j$(nproc) --output-on-failure
```

For Bazel:

```bash
bazel test --test_output=errors //...
```

---

## 3. Best Practices for Reporting and Failure Detection

### Use XML and JSON Outputs for Rich Reporting

- GoogleTest supports XML output for standard CI integration.
- Prefer adding `--gtest_output=xml:<path>` to provide CI tools with detailed test reports.
- Some CI tools also support JSON parsing; leverage GoogleTest extensions or scripts if needed.

### Fail Fast or Fail Slowly?

- For quicker feedback, configure CI to abort on first test failure if that suits your team’s workflow.
- Otherwise, use full test runs to gather comprehensive failure information, which GoogleTest provides by default.

### Capture Standard Output and Logs

- Redirect test stdout and stderr to logs linked in CI reports.
- Use `--gtest_print_time=1` to have test duration output, helping identify slow tests.

### Monitor Test Flakiness

- Identify flaky tests by repeating test runs or using `--gtest_repeat=N`.
- Mark flaky tests clearly in reports and triage immediately to avoid slowed CI pipelines.

---

## 4. Advanced Techniques for Test Parallelization and Scalability

### Parallel Test Execution Patterns

- **Sharding:** Segment tests logically with `--gtest_total_shards` and `--gtest_shard_index` to distribute workload.
- **Multiple Instances:** Run multiple test binaries simultaneously using your CI system parallel job capabilities.
- **Isolate Global State:** Ensure tests do not share state that breaks with concurrency.

### Example: Running Shards in a CI Matrix

In GitHub Actions or Jenkins, create multiple parallel jobs each running one shard index.

```yaml
jobs:
  test:
    strategy:
      matrix:
        shard: [0,1,2,3]
    runs-on: ubuntu-latest
    steps:
      - run: ./my_test_binary --gtest_total_shards=4 --gtest_shard_index=${{ matrix.shard }}
```

### Optimizing Test Execution Time

- Identify slow tests using `--gtest_print_time=1`.
- Consider separating slower integration or system tests into their own jobs to avoid blocking fast unit tests.
- Use caching in CI for build artifacts to avoid unnecessary recompilation.

### Handling Resource Contention

- Adjust the number of parallel test executions according to available CPU and memory.
- Use `--gtest_repeat` carefully to avoid excessive load.

---

## 5. Troubleshooting Common CI Integration Issues

### Common Pitfalls and Solutions

| Issue                                | Cause                                   | Solution                                         |
|------------------------------------|-----------------------------------------|-------------------------------------------------|
| Tests do not run in CI              | Build step missing or misconfigured     | Verify test targets build and are executable     |
| Test failures not detected         | Test binary exit code ignored           | Check your CI script to fail on non-zero exits   |
| XML reports not generated or found | Missing `--gtest_output` flag or wrong path | Specify explicit output path and collect it     |
| Parallelization flakes tests       | Shared global state or resources        | Ensure test isolation and adjust parallel jobs   |
| Long CI times                      | Serial test execution or large test suites | Use sharding, parallel jobs, and selective runs  |

### Debugging Tips

- Execute CI commands locally in an environment that mimics your CI system.
- Use `--gtest_filter` to isolate problematic tests.
- Use `--gtest_repeat=N` to detect intermittent failures.
- Collect logs and artifacts (e.g., XML reports) for failure analysis.

---

## 6. Summary and Next Steps

### What's Next?

- Explore [Running and Validating Tests](/getting-started/quickstart-validation/run-validate-tests) for detailed test run interpretation.
- Check [Troubleshooting Common Setup Issues](/getting-started/quickstart-validation/troubleshooting-common-issues) to resolve common errors.
- For advanced optimization, refer to [Performance Optimization for Large Test Suites](/guides/advanced-and-integration/performance-tips).
- Integrate with your preferred CI tool’s specific documentation for best integration results.

### Additional Resources

- [GoogleTest CMake and Bazel Installation Guide](https://github.com/google/googletest/tree/main/docs/getting-started/setup-installation/installation-cmake-bazel.mdx)
- [GoogleTest Primer and Basic Testing Guides](https://github.com/google/googletest/tree/main/docs/guides/getting-started/basic-test-workflow.mdx)
- [GoogleMock Integration and Usage](https://github.com/google/googletest/tree/main/docs/guides/mocking-techniques/creating-mocks.mdx)
- [GoogleTest CI Integration Overview](https://github.com/google/googletest/tree/main/docs/overview/architecture-concepts/integration-overview.mdx)

---

**Embrace CI integration with GoogleTest and GoogleMock to accelerate your development lifecycle with confidence and speed.**

---