---
title: "Parameterized and Type-Parameterized Tests"
description: "Discover how to run the same logic with multiple values or types, making your tests DRY and more comprehensive. Step-by-step instructions demonstrate setup, data injection, and assertion patterns."
---

# Parameterized and Type-Parameterized Tests

Discover how to run the same logic with multiple values or types, making your tests DRY and more comprehensive. Step-by-step instructions demonstrate setup, data injection, and assertion patterns.

---

## Workflow Overview

### What You Will Achieve

This guide will teach you how to write parameterized tests and type-parameterized tests using GoogleTest. You will be able to:  
- Create tests that run the same logic with different data values (value-parameterized tests).
- Create tests that run the same logic for multiple types (typed and type-parameterized tests).
- Make your test code more maintainable, reusable, and thorough.

### Prerequisites

- Basic familiarity with writing GoogleTest tests, including `TEST`, `TEST_F`, and test fixtures.
- A working GoogleTest environment with `#include <gtest/gtest.h>` available.
- Understanding of C++ template basics is helpful for typed tests.

### Expected Outcome

After following the instructions, you will be able to:
- Define and instantiate tests over varying input values.
- Define and instantiate tests over type lists.
- Use test fixtures, parameter injection, and custom naming effectively.

### Time Estimate

About 15-30 minutes to understand the concepts and write your first parameterized and typed tests.

### Difficulty Level

Intermediate: requires knowledge of templating in C++ and GoogleTest basics.

---

## Step-by-Step Instructions

### Part 1: Value-Parameterized Tests

Value-parameterized tests allow you to execute the same test logic with different input values.

#### 1. Define a Fixture Class

- Derive your fixture from `testing::TestWithParam<T>`, where `T` is the parameter type.

##### Example:
```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Your setup code here (optional).
};
```

#### 2. Define Parameterized Tests Using `TEST_P`

- Use `TEST_P` instead of `TEST` or `TEST_F` to define your parameterized test methods.
- Inside the test body, use `GetParam()` to access the current test's parameter.

##### Example:
```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(Process(GetParam()));
}

TEST_P(FooTest, HasPropertyA) {
  EXPECT_NE(strlen(GetParam()), 0);
}
```

#### 3. Instantiate Tests with `INSTANTIATE_TEST_SUITE_P`

- Use `INSTANTIATE_TEST_SUITE_P` to specify the parameters your test will run with.
- Provide a unique instantiation name, your test suite name, and a parameter generator.

##### Parameter Generators include:
- `Values(v1, v2, ..., vN)`: explicitly listed values
- `ValuesIn(container or array)`: values from a container
- `Range(begin, end [, step])`: generates a range of values
- `Bool()`: sequence of `false` and `true`
- `Combine(g1, g2, ...)`: Cartesian product of generators

##### Example:
```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values("meeny", "miny", "moe")
);

const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(PetTests, FooTest, testing::ValuesIn(pets));
```

#### 4. (Optional) Customize Test Parameter Names

- You can provide a function or functor to generate human-readable test names for parameters.
- The function receives a `testing::TestParamInfo<ParamType>` object and returns a `std::string`.

##### Example:
```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values("foo", "bar"),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      std::string name = info.param;
      for (auto& c : name) { if (!std::isalnum(c)) c = '_'; }
      return name;
    });
```

### Part 2: Typed Tests

Typed tests allow you to run the same test logic over multiple types.

#### 1. Define a Test Fixture Template

- Create a template test fixture class derived from `testing::Test`.

##### Example:
```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  using List = std::list<T>;
  static T shared_;
  T value_;
};

// Static member definition:
template <typename T> T FooTest<T>::shared_ = T{};
```

#### 2. Associate a List of Types with the Test Fixture

- Define a type list using `::testing::Types<T...>`.
- Use `TYPED_TEST_SUITE` to associate it with your fixture.

##### Example:
```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

#### 3. Write Typed Tests Using `TYPED_TEST`

- Use the `TYPED_TEST` macro to define tests.
- Use `TypeParam` to refer to the current type.
- Use `TestFixture::` to access static members.
- Use `this->` to access instance members or typedefs.

##### Example:
```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  EXPECT_FALSE(values.empty());
}

TYPED_TEST(FooTest, HasPropertyA) {
  EXPECT_GE(sizeof(TypeParam), 1);
}
```

#### 4. (Optional) Provide Custom Type Names

- Define a class with `GetName(int)` template method that returns a string name for each type.
- Pass it as the third argument to `TYPED_TEST_SUITE`.

##### Example:
```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### Part 3: Type-Parameterized Tests

Type-parameterized tests define a test pattern without specifying types up front. They are useful for interface verification where implementations instantiate tests with their own types.

#### 1. Define a Fixture Template

Like typed tests, define a fixture template derived from `testing::Test`.

##### Example:
```cpp
template <typename T>
class FooTest : public testing::Test {
  // ...
};
```

#### 2. Declare a Type-Parameterized Suite

Use `TYPED_TEST_SUITE_P` to declare your type-parameterized test suite.

##### Example:
```cpp
TYPED_TEST_SUITE_P(FooTest);
```

#### 3. Define Type-Parameterized Tests Using `TYPED_TEST_P`

Define as many tests as needed. Use `TypeParam` and `TestFixture` similar to typed tests.

##### Example:
```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n{};
  this->DoSomething();
}

TYPED_TEST_P(FooTest, HasPropertyA) {
  EXPECT_TRUE(true);
}
```

#### 4. Register Your Tests

Use `REGISTER_TYPED_TEST_SUITE_P` listing all test names defined.

##### Example:
```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

#### 5. Instantiate With Types

Use `INSTANTIATE_TYPED_TEST_SUITE_P` to instantiate with the type list and optionally a prefix.

##### Example:
```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyFixture, FooTest, MyTypes);
```

---

## Examples & Code Samples

### Value-Parameterized Test Example
```cpp
class PetTest : public ::testing::TestWithParam<std::string> {};

TEST_P(PetTest, IsNonEmpty) {
  EXPECT_FALSE(GetParam().empty());
}

INSTANTIATE_TEST_SUITE_P(PetVariations, PetTest,
                         testing::Values("cat", "dog", "parrot"));
```
This will generate three tests: `PetVariations/PetTest.IsNonEmpty/0` ("cat"), `/1` ("dog"), and `/2` ("parrot").

### Typed Test Example
```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T value_ = T();
};

using NumericTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, IsInitializedToZero) {
  TypeParam zero{};
  EXPECT_EQ(this->value_, zero);
}
```
The test logic runs once per type in `NumericTypes`.

### Type-Parameterized Test Example
```cpp
template <typename T>
class InterfaceComplianceTest : public ::testing::Test {
  void SomeCommonCheck();
};

TYPED_TEST_SUITE_P(InterfaceComplianceTest);

TYPED_TEST_P(InterfaceComplianceTest, HasProperValue) {
  TypeParam instance{};
  EXPECT_TRUE(instance.IsValid());
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceComplianceTest, HasProperValue);

using Implementations = ::testing::Types<FooImpl, BarImpl>;
INSTANTIATE_TYPED_TEST_SUITE_P(Implementations, InterfaceComplianceTest, Implementations);
```
This lets multiple implementations verify common interface properties with one test definition.

---

## Troubleshooting & Tips

### Common Issues

- **No tests run when using `TEST_P` without instantiation.** Use `INSTANTIATE_TEST_SUITE_P` to instantiate value-parameterized tests; otherwise, no test instances will be created.
- **Test names with underscores cause compilation errors or ambiguous class names.** Avoid underscores (`_`) in test suite and test names as per [FAQ](faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore).
- **Typedef is required for `TYPED_TEST_SUITE` and `INSTANTIATE_TYPED_TEST_SUITE_P` macro argument parsing.** Always use `using MyTypes = ::testing::Types<...>;` or equivalent.
- **Tests run but parameters aren't visible in test output.** Provide a parameter name generator function or use `PrintToStringParamName` when instantiating.
- **Using non-copyable parameter types results in compilation errors.** Parameter types must be copyable.

### Best Practices

- Use value-parameterized tests when testing behavior over multiple data values.
- Use typed tests when you want to verify the same test logic over a set of types.
- Use type-parameterized tests to define abstract test patterns reusable by different type lists.
- Provide readable test parameter names to enhance test output clarity.
- Remember test fixtures are recreated for each test; avoid persistent state unless static and thread-safe.
- Avoid underscores in test and test suite names to prevent linker or name mangling issues.

### Performance Considerations

- Typed tests generate tests for every type in the list, so large type lists increase compile time.
- Value-parameterized tests generate tests for each parameter value, increasing test count accordingly.
- Use parameter generators wisely to limit the number of instantiated tests without compromising test coverage.

---

## Next Steps & Related Content

- Explore [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for more detailed patterns and use cases.
- Learn how to combine parameterized tests with custom matchers in [Custom Matchers and Assertions](guides/advanced-testing/custom-matchers-and-assertions).
- Understand how typed tests fit within the GoogleTest architecture in [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests).
- Check [Test Fixtures](guides/getting-started/structuring-test-suites) for using shared data setups.
- Read the [FAQ](faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests) for guidance on choosing between typed and value-parameterized tests.

---

<AccordionGroup title="Example: Value-Parameterized and Typed Tests at a Glance">
<Accordion title="Value-Parameterized Test Example">
```cpp
class StringLengthTest : public testing::TestWithParam<const char*> {};

TEST_P(StringLengthTest, LengthNonZero) {
  EXPECT_GT(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(
    StringTests, StringLengthTest,
    testing::Values("hello", "world", "test"));
```
</Accordion>
<Accordion title="Typed Test Example">
```cpp
template <typename T>
class IsDefaultConstructibleTest : public testing::Test {};

using TypesList = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(IsDefaultConstructibleTest, TypesList);

TYPED_TEST(IsDefaultConstructibleTest, DefaultConstructorWorks) {
  TypeParam instance{};
  (void)instance;  // Suppress unused warning
  SUCCEED();
}
```
</Accordion>
</AccordionGroup>

<Tip>
When defining type lists for typed tests, prefer `using MyTypes = testing::Types<...>` over `typedef` for clarity and modern style.
</Tip>

<Note>
For complex parameter combinations, use `testing::Combine()` to generate Cartesian products and `ConvertGenerator()` to customize parameter types.
</Note>

<Warning>
Do not forget to instantiate parameterized tests using `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`. Tests defined with `TEST_P` or `TYPED_TEST` macros without instantiation will not run and will cause failures.
</Warning>
