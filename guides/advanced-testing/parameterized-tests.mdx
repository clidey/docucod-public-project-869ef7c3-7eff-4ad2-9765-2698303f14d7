---
title: "Parameterized and Typed Test Techniques"
description: "Master data-driven testing by running a single test across multiple data sets, value types, or custom conditions. This page covers value-parameterized tests, type-parameterized patterns, and common pitfalls."
---

# Parameterized and Typed Test Techniques

Master data-driven testing by running a single test across multiple data sets, value types, or custom conditions. This guide covers value-parameterized tests, type-parameterized tests, and common pitfalls to help you efficiently verify your code across diverse inputs.

---

## 1. Understanding Parameterized and Typed Tests

GoogleTest empowers you to avoid duplicating code by running the same test logic across various parameters or types. This enhances test coverage and flexibility while maintaining code maintainability.

- **Value-Parameterized Tests**: Run the same test multiple times with different *values* (data-driven testing).
- **Typed Tests**: Run the same test logic multiple times with different *types*.
- **Type-Parameterized Tests**: More flexible typed tests where test patterns are defined separately and instantiated later with any type list.

---

## 2. Prerequisites

Before you begin, ensure:

- Your project includes GoogleTest (`#include <gtest/gtest.h>`) and is properly built against it.
- You have basic familiarity with writing regular GoogleTest tests using `TEST()` and `TEST_F()`.
- You understand test fixtures and assertions.

For newcomers, review the [GoogleTest Primer](primer.md) before proceeding.

---

## 3. Value-Parameterized Tests: Drive tests by multiple values

### Why Use Value-Parameterized Tests?

If you want to test the same logic with different input values (e.g., different strings or numbers), value-parameterized tests let you define one test and run it across all those inputs.

### How to Write Value-Parameterized Tests

1. **Define a Test Fixture Class**

Derive from `testing::TestWithParam<T>` where `T` is the parameter type.

```cpp
class MyValueTest : public testing::TestWithParam<int> {
  // You can add shared setup or helper methods here
};
```

2. **Define Tests Using `TEST_P` Macro**

Access the test parameter with `GetParam()` within each test.

```cpp
TEST_P(MyValueTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

3. **Specify Parameter Values Using `INSTANTIATE_TEST_SUITE_P`**

Instantiate your test suite with concrete values or ranges.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues, MyValueTest,
    testing::Values(1, 42, 100));
```

Common parameter generators include:

| Generator           | Description                                   |
|---------------------|-----------------------------------------------|
| `Values(v1, v2, ...)` | Yields the exact values specified               |
| `ValuesIn(container)` | Uses values from a container or array          |
| `Range(begin, end[, step])` | Generates values in the numeric range (exclusive end) |
| `Bool()`             | Yields `false` and `true`                      |
| `Combine(g1, g2, ...)` | Creates Cartesian product of multiple generators |

### Example

```cpp
class StringLengthTest : public testing::TestWithParam<std::string> {};

TEST_P(StringLengthTest, IsNonEmpty) {
  EXPECT_FALSE(GetParam().empty());
}

INSTANTIATE_TEST_SUITE_P(
    NonEmptyStrings, StringLengthTest,
    testing::Values("hello", "world", "google"));
```

### Best Practices

- Keep the test fixture responsibilities focused on accessing parameters and shared setup.
- Use the parameter type that matches the tested functionality (e.g., primitives or structs).
- Avoid tight coupling of parameter instantiation and test definition to allow flexibility.

### Common Pitfalls

- Forgetting to instantiate the test suite causes no tests to run and a failure reported by GoogleTest.
- Using pointers as parameters without managing lifetimes carefully leads to dangling references.
- Parameter names with underscores `_` are not allowed in test names; prefer alphanumeric.

You can suppress errors about uninstantiated parameterized tests with:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyValueTest);
```

---

## 4. Typed Tests: Reuse tests for multiple types

### Purpose

Typed tests let you write a test once and run it against multiple types, ensuring your templates or generic code behave correctly for all of them.

### Writing Typed Tests

1. **Define a Fixture Class Template**

Derive from `testing::Test` and parameterize your test fixture on a type `T`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_{};
};
```

2. **Associate Types with the Suite**

Using `testing::Types` to list the types you want to test:

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write Tests Using `TYPED_TEST`**

Use the special identifier `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  EXPECT_EQ(val, this->value_);
}
```

### Example

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {};

using NumericTypes = testing::Types<int, float, double>;

TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsGreaterThanZero) {
  EXPECT_GT(std::numeric_limits<TypeParam>::max(), 0);
}
```

### Custom Type Names

You can provide a custom class to generate readable test suite names for each type:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices

- Keep the fixture simple to facilitate code reuse across types.
- Use `TypeParam` carefully to handle typed logic.
- Name types explicitly in `Types<>` to avoid confusing compiler errors.

### Common Pitfalls

- Using types that are not default constructible in typed tests without special handling.
- Failing to prefix `value_` or member accesses with `this->` inside class templates can cause compilation errors.

---

## 5. Type-Parameterized Tests: Define abstract test patterns for flexible reuse

Type-parameterized tests let you define test patterns without listing types initially. Later, instantiate them with any types desired, possibly multiple times and across translation units.

### Steps to Use Type-Parameterized Tests

1. **Define Test Fixture Template**

```cpp
template <typename T>
class MyTypeParTest : public testing::Test {
  // test logic here
};
```

2. **Declare Suite with `TYPED_TEST_SUITE_P`**

```cpp
TYPED_TEST_SUITE_P(MyTypeParTest);
```

3. **Define Type-Parameterized Tests with `TYPED_TEST_P`**

```cpp
TYPED_TEST_P(MyTypeParTest, DoesSomething) {
  TypeParam t{};
  EXPECT_TRUE(SomeFunction(t));
}
```

4. **Register Test Names with `REGISTER_TYPED_TEST_SUITE_P`**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParTest, DoesSomething);
```

5. **Instantiate with Types using `INSTANTIATE_TYPED_TEST_SUITE_P`**

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParTest, MyTypes);
```

### Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyInitially) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyInitially);

using TypesToTest = testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainers, ContainerTest, TypesToTest);
```

### Best Practices

- Use this technique for libraries or reusable components where you do not know all types upfront.
- Separate test definition and instantiation across headers and source files for better modularity.
- Provide custom names when necessary for clarity.

### Common Pitfalls

- Forgetting to register test names before instantiation leads to linker or runtime errors.
- Using incompatible types during instantiation may cause subtle compile-time errors.

---

## 6. Practical Tips & Common Pitfalls

- **Avoid underscores in test suite and test names** as GoogleTest does not allow underscores in test suite or test names due to internal naming constraints.
- **Always instantiate parameterized tests**: Every `TEST_P` must be matched by a corresponding `INSTANTIATE_TEST_SUITE_P` to prevent suspicious silent failure.
- **Be cautious with pointer parameters**: If your parameter type is a pointer, manage the lifetime of pointed objects to avoid dangling references.
- **Use `ConvertGenerator` when necessary**: If your parameter type requires explicit construction from the generated types (e.g., tuples), use `ConvertGenerator` with a conversion function to avoid type mismatch compilation errors.
- **Custom test names**: GoogleTest allows custom parameter name generators for better readability in test results.

---

## 7. Verifying and Debugging Parameterized and Typed Tests

- Use `GetParam()` (for value-parameterized) and `TypeParam` (for typed) within tests to verify test data correctness.
- Ensure your parameter or type combinations make logical sense to avoid test failures that are hard to diagnose.
- Use GoogleTestâ€™s output and filtering capabilities (`--gtest_filter`) to run and debug specific instantiated tests.
- If you see unexpected test skipping, check instantiation and parameter lists carefully.

---

## 8. Summary of Key Macros & Functions

| Macro/Function                        | Purpose                                   |
|-------------------------------------|-------------------------------------------|
| `TEST_P(TestFixture, TestName)`      | Defines a value-parameterized test        |
| `INSTANTIATE_TEST_SUITE_P(Name, TestFixture, Params)` | Instantiates value-parameterized tests with parameters |
| `TYPED_TEST_SUITE(Fixture, Types)`  | Defines typed tests with a known type list|
| `TYPED_TEST(Fixture, TestName)`      | Defines a typed test                       |
| `TYPED_TEST_SUITE_P(Fixture)`        | Declares a type-parameterized test suite  |
| `TYPED_TEST_P(Fixture, TestName)`    | Defines a type-parameterized test         |
| `REGISTER_TYPED_TEST_SUITE_P(Fixture, Tests...)` | Registers type-parameterized tests      |
| `INSTANTIATE_TYPED_TEST_SUITE_P(Name, Fixture, Types)` | Instantiates type-parameterized tests   |


---

## 9. Additional Resources

- [GoogleTest Primer](primer.md) â€” foundational concepts for writing tests.
- [Testing Reference - Testing macros and classes](reference/testing.md) â€” detailed API documentation including `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, typed test macros.
- [Advanced GoogleTest Topics](advanced.md#value-parameterized-tests) â€” deep dive into parameterized, typed, and type-parameterized tests.
- Samples: [Sample7 (value-parameterized tests)](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)
- Samples: [Sample6 (typed tests)](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)

---

## 10. Troubleshooting Common Issues

<AccordionGroup title="Common Issues with Parameterized and Typed Tests">
<Accordion title="Tests not being instantiated - no tests run">
Check that every `TEST_P` or `TYPED_TEST_P` is paired with a matching `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`. Untagged test suites produce no tests.
</Accordion>
<Accordion title="Compilation errors related to type conversions">
When using combined generators or custom parameter types, use `ConvertGenerator` with appropriate converters to cast generated parameters to your fixture's parameter type.
</Accordion>
<Accordion title="Test names containing illegal characters">
Avoid underscores `_` in test or suite names. Use alphanumeric and camelCase naming to ensure test names are valid.
</Accordion>
<Accordion title="Failing tests due to pointer parameters being invalid">
If passing pointers as parameters, ensure the lifetime of the pointed-to objects extends for the test duration.
</Accordion>
</AccordionGroup>

---

## 11. Diagram Illustrating Parameterized and Typed Test Flow

```mermaid
flowchart TD
  Start([Begin Test Definition]) --> DefineFixture[Define Test Fixture]
  DefineFixture --> ChooseTestType{Value- or Type-Parameterized?}

  ChooseTestType -->|Value-Parameterized| SetupValueFixture[Derive from TestWithParam<T>]
  ChooseTestType -->|Typed/Type-Parameterized| SetupTypeFixture[Define Template Fixture]

  SetupValueFixture --> DefineValueTests[Define TEST_P tests]
  SetupTypeFixture --> DefineTypedTests[Define TYPED_TEST or TYPED_TEST_P]

  DefineValueTests --> InstantiateValues[Use INSTANTIATE_TEST_SUITE_P]
  DefineTypedTests --> RegisterTypedTests[REGISTER_TYPED_TEST_SUITE_P (if applicable)]
  RegisterTypedTests --> InstantiateTypedTests[Use INSTANTIATE_TYPED_TEST_SUITE_P]

  InstantiateValues --> RunTests[Run tests with each parameter]
  InstantiateTypedTests --> RunTests

  RunTests --> End([Tests Executed Across Multiple Values / Types])

  classDef decision fill:#f9f,stroke:#333,stroke-width:2px;
  class ChooseTestType decision
```

---

# End of Guide

For further mastery, combine this knowledge with the [Mocking Reference](mocking.md) to achieve comprehensive, maintainable, and efficient tests with GoogleTest.
