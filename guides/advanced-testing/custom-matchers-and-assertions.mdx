---
title: "Custom Matchers and Assertions"
description: "Learn how to create expressive custom matchers and assertions tailored to your codebase. This tutorial empowers you to extend GoogleTest's and GoogleMock's built-in capabilities for precise and readable tests."
---

# Custom Matchers and Assertions

Welcome to the guide on creating expressive custom matchers and assertions with GoogleTest and GoogleMock. This tutorial empowers you to extend the built-in capabilities of GoogleTest and GoogleMock, enabling you to write precise, readable tests that fit your codebase's unique needs.

---

## 1. Overview

### What This Guide Helps You Accomplish
This guide teaches you how to create your own custom matchers and assertions beyond GoogleTest's default set. By doing so, you gain the power to write more intuitive test conditions, clearly communicate intent, and capture complex domain-specific logic as reusable building blocks.

### Prerequisites
Before beginning, you should have:
- A working knowledge of GoogleTest and GoogleMock basics.
- A project with GoogleTest and GoogleMock installed and configured.
- Familiarity with writing simple tests and using built-in matchers (`Eq()`, `Lt()`, `_`, etc).

### Expected Outcome
By the end of this guide, you will:
- Understand how to define custom matcher classes for specific conditions.
- Use the convenient `MATCHER` and `MATCHER_P` macros to write concise matchers.
- Implement expressive assertions tailored to your data types and logic.
- Know best practices to avoid common pitfalls and write maintainable matchers.

### Time Estimate
Allow 30-45 minutes to practice and adopt custom matchers effectively.

### Skill Level
Intermediate to advanced users who want to extend GoogleTest's capabilities.

---

## 2. Creating Custom Matchers

### Why Custom Matchers?
Built-in matchers cover many common scenarios, but often your tests require domain-specific checks. For example, verifying complex invariants or object states that do not map neatly to simple operators.

Custom matchers help you:
- Simplify test code by encapsulating details.
- Provide clearer, human-readable failure messages.
- Reuse complex matching logic across tests.

### The Basic Matcher Class

At its core, a matcher is a class or object with three responsibilities:

- **Matching:** Evaluate whether the input satisfies a condition.
- **Describing the expected condition:** To produce clear test failure messages.
- **Describing the negation:** What it means to *not* match.

### Example: A Simple Custom Matcher Class

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;  // Marks this as a matcher for GoogleTest

  explicit BarPlusBazEqMatcher(int expected_sum)
      : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /* listener */) const {
    return (foo.bar() + foo.baz()) == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  const int expected_sum_;
};

// Factory function for easy use
::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return BarPlusBazEqMatcher(expected_sum);
}

// Usage in your test
Foo foo;
EXPECT_THAT(foo, BarPlusBazEq(5));
```

This matcher checks whether `foo.bar() + foo.baz()` is equal to a given sum.

### Notes:
- `using is_gtest_matcher = void;` signals to GoogleTest that this is a matcher.
- `MatchAndExplain()` performs the actual logic.
- `DescribeTo()` and `DescribeNegationTo()` explain to the user what the matcher checks.

### Using the MATCHER and MATCHER_P macros

GoogleMock offers macros to reduce boilerplate for common matcher patterns.

#### MATCHER

Defines a parameterless matcher.

Example:

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

// Usage:
EXPECT_CALL(mock, Func(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

You can add detailed explanations for failures via streaming to `*result_listener`.

#### MATCHER_P

Defines a matcher with one parameter.

Example:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}

// Usage:
EXPECT_THAT(number, HasAbsoluteValue(10));
```

You can define multi-parameter matchers (`MATCHER_P2`, `MATCHER_P3`, etc.) similarly.

### Writing Descriptions

The last argument in `MATCHER`/`MATCHER_P` can be a description string, which can dynamically reflect matcher parameters and negation:

```cpp
MATCHER_P(IsDivisibleBy, divisor,
          absl::StrCat(negation ? "isn't" : "is", " divisible by ", divisor)) {
  return (arg % divisor) == 0;
}
```

This enhances failure messages, e.g., "expected: is divisible by 7".

---

## 3. Writing Custom Assertions

### Using `EXPECT_THAT` with Matchers

GoogleTest provides `EXPECT_THAT(value, matcher)` where `matcher` can be a custom matcher.
Use custom matchers created as above to write expressive assertions.

Example:

```cpp
EXPECT_THAT(my_number, IsDivisibleBy7());
```

Failures will show detailed messages.

### Combining Custom Matchers with Built-in Ones

You can compose matchers using logical operators like `AllOf()`, `AnyOf()`, `Not()`, or combine simple matchers to build complex checks.

---

## 4. Best Practices and Tips

- **Keep matchers pure:** They should not have side effects or modify external state.
- **Focus matcher logic on predicates:** The result must only depend on the current argument and parameters.
- **Describe clearly:** Help others understand test failures quickly.
- **Reuse matchers:** Avoid duplication of complex conditions.
- **Use parameters:** Use `MATCHER_P` family to make matchers flexible and descriptive.
- **Avoid over-specification:** Only check what is necessary for your test's purpose.

---

## 5. Common Pitfalls

- **Infinite recursion:** When writing custom matchers, avoid calling mock methods inside matcher logic.
- **Ambiguous matchers:** Particularly when matching overloaded functions, be explicit in types or use safe matcher casts.
- **Expectations on calls:** Remember to set expectations *before* exercising code to avoid undefined behavior.

---

## 6. Conclusion and Next Steps

By mastering custom matchers and assertions, you gain expressive power in your tests, improve readability, and reduce maintenance overhead.

Explore these further guides for advanced techniques:
- [Mocking with GoogleMock](/guides/advanced-testing/mocking-with-googlemock) 
- [Built-in Matchers Reference](/api-reference/matchers-assertions/core-matchers)
- [Custom and Advanced Matchers](/api-reference/matchers-assertions/custom-matchers)

Also, check out the GoogleMock Cookbook for practical recipes and examples.

---

For comprehensive understanding, visit the [Mocking Reference](reference/mocking.md) and [Assertions Reference](reference/assertions.md) pages.

---

## Appendix: Frequently Used Matcher Patterns

### Matching Arguments by Value or Property

Use matchers like:
- `Eq(value)` for equality
- `Lt(value)`, `Gt(value)` for comparisons
- `Field(&Class::member, matcher)` for matching object fields
- `Property(&Class::property, matcher)` for matching getter methods

### Matching Containers

Matchers such as `ElementsAre()`, `Contains()`, and `UnorderedElementsAre()` help check container contents precisely or fuzzily.

### Using Predicates and Lambdas

Use `Truly(predicate)` to convert arbitrary unary predicates into matchers.

Example:
```cpp
EXPECT_CALL(mock, Foo(Truly([](int n) { return n % 2 == 0; })));
```

---

Thank you for extending your testing capabilities with custom matchers and assertions in GoogleTest.

---
