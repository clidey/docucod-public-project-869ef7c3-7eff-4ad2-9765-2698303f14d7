---
title: "Parameterized and Typed Tests"
description: "Step-by-step guides on writing tests that execute over multiple data values or types, making it easier to cover a range of scenarios with less boilerplate. Includes tips for readability and debugging failed parameterized tests."
---

# Parameterized and Typed Tests

## Overview

Parameterized and typed tests in GoogleTest enable you to write test logic that runs with multiple data values or types. This approach reduces boilerplate by covering a broad range of scenarios efficiently while promoting test maintainability and clarity.

This guide walks you through creating, instantiating, and managing these tests, including practical tips for improving test readability and debugging failures.

---

## 1. Value-Parameterized Tests (Parameterizing Over Data Values)

### What are Value-Parameterized Tests?

Value-parameterized tests enable you to run the same test logic multiple times with different input values. This is ideal when you want to verify that your code behaves correctly under varied inputs without duplicating test code.

### Prerequisites

- A test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.
- GoogleTest properly installed and integrated into your project.

### Writing Value-Parameterized Tests

1. **Define a fixture class:**

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // You can define setup/teardown as needed.
};
```

2. **Write parameterized test patterns using `TEST_P`:**

```cpp
TEST_P(FooTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(DoSomething(param));
}
```

3. **Instantiate the tests with parameters:**

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest, testing::Values(1, 2, 3));
```

By default, the instantiated tests will be named as `InstantiationName/FooTest.DoesSomething/i` where `i` is the index of the parameter.

### Parameter Generators
GoogleTest provides several built-in parameter generators for convenient instantiations:

- `Range(begin, end[, step])` - values starting from `begin` to just before `end`, by `step`.
- `Values(v1, v2, ..., vN)` - explicit list of values.
- `ValuesIn(container)` - values from any STL container or C-style array.
- `Bool()` - generates `false` and `true`.
- `Combine(g1, g2, ..., gN)` - Cartesian product of multiple generators, yielding tuples.

### Customizing Test Names
The last argument to `INSTANTIATE_TEST_SUITE_P` can be a function or functor that generates names for test instances based on parameters for clearer output:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyGroup, FooTest, testing::Range(0, 10),
    [](const ::testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param" + std::to_string(info.param);
    });
```

### Notes and Best Practices

- Test fixtures used with `TEST_P` must declare `SetUpTestSuite()` and `TearDownTestSuite()` as **public** if defined.
- All tests defined with `TEST_P` must have corresponding `INSTANTIATE_TEST_SUITE_P` calls unless explicitly allowed by `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Avoid underscores in test suite and test names to prevent name clashes.

---

## 2. Typed Tests (Parameterizing Over Types)

### What are Typed Tests?

Typed tests let you run the same test logic across a predetermined list of types. This is useful for testing multiple implementations of an interface or verifying template class behaviors.

### Prerequisites

- Define a class template fixture deriving from `testing::Test`.
- A type list defined using `::testing::Types<...>`.

### Writing Typed Tests

1. **Define a typed fixture template:**

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_;
  // Additional type-specific setup
};
```

2. **Associate the fixture with a type list:**

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyFixture, MyTypes);
```

3. **Define typed test cases with `TYPED_TEST`:**

```cpp
TYPED_TEST(MyFixture, DoesSomething) {
  TypeParam n = this->value_;
  EXPECT_TRUE(SomeCheck(n));
}
```

4. **Run tests as usual:** GoogleTest will run each test for all specified types.

### Custom Type Names
You can define a class with a static template function `GetName(int)` to control the name that appears for each type:

```cpp
class MyTypeNames {
 public:
  template<typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    // ...
  }
};

TYPED_TEST_SUITE(MyFixture, MyTypes, MyTypeNames);
```

---

## 3. Type-Parameterized Tests (Abstract Test Patterns)

### What are Type-Parameterized Tests?

Type-parameterized tests let you define the test logic *once* without a concrete type list, then instantiate it multiple times with different type sets later. This pattern helps verify interfaces or concepts across implementations.

### Writing Type-Parameterized Tests

1. **Define a fixture template:**

```cpp
template<typename T>
class MyTest : public testing::Test { /*...*/ };
```

2. **Declare the type-parameterized test suite:**

```cpp
TYPED_TEST_SUITE_P(MyTest);
```

3. **Define type-parameterized tests:**

```cpp
TYPED_TEST_P(MyTest, DoesAction) {
  TypeParam x = TypeParam();
  EXPECT_TRUE(SomeCheck(x));
}
```

4. **Register test names:**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTest, DoesAction /*, other tests */);
```

5. **Instantiate with concrete types:**

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTest, MyTypes);
```


---

## 4. Tips for Readability and Debugging

- Use `GetParam()` inside `TEST_P` to obtain current parameter value.
- Use meaningful naming functions in `INSTANTIATE_TEST_SUITE_P` for easier result interpretation.
- Avoid underscores (`_`) in test and suite names to prevent internal name collisions.
- Apply `SCOPED_TRACE` to add contextual traces for failed parameterized tests to see which parameter caused failure.

Example for `SCOPED_TRACE` usage in a parameterized test:

```cpp
TEST_P(FooTest, CheckSomething) {
  SCOPED_TRACE("Parameter: " + std::to_string(GetParam()));
  EXPECT_TRUE(Validate(GetParam()));
}
```

---

## 5. Common Pitfalls and How to Address Them

- Forgetting to instantiate `TEST_P` tests results in no tests running; fix by adding `INSTANTIATE_TEST_SUITE_P` or suppress warnings with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Using `TEST` and `TEST_F` inconsistently or mismatching test fixture classes in a test suite causes runtime errors.
- Not respecting naming rules for test suite and test names may cause subtle compilation or runtime failures.

---

## 6. Summary

With parameterized and typed tests, you can apply the same test logic over many values or types efficiently. They reduce code duplication, improve coverage, and provide clearer test organizations.

Remember to clearly instantiate your parameterized tests and use naming functions to keep your test outputs readable and debuggable.

---

## 7. References & Additional Resources

- [Testing Reference: Parameterized Tests](reference/testing.md#TEST_P)
- [GoogleTest Primer: Value-Parameterized Tests & Typed Tests](docs/primer.md#value-parameterized-tests)
- [Advanced Guide: Value-Parameterized & Typed Tests](docs/advanced.md#value-parameterized-tests)
- [Matchers Reference](../api-reference/advanced-behaviors/argument-matchers.html)


---

_For code samples and comprehensive examples, see Google's official samples [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) and [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)._
