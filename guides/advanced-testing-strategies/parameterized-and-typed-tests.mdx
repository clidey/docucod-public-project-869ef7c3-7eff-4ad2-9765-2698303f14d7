---
title: "Parameterized and Type-Parameterized Tests"
description: "A practical walkthrough of creating tests that run with varying data values and types. Covers macros, generators, and registration patterns, enabling concise test code that adapts across multiple scenarios."
---

# Parameterized and Type-Parameterized Tests

## Overview

This guide provides a practical walkthrough of creating tests in GoogleTest that run with varying data values and types. It covers the essential macros, parameter generators, and test registration patterns that enable concise and adaptable test code across multiple scenarios. By mastering these, you can write tests that automatically repeat with different inputs or types, increasing test coverage without code duplication.

---

## 1. Value-Parameterized Tests

Value-parameterized tests are ideal when you want to run the same test logic with different data values. They let you define a test fixture that accepts parameters and instantiate tests over a parameter set with built-in generators.

### Workflow Overview
- **Task Description:** Write tests that run multiple times with different parameter values automatically.
- **Prerequisites:** Basic understanding of GoogleTest fixtures and macros.
- **Expected Outcome:** Tests run repeatedly with supplied parameter values.
- **Time Estimate:** 10-20 minutes
- **Difficulty Level:** Intermediate

### Key Steps

<Steps>
<Step title="Define a parameterized test fixture">
Create a test fixture class inheriting from `testing::TestWithParam<T>`, where `T` is the parameter type. This class can contain normal test setup.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Test setup or utilities
};
```
</Step>
<Step title="Use the TEST_P macro to define parameterized tests">
Write your tests with the `TEST_P` macro, which defines tests inside the parameterized fixture.

Use `GetParam()` to fetch the current parameter.

```cpp
TEST_P(FooTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(CheckFunction(param));
}
```
</Step>
<Step title="Instantiate tests with parameter values">
Invoke `INSTANTIATE_TEST_SUITE_P` to create tests over concrete values or ranges.

GoogleTest offers many built-in 
[parameter generators](#parameter-generators), including `Values()`, `Range()`, `ValuesIn()`, `Bool()`, and `Combine()`.

```cpp
INSTANTIATE_TEST_SUITE_P(
  Numbers, FooTest,
  testing::Values(1, 2, 3, 4));
```
</Step>
</Steps>

### Parameter Generators

| Generator         | Description                                                                                       |
|-------------------|------------------------------------------------------------------------------------------------|
| `Range(start, end [, step])` | Produces values starting at `start` up to but not including `end`, stepped by `step` (default 1). |
| `Values(...)`      | Produces an explicit list of values.
| `ValuesIn(container or iterator range)` | Produces values from a container or iterator range.
| `Bool()`           | Produces `false` and `true`.
| `Combine(g1, g2, ..., gN)` | Produces the Cartesian product of N generators, yielding tuples.

### Example: Running tests with multiple string inputs

```cpp
class MyStringTest : public testing::TestWithParam<const char*> {};

TEST_P(MyStringTest, IsNotEmpty) {
  EXPECT_GT(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(StringTests, MyStringTest,
                         testing::Values("foo", "bar", "baz"));
``` 

This generates tests with parameters "foo", "bar", and "baz", running the `IsNotEmpty` test on each.

### Customizing Test Names

Tests instantiated by `INSTANTIATE_TEST_SUITE_P` get generated names like:

```
InstantiationName/TestSuiteName.TestName/Index
```

You can customize the suffix using a name generator function or functor, which takes a `TestParamInfo<ParamType>`, returning a string with a valid test name (alphanumeric and underscores only).

Example with a lambda:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomName, MyStringTest,
    testing::Values("one", "two"),
    [](const testing::TestParamInfo<const char*>& info) {
      return std::string(info.param);
    });
```

**Important:** The names must be unique and valid C++ identifier components (no spaces, dashes, etc).

### Best Practices and Pitfalls

- Always declare `SetUpTestSuite()` and `TearDownTestSuite()` as **public** in parameterized fixtures to avoid linkage errors with `TEST_P`.
- Do not instantiate parameterized tests at function scope—instantiate them at global or namespace scope.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName);` if you plan to define a test suite without instantation.

---

## 2. Typed Tests

Typed tests allow running the same test logic for multiple **types** instead of values. This is especially useful to verify behavior over a set of types or template instantiations.

### Workflow Overview
- **Task Description:** Create tests that automatically repeat over different types.
- **Prerequisites:** Understanding of C++ templates.
- **Expected Outcome:** Tests validate the same logic for a list of types.
- **Time Estimate:** 15-30 minutes
- **Difficulty Level:** Advanced

### Key Steps

<Steps>
<Step title="Define a typed test fixture class template">
Write a class template test fixture inherited from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  // Any type-dependent setup here
};
```
</Step>
<Step title="Declare a list of types and associate it">
Define a type list with `::testing::Types<T1, T2, ...>` and use `TYPED_TEST_SUITE` to link it.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write tests with TYPED_TEST macro">
Use the `TYPED_TEST` macro to write tests. Access the current type as `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam value{};
  EXPECT_TRUE(SomeCheck(value));
}
```
</Step>
</Steps>

### Customizing Typed Test Names

You may provide an optional third argument to `TYPED_TEST_SUITE` with a class that defines a static template method `GetName(int)` returning custom type names.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Other";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## 3. Type-Parameterized Tests

Type-parameterized tests are similar to typed tests but allow defining test logic **independently** of the instantiation. This enables abstract test definitions reusable across translation units.

### Workflow Overview
- **Task Description:** Define reusable test patterns to be instantiated later with various types.
- **Prerequisites:** Experience with typed tests and templates.
- **Expected Outcome:** Abstract tests that can be instantiated flexibly.
- **Time Estimate:** 20-40 minutes
- **Difficulty Level:** Advanced

### Key Steps

<Steps>
<Step title="Define fixture template and declare with TYPED_TEST_SUITE_P">
Define a fixture class template as usual, then declare the suite with `TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test { ... };

TYPED_TEST_SUITE_P(MyTypeParamTest);
```
</Step>
<Step title="Define tests with TYPED_TEST_P macro">
Write tests with `TYPED_TEST_P` similar to `TYPED_TEST`.

```cpp
TYPED_TEST_P(MyTypeParamTest, HasProperty) {
  TypeParam val{};
  EXPECT_TRUE(CheckProperty(val));
}
```
</Step>
<Step title="Register named tests">
Register the tests to be used with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, HasProperty);
```
</Step>
<Step title="Instantiate suites with INSTANTIATE_TYPED_TEST_SUITE_P">
Instantiate the pattern with a type list where needed.

```cpp
using MyTypes = ::testing::Types<char, int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, MyTypeParamTest, MyTypes);
```
</Step>
</Steps>

### Notes

- These tests can be defined once (e.g., in a header) and instantiated multiple times in different translation units with different type sets.
- The test suite names include the prefix given at instantiation.

---

## 4. Troubleshooting & Tips

### Common Issues

- **Missing `INSTANTIATE_TEST_SUITE_P` for `TEST_P` tests:** Causes failure with errors about uninstantiated parameterized tests. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress if intentional.
- **Invalid test names in name generators:** Names must be alphanumeric or underscores, unique, and non-empty.
- **Linkage errors with `SetUpTestSuite` / `TearDownTestSuite`:** Make sure these are public in parameterized tests.
- **Dangling references in `ConvertGenerator` lambdas:** If you use temporary objects with lambdas, specify explicit type for generated values or avoid types like `string_view` that may dangle.

### Best Practices

- Use `ValuesIn` for specifying parameters from existing containers to avoid manual unrolling.
- Use `Combine` to test multiple parameter dimensions together via Cartesian products.
- Customize test names for clarity when parameters are complex.
- Use typed and type-parameterized tests to avoid repetitive test code covering multiple types.

### Performance Considerations

- Parameterized tests instantiate many tests — ensure you balance coverage with test run time.
- Use filters (`--gtest_filter`) to run subsets for quick iteration.

---

## 5. Example Code Snippets

### Value-Parameterized Test: Range and Values

```cpp
class IntRangeTest : public testing::TestWithParam<int> {};

TEST_P(IntRangeTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveNumbers, IntRangeTest, testing::Range(1, 5));
```

### Combining Parameters

```cpp
class AnimalTest : public testing::TestWithParam<std::tuple<const char*, int>> {};

TEST_P(AnimalTest, HasValidProperties) {
  auto [animal, age] = GetParam();
  EXPECT_NE(animal, nullptr);
  EXPECT_GE(age, 0);
}

INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalTest,
  testing::Combine(testing::Values("cat", "dog"), testing::Values(1, 3)));
```

### Typed Test Example

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T default_value = T{};
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->default_value;
  EXPECT_EQ(val, TypeParam{});
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, FooTest) {
  TypeParam val{};
  EXPECT_TRUE(DoSomething(val));
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, FooTest);

using MyTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

---

## Additional Resources

- [Writing and Running Your First Tests Guide](/guides/core-workflows/writing-first-tests)
- [Organizing Test Suites Guide](/guides/core-workflows/organizing-test-suites)
- [GoogleTest Primer](docs/primer.md)
- [Testing Reference: Value-Parameterized Tests and Typed Tests](docs/reference/testing.md#TEST_P)
- [Advanced Testing Strategies: Parameterized and Type-Parameterized Tests](/guides/advanced-testing-strategies/parameterized-and-typed-tests)

---

## Summary
Parameterized and type-parameterized tests in GoogleTest let you run test logic repeatedly with varying input values or types. This guide walks you through defining fixtures with parameters, using macros like `TEST_P` and `TYPED_TEST`, employing parameter generators like `Values` and `Combine`, and instantiating tests with `INSTANTIATE_TEST_SUITE_P` macros. Advanced techniques such as type-parameterized tests empower you to abstract and reuse test logic efficiently, ensuring broad coverage with minimal code duplication.

<Tip>
When writing parameterized tests, start simple by creating a fixture with a single parameter and instantiate a small set of values. Gradually add complexity by combining parameters or using typed tests as needed.
</Tip>

---

## Troubleshooting

<AccordionGroup title="Troubleshooting">
<Accordion title="Tests Not Running or Reporting as Uninstantiated">
Check you have corresponding `INSTANTIATE_TEST_SUITE_P` calls for every `TEST_P`. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if no instantiation is intended.
</Accordion>
<Accordion title="Invalid or Duplicate Test Names in Parameter Generators">
Ensure custom test name generators return unique alphanumeric or underscore strings without spaces or special characters.
</Accordion>
<Accordion title="Linker Errors with SetUpTestSuite/TearDownTestSuite">
Declare those methods as **public** in parameterized fixture classes.
</Accordion>
<Accordion title="Dangling References or Crashes in ConvertGenerator Lambdas">
Avoid returning temporary references or `string_view` pointing to temporaries in lambdas. Prefer explicit types and value captures.
</Accordion>
</AccordionGroup>
