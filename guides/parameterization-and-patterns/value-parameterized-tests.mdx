---
title: "Value-Parameterized Tests: Testing With Multiple Inputs"
description: "Learn how to write tests that run automatically with multiple input values using TEST_P and INSTANTIATE_TEST_SUITE_P macros. Achieve broad coverage while avoiding repetitive code, and see real-world examples for common functions and algorithms."
---

# Value-Parameterized Tests: Testing With Multiple Inputs

## Workflow Overview

### Task Description
This guide helps you write and run tests that automatically execute with multiple input values using GoogleTest's `TEST_P` and `INSTANTIATE_TEST_SUITE_P` macros. It shows how to efficiently cover broad input sets without duplicating code and provides practical examples relevant to common functions and algorithms.

### Prerequisites
- A working GoogleTest environment with C++17 support.
- Basic understanding of writing simple tests using `TEST` or `TEST_F` macros.
- Familiarity with defining test fixtures in GoogleTest.

### Expected Outcome
By following this guide, you will create value-parameterized test fixtures, write parameterized tests that leverage input parameters, instantiate tests with varied values or ranges, and generate descriptive test names for clarity during test execution.

### Time Estimate
Approximately 15-30 minutes to write and instantiate value-parameterized tests for a common scenario.

### Difficulty Level
Intermediate â€“ assumes familiarity with GoogleTest basics and C++ class inheritance.

## Step-by-Step Instructions

### 1. Define a Value-Parameterized Test Fixture
Create a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the type of the parameter you want to test with. This makes your fixture both a regular test class and allows it to access the parameter via `GetParam()`.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Additional test fixture setup or members can be added here.
};
```

**Outcome:** The fixture is ready to be used for defining parameterized tests.

---

### 2. Write Parameterized Tests Using `TEST_P`
Use the `TEST_P` macro to define multiple test patterns that use the parameter from your fixture. Within the test body, call `GetParam()` to access the current input value.

```cpp
TEST_P(FooTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);  // Check that the value is greater than zero.
}

TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0) << "Value " << value << " is not even.";
}
```

**Outcome:** Test logic is defined once but will run repeatedly for each parameter value.

---

### 3. Instantiate the Test Suite with Input Values
Use `INSTANTIATE_TEST_SUITE_P` to create instances of your parameterized test suite with specific input values using parameter generator functions. Specify:

- A unique instantiation name (prefix for test suite).
- The test fixture class name.
- A parameter generation function (e.g., `Values`, `Range`, `ValuesIn`).
- Optionally, a function or functor to generate custom test parameter names.

```cpp
// Instantiate with discrete values.
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, FooTest,
    ::testing::Values(2, 4, 6, 8, 10));

// Instantiate with a range (0 to 5, exclusive).
INSTANTIATE_TEST_SUITE_P(
    SmallNumbers, FooTest,
    ::testing::Range(0, 5));

// Custom test names for better readability.
INSTANTIATE_TEST_SUITE_P(
    NamedValues, FooTest,
    ::testing::Values(1, 3, 5),
    [](const ::testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

**Outcome:** Tests are instantiated for each input value and run automatically when `RUN_ALL_TESTS()` is called.

---

### 4. Access and Use Parameters within Tests
Inside your parameterized tests (`TEST_P`), use `GetParam()` to get the current test value. This allows you to write test assertions that depend on dynamic input.

```cpp
TEST_P(FooTest, CheckComputation) {
  int input = GetParam();
  int result = ComputeSomething(input);
  EXPECT_EQ(result, ExpectedResultFor(input));
}
```

**Outcome:** Your tests dynamically adapt based on each input parameter.

---

### 5. Handle Complex Parameters and Custom Conversions
If your parameter type is complex (e.g., a tuple or a custom struct), you can use `testing::Combine` to generate Cartesian products of multiple parameter sets or `ConvertGenerator` to cast generated tuples into your custom parameter type.

```cpp
// Define a parameter type
struct Param {
  int a;
  bool flag;

  explicit Param(std::tuple<int, bool> t) : a(std::get<0>(t)), flag(std::get<1>(t)) {}
};

class ComplexTest : public ::testing::TestWithParam<Param> {};

TEST_P(ComplexTest, CombinesParameters) {
  Param p = GetParam();
  EXPECT_GE(p.a, 0);
}

INSTANTIATE_TEST_SUITE_P(
    ComboTests, ComplexTest,
    testing::ConvertGenerator<std::tuple<int, bool>>(
        testing::Combine(testing::Values(1, 2, 3), testing::Bool())));
```

**Outcome:** You can test across multiple dimensions of input with ease.

---

### 6. Suppress Warnings for Uninstantiated Parameterized Tests
If you define `TEST_P` tests but intentionally leave some uninstantiated (for example, abstract tests in a library), suppress warnings with:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);
```

**Outcome:** Avoids spurious test execution failures due to missing instantiations.

---

## Examples & Code Samples

### Basic Integer Parameterized Test Example
```cpp
class EvenNumberTest : public ::testing::TestWithParam<int> {};

TEST_P(EvenNumberTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenValues, EvenNumberTest, ::testing::Values(2, 4, 6, 8));
```

Expected test names when run:
- `EvenValues/EvenNumberTest.IsEven/0` for parameter 2
- `EvenValues/EvenNumberTest.IsEven/1` for parameter 4
- And so on...

---

### Using `Range` Generator
```cpp
INSTANTIATE_TEST_SUITE_P(
    SmallNumbers, EvenNumberTest, ::testing::Range(2, 10, 2));  // 2, 4, 6, 8
```

---

### Custom Test Name Generator
```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, EvenNumberTest, ::testing::Values(2, 4, 6),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

This results in test names like `CustomNames/EvenNumberTest.IsEven/Value_2`.

---

### Combining Multiple Parameters
```cpp
class FlaggedTest : public ::testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(FlaggedTest, ComplexCheck) {
  int number = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  // Test logic using number and flag
}

INSTANTIATE_TEST_SUITE_P(
    Combinations, FlaggedTest,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

---

## Troubleshooting & Tips

### Common Issues

- **No Tests Run or Failing Due to Missing Instantiations**: Every `TEST_P` definition must have a corresponding `INSTANTIATE_TEST_SUITE_P`. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings for intentionally uninstantiated test suites.

- **Invalid Test Names**: Test parameter names must only contain alphanumeric characters and underscores, and cannot be empty. If using a custom name generator, ensure it produces valid names.

- **Parameters Not Passing Correct Types**: Use `ConvertGenerator` when the generated parameter types do not match the fixture's parameter type explicitly.

### Best Practices

- Keep the parameter type `T` simple and copyable to avoid lifecycle management issues.
- Use meaningful instantiation names to differentiate parameter sets clearly.
- Leverage `testing::Combine` to test multiple dimension parameter spaces without writing nested loops.
- If parameters are complex types, provide custom printing functions (`PrintTo` or `AbslStringify`) for readable test output.

### Performance Considerations

- Avoid generating overly large Cartesian products without careful consideration to prevent combinatorial explosion.
- Instantiate only the necessary parameters for the tests to run efficiently.

### Alternative Approaches

- Use typed tests (`TYPED_TEST`) or type-parameterized tests for checking behaviors across different types rather than values.
- For testing sequences not easily expressed as parameters, consider programmatically generating tests with `RegisterTest`.

## Next Steps & Related Content

- **Typed Tests**: For tests repeated over type lists, see [Typed Tests: Reusing Tests Across Types](../parameterization-and-patterns/type-parameterized-tests).
- **Test Fixtures**: Learn how to build reusable test fixtures for organizing test setup and teardown in [Writing and Running Your First Unit Test](../core-workflows/writing-unit-tests).
- **Test Parameter Generators**: Understand all built-in parameter generators in the [Testing Reference](../../reference/testing.md#INSTANTIATE_TEST_SUITE_P).
- **Custom Name Generation**: Dive deeper into custom test names with [Specifying Names for Value-Parameterized Test Parameters](../advanced.md#specifying-names-for-value-parameterized-test-parameters).

---

For a broader understanding of GoogleTest's features, consult [Feature Overview: Test, Assert, Mock](../../overview/architecture-features-integration/features-at-a-glance) and [Core Concepts & Testing Terminology](../../overview/product-intro-concepts/core-concepts-terminology).

---

## References
- [GoogleTest: TEST_P and INSTANTIATE_TEST_SUITE_P](../../reference/testing.md#TEST_P)
- [GoogleTest Advanced Topics: Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [GoogleTest: Writing and Running Your First Unit Test](../core-workflows/writing-unit-tests)

---

## Summary
This guide walks you through creating value-parameterized tests in GoogleTest using `TEST_P` and `INSTANTIATE_TEST_SUITE_P`. You'll learn to define versatile test fixtures, write tests that run over multiple input values efficiently, and produce readable, well-named test cases to enhance test clarity and maintenance.