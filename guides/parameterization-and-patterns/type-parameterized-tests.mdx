---
title: "Type-Parameterized Tests: Reusing Tests Across Types"
description: "Explore how to create and use type-parameterized tests for verifying the same logic across multiple C++ types. This tutorial covers the use of TYPED_TEST and related macros, making your test suite adaptable and future-proof."
---

# Type-Parameterized Tests: Reusing Tests Across Types

Explore how to create and use type-parameterized tests for verifying the same logic across multiple C++ types. This tutorial covers the use of `TYPED_TEST`, `TYPED_TEST_SUITE`, and related macros, making your test suite adaptable and future-proof.

---

## What Are Type-Parameterized Tests?
Type-parameterized tests let you write test logic once and run it against multiple types. This is invaluable when you want to verify that different types — for example, various container types or numeric types — all behave according to the same expected rules or interfaces.

Unlike value-parameterized tests, type-parameterized tests focus on varying the **type** rather than values, reducing code duplication and improving maintainability.


## Prerequisites
- Familiarity with C++ templates and test fixtures.
- Basic understanding of **GoogleTest** and writing `TEST` or `TEST_F` tests.
- GoogleTest installed and configured in your project.


## Outcomes
By the end of this guide, you will:
- Define type-parameterized test fixtures.
- Register and instantiate type-parameterized test suites.
- Write reusable test cases that automatically run over various types.
- Employ best practices to keep your test suite clean and efficient.


## Time Estimate
Approximately 15-30 minutes to learn and implement a basic type-parameterized test suite.


---

# Getting Started with Typed Tests

### Step 1: Define a Fixture Class Template
Start by creating a template test fixture class parameterized by a type `T`. Typically, the fixture derives from `testing::Test`. Inside the fixture, you can define members and helper functions that use the templated type.

```cpp
#include "gtest/gtest.h"

template <typename T>
class FooTest : public testing::Test {
 public:
  // Example member using T
  T value_{};

  void SetUp() override {
    // Optional per-test setup
  }

  // You can define more members as needed
};
```


### Step 2: Associate a List of Types
Use the macro `TYPED_TEST_SUITE` to associate a list of types with your fixture. GoogleTest provides the `Types` template to specify a variadic list of types.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

> **Tip:** If you have only one type, you can directly specify it without wrapping in `Types<>`.


### Step 3: Write Typed Tests Using `TYPED_TEST`
Replace the usual `TEST_F` macro with `TYPED_TEST` and write your test using the special identifier `TypeParam` to refer to the test type parameter.

```cpp
TYPED_TEST(FooTest, DefaultValueIsZero) {
  TypeParam default_value{};  // Zero-initialized
  EXPECT_EQ(default_value, TypeParam{});
}

TYPED_TEST(FooTest, CanAssignAndCompare) {
  TypeParam a = static_cast<TypeParam>(5);
  TypeParam b = static_cast<TypeParam>(10);
  EXPECT_TRUE(a < b);
}
```


### Step 4: Run Your Tests
Each test case written with `TYPED_TEST` will be instantiated and run for each type in your list. For the example above, GoogleTest runs six tests (two tests × three types).


---

# Advanced: Type-Parameterized Tests for Reusable Test Suites
Sometimes you want to define reusable test logic _without_ knowing the types upfront and instantiate the tests in different translation units. Type-parameterized tests solve this with _type-parameterized test suites_.


### Step 1: Define the Fixture Template (Same as Typed Tests)

```cpp
template <typename T>
class BarTest : public testing::Test {
  void DoSetup();
  //...
};
```

### Step 2: Declare a Type-Parameterized Test Suite
Use `TYPED_TEST_SUITE_P` instead of `TYPED_TEST_SUITE`. This declares a suite that can be instantiated later.

```cpp
TYPED_TEST_SUITE_P(BarTest);
```


### Step 3: Define Tests with `TYPED_TEST_P`
Write the test cases with the `_P` macro suffix.

```cpp
TYPED_TEST_P(BarTest, HasDefaultValue) {
  TypeParam val{};
  EXPECT_EQ(val, TypeParam{});
}

TYPED_TEST_P(BarTest, IsLessThan) {
  TypeParam one = static_cast<TypeParam>(1);
  TypeParam two = static_cast<TypeParam>(2);
  EXPECT_LT(one, two);
}
```

### Step 4: Register the Test Names
Register the names of the tests before instantiation.

```cpp
REGISTER_TYPED_TEST_SUITE_P(BarTest, HasDefaultValue, IsLessThan);
```

### Step 5: Instantiate the Suite with Types
Finally, instantiate the test suite in your source file with a prefix and list of types.

```cpp
using MyBarTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, BarTest, MyBarTypes);
```

> **Tip:** The prefix helps distinguish multiple instantiations of the same test suite with different types.


---

# Best Practices and Common Pitfalls

- **Use consistent naming:** Do not use underscores in test suite or test names to avoid conflicts and build errors.
- **Fixture constructors:** Prefer writing setup code inside `SetUp()` instead of constructors to allow safe use of fatal assertions.
- **Static members:** Remember that static shared resources should be managed carefully with `SetUpTestSuite` and `TearDownTestSuite`.
- **Avoid mixing test macros:** Mixing `TEST`, `TEST_F`, and typed variants in the same test suite leads to errors.
- **Type names in test results:** To make your test output readable, you can provide name generators when using `TYPED_TEST_SUITE`.
- **Uninstantiated suites:** When you define type-parameterized tests but do not instantiate the suite, you'll get errors. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` to suppress if intentional.


---

# Troubleshooting

### Test Suite Instantiation Errors
If you get errors that a type-parameterized test suite was never instantiated, ensure:
- You have called `INSTANTIATE_TYPED_TEST_SUITE_P` for every suite.
- You have registered all test names before instantiation.
- Multiple instantiations have unique prefixes.

### Linking and Fixture Errors
- Make sure your fixture class templates are default constructible unless you handle test construction manually.
- Avoid mixing `TEST` and `TEST_F` or parameterized and non-parameterized tests in the same suite.

### Assertion Errors in Constructors
If you get compilation errors related to using `ASSERT_*` macros in constructors or non-void functions, move the assertions to `SetUp()` per GoogleTest design.


---

# Example: Complete Typed Test

```cpp
#include <vector>
#include "gtest/gtest.h"

template <typename T>
class VectorTest : public testing::Test {
 public:
  std::vector<T> vec_;
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(VectorTest, MyTypes);

TYPED_TEST(VectorTest, InitiallyEmpty) {
  EXPECT_TRUE(this->vec_.empty());
}

TYPED_TEST(VectorTest, CanAddElements) {
  this->vec_.push_back(static_cast<TypeParam>(1));
  EXPECT_EQ(1u, this->vec_.size());
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```


---

# Additional Resources
- [GoogleTest Primer](primer.md) - for basic test concepts
- [Advanced GoogleTest Topics](advanced.md#typed-tests) - detailed explanation of typed and type-parameterized tests
- [Testing Reference: TYPED_TEST and related macros](reference/testing.md#TYPED_TEST)
- [FAQ: Working with Parameterized and Typed Tests](faq.md#working-with-parameterized-and-typed-tests)


---

# Summary
Type-parameterized tests in GoogleTest empower you to write scalable, reusable test logic across multiple types, promoting DRY principles and simplifying test maintenance. By carefully defining template fixtures, registering test patterns, and instantiating suites with desired type lists, you ensure your test coverage is comprehensive and adaptable to evolving codebases.


---

<AccordionGroup title="Quick Reference">
<Accordion title="Macros Overview">
- `TYPED_TEST_SUITE(TestFixture, Types)` - Associates a fixed list of types with the test fixture.
- `TYPED_TEST(TestFixture, TestName)` - Defines a typed test that runs once per type.
- `TYPED_TEST_SUITE_P(TestFixture)` - Declares a type-parameterized test suite (type list unknown yet).
- `TYPED_TEST_P(TestFixture, TestName)` - Defines a test pattern for type-parameterized suite.
- `REGISTER_TYPED_TEST_SUITE_P(TestFixture, TestNames...)` - Registers test names.
- `INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestFixture, Types)` - Instantiates with a type list.
- `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestFixture)` - Suppresses unused test warnings.
</Accordion>
<Accordion title="Common Error Messages">
- *No matching function for call to FooTest::FooTest()*: Missing default constructor.
- *All tests in the same test suite must use the same test fixture class*: Mixing test macros or fixture declarations.
- *Type parameterized test suite ... never instantiated*: Forgot to instantiate the suite.
</Accordion>
</AccordionGroup>


---

# Visual Workflow
```mermaid
flowchart TD

  A[Define Fixture Template <br/> 'template <typename T> class FooTest'] --> B[Declare Typed Suite <br/> 'TYPED_TEST_SUITE(FooTest, Types)']
  B --> C[Write Tests with 'TYPED_TEST(FooTest, TestName)']
  C --> D[Run Tests <br/> Instantiated for Each Type]

  subgraph Advanced Usage
    E[Declare Type-Parameterized Suite <br/> 'TYPED_TEST_SUITE_P(FooTest)'] --> F[Write Tests with 'TYPED_TEST_P(FooTest, TestName)']
    F --> G[Register Tests <br/> 'REGISTER_TYPED_TEST_SUITE_P(FooTest, ...)' ]
    G --> H[Instantiate with Types <br/> 'INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, FooTest, Types)']
    H --> D
  end

  style A fill:#f9f,stroke:#333,stroke-width:2px
  style B fill:#bbf,stroke:#333,stroke-width:2px
  style C fill:#bbf,stroke:#333,stroke-width:2px
  style D fill:#bfb,stroke:#333,stroke-width:2px
  style E fill:#f9f,stroke:#333,stroke-width:2px
  style F fill:#bbf,stroke:#333,stroke-width:2px
  style G fill:#bbf,stroke:#333,stroke-width:2px
  style H fill:#bbf,stroke:#333,stroke-width:2px
```

---

# Next Steps & Related Guides

- Dive into [Value-Parameterized Tests](value-parameterized-tests) for parameterizing with values.
- Explore [Death Tests](death-tests) for process-exit verification.
- Learn about [Mocking](introduction-to-mocking) to combine typed tests with mocks.
- Study [Using Assertions Effectively](using-assertions) to write better test validations.


---

# Summary
Type-parameterized tests enable scalable, efficient, and maintainable testing across C++ types. Use the provided macros to craft reusable fixtures and test logic, reduce code duplication, and guarantee consistent behavior for all relevant types.


# Additional References
- [GoogleTest GitHub Repository](https://github.com/google/googletest)
- [GoogleTest Typed Tests Reference](reference/testing.md#TYPED_TEST)
- [GoogleTest Advanced Topics](advanced.md#type-parameterized-tests)

---

<Check>
Ensure your fixture templates are default-constructible unless you use custom test factories.
</Check>
<Check>
Always register test names before instantiating type-parameterized suites.
</Check>
<Info>
Avoid mixing `TEST`, `TEST_F`, and typed tests within the same test suite.
</Info>

---

Enjoy powerful, maintainable testing with GoogleTest's type-parameterized tests!


