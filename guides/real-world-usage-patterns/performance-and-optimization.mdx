---
title: "Optimizing Test Performance"
description: "Strategies and patterns for speeding up test execution and reducing flakiness in large codebases. Covers test selection, parallel execution, use of test doubles, and optimizing fixture setup."
---

# Optimizing Test Performance

## Workflow Overview

This guide helps C++ developers efficiently optimize test execution and reliability when using GoogleTest and GoogleMock in large codebases. It focuses exclusively on practical strategies available in the mocking framework to speed up tests and reduce flakiness.

### Prerequisites
- You have existing tests written with GoogleTest and GoogleMock.
- Familiarity with mocking basics: creating mocks, setting `EXPECT_CALL`s and `ON_CALL`s.
- Your project is of a size or complexity where test execution time or flakiness is a concern.

### Expected Outcome
- Your test suite will execute faster and more reliably.
- You will apply best practices such as selective test execution, parallelization, use of test doubles, and optimized fixture management.

### Time Estimate
Approximately 30 minutes to 1 hour to understand and implement the strategies in active test code projects.

### Difficulty Level
Intermediate: Requires some experience with GoogleMock and test structuring techniques.

---

## Step-by-Step Instructions

### 1. Use Test Selection to Limit Executed Tests
- Utilize GoogleTest filtering flags (e.g., `--gtest_filter`) to run only impacted tests in CI or locally.
- Leverage mock-specific expectations to focus verification on key interactions only.

> **Expected Result:** Reduced test execution time by avoiding unnecessary tests.

### 2. Employ Parallel Test Execution
- Integrate GoogleTest with build system or CI parallelization capabilities.
- Structure test binaries so tests can run concurrently safely without shared state.

> **Expected Result:** Significant runtime reduction on multi-core machines or CI runners.

### 3. Optimize Use of Test Doubles
- Use `ON_CALL` to set unverified default behaviors, reducing flakiness from unexpected uninteresting calls.
- Apply `NiceMock` or `StrictMock` judiciously to control warnings and failures on uninteresting calls, avoiding noise and preserving test intent.
- When return values depend on state, use `WillOnce`, `WillRepeatedly`, and custom actions to reduce redundant computation.

> **Expected Result:** Cleaner, more stable tests with fewer spurious warnings or failures.

### 4. Minimize Test Fixture Overhead
- Design fixtures to avoid expensive setup where possible.
- Reuse mock object configurations using `ON_CALL` in fixture `SetUp()` methods rather than repeated `EXPECT_CALL` in tests.
- Use `RetiresOnSaturation()` on expectations to retire them once exhausted, avoiding false upper-bound violations.

> **Expected Result:** Reduced test execution time and fewer false positives caused by overly sticky expectations.

### 5. Sequence Expectations Intelligently
- Use `InSequence` or `After` clauses to explicitly order expectations only when necessary.
- Avoid overly strict ordering that makes tests brittle and slows down parallelism.

> **Expected Result:** Tests that wait precisely on required call order while maximizing concurrency where possible.

### 6. Leverage Default Actions and Reset Verification
- Use `ON_CALL(...).WillByDefault(...)` to provide consistent return values, minimizing need for repetitive `EXPECT_CALL`s.
- Call `Mock::VerifyAndClearExpectations(&mock)` after tests where mocks persist across many executions to clean state and keep tests isolated.

> **Expected Result:** Reduced test flakiness and improved test independence.

---

## Examples & Code Snippets

### Defining a Nice Mock to Suppress Uninteresting Call Warnings
```cpp
using ::testing::NiceMock;
class MockDatabase {
 public:
  MOCK_METHOD(bool, Connect, (), (override));
  MOCK_METHOD(int, Query, (const std::string& query), (override));
};

// Use NiceMock to suppress warnings for calls without EXPECT_CALL
NiceMock<MockDatabase> mock_db;
ON_CALL(mock_db, Connect()).WillByDefault(Return(true));
EXPECT_CALL(mock_db, Query("SELECT * FROM users")).Times(1).WillOnce(Return(10));

// Calling Query with different args won't warn now
mock_db.Query("SELECT name FROM users");
```

### Sequencing Expectations for Controlled Order
```cpp
using ::testing::Sequence;

Sequence s;
EXPECT_CALL(mock_db, Connect()).InSequence(s);
EXPECT_CALL(mock_db, Query(_)).InSequence(s);

// Connect must happen before Query
mock_db.Connect();
mock_db.Query("SELECT *");
```

### Retiring Expectations to Avoid Sticky Failures
```cpp
EXPECT_CALL(mock_db, Query("SELECT 1")).WillOnce(Return(1)).RetiresOnSaturation();
EXPECT_CALL(mock_db, Query(_)).WillRepeatedly(Return(0));

mock_db.Query("SELECT 1");  // Matches first expectation
mock_db.Query("SELECT 1");  // Matches second expectation, no failure
```

### Using `Mock::VerifyAndClearExpectations()`
```cpp
MockDatabase mock_db;
EXPECT_CALL(mock_db, Connect()).WillOnce(Return(true));
mock_db.Connect();

// After test, verify and clear
bool success = Mock::VerifyAndClearExpectations(&mock_db);
ASSERT_TRUE(success);
```

---

## Troubleshooting & Tips

### Common Issues
- **Excessive call failures:** Usually caused by sticky expectations not retired on saturation. Use `.RetiresOnSaturation()`.
- **Uninteresting calls warning:** Suppress with `NiceMock<T>` or add a catch-all `EXPECT_CALL(...).Times(AnyNumber())`.
- **Tests slower than expected:** Check fixture setup and scope of mocks; move expensive initialization out of per-test setup.
- **Flaky test order dependencies:** Use sequences or `After` only when necessary; avoid implicit ordering.
- **Leaked mocks error:** Use `Mock::AllowLeak(&mock_obj)` if intentional; otherwise ensure proper ownership and destruction.

### Best Practices
- Favor `ON_CALL` for default behavior, `EXPECT_CALL` for required verifications.
- Use matcher `_` where argument values are not important to reduce maintenance and flakiness.
- Minimize mock method calls and matchers for speedy evaluation.
- Structure tests to allow parallel execution by limiting shared state.

### Performance Considerations
- Isolate slow tests and run separately.
- Compile mocks with constructors and destructors defined out-of-line to speed up build.
- Use lightweight mock methods where possible.

### Alternative Approaches
- Delegate to fakes or real objects using `ON_CALL().WillByDefault()` for heavier behaviors.
- Use partial ordering to relax strict sequences for more concurrency.

---

## Next Steps & Related Content

### What's Next
- Explore detailed usage of mocks and expectations in [Mocking Basics: Simulating Dependencies](/guides/getting-started/basic-mocking).
- Learn about assertion and matcher best practices in [Assertions and Matchers in Depth](/guides/writing-and-structuring-tests/assertions-and-matchers).
- Review [Advanced Mocking Patterns and Behaviors](/guides/writing-and-structuring-tests/advanced-mocking-patterns) for complex sequencing and cardinality.

### Related Guides
- [Organizing and Scaling Large Test Suites](/guides/writing-and-structuring-tests/organizing-large-test-suites) 
- [Integration with Build Systems and CI](/guides/real-world-usage-patterns/integration-with-build-systems)
- [Troubleshooting Common Test Failures](/guides/real-world-usage-patterns/troubleshooting-test-failures)

### Resources
- gMock Cheat Sheet: /docs/gmock_cheat_sheet.md
- gMock Cookbook: /docs/gmock_cook_book.md
- gMock for Dummies Tutorial: /docs/gmock_for_dummies.md

---

For detailed API references and macro usage, see the [Mocking Reference](/docs/reference/mocking.md).


---

