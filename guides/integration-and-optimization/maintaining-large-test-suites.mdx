---
title: "Managing and Scaling Large Test Suites"
description: "Strategies and tools for maintaining, organizing, and scaling large GoogleTest/GoogleMock suites. Covers selective test runs, parallelization, and handling flaky tests. Practical tips to keep test suites fast and reliable as projects grow."
---

# Managing and Scaling Large Test Suites

## Overview

As your project grows, so does your test suite. Managing and scaling large GoogleTest and GoogleMock test suites requires strategic organization and efficient execution to keep tests fast, reliable, and maintainable. This guide focuses specifically on techniques and tools to maintain large suites effectively, selectively run tests, parallelize execution, and manage flaky tests to ensure continuous, scalable testing success.

---

## Prerequisites

- A functioning GoogleTest and GoogleMock setup integrated with your C++ project.
- Familiarity with writing basic tests, using fixtures, and running tests via test executables.
- Basic understanding of command-line flags and environment variables relevant to test execution.

## What You Will Achieve

By completing this guide, you will be able to:

- Selectively run subsets of tests within large suites for faster feedback.
- Configure and utilize test sharding and parallelization.
- Detect, manage, and reduce flaky tests in your suite.
- Understand best practices for organizing tests in large projects to improve scalability.

---

## Time Estimate

Approximately 30 minutes to 1 hour depending on test suite size and integration complexity.

## Difficulty Level

Intermediate

---

# Step-by-Step Instructions for Managing and Scaling Large Test Suites

### 1. Selectively Running Subsets of Tests

When the number of tests grows large, running the entire suite for every change may be inefficient. GoogleTest provides flexible filtering options to run only specific tests.

#### Actions:

- Use the `--gtest_filter` flag when running your test binary.

```bash
./your_test_binary --gtest_filter=TestSuiteName.TestName
```

- Use wildcards (`*` and `?`) to match multiple tests.

```bash
./your_test_binary --gtest_filter=MySuite.*
```

- Combine patterns with `:` and exclude tests using `-` to exclude.

```bash
./your_test_binary --gtest_filter=Foo*:*Bar*-Foo.Bar
```

#### Expected Results:

- Only the tests matching the positive patterns and not listed in the negative patterns run.
- Non-matching tests are skipped, saving time during development.

#### Tips:

- Use `--gtest_list_tests` to list all available tests to help craft filters.
- To temporarily disable a test, prefix its name or the test suite with `DISABLED_` to exclude it from runs.

---

### 2. Parallelizing Test Execution

Running tests in parallel shortens total test time and improves continuous integration (CI) throughput.

#### Local Parallel Execution via Sharding:

GoogleTest supports sharding, allowing multiple instances of the test executable to run different partitions of the test suite in parallel.

#### Actions:

- Divide tests into shards by setting environment variables before running each test instance.

```bash
# On machine 1
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=0
./your_test_binary

# On machine 2
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=1
./your_test_binary

# On machine 3
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=2
./your_test_binary
```

- Each shard runs a disjoint portion of tests. Collect the results after all shards complete.

#### Expected Results:

- Test executions are distributed evenly across shards.
- Test results from all shards cover the full test suite exactly once.

#### Tips:

- Use the same `GTEST_TOTAL_SHARDS` across shards.
- Adjust the number of shards according to available compute resources.
- For CI, configure your CI jobs to set these variables accordingly.

#### Built-in Support for Test Repeating and Shuffling:

- Use `--gtest_repeat=N` to run tests multiple times, useful to catch flaky tests.
- Use `--gtest_shuffle` to randomize test order and detect inter-test dependencies.

---

### 3. Handling Flaky Tests

Some tests intermittently fail due to timing, environment issues, or implicit dependencies.

#### Actions:

- Identify flaky tests by running tests repeatedly:

```bash
./your_test_binary --gtest_repeat=100 --gtest_break_on_failure
```

- Isolate flaky tests using filtering and fix the underlying issues.
- Consider annotating flaky tests or temporarily disabling them with the `DISABLED_` prefix until stabilized.

#### Best Practices:

- Avoid shared mutable state between tests.
- Use `SetUpTestSuite()` and `TearDownTestSuite()` for expensive resources shared by tests.
- Use `SCOPED_TRACE` to add trace information aiding flaky test diagnosis.

---

### 4. Organizing Large Test Suites

Well-structured test suites make scaling easier by logically grouping tests and enabling reuse.

#### Recommendations:

- Group related tests into test suites that mirror your production code structure.
- Use test fixtures (`TEST_F`) to share common setup/tear-down logic.
- For parameterized tests, leverage `TEST_P` and `INSTANTIATE_TEST_SUITE_P` to cover many cases with minimal duplication.
- Use typed tests (`TYPED_TEST_SUITE`) when validating different data types against the same test logic.

#### Shared Resources:

- Use `static` members and define `SetUpTestSuite()` and `TearDownTestSuite()` to share resources efficiently.

```cpp
class FooTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    shared_resource_ = new ExpensiveObject();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  static ExpensiveObject* shared_resource_;
};

ExpensiveObject* FooTest::shared_resource_ = nullptr;
```

---

## Examples

### Filtering Tests

Run only tests containing "Login" in their name.

```bash
./app_tests --gtest_filter=*Login*
```

### Shard Tests Across Machines

On 2 machines, split tests roughly half-and-half:

```bash
# Machine 0
export GTEST_TOTAL_SHARDS=2
export GTEST_SHARD_INDEX=0
./app_tests

# Machine 1
export GTEST_TOTAL_SHARDS=2
export GTEST_SHARD_INDEX=1
./app_tests
```

### Use SCOPED_TRACE to Diagnose Flaky Tests

```cpp
void Helper(int value) {
  SCOPED_TRACE(testing::Message() << "value = " << value);
  EXPECT_EQ(Compute(value), expected_value);
}

TEST(MyTestSuite, FlakyTest) {
  for (int i = 0; i < 5; ++i) {
    Helper(i);
  }
}
```

Failures will show the trace "value = i" helping to pinpoint iteration.

---

## Troubleshooting & Tips

### Test Filtering Tips

- Check spelling of test names and suite names carefully.
- Use `--gtest_list_tests` to confirm available tests.
- Remember disabled tests won't run unless `--gtest_also_run_disabled_tests` is specified.

### Parallel Execution Pitfalls

- Ensure no tests share non-thread-safe global data.
- Use test fixtures correctly to isolate tests.
- Beware of environment-specific dependencies causing uneven shard distribution.

### Flaky Test Diagnosis

- Use `--gtest_repeat` with `--gtest_break_on_failure` for easy debugging.
- Consider adding detailed logs or trace points inside the test to find timing issues.

### Managing Shared Resources

- Avoid modifying shared resources without proper synchronization.
- Clean up shared resources properly in `TearDownTestSuite()` to prevent leaks.

---

## Next Steps & Related Content

- [Installing and Configuring GoogleTest](guides/getting-started/installing-and-configuring) — for setup and test integration
- [Writing Your First Test Cases](guides/getting-started/writing-your-first-tests) — to get started with test creation
- [GoogleTest with Continuous Integration](guides/integration-and-optimization/continuous-integration-setup) — for CI pipelines
- [Using Assertions Effectively](guides/testing-techniques/advanced-assertions) — for robust test validation
- [Mocking with GoogleMock](guides/mocking-with-googlemock/introduction-to-mocking) — to simulate dependencies in tests

---

Explore further to maximize your testing effectiveness and maintainability as your codebase and test suite evolve. Effective scaling and organization will keep your automated tests agile and trustworthy.
