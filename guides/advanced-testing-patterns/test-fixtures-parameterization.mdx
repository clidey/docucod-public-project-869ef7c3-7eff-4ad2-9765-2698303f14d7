---
title: "Test Fixtures, Parameterized, and Typed Tests"
description: "Shows how to use test fixtures to share setup code, run tests with multiple data sets, and write generic tests for multiple types. Illustrates when and how to use value-parameterized and type-parameterized tests."
---

# Test Fixtures, Parameterized, and Typed Tests

This guide helps you write tests using GoogleTest's advanced test organization features: test fixtures for shared setup, value-parameterized tests to run tests with multiple data inputs, and typed tests for generic testing across multiple types. You'll learn when and how to use each feature to maximize code reuse, make your tests clear, and cover diverse test scenarios.

---

## 1. Workflow Overview

### What You'll Accomplish
- Use **test fixtures** to share common setup and cleanup among related tests.
- Write **value-parameterized tests** to run the same test logic over different input values.
- Write **typed tests** to run identical tests for multiple types, ensuring generic correctness.

### Prerequisites
- Basic familiarity with GoogleTest and simple tests (`TEST()` and `TEST_F()`).
- A C++17-compatible compiler and GoogleTest installed and set up.

### Expected Outcome
By following this guide, you'll be able to write organized, maintainable, and expressive tests that handle different inputs and types without redundant code.

### Time Estimate
Initial learning and examples: 15-30 minutes. Applying these patterns to your project: variable, depending on test suite size.

### Skill Level
Intermediate C++ developer familiar with basic automated testing concepts.

---

## 2. Test Fixtures: Sharing Setup for Multiple Tests

### Purpose
Test fixtures let you group tests that need the same configuration or resources. This avoids repeating setup code and makes tests clearer and faster.

### How to Define a Test Fixture

1. Derive a class from `testing::Test` (usually named with `Test` suffix).
2. Declare member variables and setup/teardown code inside it.
3. Use `TEST_F()` to define tests using this fixture. 

```cpp
class MyFixture : public testing::Test {
 protected:
  MyFixture() {
    // Common setup for all tests
  }

  void SetUp() override {
    // Called before each test
  }

  void TearDown() override {
    // Called after each test
  }

  // Shared objects
  std::vector<int> data_;
};

// Use TEST_F to access fixture members
TEST_F(MyFixture, TestOne) {
  data_.push_back(10);
  EXPECT_EQ(data_.size(), 1);
}

TEST_F(MyFixture, TestTwo) {
  EXPECT_TRUE(data_.empty());  // Fresh fixture objects per test
}
```

### Key Details
- Each `TEST_F` runs in a fresh fixture instance; tests don't share state unless in static members.
- Use the constructor or `SetUp()` for per-test initialization.
- Use `TearDown()` or destructor to clean up.

### Sharing Expensive Resources (Test Suite Setup)
Use `static` members in the fixture and override `SetUpTestSuite()` and `TearDownTestSuite()` for expensive setup/cleanup done once per test suite run.

```cpp
class FixtureWithSharedResource : public testing::Test {
 public:
  static void SetUpTestSuite() {
    shared_resource_ = new ExpensiveResource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

 protected:
  static ExpensiveResource* shared_resource_;
};

ExpensiveResource* FixtureWithSharedResource::shared_resource_ = nullptr;

TEST_F(FixtureWithSharedResource, UsesResource) {
  ASSERT_NE(shared_resource_, nullptr);
  EXPECT_TRUE(shared_resource_->IsReady());
}
```

### Tips and Pitfalls
- Don't rely on order of tests; their execution order is undefined.
- Protect shared resources against concurrent access if tests run in parallel.
- Make sure to clear or reset shared static state between tests if modified.

---

## 3. Value-Parameterized Tests

### Why Use Them?
To run the same test logic with different input values without duplicating code.

### How They Work
Value-parameterized tests run multiple test instances where each instance gets a different parameter.

### Steps to Write Value-Parameterized Tests

1. **Create a fixture class** derived from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // Fixture code here
};
```

2. **Define parameterized tests** using the `TEST_P` macro.

```cpp
TEST_P(MyParamTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

3. **Instantiate the test suite** with parameter values using `INSTANTIATE_TEST_SUITE_P` and a parameter generator:

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyParamTest, testing::Values(2, 4, 6, 8));
```

You can use multiple predefined parameter generators:
- `Values()` – explicit list
- `ValuesIn()` – from containers or arrays
- `Range()` – values in numeric ranges
- `Bool()` – boolean values
- `Combine()` – Cartesian product of multiple parameter generators

### Accessing the Parameter
Inside your `TEST_P` body, call `GetParam()` to obtain the current parameter value.

### Example: Testing Multiple Inputs

```cpp
class FactorialTest : public testing::TestWithParam<int> {};

int Factorial(int n) { /* ... */ }

TEST_P(FactorialTest, ReturnsCorrectValue) {
  int n = GetParam();
  int expected = /* precomputed factorial for n */;
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(Values, FactorialTest, testing::Values(0, 1, 5, 10));
```

### Naming Parameterized Tests
The first argument to `INSTANTIATE_TEST_SUITE_P` is a unique prefix distinguishing multiple instantiations.

You can provide a custom function or lambda to generate readable parameter-based test names.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyGroup, MyParamTest, testing::Range(0, 3),
    [](const testing::TestParamInfo<MyParamTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Advanced: Custom Parameter Types
You can use any copyable type as parameter, including user classes, tuples, structs, or smart pointers. Just ensure proper equality and stream output support.

### Suppressing Missing Instantiations
A `TEST_P` without an instantiation triggers an error unless you declare:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyParamTest);
```

### Pitfalls
- `GetParam()` is not available outside `TEST_P` or `SetUp()/TearDown()` of fixture.
- Parameter generators are evaluated at `InitGoogleTest()` time.
- Avoid modifying parameters inside tests as they are immutable.

---

## 4. Typed Tests

### Purpose
Test the same test suite logic against multiple types, useful for verifying template classes or interfaces.

### Key Differences
- Typed tests handle type variations, not values.
- Advantageous when you want to confirm behavior consistency across types.

### How to Write Typed Tests

1. Define a test fixture class template derived from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  // TypeParam is available inside typed tests.
  void SetUp() override {
    // Setup code specific to type T
  }
};
```

2. Declare the list of types you want to instantiate using `::testing::Types<...>`.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```

3. Associate the types with the test suite using `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. Write typed tests with `TYPED_TEST` macro.

```cpp
TYPED_TEST(MyTypedTest, Works) {
  TypeParam value{};  // Default-constructed
  // Access fixture members with 'this->'
  EXPECT_TRUE(this->IsValid(value));
}
```

5. Each `TYPED_TEST` body is compiled and run for each type in `MyTypes`.

### Tips
- Use `TypeParam` to refer to the current type inside tests.
- Use `this->` to access non-static members in the fixture class template.
- You can have multiple `TYPED_TEST`s in the same suite.

### Typed Test Example

```cpp
template<typename T>
class StackTest : public testing::Test {
 protected:
  Stack<T> stack;
};

TYPED_TEST_SUITE(StackTest, ::testing::Types<int, float>);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack.empty());
}

TYPED_TEST(StackTest, PushIncreasesSize) {
  this->stack.push(TypeParam());
  EXPECT_EQ(this->stack.size(), 1);
}
```

### When to Use Typed Tests
- Testing templated algorithms/classes over different type parameters.
- Ensuring your class works identically for integral, floating, or complex types.

### Related: Type-Parameterized (*Parameterized Typed*) Tests
For advanced use, where test class template is defined but test list is unknown upfront. Use `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, with registration and instantiation.

---

## Troubleshooting & Tips

### Common Issues
- **Test Fixture Not Found:** Make sure your fixture class has a public default constructor for `TEST_F` or `TEST_P`.
- **Parameter Type Issues:** Parameter types must be copyable and streamable for nice error messages.
- **Undeclared Test Instantiations for `TEST_P`:** Either instantiate explicitly or allow uninstantiated.
- **Test Naming Conflicts:** Avoid underscores (`_`) in test suite or test names.
- **Custom Parameter Names Invalid:** Ensure name suffix returned by custom functions only contains alphanumeric or underscore characters.

### Best Practices
- Name test suites and test cases with meaningful names reflecting tested features.
- Use parameterized tests for inputs that just change data, and typed tests for different types.
- Avoid overly complex parameter generators; keep test clarity.
- Use `SetUpTestSuite` for expensive setup shared by all tests in fixture.
- Use fixtures to avoid repetitive setup in each test.

### Performance Considerations
- Parameterized tests with large parameter sets may increase test execution time.
- Careful with combining multiple parameter generators that create Cartesian products; use selective testing to limit combinations.

### Example Workflows
- **Data-driven test:** Use `TEST_P` with `ValuesIn` or `Range` to test multiple inputs.
- **Generic container tests:** Use typed tests to verify container operations on various element types.

---

## Next Steps & Related Content

- Learn mocking to integrate with fixtures: see [Mocking Workflows with GoogleMock](/guides/advanced-testing-patterns/mocking-workflows).
- Explore advanced assertions and how to handle test failures in [Essential Assertions and Failure Handling](/guides/getting-started/essential-assertions).
- Review the [GoogleTest Primer](../primer.md) for foundational concepts.
- Check [Handling Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for more advanced use cases.

---

## References & Further Reading

- [GoogleTest Testing Reference - Parameterized & Typed Tests](reference/testing.md#value-parameterized-tests)
- [GoogleTest Primer - Writing Tests and Fixtures](primer.md)
- [Advanced GoogleTest Topics - Parameterized & Typed Tests](advanced.md#value-parameterized-tests)
- [GoogleMock Cookbook - For Mock Classes and Actions](gmock_cook_book.md)

---

Your ability to write versatile and maintainable tests grows exponentially by mastering test fixtures, parameterized tests, and typed tests. Use these tools to make your testing more robust, expressive, and efficient.