---
title: "Parameterized and Type-Parameterized Tests"
description: "Implement tests that run over a range of values or types with minimal code duplication. This guide shows both value and type parameterization, with practical examples for comprehensive coverage."
---

# Parameterized and Type-Parameterized Tests

This guide demonstrates how to implement tests in GoogleTest that systematically run over a range of values or types, eliminating redundant code and ensuring comprehensive coverage with minimal effort. We cover both value and type parameterization techniques, complete with practical examples and instructions.

---

## 1. Overview of Parameterized and Type-Parameterized Tests

### What This Guide Covers
- How to define tests that execute multiple times with different input values (value-parameterized tests).
- How to define tests that run across a set of types (type-parameterized tests).
- Using GoogleTest macros and facilities to efficiently instantiate such tests.
- Accessing parameters within tests and organizing them for clear and maintainable code.

### Why Parameterization Matters
Imagine writing a test for a function that should work for multiple inputs or different types. Duplicating test code is error-prone and tedious. Parameterized tests enable you to write the logic once and automatically run it with various inputs or types, ensuring broader coverage and better maintainability.

### Prerequisites
- Basic familiarity with GoogleTest syntax, writing `TEST()` and `TEST_F()` tests.
- Understanding of test fixtures.
- A C++ compiler supporting C++11 or later.

### Expected Outcome
By following this guide, you will gain the ability to write tests that cover multiple values or types without duplicating code. Your test suite will be easier to expand and maintain.

---

## 2. Value-Parameterized Tests

Value-parameterized tests allow running a single test logic multiple times, each time with a different input value supplied by a parameter generator.

### Step 1: Define a Test Fixture Class Inheriting from `::testing::TestWithParam<T>`
Create a test fixture template and inherit from `TestWithParam`, where `T` is the parameter type.

```cpp
class MyTestSuite : public ::testing::TestWithParam<int> {
  // Optional: Define helper functions or variables if needed
};
```

### Step 2: Write Test Cases Using `TEST_P` Macro
Inside your parameterized test, access the parameter with `GetParam()`:

```cpp
TEST_P(MyTestSuite, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

### Step 3: Instantiate Your Test Suite with a Parameter Generator
Use `INSTANTIATE_TEST_SUITE_P()` to specify the values to run the test with.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues, MyTestSuite,
    ::testing::Values(1, 2, 3, 10));
```

Now, GoogleTest runs `MyTestSuite.IsPositive` as four tests, once per value.

### Parameter Generator Options
You can use various generators to supply parameters:
- `Values(v1, v2, ..., vN)` for explicit sets
- `Range(begin, end, step)` for sequences
- `Bool()` for true and false
- `ValuesIn(container_or_array)` to use a collection
- `Combine()` to create Cartesian products

### Example: Testing a Function with Multiple Inputs
```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ReturnsCorrectFactorial) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ExpectedValueFor(n));
}

INSTANTIATE_TEST_SUITE_P(
    Computations, FactorialTest,
    ::testing::Values(0, 1, 2, 5, 10));
```

### Using `ConvertGenerator` for Parameter Conversion
When the parameter types donâ€™t match exactly, use `ConvertGenerator` for explicit conversion:

```cpp
// Supposing your fixture uses a class 'MyParam'
INSTANTIATE_TEST_SUITE_P(
    MyConversion, MyTestSuite,
    ::testing::ConvertGenerator<std::tuple<int, bool>>(
        ::testing::Combine(::testing::Values(1, 2), ::testing::Bool())));
```

### Best Practices
- Use descriptive instantiation names in `INSTANTIATE_TEST_SUITE_P`.
- Use `PrintToStringParamName` or custom name generators to generate readable test names.
- Keep your parameters simple and relevant to the tested behavior.

---

## 3. Type-Parameterized Tests

Type-Parameterized tests run the same test logic using different types rather than just values.

### Step 1: Define a Typed Test Fixture Template
Create a class template derived from `::testing::Test` and define your test logic inside `TYPED_TEST`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // Test utility code here
};
```

### Step 2: Use `TYPED_TEST_SUITE` to Register the Types
Define a list of types, then register it.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Step 3: Write Tests with `TYPED_TEST`
Inside tests, use `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};  // Default construction
  (void)value;       // Avoid unused variable warning
  SUCCEED();         // Test passes as long as construction succeeds
}
```

### Step 4: Compile and Run
GoogleTest instantiates and runs a test for each type in `MyTypes`.

### Optional: Name Generator for Better Test Names
Implement a class with a template static method `GetName(int)` to specify meaningful test suite names. Example:

```cpp
class TypeNameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, char>) return "Char";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, TypeNameGenerator);
```

### Real-World Scenario
Testing container classes for correctness across multiple element types.

```cpp
template <typename T>
class QueueTest : public ::testing::Test {
  // Setup test data
};

using QueueTypes = ::testing::Types<int, std::string>;
TYPED_TEST_SUITE(QueueTest, QueueTypes);

TYPED_TEST(QueueTest, CanEnqueueAndDequeue) {
  TypeParam element{};
  Queue<TypeParam> queue;
  queue.Enqueue(element);
  EXPECT_EQ(queue.Dequeue(), element);
}
```

---

## 4. Advanced Parameterization

### Combining Value and Type Parameterization
Combining both provides powerful test suites that vary both input types and values:

```cpp
using CombinedParam = std::tuple<TypeParam, int>;

template <typename T>
class CombinedTest : public ::testing::TestWithParam<CombinedParam> {};

TYPED_TEST_SUITE_P(CombinedTest);

TYPED_TEST_P(CombinedTest, ProcessesCombination) {
  typename std::tuple_element<0, CombinedParam>::type type_value;
  int int_value = ::testing::TestWithParam<CombinedParam>::GetParam();
  ...
}

// Instantiation code omitted for brevity
```

### Naming Parameterized Tests
Use parameter and type name generators to produce readable test names.

### Using `GetParam()`
- Access your parameter via `GetParam()`, which returns the currently active parameter.
- For structured params (tuples), use `std::get<i>(GetParam())`.

### Tips
- Test parameter values should be deterministic and as small as possible.
- Avoid complex objects for parameters unless necessary.
- Refactor common parameterized test logic into fixtures.
- Use explicit `INSTANTIATE_TEST_SUITE_P` to keep control over test instances.

---

## 5. Troubleshooting & Tips

### Common Pitfalls
- Forgetting to instantiate the test suite: If you write a `TEST_P` or `TYPED_TEST` without an `INSTANTIATE_TEST_SUITE_P` or `TYPED_TEST_SUITE` call, your tests won't run.
- Misusing parameter types: Make sure parameter types used in fixtures match those generated.
- Overly strict expectations: Parameterized tests run with multiple inputs, so ensure your assertions accommodate all valid parameter cases.

### Best Practices
- Use parameterized tests to reduce code duplication and improve coverage.
- Use meaningful instantiation names and value/type print functions to clarify test outputs.
- Combine parameters smartly using `Combine()` for exhaustive coverage.
- Use `ConvertGenerator` for implicit or explicit type conversions.

### Performance Considerations
- Large Cartesian products can explode test count; balance thoroughness and speed.
- Use filtering options in test execution to run subsets efficiently.

---

## 6. Next Steps & Related Documentation

- Explore the [Writing Your First Test](../getting-started/first-test-run/create-first-test.mdx) guide for basic test creation.
- Read [Organizing and Running Test Suites](../guides/getting-started/organizing-test-suites.mdx) to manage complex test suites.
- See [Using Assertions Effectively](../guides/getting-started/using-assertions.mdx) to write clearer assertions.
- For advanced needs, dig into the [Mocking with GoogleMock](../guides/advanced-testing-patterns/using-googlemock.mdx) guide.
- Review [Parameterized and Typed Testing Concepts](../concepts/core-architecture/parameterized-testing.mdx) for core theory.

---

## 7. References

- [`TEST_P` and `INSTANTIATE_TEST_SUITE_P` - Testing Reference](../docs/reference/testing.md#TEST_P)
- [`TYPED_TEST_SUITE` and `TYPED_TEST` - Testing Reference](../docs/reference/testing.md#TYPED_TEST_SUITE)
- [GoogleTest Advanced Guide: Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [GoogleTest Advanced Guide: Typed Tests](../advanced.md#typed-tests)

---

By mastering parameterized and type-parameterized tests, you ensure your code is tested against a broad set of scenarios while keeping your test code clean, maintainable, and scalable.