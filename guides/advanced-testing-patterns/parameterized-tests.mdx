---
title: "Value and Type Parameterized Tests"
description: "Step-by-step demonstration of creating parameterized and type-parameterized tests, including real use cases and advice for code reuse and coverage across multiple input values or data types."
---

# Value and Type Parameterized Tests

This guide provides a clear, step-by-step approach to creating **value-parameterized** and **type-parameterized tests** using GoogleTest. You'll learn how to reuse test logic across multiple input values or data types, ensuring broad coverage with minimal duplication. Practical use cases, examples, and tips are included to help you design robust and maintainable test suites.

---

## 1. Workflow Overview

### What This Guide Helps You Accomplish
- Learn how to write **value-parameterized tests** that run the same test logic over different input values.
- Discover how to write **type-parameterized tests** that run identical tests over multiple data types.
- Understand how to instantiate these tests properly to cover diverse cases with concise code.

### Prerequisites
- Familiarity with basic GoogleTest usage (`TEST`, `TEST_F`).
- Understanding of C++ templates and types for type-parameterized tests.
- GoogleTest included in your project with `#include <gtest/gtest.h>`.

### Expected Outcome
By following this guide, you will confidently write and instantiate tests that:
- Execute the same test logic repeatedly over supplied value sets (value-parameterized).
- Execute the same test logic across multiple types (typed and type-parameterized tests).
- Utilize provided parameter generators and instantiate tests with clear, user-friendly names.

### Time Estimate
About 20–30 minutes to read and implement your first parameterized tests.

### Difficulty Level
Intermediate: Requires some knowledge of C++ testing and templates.

---

## 2. Creating Value-Parameterized Tests

### Step 1: Define a Parameterized Test Fixture
Derive your fixture class from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Your setup and member functions
};
```

### Step 2: Write Parameterized Test Cases Using `TEST_P`
Define tests that access the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, HandlesValues) {
  int param = GetParam();
  EXPECT_GT(param, 0);
  // Add your test logic using param.
}
```

### Step 3: Instantiate the Test Suite with Parameters Using `INSTANTIATE_TEST_SUITE_P`
Specify the parameters with GoogleTest parameter generators like `Values()`, `Range()`, `ValuesIn()`, or combinations.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveIntegers, FooTest,
    testing::Values(1, 10, 100));
```

- This runs the test for parameters 1, 10, and 100. Each instantiation generates a test with a unique name suffix.

### Practical Parameter Generators Overview
| Generator         | Description                                                                                            |
| ----------------- | -------------------------------------------------------------------------------------------------- |
| `Range(start,end [,step])` | Produces sequential values starting from `start` up to but not including `end` with optional step. |
| `Values(v1, v2, ..., vN)`   | Generate explicitly listed values.                                                                  |
| `ValuesIn(container)`        | Generates values from any STL container or array.                                                  |
| `Bool()`                    | Generates `false` and `true`.                                                                       |
| `Combine(g1, g2, ..., gN)`  | Cartesian product, combines multiple generators to generate tuples of parameters.                   |

### Step 4: (Optional) Customize Parameterized Test Naming
By default, GoogleTest names parameterized tests with numerical suffixes. To improve readability:

- Use the built-in `testing::PrintToStringParamName` for printable types.
- Provide a custom naming function/functor that takes a `TestParamInfo` to produce valid test suffixes (alphanumeric and underscores only).

Example of custom naming:
```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

### Verification
- Run your tests with `--gtest_list_tests` to confirm parameterized tests and names are generated.
- Use filters like `--gtest_filter=MyInstantiation/FooTest.*` to run specific parameterized tests.

### Common Pitfalls & Notes
- Each `INSTANTIATE_TEST_SUITE_P` must have a unique prefix.
- `INSTANTIATE_TEST_SUITE_P` instantiates *all* tests defined with `TEST_P` in the suite.
- If you define `TEST_P` but do not instantiate, GoogleTest will report a failure unless tagged with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- If parameters are complex, overriding `PrintToString()` or providing custom naming helps test output clarity.

---

## 3. Creating Typed Tests

Typed tests allow repeating the exact same test logic for different data types.

### Step 1: Declare a Test Fixture Template Class
Create a class template deriving from `testing::Test`.

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T value_ = T(0);
};
```

### Step 2: Define the List of Types
Use the `::testing::Types<>` template to declare types.

```cpp
using NumericTypes = ::testing::Types<int, float, double>;
``` 

### Step 3: Associate the Types with Your Fixture Using `TYPED_TEST_SUITE`

```cpp
TYPED_TEST_SUITE(NumericTest, NumericTypes);
```

If your type list contains a single type, you may write only that type.

### Step 4: Write Typed Tests with `TYPED_TEST`
Within each test, refer to the type parameter as `TypeParam`. Access fixture members via `this->`.

```cpp
TYPED_TEST(NumericTest, IsZeroInitially) {
  TypeParam expected = TypeParam(0);
  EXPECT_EQ(this->value_, expected);
}
```

You can define multiple tests within the same suite using `TYPED_TEST`.

### Step 5: Run Tests Normally
Tests will run once for each type in the list with clear output names.

### Customizing Type Names in Output
Provide a name generator type with a static template `GetName(int)` method:

```cpp
class MyTypeName {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, float>) return "float";
    if constexpr (std::is_same_v<T, double>) return "double";
    return "unknown";
  }
};

TYPED_TEST_SUITE(NumericTest, NumericTypes, MyTypeName);
```

### Notes
- The test suite name is the fixture name.
- `TYPED_TEST` replaces `TEST_F` when using typed tests.
- The test framework creates separate tests per type.

---

## 4. Creating Type-Parameterized Tests

Type-parameterized tests form abstract test suites that can be instantiated repeatedly with different type lists.

### Step 1: Declare a Fixture Template and Register with `TYPED_TEST_SUITE_P`

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyTypeParamTest);
```

### Step 2: Define Type-Parameterized Tests using `TYPED_TEST_P`

```cpp
TYPED_TEST_P(MyTypeParamTest, TestSomething) {
  TypeParam val{};
  EXPECT_TRUE(SomeCheck(val));
}
```

Define as many tests as needed.

### Step 3: Register Tests

Register the test names to prepare for instantiation.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestSomething);
```

### Step 4: Instantiate Tests Using `INSTANTIATE_TYPED_TEST_SUITE_P`

Supply the prefix, test fixture, and a list of types as before.

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, MyTypeParamTest, MyTypes);
```

You can instantiate the same pattern multiple times with different type lists.

### Summary of Differences
| Typed Tests                         | Type-Parameterized Tests                  |
|-----------------------------------|------------------------------------------|
| Type list known at test definition| Type list supplied later, can instantiate multiple times |
| Define test fixtures and types together| Define fixture and tests separately then instantiate|

---

## 5. Real-World Examples

### Example: Value-Parameterized Test with Combinations

```cpp
class MathTest : public testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(MathTest, WorksForMultipleInputs) {
  int number;
  bool flag;
  std::tie(number, flag) = GetParam();
  EXPECT_GE(number, 0);
  if (flag) {
    EXPECT_TRUE(number % 2 == 0);
  }
}

INSTANTIATE_TEST_SUITE_P(
    AllCases, MathTest,
    testing::Combine(testing::Values(0, 2, 3), testing::Bool()));
```

### Example: Typed Test Suite with Custom Type Names

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container_;
};

using Containers = ::testing::Types<std::vector<int>, std::list<int>>;

class ContainerNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, std::vector<int>>) return "Vector";
    if constexpr (std::is_same_v<T, std::list<int>>) return "List";
  }
};

TYPED_TEST_SUITE(ContainerTest, Containers, ContainerNames);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

---

## 6. Troubleshooting & Tips

### Common Issues
- **Tests not instantiated**: Ensure you call the appropriate `INSTANTIATE_TEST_SUITE_P` macros.
- **Invalid test parameter names**: Custom names must be alphanumeric or underscores only; illegal characters cause registration errors.
- **Test failures not related to logic**: Check that parameter types and fixture parameter types are compatible.
- **Name collisions in typed tests**: Customize type name generation to avoid ambiguous output.

### Best Practices
- Use typed and parameterized tests to **avoid duplicating test code**.
- Customize parameter names for clearer **failure messages** and filtering.
- For complex parameters, teach GoogleTest how to print them using `PrintTo()` or `AbslStringify()`.
- Use `Combine()` sparingly — the Cartesian product grows exponentially with parameters.
- Remember that `INSTANTIATE_TEST_SUITE_P` executes after `InitGoogleTest()`. Use runtime values carefully.

### Performance & Coverage
- Parameterized tests can dramatically increase test coverage with little code.
- Avoid overly large parameter ranges to keep test runtime reasonable.

---

## 7. Next Steps & Related Content

- Learn [Writing Your First Unit Test](/guides/getting-started-workflows/first-cpp-test) to build foundations.
- Explore [Mocking Basics](/guides/getting-started-workflows/mocking-basics) for mock objects in parameterized contexts.
- See [Specifying Names for Value-Parameterized Test Parameters](/docs/advanced.md#value-parameterized-tests) for advanced naming.
- Review [Typed Tests and Type-Parameterized Tests](/docs/reference/testing.md#TYPED_TEST_SUITE) in the official testing reference.

---

### Additional Resources
- [GoogleTest Primer](docs/primer.md) for overall basics.
- [Parameterized & Typed Tests Reference](docs/reference/testing.md#TEST_P)
- Sample code in Googletest GitHub repository, e.g., `samples/sample7_unittest.cc`, `sample6_unittest.cc`.

---

### Practical Tips at a Glance
<Tip>
- Always instantiate your parameterized test suites to avoid false failures.
- Customize test name generation for better test reports.
- Use `GetParam()` carefully — it's a copy; consider const ref if needed.
- Typed tests require template fixture classes.
- Avoid underscores in test and suite names to prevent conflicts.
</Tip>

---