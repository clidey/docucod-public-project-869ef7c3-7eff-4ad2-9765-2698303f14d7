---
title: "Sample Use Cases & Recipes"
description: "Explore battle-tested recipes and real-world examples: database testing, networking code, legacy code refactoring, and more. Each scenario provides practical C++ test code patterns to inspire your own robust solutions."
---

# Sample Use Cases & Recipes

Explore battle-tested recipes and real-world examples: database testing, networking code, legacy code refactoring, and more. Each scenario provides practical C++ test code patterns to inspire your own robust solutions.

---

## Workflow Overview

### Task Description
This page helps you explore practical, real-world usage patterns of GoogleTest and GoogleMock for writing robust, maintainable C++ tests. It offers battle-tested recipes for common but challenging scenarios such as testing database interactions, networking code, and refactoring legacy code. Each example provides concrete test code patterns, highlighting best practices and pitfalls to avoid.

### Prerequisites
- Familiarity with writing basic GoogleTest and GoogleMock tests (see the [Getting Started guides](../getting-started/first-test-experience/))
- A C++ environment with GoogleTest and GoogleMock integrated
- Basic understanding of mocking concepts and macros such as `MOCK_METHOD`, `EXPECT_CALL`, and `ON_CALL`

### Expected Outcome
By following the use cases and recipes presented here, you will gain actionable patterns to implement reliable tests in complex C++ scenarios. These recipes will help you:
- Write tests that cover hard-to-test legacy or third-party code
- Handle asynchronous or network-bound functions with mocks
- Structure expectations and actions effectively
- Avoid common mock pitfalls and debugging traps

### Time Estimate
Reading and applying these recipes will vary based on your familiarity but expect to spend 30–60 minutes per scenario to fully understand and adapt the patterns.

### Difficulty Level
Intermediate to Advanced. Designed for developers comfortable with GoogleTest/GoogleMock basics seeking practical, reusable techniques.

---

## Step-by-Step Instructions

Each use case is presented as a storytelling flow that anticipates user goals, challenges, and the needed test constructs:

### 1. Define or identify the interface to mock
- Use `MOCK_METHOD` macros to declare mock methods for virtual functions or interfaces.
- For complex or overloaded methods, consider using alias types or wrappers to simplify mocking.

### 2. Configure default mock behaviors using `ON_CALL` for shared/common behavior
- Use `ON_CALL` to specify what happens when methods are called without explicit expectations.
- This avoids noise from uninteresting calls and provides sensible defaults.

### 3. Set explicit expectations using `EXPECT_CALL` where necessary
- Use argument matchers (`_`, `Eq()`, `Ge()`, `Ref()`, etc.) to specify call parameters.
- Chain clauses such as `.Times()`, `.WillOnce()`, `.WillRepeatedly()`, `.InSequence()`, and `.RetiresOnSaturation()` to fully specify call behavior and order.

### 4. Use sequences or `After()` clauses to express call order when needed
- Use `Sequence` objects or `InSequence` blocks to enforce order.
- Use `After()` to specify partial order or prerequisite calls.

### 5. Run tests and utilize GoogleMock verbose flags for debugging
- Use `--gmock_verbose=info` to see detailed call and expectation match logs.
- Investigate warnings about uninteresting calls and unexpected calls to uncover test gaps.

### 6. Verify mock object lifetime and expectation clearing
- Ensure mock objects are properly destructed to trigger verification.
- Use `Mock::AllowLeak()` if leaking is intentional, with justification.
- Use `Mock::VerifyAndClearExpectations()` for explicit verification before destruction if necessary.

---

## Examples & Code Samples

### Example 1: Mocking a legacy class with move-only types
```cpp
class Buzz {
 public:
  explicit Buzz(AccessLevel access);
};

class Buzzer {
 public:
  virtual ~Buzzer() {}
  virtual std::unique_ptr<Buzz> MakeBuzz(StringPiece text) = 0;
  virtual bool ShareBuzz(std::unique_ptr<Buzz> buzz, int64_t timestamp) = 0;
};

class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));
  MOCK_METHOD(bool, ShareBuzz, (std::unique_ptr<Buzz> buzz, int64_t timestamp), (override));
};
```

Test usage with move-only types:
```cpp
MockBuzzer mock_buzzer;

EXPECT_CALL(mock_buzzer, MakeBuzz("hello"))
    .WillOnce(Return(std::make_unique<Buzz>(AccessLevel::kInternal)));

EXPECT_CALL(mock_buzzer, ShareBuzz(NotNull(), _)).WillOnce(Return(true));

auto buzz = mock_buzzer.MakeBuzz("hello");
EXPECT_NE(nullptr, buzz);
EXPECT_TRUE(mock_buzzer.ShareBuzz(std::move(buzz), 0));
```

### Example 2: Specifying call sequences and partial orders
```cpp
using ::testing::Sequence;

Sequence s1, s2;

EXPECT_CALL(mock, Start())
    .InSequence(s1, s2);
EXPECT_CALL(mock, Step1())
    .InSequence(s1);
EXPECT_CALL(mock, Step2())
    .InSequence(s2);
EXPECT_CALL(mock, Finish())
    .After(s1).
    After(s2);
```

This enforces that `Start()` precedes both `Step1()` and `Step2()`, and `Finish()` occurs after both `Step1()` and `Step2()`.

### Example 3: Using `ON_CALL` to define default behaviors
```cpp
ON_CALL(mock, Compute(_))
    .WillByDefault(Return(42));

EXPECT_CALL(mock, Compute(5))
    .WillOnce(Return(50));
```
The default `Compute` returns 42 for arguments except `5`, where it returns 50.

### Example 4: Handling uninteresting calls and suppressing warnings
```cpp
using ::testing::NiceMock;

NiceMock<MockClass> mock;

// No EXPECT_CALL for Foo(), so calls to Foo() won’t trigger warnings
mock.Foo(10);
```

### Example 5: Delegating mocks to real or fake objects
```cpp
class FakeFoo : public Foo {
 public:
  char DoThis(int n) override {
    // real logic
  }
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(char, DoThis, (int n), (override));

  void DelegateToFake() {
    ON_CALL(*this, DoThis).WillByDefault(
        [this](int n) { return fake_.DoThis(n); });
  }

 private:
  FakeFoo fake_;
};

// Test
MockFoo mock;
mock.DelegateToFake();
EXPECT_CALL(mock, DoThis(5));
mock.DoThis(5); // Uses FakeFoo behavior
```

---

## Troubleshooting & Tips

### Common Issues

- **Uninteresting calls warning:** If you see warnings about uninteresting calls, consider whether those calls should be expected. Using `NiceMock` can suppress these warnings if the calls are unimportant.

- **Unexpected call failures:** Occur if a mock method is called with arguments that don't match any `EXPECT_CALL`. Check your expectations' matchers and consider adding catch-all expectations with `_` and `Times(AnyNumber())` if needed.

- **Excessive calls:** Calling a mock method more times than expected triggers failures. Use `.Times(AnyNumber())` for unlimited calls, or `.RetiresOnSaturation()` to retire expectations after saturation.

- **Retired expectations mismatch:** If a call matches a retired expectation, it will not be accepted. Review use of `.RetiresOnSaturation()` and call ordering.

- **Leaked mocks:** Tests that fail with leaked mock object errors indicate mocks were not deleted and their expectations not verified. Use `Mock::AllowLeak()` sparingly or ensure proper ownership.

- **Compilation errors with complex signatures:** Wrap types with commas in parentheses or use type aliases in `MOCK_METHOD` declarations.

### Best Practices

- Use `ON_CALL` to set default behaviors shared across tests; reserve `EXPECT_CALL` for verifying specific interactions.
- Avoid over-specifying expectations; prefer catch-all expectations with `_` to reduce test brittleness.
- Specify call order explicitly using `Sequence` or `InSequence` to avoid flaky tests.
- Use `RetiresOnSaturation()` when defining multiple expectations for the same method that should not overlap in call counts.
- Leverage GoogleMock verbosity flags (`--gmock_verbose=info|warning|error`) to debug test failures.
- Test your mocks early and incrementally; verify expectations and adjust your mock declarations to match real code behavior.

### Performance Considerations

- Prefer moving constructor and destructor definitions of mock classes to `.cc` files to speed up compilation.
- Reuse matcher and action objects when possible to minimize overhead.

### Alternative Approaches

- Use delegating mocks to fake or real objects when partial real behavior is needed.
- Mock interfaces rather than concrete classes to maintain flexible and maintainable tests.

---

## Next Steps & Related Content

- After learning recipes here, explore the [Building & Using Mocks](../guides/mocking-advanced-usage/building-mocks) guide for detailed mock class techniques.
- Enhance your understanding of [Custom Actions & Matchers](../guides/mocking-advanced-usage/custom-actions-and-matchers) for advanced mock behavior.
- Use [Nice, Naggy, and Strict Mocks](../guides/mocking-advanced-usage/nice-strict-mocks) to fine-tune test strictness.
- For integration, see [Integrating with Build Systems & External Tools](../guides/mocking-advanced-usage/integration-with-build-systems).
- Consult [Debugging Common Test Failures](../guides/real-world-patterns/debugging-common-failures) to interpret and fix broken tests.
- For foundational concepts, refer to [Core Concepts & Terminology](../../overview/fundamentals-and-architecture/core-concepts-and-terminology).

---

## Additional Resources

- [gMock Cheat Sheet](../docs/gmock_cheat_sheet.md)
- [gMock Cookbook](../docs/gmock_cook_book.md)
- [gMock for Dummies](../docs/gmock_for_dummies.md)
- [Mocking Reference](../docs/reference/mocking.md)

---