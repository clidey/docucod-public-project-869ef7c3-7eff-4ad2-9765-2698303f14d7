---
title: "Test Performance Optimization Tips"
description: "Actionable strategies for reducing test suite runtime and increasing feedback speed. Includes advice on test parallelization, fixture design, avoiding global state, and selective test execution."
---

# Test Performance Optimization Tips

## Overview

This guide provides practical strategies to reduce your GoogleTest and GoogleMock test suite runtime and accelerate the feedback loop during development. Improving the performance of your tests helps maintain productivity and enables continuous integration systems to run tests efficiently.

## Prerequisites

- A working GoogleTest and GoogleMock test suite.
- Familiarity with writing tests, test fixtures, and mock classes.
- Control over test code and test fixture design.

## Expected Outcome

By following this guide, you will:
- Decrease the time spent waiting for your test suite to complete.
- Understand how to parallelize tests and improve fixture efficiency.
- Learn best practices to avoid common performance pitfalls.

## Time Estimate

Optimizing your test suite may take from a few minutes to several hours depending on the size and complexity of your existing tests.

## Difficulty Level

Intermediate to Advanced, as it involves refactoring test code and adjusting test execution settings.

---

## 1. Test Parallelization

Test parallelization leverages concurrency to run tests simultaneously across multiple threads or processes. GoogleTest supports two main parallelization mechanisms:

- **Test Sharding:** Using environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX`, you can split your entire test suite across multiple machines or processes.
- **Test Process Parallelism:** Running multiple test executables or instances in parallel externally or via CI orchestration.

### How to Use Test Sharding

1. Determine how many shards (parallel runners) you want.
2. Set the environment variable `GTEST_TOTAL_SHARDS` to the total number of shards.
3. Set `GTEST_SHARD_INDEX` to the shard index that each machine or process will run (0 to `GTEST_TOTAL_SHARDS - 1`).
4. Run the test executable on all shards with their respective shard index.

### Benefits

- Distributes test load.
- Enables near-linear speed up depending on hardware resources.

### Caveats

- Tests must be isolated with no shared global state.
- Sharding divides tests deterministically; if tests are unevenly slow, your shards might be unbalanced.

<Check>
Ensure tests are independent and do not rely on shared resources not isolated per process.
</Check>

## 2. Fixture Design Optimization

Creating and tearing down expensive test fixtures can dominate test runtime. Optimize test fixtures for better performance with these best practices:

### Use Per-Test-Suite Setup and Teardown

- Use `static void SetUpTestSuite()` and `static void TearDownTestSuite()` in your `Test` fixture class to initialize shared, expensive resources only once per test suite instead of per test.

- Make sure tests do not modify shared state or properly restore it.

### Minimize Work Done in `SetUp()` and `TearDown()`

- Keep per-test setup and teardown lightweight.
- Move heavy initialization to the test suite setup.

### Prefer Constructor Initialization

- Initialize constant members in the fixture constructor for better compiler optimizations.

<Note>
GoogleTest creates a fresh fixture object per test and calls `SetUp()` before each test, so reduce redundant operations for faster execution.
</Note>

## 3. Avoid Global State and Side Effects

Global state shared across tests can cause hidden dependencies and require complex setup and synchronization, slowing performance and causing unpredictability.

### Recommendations

- Remove or minimize global variables used by tests.
- Use test fixtures to control state scoping.
- Make tests deterministic and side-effect free.

## 4. Selective and Filtered Test Execution

Reducing the number of tests run during development cycles can dramatically speed feedback:

### Filter Tests Using `--gtest_filter`

- Use the `--gtest_filter` flag to run only a subset of tests by name pattern.
- Example: `./my_test --gtest_filter=MySuite.*` runs all tests in `MySuite`.

### Disable or Exclude Slow or Long-Running Tests

- Mark slow tests with a distinctive test or test suite name.
- Use filters excluding slow tests during rapid iteration, e.g., `--gtest_filter=-*SlowTest.*`.

### Use `DISABLED_` Prefix for Temporary Skip

- Add `DISABLED_` prefix to disable tests temporarily while preserving them in source.

### Automate Test Prioritization

- Integrate test selection with your build or CI system.

## 5. Parallel Test Execution at the Test Binary Level

If you organize tests into multiple smaller test executables (recommended), these can be executed simultaneously by your build system or CI.

### Benefits

- Better CPU core utilization.

### Tips

- Partition tests logically.
- Ensure test binaries have balanced workloads.

<Warning>
Beware of flaky tests that may cause test parallelization to hide intermittent failures.
</Warning>

## 6. Using Lightweight Mocks and Stubs

Mocks that perform heavy computations or setup slow down test execution.

### Tips

- Simplify mock behavior using `ON_CALL` with default simple actions.
- Avoid over-specifying expectations that cause unnecessary complexity.
- Use `NiceMock` to reduce overhead from uninteresting calls warnings during performance runs.

## 7. Optimize Assertions and Matchers

Using complex or custom matchers and assertions can add parsing and execution overhead.

### Recommendations

- Use simple matchers when possible.
- Avoid expensive operations in assertions.
- Use `EXPECT_*` (non-fatal) assertions where test should continue.

## 8. Running Tests Repeatedly vs Verbose Logging

### Minimize Logging

- Avoid verbose logging or debug output when running performance tests.
- Use `--gmock_verbose=error` or `--gtest_brief=1` to reduce output overhead.

### Repeated Runs

- Use `--gtest_repeat=N` only when debugging; repeated runs increase total runtime.

## 9. Example: Parallelizing a Large Test Suite

Suppose your project has a large test executable `project_test` which runs 500 tests serially taking 15 minutes total.

### Steps

1. Split tests into logically grouped smaller executables, e.g., `project_core_test`, `project_network_test`, etc.
2. Enable CI parallelism to run these test binaries simultaneously.
3. Use `--gtest_filter` during development to run only tests relevant to your recent changes.
4. Use the `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` to distribute tests across multiple nodes for further speedup during CI runs.

## Troubleshooting & Tips

<AccordionGroup title="Common Performance Issues and Solutions">
<Accordion title="Tests Not Running in Parallel">
If your tests do not parallelize fully:
- Confirm you have set `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` correctly.
- Check for shared global state or static variables causing dependency conflicts.
- Verify your CI environment supports parallel execution.
</Accordion>
<Accordion title="Fixture Setup Overhead">
If fixture setup is slow:
- Move heavy initialization to `SetUpTestSuite()`.
- Use static members for shared expensive resources.
- Avoid per-test rebuilding of large objects.
</Accordion>
<Accordion title="Flaky Tests with Parallel Execution">
Flaky tests may pass or fail nondeterministically when run in parallel:
- Use synchronization primitives in multi-threaded tests.
- Isolate shared resources.
- Run flaky tests separately.
</Accordion>
</AccordionGroup>

## Next Steps & Related Content

- Read [Scaling and Maintaining Large Test Suites](guides/integration-best-practices/scaling-maintaining-tests.md) for organizational strategies.
- Explore [Integrating with Build Systems & CI](guides/integration-best-practices/build-system-integration.md) to automate your optimized tests.
- Review [Test Fixtures & Parameterized Testing](guides/core-test-workflows/structured-fixtures-parameterized-tests.md) to improve fixture efficiency.
- Study [Basic Mocking with GoogleMock](guides/getting-started/basic-mocking.md) to create lightweight mocks.

---

## Summary

Effective test performance optimization in GoogleTest involves running tests in parallel through sharding or multiple binaries, designing efficient test fixtures, minimizing global state, selectively executing tests, and optimizing mock and assertion behavior. Combining these techniques ensures faster iterations and scalable test suites.

---

# Appendix: Relevant Commands and Flags

- `--gtest_filter=pattern` — Run a filtered subset of tests.
- `--gtest_repeat=N` — Repeat tests N times.
- `--gtest_shuffle` — Randomize test order.
- `--gtest_break_on_failure` — Pause on first failure.
- `GTEST_TOTAL_SHARDS` / `GTEST_SHARD_INDEX` — Environment variables for sharding test execution.
- `--gmock_verbose=LEVEL` — Controls verbosity (info, warning, error).
- Use `SetUpTestSuite()` / `TearDownTestSuite()` for per-suite fixture setup.

---

# Practical Example: Using Sharding Environment Variables

```bash
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=0  # Run this on machine 1
./my_test

export GTEST_SHARD_INDEX=1  # Run this on machine 2
./my_test

export GTEST_SHARD_INDEX=2  # Run this on machine 3
./my_test

export GTEST_SHARD_INDEX=3  # Run this on machine 4
./my_test
```

Each shard will execute a distinct subset of tests, allowing parallel speedup.

---