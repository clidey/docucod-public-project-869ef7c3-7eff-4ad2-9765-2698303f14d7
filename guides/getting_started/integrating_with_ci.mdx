---
title: "Integrating Tests with Continuous Integration (CI)"
description: "Best practices for integrating your tests with CI workflows, including sample shell scripts, recommended test runners, and advice for automation on popular platforms."
---

# Integrating Tests with Continuous Integration (CI)

GoogleTest and GoogleMock are designed to be easily integrated into continuous integration (CI) workflows, enabling high-quality, automated testing as part of your software delivery pipeline. This guide provides best practices, practical advice, and sample scripts for integrating your C++ test suites with popular CI platforms.

---

## 1. Understanding the CI Integration Workflow

### What This Guide Helps You Accomplish
This guide helps you embed your GoogleTest and GoogleMock tests seamlessly into automated CI pipelines. It covers setting up test execution, capturing results, handling failures, and automating workflows to maximize developer productivity and test reliability.

### Prerequisites
- A working GoogleTest and GoogleMock test suite configured and building successfully.
- Access to your CI environment (e.g., Jenkins, GitHub Actions, GitLab CI, Travis CI).
- Familiarity with your CI's configuration files and scripting environment.

### Expected Outcomes
- Automated triggering of tests on code changes.
- Test results reported clearly, with pass/fail status.
- Early feedback on regressions and issues.
- Ability to incorporate test runs into build status and quality gates.

### Time Estimate
Integrating basic test runs usually takes 30-60 minutes. Advanced steps, such as parallel test execution or custom reporting, may require more time.

### Difficulty Level
Intermediate: This assumes basic experience with CI and C++ build systems.

---

## 2. Step-by-Step Integration Instructions

<Steps>
<Step title="Prepare Your Test Executable">
Ensure your test executable builds and runs successfully in your local environment. The executable should:
- Link to GoogleTest and GoogleMock libraries properly.
- Run `RUN_ALL_TESTS()` and return exit code 0 on success, 1 on failure.
- Output results in a standard form (GoogleTest's default console output).

Example basic test main function:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

After building, verify locally:
```bash
./your_test_binary
```
You should see detailed test results and a success/failure summary.

</Step>

<Step title="Configure Your CI Environment to Build Your Tests">
In your CI pipeline configuration file (e.g., Jenkinsfile, `.github/workflows/...yml`, `.gitlab-ci.yml`), add steps to:

- Check out your source code.
- Install required dependencies (compiler, CMake, etc.).
- Build your tests by invoking your build system.

Example Jenkins pipeline snippet:

```groovy
stage('Build') {
  steps {
    sh 'mkdir -p build && cd build && cmake .. && make -j$(nproc)'
  }
}
```


This ensures the CI environment generates the test executables needed.
</Step>

<Step title="Invoke Tests with Suitable Test Runner Options">
Execute your test binaries in your pipeline with options that provide:

- Verbose output for debugging.
- Enriched logs if needed (`--gtest_verbose=info`).
- XML output for machine-readable reports (JUnit format). GoogleTest supports this via the `--gtest_output=xml:<file>` flag.

Example:

```bash
./your_test_binary --gtest_output=xml:report.xml
```

This generates an XML report (`report.xml`) that your CI can collect and display.
</Step>

<Step title="Collect and Publish Test Results">
Use your CIâ€™s native support to parse and present test results.

For example, in Jenkins, configure the `JUnit` post-build action to read the generated `report.xml`. This allows features like:
- Pass/fail marks.
- Test duration tracking.
- Trends and history.

In GitHub Actions, use the `actions/upload-artifact` action to upload the report as an artifact or use a third-party action that parses GoogleTest XML and annotates PRs with test results.
</Step>

<Step title="Handling Test Failures in CI">
Configure the CI to:
- Mark the build as failed if tests fail (exit code != 0).
- Optionally proceed to further steps only if tests succeed.
- Save test logs and artifacts for debugging.

Example Jenkins Pipeline:

```groovy
stage('Run tests') {
  steps {
    sh script: './your_test_binary --gtest_output=xml:report.xml', returnStatus: true
  }
  post {
    unsuccessful {
      archiveArtifacts 'report.xml'
    }
  }
}
```
</Step>

<Step title="Optimizing Test Execution">
For large test suites:
- Enable parallel test execution using `--gtest_parallel` or external test runners.
- Divide tests across CI agents using filtering options like `--gtest_filter`.
- Cache built dependencies and artifacts between CI runs.

Tip: Use `--gtest_filter` with patterns:
```bash
./your_test_binary --gtest_filter=TestSuiteName.TestName
```
to run specific tests if needed.
</Step>

<Step title="Advanced: Mocking and Dependency Injection in CI">
If your tests use sophisticated mocks, ensure:
- All dependency mocks are included in the build.
- Initialization of mocks (possibly GoogleMock initialization) is configured correctly.

Typical mock initialization in main():

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleMock(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This ensures mocks are registered and expectations are verified on teardown.
</Step>
</Steps>

---

## 3. Example: GitHub Actions Workflow Snippet

```yaml
name: C++ CI

on: [push, pull_request]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y cmake g++ libgtest-dev

      - name: Configure and Build
        run: |
          mkdir build
          cd build
          cmake ..
          make -j

      - name: Run Tests
        run: ./build/your_test_binary --gtest_output=xml:report.xml

      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: report.xml
```

This simple workflow builds the tests, executes them with XML reporting enabled, and uploads the test report as an artifact for further inspection.

---

## 4. Troubleshooting Common CI Issues

<AccordionGroup title="Troubleshooting CI Integration">
<Accordion title="Test Executable Not Found">
Ensure your build steps produce the test binary at the expected location. Use absolute or workspace-relative paths consistently.
</Accordion>
<Accordion title="Tests Are Not Run or Report Zero Tests">
- Confirm tests are registered properly using the `TEST` or `TEST_F` macros.
- Make sure `RUN_ALL_TESTS()` is called in `main()`.
- Verify that test discovery is not filtered unintentionally by `--gtest_filter`.
</Accordion>
<Accordion title="XML Report Not Generated or Parsed">
- Use a recent version of GoogleTest supporting `--gtest_output=xml`.
- Confirm the output file path is writable in CI.
- For CI systems expecting specific file names, rename or move the report accordingly.
</Accordion>
<Accordion title="Tests Fail Without Useful Logs">
- Use `--gtest_color=yes` for improved console output.
- Use `--gtest_verbose=info` for more detailed mock call tracing.
- Capture and archive console logs in your CI.
</Accordion>
</AccordionGroup>

---

## 5. Best Practices & Tips

- **Use the XML output feature** to integrate with CI dashboards effectively.
- **Keep tests fast and independent** to reduce pipeline bottlenecks.
- **Suppress warnings on uninteresting mock calls** with `NiceMock` to avoid log noise.
- **Leverage CI cache** to speed up installation of dependencies.
- **Use CI environment variables** to customize test execution (e.g., run slower tests conditionally).
- **Automate running tests on multiple platforms** (Linux, Windows, macOS) for cross-platform coverage.

---

## 6. Next Steps & Related Content

- Explore the [Setting Up GoogleTest and GoogleMock Guide](/guides/getting_started/project_setup) for detailed build and configuration instructions.
- Learn how to write unit and mock tests in the [Writing Your First Unit and Mock Tests Guide](/guides/getting_started/writing_first_tests).
- Combine your CI integration with [Integration & Ecosystem](/overview/architecture-concepts/integration-ecosystem) concepts for a comprehensive understanding.
- Review [Troubleshooting Common Setup Issues](/getting-started/first-steps-usage-validation/troubleshooting-common-issues) for resolving CI-related build or test failures.

---

## 7. Additional Resources

- GoogleTest Official Repository: https://github.com/google/googletest
- GoogleTest Primer: https://google.github.io/googletest/primer.html
- gMock Cookbook for advanced mocking patterns: https://google.github.io/googletest/gmock_cook_book.html
- GoogleTest XML output specification: https://github.com/google/googletest/blob/main/googletest/docs/advanced.md#generating-xml-test-reports


---

Integrating your tests with CI is a pivotal step for continuous quality assurance. Following this guide will empower your team to catch regressions quickly, enforce test discipline, and maintain high code quality effortlessly.