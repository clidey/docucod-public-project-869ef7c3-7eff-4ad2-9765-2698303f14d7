---
title: "Working with Parameterized and Typed Tests"
description: "Master the use of value-parameterized and type-parameterized tests to maximize coverage while minimizing code duplication. Learn how to define, instantiate, and organize complex test suites that exercise your code under various inputs and type conditions."
---

# Working with Parameterized and Typed Tests

GoogleTest empowers you to write *value-parameterized* and *type-parameterized* tests that dramatically expand your test coverage while minimizing repetitive code. This page guides you through mastering these features, allowing you to define, instantiate, and organize complex test suites that systematically verify your code against diverse input values and multiple types.

---

## Workflow Overview

### What You Will Achieve

By following this guide, you will:
- Write *value-parameterized tests* to run the same test logic over multiple input values.
- Create *typed tests* to apply one test suite to multiple C++ types without duplicating code.
- Use *type-parameterized tests* for defining test logic abstractly and instantiating it with arbitrary type lists later.
- Manage instantiation and test suite names to maintain clarity and ease debugging.

### Prerequisites

Ensure you have:
- A working GoogleTest setup with `#include <gtest/gtest.h>`.
- Familiarity with basic GoogleTest tests and fixtures (see the [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md)).
- Basic understanding of C++ templates and classes.

### Expected Outcome

After completing the steps, you will be proficient in:
- Defining test fixtures that accept parameters or types.
- Leveraging built-in parameter generators to drive tests.
- Instantiating tests cleanly and efficiently.
- Customizing test names for meaningful output.

### Difficulty Level
Intermediate - some familiarity with templates and C++ testing concepts is recommended.

---

## Value-Parameterized Tests: Step-by-Step

### 1. Define a Parameterized Test Fixture

Define a fixture class derived from `testing::TestWithParam<T>`, where `T` is the type of your test parameter.

```cpp
class FooTest : public testing::TestWithParam<const char*> {
  // Add setup/teardown or members if needed
};
```

### 2. Write Parameterized Tests Using `TEST_P`

Use `TEST_P` to declare parameterized test cases that can access the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, IsValidInput) {
  const char* param = GetParam();
  EXPECT_TRUE(ProcessInput(param));
}

TEST_P(FooTest, HasExpectedSize) {
  const char* param = GetParam();
  EXPECT_GT(std::strlen(param), 0);
}
```

### 3. Instantiate the Test Suite with Parameters

Use `INSTANTIATE_TEST_SUITE_P` with a unique prefix and a parameter generator to instantiate the suite.

```cpp
INSTANTIATE_TEST_SUITE_P(
  ValidStrings,
  FooTest,
  testing::Values("alpha", "beta", "gamma")
);
```

### 4. Use Built-in Parameter Generators

Key generators include:
- `Values(v1, v2, ..., vN)`: Explicit list of values.
- `ValuesIn(container)`: Values from a container or array.
- `Range(start, end[, step])`: Sequence of values excluding end.
- `Bool()`: Sequences of bool `{false, true}`.
- `Combine(g1, g2, ...)`: Cartesian product of generators.

Example combining two boolean flags:

```cpp
class FeatureToggleTest : public testing::TestWithParam<std::tuple<bool, bool>> {};

TEST_P(FeatureToggleTest, BehavesAsExpected) {
  bool flag1, flag2;
  std::tie(flag1, flag2) = GetParam();
  EXPECT_TRUE(TestFeature(flag1, flag2));
}

INSTANTIATE_TEST_SUITE_P(AllFlagCombinations, FeatureToggleTest,
                         testing::Combine(testing::Bool(), testing::Bool()));
```

### 5. Customize Test Names

By default, test instances are named with indices (e.g., `ValidStrings/FooTest.IsValidInput/0`). Use the last argument of `INSTANTIATE_TEST_SUITE_P` to specify a function that returns string suffixes from parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedStrings,
  FooTest,
  testing::Values("alpha", "beta", "gamma"),
  [](const testing::TestParamInfo<const char*>& info) {
    std::string name(info.param);
    // Replace non-alphanumeric chars with '_'
    std::replace_if(name.begin(), name.end(),
                    [](char c) { return !std::isalnum(c); }, '_');
    return name;
  }
);
```

### 6. Handle Abstract Parameterized Tests

You can define test suites in headers, implement them in source files, and instantiate with different parameters in others, supporting reusable test libraries.

---

## Typed Tests: Step-by-Step

Typed tests allow running the *same test logic* for multiple types.

### 1. Define a Fixture Template

Define a class template derived from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_;
  static T shared_;
};

template <typename T>
T FooTest<T>::shared_ = T();
```

### 2. Associate a Type List with the Fixture

Use `testing::Types` and `TYPED_TEST_SUITE`.

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

### 3. Write Typed Tests with `TYPED_TEST`

Refer to the type parameter via `TypeParam`.

```cpp
TYPED_TEST(FooTest, InitializesToZero) {
  TypeParam zero{};
  EXPECT_EQ(zero, this->value_);
}

TYPED_TEST(FooTest, SharedVarAccessible) {
  EXPECT_EQ(TypeParam(), FooTest<TypeParam>::shared_);
}
```

### 4. Custom Type Name Generation

To make test suite names meaningful, provide a name generator class with a static template method `GetName(int index)`:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, char>) return "char";
    return "unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### 5. Run Tests Normally

Running `RUN_ALL_TESTS()` executes tests for each type.


---

## Type-Parameterized Tests: Step-by-Step

Type-parameterized tests differ by allowing deferred instantiation of the test suite with arbitrary type lists.

### 1. Define a Fixture Template

Similar to typed tests, but test suite definition and test registration are separated.

```cpp
template <typename T>
class BarTest : public testing::Test {
  // Fixture content
};
```

### 2. Declare a Type-Parameterized Test Suite

Use `TYPED_TEST_SUITE_P` to declare it.

```cpp
TYPED_TEST_SUITE_P(BarTest);
```

### 3. Define Type-Parameterized Tests with `TYPED_TEST_P`

```cpp
TYPED_TEST_P(BarTest, TestSomething) {
  TypeParam n = 0;
  // Your test code
}

TYPED_TEST_P(BarTest, TestAnotherThing) {
  // Another test
}
```

### 4. Register Test Names

Register the defined tests before instantiation.

```cpp
REGISTER_TYPED_TEST_SUITE_P(BarTest, TestSomething, TestAnotherThing);
```

### 5. Instantiate with Types

Choose concrete types and instantiate with a prefix.

```cpp
using BarTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyBar, BarTest, BarTypes);
```

You can instantiate multiple times with different type lists and prefixes.

---

## Practical Tips and Best Practices

- **Unique Instantiation Names:** Always use distinctive prefixes in `INSTANTIATE_TEST_SUITE_P` and `INSTANTIATE_TYPED_TEST_SUITE_P` to prevent name collisions.

- **Parameter Lifetime Management:** Be cautious when passing pointers or references as parameters; ensure their lifetime spans test execution.

- **Custom Names:** Avoid underscores in test suite and test names, especially for parameterized tests, to prevent naming conflicts (`faq.md#Why should test suite names and test names not contain underscore?`).

- **Suppress Warnings:** If you intentionally donâ€™t instantiate certain parameterized tests, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to avoid GitHub verification failures.

- **Test Separation:** Prefer testing interfaces using typed or type-parameterized tests for multiple implementations.

- **Combining Generators:** Use `Combine()` to create a Cartesian product of parameters, enabling comprehensive scenarios with multiple variable inputs.

- **Use Lambdas for Conversion:** For complex parameter types, use `ConvertGenerator` with a lambda to produce test parameter objects from tuples or other sources.

---

## Troubleshooting Common Issues

### No Tests Run From Parameterized Fixtures
- Verify you have invoked `INSTANTIATE_TEST_SUITE_P` for all your `TEST_P` fixtures.
- If the test suite is deliberately abstract, add `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);` to suppress errors.

### Duplicate or Conflicting Test Names
- Avoid `_` character in test and test suite names to prevent internal macro and linker issues.
- Use distinct prefixes on instantiations.

### Type Conversion Errors in Parameters
- Use `ConvertGenerator<T>` to explicitly control parameter type conversion.
- Provide conversion lambdas to map parameter tuples to complex types.

### Parameter Name Generation Produces Unreadable Output
- Provide a custom name generator function to produce sanitized and meaningful test suffixes.

### Lifetime Issues with String Parameters
- When passing temporary string objects as parameters with lambdas, explicitly specify the parameter type in `ConvertGenerator` to avoid dangling references.

---

## Code Samples

### Basic Value-Parameterized Test

```cpp
class StringTest : public testing::TestWithParam<const char*> {};

TEST_P(StringTest, IsNotEmpty) {
  EXPECT_GT(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(NonEmptyStrings, StringTest,
                         testing::Values("foo", "bar", "baz"));
```

### Combining Multiple Generators

```cpp
enum Color { RED, GREEN, BLUE };

class AnimalTest : public testing::TestWithParam<std::tuple<const char*, Color>> {};

TEST_P(AnimalTest, HasValidColor) {
  auto [animal, color] = GetParam();
  EXPECT_NE(color, RED);  // Just an example
}

INSTANTIATE_TEST_SUITE_P(
    AllAnimalColors, AnimalTest,
    testing::Combine(testing::Values("cat", "dog"), testing::Values(RED, GREEN, BLUE)));
```

### Typed Test Example

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  static T zero() { return T(0); }
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, ZeroIsFalse) {
  EXPECT_FALSE(static_cast<bool>(typename TestFixture::zero()));
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class InterfaceTest : public testing::Test {};

TYPED_TEST_SUITE_P(InterfaceTest);

TYPED_TEST_P(InterfaceTest, DefaultConstructible) {
  TypeParam obj;
  // Test default construction works
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, DefaultConstructible);

using Implementations = testing::Types<MyImpl1, MyImpl2>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImplementations, InterfaceTest, Implementations);
```

---

## Next Steps & Additional Resources

- Review [Using Assertions for Effective Validation](/guides/gtest-core-guides/using-assertions) to refine your assertion usage within parameterized and typed tests.
- Explore [Running and Interpreting Your Tests](/guides/gtest-core-guides/running-tests) for test execution best practices.
- Study [Core Concepts and Terminology](/overview/architecture-core-features/core-concepts-terminology) for foundational knowledge.

Refer also to concrete sample files `sample7_unittest.cc` and `sample8_unittest.cc` in the GoogleTest repository for complete parameterized test examples: https://github.com/google/googletest/tree/main/googletest/samples

---