---
title: "Extending GoogleTest with Custom Assertions"
description: "See how to write your own assertion macros and messages tailored to your project's unique needs. This guide covers AssertionResult, custom predicates, and techniques for producing expressive and actionable test output."
---

# Extending GoogleTest with Custom Assertions

GoogleTest offers a rich set of assertions that cover many common testing scenarios. However, there will be cases where you need assertions tailored to the specific needs of your project — more expressive, more domain-specific, or simply offering clearer failure messages.

This guide walks you through creating your own custom assertion macros and messages by leveraging GoogleTest's core assertion primitives, the `AssertionResult` class, custom predicates, and predicate-formatters. By following this guide, you'll be able to produce expressive and actionable test output that boosts your debugging productivity.

---

## 1. Understanding `AssertionResult` — The Core of Custom Assertions

At the heart of user-defined assertions lies `testing::AssertionResult`. It encapsulates the success or failure of an assertion and optionally stores a failure message.

### What `AssertionResult` Enables
- Clear signaling of pass or fail in complex predicates.
- Rich failure messages by streaming text into an `AssertionResult` object.

### Basic Usage
Use either:

```cpp
// Represents success
testing::AssertionResult result = testing::AssertionSuccess();

// Represents failure with a message
testing::AssertionResult failure = testing::AssertionFailure() << "Failure reason";
```

You can then return these results from custom predicate functions, making the test output more informative.

---

## 2. Creating Custom Predicates That Return `AssertionResult`

When a simple `bool` predicate is insufficient for clear failure reporting, define a predicate that returns `AssertionResult`.

### Why? 
Unlike raw `bool` predicates (used with `EXPECT_TRUE`), `AssertionResult` predicates can explain *why* the check failed.

### Example: Checking Evenness with a Custom Predicate

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess();
  } else {
    return testing::AssertionFailure() << n << " is odd";
  }
}

TEST(MyTest, Example) {
  EXPECT_TRUE(IsEven(3));  // Produces informative failure message
}
```

Output on failure:

```
Value of: IsEven(3)
  Actual: false (3 is odd)
Expected: true
```

### Pro Tip
You can also add custom success messages by streaming into the success case, though note this makes successful assertions slower.

---

## 3. Using Predicate-Formatter Assertions for Full Control

If the default failure message of predicate assertions isn’t enough — for example, when arguments do not support streaming or you want total control over formatting — you can use predicate-formatter assertions.

### What is a Predicate-Formatter?
A callable matching this signature:

```cpp
typing::AssertionResult PredicateFormatter(const char* expr1, const char* expr2, ..., T1 val1, T2 val2, ...);
```

- `expr1`, `expr2`, ... are the textual representations of the arguments in source code.
- `val1`, `val2`, ... are the actual values.

### How to Use
Use one of these macros:

| Macro                   | Description                           |
|-------------------------|-----------------------------------|
| `EXPECT_PRED_FORMAT2`   | For predicates with 2 arguments    |
| `ASSERT_PRED_FORMAT2`   | Fatal variant                      |
| (Similarly for 1-5 args) |                                   |

### Example: Mutually Prime Checker

```cpp
bool MutuallyPrime(int m, int n) {
  // ... implementation ...
}

testing::AssertionResult AssertMutuallyPrime(const char* m_expr,
                                             const char* n_expr,
                                             int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();

  return testing::AssertionFailure() << m_expr << " and " << n_expr
      << " (" << m << " and " << n << ") are not mutually prime";
}

TEST(NumberTest, PrimeCheck) {
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, 3, 4);  // Passes
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, 4, 10); // Fails with custom message
}
```

Failure message:

```
4 and 10 (4 and 10) are not mutually prime
```

---

## 4. Defining Custom Assertion Macros

To improve readability and reuse, wrap your custom predicate or predicate-formatter into a macro. This allows a semantic assertion name and convenient usage.

### Example: Defining `EXPECT_MUTUALLY_PRIME`

```cpp
#define EXPECT_MUTUALLY_PRIME(m, n) \
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, m, n)

// Usage
TEST(NumberTest, Example) {
  EXPECT_MUTUALLY_PRIME(15, 28);
}
```

### Guidelines for Custom Assertion Macros

- Name the macro with a meaningful descriptive name.
- Use `EXPECT_` for nonfatal assertions, `ASSERT_` for fatal assertions.
- Wrap the GoogleTest predicate macros to get good integration.
- Provide overloads if supporting string literal inputs.

---

## 5. Best Practices and Tips

### Streaming Messages
- Always use streaming operators (`<<`) to produce informative, detailed failure messages.
- Avoid side effects in streamed expressions.

### Use `SCOPED_TRACE` to Add Context
When calling custom predicates deep in complex test routines, include trace context:

```cpp
SCOPED_TRACE("Checking primality in test input loop iteration " << i);
EXPECT_MUTUALLY_PRIME(a, b);
```

This will add helpful diagnostic traces to failure output.

### Use `HasFatalFailure` to Propagate Failures
In helper functions using `ASSERT_*` macros, remember that fatal assertions only abort the current function. To properly stop the test after a helper fails, check:

```cpp
void Helper() {
  ASSERT_TRUE(SomeCondition());
  // ...
}

TEST(MyTest, Example) {
  Helper();
  if (HasFatalFailure()) return;  // Early return on failure
  // ...rest of test...
}
```

### Failure Handling Options
- Fatal assertions abort the current function (use carefully).
- Nonfatal assertions allow tests to continue and report multiple failures.
- Use `ASSERT_*` in setup code to avoid invalid states.

---

## 6. Troubleshooting Custom Assertions

### Common Issues
- **No informative messages:** Ensure your predicate returns `AssertionFailure()` with a streamed message.
- **Predicate called multiple times:** Avoid predicates with side-effects.
- **Macro misuse:** Use provided GoogleTest predicate macros to properly integrate with test reporting.

### Debugging Steps
- Confirm the predicate's failure path returns an `AssertionResult` indicating failure with a message.
- Check that all argument streaming is safe and does not throw exceptions.
- Use `SCOPED_TRACE` to add context.
- Run tests with the `--gtest_break_on_failure` to catch failures in debugger.

---

## 7. Next Steps and Additional Resources

After mastering custom assertions, consider exploring:

- **Value-Parameterized Tests:** Write tests running over sets of input values.
- **Typed and Type-Parameterized Tests:** Extend your tests across types.
- **Matchers:** Use or write matchers to improve assertion expressiveness.
- **Death Tests:** Write tests verifying process-terminating conditions.

Refer to:
- [Advanced GoogleTest Topics](advanced.md)
- [Assertions Reference](reference/assertions.md)
- [Writing and Organizing Tests](guides/gtest-core-guides/writing-tests.mdx)

---

## Example: Complete Custom Assertion

```cpp
// Custom predicate that checks if a vector is sorted.
testing::AssertionResult IsSorted(const std::vector<int>& v) {
  for (size_t i = 1; i < v.size(); ++i) {
    if (v[i] < v[i - 1]) {
      return testing::AssertionFailure()
             << "Element at index " << i << " is " << v[i]
             << ", which is less than previous element " << v[i - 1];
    }
  }
  return testing::AssertionSuccess();
}

#define EXPECT_SORTED(container) \ 
  EXPECT_PRED_FORMAT1(IsSorted, container)

TEST(SortingTest, CheckSorted) {
  std::vector<int> data = {1, 3, 2, 4};
  EXPECT_SORTED(data);  // Fails with message describing the problem
}
```

Output on failure:

```
Element at index 2 is 2, which is less than previous element 3
```

This example shows how to make your test output informative and easily actionable.

---