---
title: "Parameterized and Typed Tests"
description: "Master value-parameterized and type-parameterized tests to validate code against diverse inputs and data types. Includes setup instructions, real-world patterns, and useful macros to maximize reuse and coverage."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write robust, reusable tests by allowing you to validate your code against a range of inputs and types without duplicating code. This page focuses on mastering value-parameterized and type-parameterized tests to maximize test coverage while keeping your test code DRY (Don't Repeat Yourself).

---

## Overview

### What You Will Learn

This guide helps you:
- Create tests that run the same logic over diverse parameter values or data types.
- Use GoogleTest macros and generators to define and instantiate parameterized tests.
- Manage naming and organization of parameterized tests effectively.
- Leverage advanced parameter generators, including combinatorial test parameterization.

### Prerequisites

- Basic understanding of GoogleTest test cases and fixtures.
- Familiarity with C++ templates and inheritance.
- GoogleTest installed and properly configured in your project.

### Outcome

By completing this guide, you will be able to write and maintain parameterized and typed tests that improve your testing efficiency and code coverage while reducing boilerplate.

### Estimated Time

Approximately 20-30 minutes to read and implement basic and intermediate examples.

### Difficulty

Intermediate

---

## Value-Parameterized Tests

Value-parameterized tests let you run the same test logic for multiple values, avoiding repetitive test definitions.

### Defining a Value-Parameterized Test

1. **Create a fixture class** that inherits from `testing::TestWithParam<T>`, where `T` is the type of your test parameter (any copyable type).

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Define any test setup if needed
};
```

2. **Define parameterized tests** using the `TEST_P` macro with your fixture name.

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}
```

3. **Instantiate the test suite** with a set of parameter values using `INSTANTIATE_TEST_SUITE_P` and a parameter generator.

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName,
                         FooTest,
                         testing::Values("meeny", "miny", "moe"));
```

- The instance tests are named as `InstantiationName/FooTest.DoesBlah/i` where `i` is the zero-based parameter index.
- Parameter type `T` can be primitive types, pointers, STL containers, or user-defined copyable types.

### Parameter Generators

GoogleTest provides several built-in generators in namespace `testing`:

| Generator                | Description                                                              |
|--------------------------|--------------------------------------------------------------------------|
| `Range(begin, end[, step])` | Generates values from `begin` up to but not including `end` with optional `step` (default 1). |
| `Values(v1, v2, ..., vN)` | Generates the given explicit values.                                    |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Generates values from a container or iterator range.                   |
| `Bool()`                  | Generates `false` and `true`.                                            |
| `Combine(g1, g2, ..., gN)` | Generates the Cartesian product (all combinations) of values generated by `g1` through `gN`. |

Example using multiple generators combined:

```cpp
INSTANTIATE_TEST_SUITE_P(AnimalVariations, AnimalTest,
                         testing::Combine(testing::Values("cat", "dog"),
                                          testing::Values(BLACK, WHITE)));
```

This creates tests running for every `(string, Color)` tuple.

### Custom Test Name Generation

You can supply a function or lambda generating custom test suffixes for clearer output:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite, testing::Values(...),
    [](const testing::TestParamInfo<MyTestSuite::ParamType>& info) {
      std::string name = ...; // Build a string from info.param
      return name;
    });
```

Ensure that generated names contain only alphanumeric characters or underscores.

### Mixed-Type Parameters and Conversion

Generators allow parameters of types convertible to the fixture parameter type, but for explicit or complex conversions, use `ConvertGenerator`:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,
    testing::ConvertGenerator<std::tuple<int, bool>>(
        testing::Combine(testing::Values(0.1, 1.2), testing::Bool())));
```

You can also provide a conversion function:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,
    testing::ConvertGenerator(testing::Combine(testing::Values(1, 1.2), testing::Bool()),
                             [](std::tuple<int, bool> t) {
                               return MyParam(std::get<0>(t), std::get<1>(t));
                             }));
```

---

## Type-Parameterized Tests

Type-parameterized tests allow testing the same logic against different types.

### Writing Typed Tests

1. **Define a fixture class template** derived from `testing::Test`.

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
   // Members with type T
   T value_;
};
```

2. **Define a type list** using `testing::Types<T1, T2, ...>`.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned>;
```

3. **Associate the fixture with the type list** using `TYPED_TEST_SUITE` macro.

```cpp
TYPED_TEST_SUITE(MyFixture, MyTypes);
```

4. **Write typed tests** using `TYPED_TEST` macro.

```cpp
TYPED_TEST(MyFixture, DoesBlah) {
  TypeParam n = this->value_;
  ...
}
```

Inside the test, `TypeParam` refers to the current type.

### Writing Type-Parameterized Tests (Advanced / Abstract)

Type-parameterized tests differ from typed tests in that the type list is supplied later, enabling library authors to define tests without knowing implementation types.

1. **Define a fixture class template** as before.

2. **Declare type-parameterized test suite** with `TYPED_TEST_SUITE_P` macro.

```cpp
TYPED_TEST_SUITE_P(MyFixture);
```

3. **Define test patterns** using `TYPED_TEST_P` macro.

```cpp
TYPED_TEST_P(MyFixture, DoesBlah) {
  TypeParam n = 0;
  ...
}
```

4. **Register all tests** using `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyFixture, DoesBlah, HasPropertyA);
```

5. **Instantiate the test suite with type list** anywhere you want.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyFixture, MyTypes);
```

### Customizing Test Names

For typed and type-parameterized tests, a name generator class can be specified when associating the type list, enabling custom suffix naming per type. The generator must have a static template method `GetName(int)` returning a string for each type.

---

## Practical Tips and Best Practices

- **Define Parameterized Tests in Headers for Abstract Tests:**
  When sharing abstract test suites across projects or modules, put test fixture and test definitions in headers, and instantiate them explicitly elsewhere.

- **Choose Clear Instantiation Names:**
  Select unique prefixes in `INSTANTIATE_TEST_SUITE_P` to differentiate instances.

- **Manage Lifetimes for Pointer Parameters:**
  When parameters are pointers, manage object lifetime carefully to avoid undefined behavior.

- **Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`** to suppress warnings for suites deliberately not instantiated.

- **Combine Generators for Multidimensional Testing:**
  Use `Combine()` to test all relevant parameter permutations without nested loops.

- **Use Custom Test Naming Where Meaningful:**
  Custom parameter name generators improve test output readability, especially when default names are ambiguous.

---

## Troubleshooting Common Issues

- **Tests Not Running After Definition:**
  Ensure you call `INSTANTIATE_TEST_SUITE_P` for all `TEST_P` test suites, or mark with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if intended.

- **Name Collisions:**
  Avoid underscores in test suite and test names to prevent filtering issues.

- **Parameter Type Mismatches:**
  Use `ConvertGenerator` when parameter generator value types do not match fixture parameter type exactly.

- **Dangling References in Conversion Lambdas:**
  When converting from temporary values, specify generated type explicitly to avoid dangling references caused by lambda parameter deduction.

- **Multiple Instantiations with Same Prefix:**
  Use unique prefixes for each instantiation to keep test names distinct.

---

## Sample Example: Value-Parameterized Test with Multiple Parameters

```cpp
class AnimalTest : public testing::TestWithParam<std::tuple<const char*, int>> {
  // Typical test fixture content
};

TEST_P(AnimalTest, AnimalLooksNice) {
  const char* animal = std::get<0>(GetParam());
  int color = std::get<1>(GetParam());
  EXPECT_TRUE(IsNice(animal, color));
}

INSTANTIATE_TEST_SUITE_P(
    AnimalVariations,
    AnimalTest,
    testing::Combine(testing::Values("cat", "dog"), testing::Values(BLACK, WHITE)));
```

---

## Sample Example: Type-Parameterized Tests

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T value_;
};

using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value_;
  EXPECT_TRUE(Process(val));
}
```

---

## See Also and Next Steps

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) - deeper details
- [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests) - more on typed tests
- [GoogleTest Primer](primer.md) - foundational testing concepts
- [Testing Reference](reference/testing.md) - macros and API details
- [GoogleTest Samples](samples.md) - practical example code

---

This documentation equips you with the essentials to efficiently write parameterized and type-parameterized tests, enabling comprehensive and maintainable test coverage for your C++ codebase.