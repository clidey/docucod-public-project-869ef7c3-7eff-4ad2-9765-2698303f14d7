---
title: "Writing Parameterized Tests"
description: "A step-by-step guide to creating tests that run automatically across multiple input values, reducing boilerplate and ensuring coverage. Covers custom parameter generators and naming best practices."
---

# Writing Parameterized Tests

## Overview
This guide leads you through creating parameterized tests in GoogleTest, enabling you to run the same test logic across multiple input values automatically. Parameterized tests help reduce repetitive code and boost test coverage by iterating over different data sets or configurations.

You will also learn about custom parameter generators and best practices for naming your test cases.

---

## Prerequisites
- Familiarity with writing basic tests using GoogleTest, especially test fixtures (`TEST_F`).
- GoogleTest environment set up, including `#include <gtest/gtest.h>` in your test files.
- Understanding of C++ templates and basic test fixtures.

---

## What You Will Achieve
- Define test fixtures that accept parameters.
- Write parameterized test definitions that run for every input.
- Instantiate test suites with different types or sets of input values using built-in parameter generators.
- Customize test name suffixes for clear and unique test identification.

---

## Estimated Time
15 - 30 minutes

---

## Difficulty Level
Intermediate

---

# Step-by-Step Instructions

### 1. Define a Parameterized Test Fixture
Create a test fixture class inheriting from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the parameter type you want to test with. Alternatively, use `testing::TestWithParam<T>`, which already inherits both.

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // Add test-specific setup or utilities here.
};
```

ðŸ“Œ **Note:** Make sure that if you define `SetUpTestSuite()` or `TearDownTestSuite()` in your fixture, declare them as `public` to ensure compatibility with parameterized tests.

---

### 2. Write Parameterized Tests Using TEST_P
Within the same test file or source, write your tests with the `TEST_P` macro instead of `TEST_F`. This enables the test body to be executed once per parameter value.

```cpp
TEST_P(MyParamTest, HandlesValue) {
  int value = GetParam();  // Access the test parameter
  EXPECT_GT(value, 0);    // Example assertion
}
```

Multiple `TEST_P` definitions can be used for the same fixture to cover different test logic.

---

### 3. Instantiate Tests with Parameter Generators
Use the `INSTANTIATE_TEST_SUITE_P` macro at global or namespace scope to instantiate your parameterized test suite with sets of parameters. You can use predefined generators like `Values()`, `ValuesIn()`, `Range()`, `Bool()`, and `Combine()` to specify parameters.

#### Using Values()

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,
    MyParamTest,
    testing::Values(1, 2, 3, 4, 5));
```

This will run `MyParamTest.HandlesValue` five times with values 1, 2, 3, 4, and 5.

#### Using ValuesIn() with an Array or Container

```cpp
int data[] = {10, 20, 30};
INSTANTIATE_TEST_SUITE_P(DataSequence, MyParamTest, testing::ValuesIn(data));
```

#### Using Range()

```cpp
INSTANTIATE_TEST_SUITE_P(RangeTests, MyParamTest, testing::Range(5, 10));
```

This runs tests with parameters 5, 6, 7, 8, and 9 (note that `end` is exclusive).

#### Using Bool() for Boolean Flags

```cpp
INSTANTIATE_TEST_SUITE_P(BooleanFlags, MyBoolTest, testing::Bool());
```

#### Using Combine() to Test Combinations

If your parameter is a tuple, use `Combine()` to generate Cartesian products.

```cpp
INSTANTIATE_TEST_SUITE_P(
    ComboTests, MyTupleTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

This will run tests with parameters `(1, false)`, `(1, true)`, `(2, false)`, and `(2, true)`.

---

### 4. Customize Test Names (Optional but Recommended)
By default, test names for parameterized tests are suffixed with an index (0-based). For readability and easier debugging, you can supply a custom name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P`.

The name generator must accept a `const testing::TestParamInfo<ParamType>&` and return a `std::string` containing only alphanumeric characters and underscores (avoid spaces, dashes, or special characters).

Example with a lambda:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, MyParamTest, testing::Values(5, 10, 15),
    [](const testing::TestParamInfo<MyParamTest::ParamType>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

The test names will be suffixed with `Value_5`, `Value_10`, etc.

**Warning:** Names must be unique, non-empty, and valid for test filtering.

---

### 5. Run Your Tests
Build and run your test binary as usual. GoogleTest will automatically generate and run the instantiated parameterized tests.

Example output shows test cases like:

```
NamedTests/MyParamTest.HandlesValue/Value_5 PASSED
NamedTests/MyParamTest.HandlesValue/Value_10 PASSED
NamedTests/MyParamTest.HandlesValue/Value_15 PASSED
```

You can run specific parameterized tests via `--gtest_filter` using these names.

---

## Best Practices

- **Parameter Type**: Use small, copyable types for parameters. If passing complex data, consider using `std::tuple` or custom structs.
- **Test Isolation**: Parameterized tests should behave independently for each input; avoid shared global state changes.
- **Name Generators**: Always provide meaningful test names when parameter types are strings or complex types to avoid default numeric suffixes.
- **Instantiation Placement**: Place `INSTANTIATE_TEST_SUITE_P` at namespace or global scope, never inside functions.
- **Suppression of Warnings**: Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when your parameterized test fixture may be defined but not instantiated in all builds.

---

## Common Pitfalls & Troubleshooting

### Test Not Running
- Ensure you instantiate the suite with `INSTANTIATE_TEST_SUITE_P`.
- Check that `INSTANTIATE_TEST_SUITE_P` is not inside a function (should be global).
- If using filters, verify that the test names match.
- If you see warnings about uninstantiated tests, either instantiate or suppress the warning.

### Invalid Test Names
- Test parameter name suffixes must contain **only** alphanumeric characters or underscores.
- Avoid spaces, dashes, or special characters.
- If your parameter type does not easily convert to a valid name, use a custom name generator.

### Compile Errors
- Verify that the test fixture inherits from `testing::TestWithParam<T>` or `testing::Test` and `testing::WithParamInterface<T>`.
- Use `GetParam()` inside your test body to access the current parameter.

### Debugging Tips
- Use `SCOPED_TRACE()` inside tests to add more detailed context messages.
- Use test filtering to run only relevant parameterized tests.

---

## Real-World Examples

### Example: Simple Parameterized Test
```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Example: Using Combine with Multiple Parameters
```cpp
class ComplexTest
    : public testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(ComplexTest, HandlesCombination) {
  int num = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  // Test logic here
}

INSTANTIATE_TEST_SUITE_P(
    VariousCombos, ComplexTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Example: Custom Parameter Type and Name Generator
```cpp
struct MyParam {
  int id;
  std::string label;
  explicit MyParam(std::tuple<int, std::string> t)
      : id(std::get<0>(t)), label(std::get<1>(t)) {}
};

class MyParamTest : public testing::TestWithParam<MyParam> {};

TEST_P(MyParamTest, WorksWithCustomParam) {
  MyParam p = GetParam();
  EXPECT_GT(p.id, 0);
}

INSTANTIATE_TEST_SUITE_P(
    CustomParams, MyParamTest,
    testing::ConvertGenerator<MyParam::TupleT>(
        testing::Combine(
            testing::Values(1, 2), testing::Values("foo", "bar"))),
    [](const testing::TestParamInfo<MyParam>& info) {
      return info.param.label + std::to_string(info.param.id);
    });
```

---

## Next Steps
- Explore **Typed Tests and Type-Parameterization** to run tests across multiple types.
- Learn more about **Custom Matchers** for advanced assertion handling.
- Review the **Testing Reference** for detailed API functions related to parameterized tests.
- See the **Advanced Guide** for best practices around failure handling and test suite management.

---

## Additional Resources
- [GoogleTest Primer](primer.md) â€” Introduction and foundational concepts.
- [Testing Reference](reference/testing.md) â€” Macro and API documentation.
- [Samples Directory on GitHub](https://github.com/google/googletest/tree/main/googletest/samples) â€” Real-world test examples.
- [Value-Parameterized Tests](advanced.md#value-parameterized-tests) â€” In-depth explanation and examples.

---

Happy Testing! ðŸŽ¯

---

<AccordionGroup title="Frequently Asked Questions">
<Accordion title="Can I pass complex data types as parameters?">
Yes. You can pass structs, classes, or tuples as parameters to your parameterized tests. Use `testing::Combine()` and `ConvertGenerator()` to wrap complex types efficiently.
</Accordion>
<Accordion title="Where should I put INSTANTIATE_TEST_SUITE_P?">
Place it at global or namespace scope, not inside functions or classes.
</Accordion>
<Accordion title="Why do I get errors about uninstantiated parameterized tests?">
If you define but do not instantiate a parameterized test, GoogleTest will generate a failing test as a warning. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FixtureName);` to suppress this if intended.
</Accordion>
</AccordionGroup>
