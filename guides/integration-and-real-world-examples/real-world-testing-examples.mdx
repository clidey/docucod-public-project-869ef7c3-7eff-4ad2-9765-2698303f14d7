---
title: "Real-World Testing Examples"
description: "A curated collection of real-life testing scenarios and sample codes, demonstrating patterns for testing legacy code, handling dependencies, and writing robust, maintainable tests in C++ projects."
---

# Real-World Testing Examples

This page presents a curated collection of practical testing scenarios and sample code demonstrating effective testing patterns used in C++ projects. You will find examples covering legacy code testing, dependency handling strategies, and guidelines for writing robust, maintainable tests.

---

## Testing Legacy Code

Legacy code often lacks testability due to tightly coupled dependencies and absence of clear interfaces. This section guides you through integrating tests into legacy systems using mocks and adapters to isolate components effectively.

### Strategy: Wrapping Legacy Code for Testability

- Identify tightly coupled classes or global functions.
- Introduce interfaces or abstract layers to isolate dependencies.
- Use adapters to connect legacy code with new testable interfaces.
- Define mock classes for the interfaces to set expectations and verify interactions.

### Example: Adapting a Legacy File Manager

Suppose you have a legacy class `LegacyFileManager` with non-virtual methods for file operations that are hard to mock directly:

```cpp
class LegacyFileManager {
 public:
  bool Open(const char* path);  // Non-virtual
  bool Close();
  int Read(void* buffer, int size);
  // ...
};
```

**Approach:** Create an interface and adapter to enable mocking:

```cpp
// Define an interface for file operations.
class IFileManager {
 public:
  virtual ~IFileManager() = default;
  virtual bool Open(const char* path) = 0;
  virtual bool Close() = 0;
  virtual int Read(void* buffer, int size) = 0;
};

// Adapter forwarding calls to legacy code
class LegacyFileManagerAdapter : public IFileManager {
 public:
  LegacyFileManagerAdapter(LegacyFileManager* legacy)
      : legacy_(legacy) {}

  bool Open(const char* path) override {
    return legacy_->Open(path);
  }

  bool Close() override {
    return legacy_->Close();
  }

  int Read(void* buffer, int size) override {
    return legacy_->Read(buffer, size);
  }

 private:
  LegacyFileManager* legacy_;
};
```

Now, you can use `IFileManager` in your components and mock it in tests:

```cpp
#include <gmock/gmock.h>

class MockFileManager : public IFileManager {
 public:
  MOCK_METHOD(bool, Open, (const char* path), (override));
  MOCK_METHOD(bool, Close, (), (override));
  MOCK_METHOD(int, Read, (void* buffer, int size), (override));
};
```

This pattern empowers testing code that depends on legacy components without modifying legacy classes themselves.

---

## Handling External Dependencies

When your code interacts with external resources (e.g., databases, network services), direct testing can be slow, brittle, or non-deterministic.

### Solution: Mock External Dependencies

Use mock objects to simulate external services, enabling:

- Stable and fast tests.
- Control over scenarios, including error conditions.
- Precise verification of interactions.

### Example: Mocking a Network Service Interface

Define an interface representing the external service:

```cpp
class NetworkService {
 public:
  virtual ~NetworkService() = default;
  virtual bool Connect(const std::string& url) = 0;
  virtual std::string FetchData(int request_id) = 0;
};
```

Create a mock implementation with gMock:

```cpp
#include <gmock/gmock.h>

class MockNetworkService : public NetworkService {
 public:
  MOCK_METHOD(bool, Connect, (const std::string& url), (override));
  MOCK_METHOD(std::string, FetchData, (int request_id), (override));
};
```

Set expectations and simulate behavior in tests:

```cpp
using ::testing::Return;
using ::testing::_;

TEST(ServiceClientTest, FetchesDataSuccessfully) {
  MockNetworkService mock_service;
  EXPECT_CALL(mock_service, Connect(_))
      .WillOnce(Return(true));
  EXPECT_CALL(mock_service, FetchData(42))
      .WillOnce(Return("TestData"));

  ServiceClient client(&mock_service);
  EXPECT_TRUE(client.Initialize("http://example.com"));
  EXPECT_EQ(client.GetData(42), "TestData");
}
```

This approach removes the need for a real external service in unit tests and improves reliability and speed.

---

## Writing Maintainable Tests

Maintainability is vital for effective long-term testing. Key practices:

- **Use clear and focused expectations**: Avoid over-specifying calls - only specify what matters.
- **Isolate tests**: Each test should be independent and focus on a single concern.
- **Use sequences sparingly**: Enforce call order only when critical; liberal ordering prevents brittleness.
- **Manage mock strictness wisely**: Use `NiceMock` to suppress warnings in noisy tests and `StrictMock` only when uninteresting calls must be errors.

### Example: Limiting Interaction Strictness

```cpp
using ::testing::NiceMock;

NiceMock<MockNetworkService> mock_service;  // Suppresses warnings for uninteresting calls.
EXPECT_CALL(mock_service, Connect(_)).Times(1).WillOnce(Return(true));
// Other calls are allowed but won't trigger warnings.
```

---

## Practical Tips and Common Pitfalls

- Ensure **virtual destructors** in interfaces to avoid memory leaks when using mocks.
- Remember to **set expectations before exercising mocks**. Setting expectations after calls leads to undefined behavior.
- Use `ON_CALL()` to define default behavior without expectation, keeping tests resilient to harmless calls.
- Use **`RetiresOnSaturation()`** to avoid sticky expectations that lead to upper-bound call errors.
- When mocking **overloaded methods**, mock each overload explicitly to avoid compiler warnings.
- Beware of **unintentional strictness**: overly strict mocks cause brittleness.

<Tip>
Always verify your mocks are destroyed properly to trigger expectation verification. Use heap checkers as necessary.
</Tip>

---

## Summary

Real-world testing in C++, especially with legacy code or external dependencies, demands thoughtful structuring and isolation. By introducing interfaces and adapters, employing mocks strategically for dependencies, and following maintainability best practices, you achieve faster, reliable, and easier-to-maintain tests.

---

## Next Steps & Related Content

- Explore the [Mocking for Dummies](gmock_for_dummies.md) for a gentle introduction to mocks.
- Deepen your skills with the [gMock Cookbook](gmock_cook_book.md) for advanced mocking recipes.
- Reference the [Mocking Reference](reference/mocking.md) for detailed syntax and API.
- See [Common Mocking Patterns](guides/mocking-and-advanced-patterns/common-mocking-patterns.md) for practical usage advice.

---

## Additional Resources

- Official GoogleTest Documentation: https://google.github.io/googletest/
- gMock API Reference: https://google.github.io/googletest/reference/mocking.html
- Design Patterns for Testability: https://martinfowler.com/articles/mocksArentStubs.html

---

*This page is part of the GoogleTest Guides collection.*
