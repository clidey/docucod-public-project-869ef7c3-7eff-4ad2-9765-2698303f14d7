---
title: "Parameterized and Type-Parameterized Tests"
description: "Streamline test coverage by using value-parameterized and type-parameterized tests. This page walks through defining, instantiating, and running parameterized tests—covering practical examples for data-driven and template-based scenarios."
---

# Parameterized and Type-Parameterized Tests

## Overview

This guide helps you streamline your test coverage in GoogleTest by leveraging parameterized tests. Parameterized tests allow you to write a test pattern once and execute it multiple times with different inputs or types, minimizing code duplication and improving test maintainability.

GoogleTest supports two kinds of parameterized tests:

- **Value-Parameterized Tests:** Test the same logic with different runtime values, ideal for data-driven testing.
- **Typed Tests and Type-Parameterized Tests:** Test the same logic with different compile-time types, perfect for template-based scenarios.

This page walks you through defining, instantiating, and running both forms with practical examples and actionable steps.

---

## 1. Value-Parameterized Tests (Value-Parameterized Test Suites)

### Intent
Value-parameterized tests let you run the same test logic multiple times with different parameter values, enhancing test coverage without repetitive code.

### Prerequisites
- Knowledge of C++ and basic GoogleTest test fixtures.
- Include `<gtest/gtest.h>`.

### Expected Outcome
You will write a test fixture that can receive parameters, define parameterized tests on it, and instantiate the test suite with a variety of input values.

### Time Estimate
10–15 minutes for simple use cases.

### Difficulty Level
Intermediate

---

### Step-by-Step Instructions

<Steps>
<Step title="Define the Parameterized Test Fixture">
Derive your test fixture from `::testing::TestWithParam<T>`, where `T` is the type of your test parameter. This combines `Test` and `WithParamInterface<T>`, giving your tests access to `GetParam()`.

Example:

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional: fixture setup and teardown
};
```

This class can now access the parameter via `GetParam()`.
</Step>

<Step title="Write TEST_P Test Cases">
Use the `TEST_P` macro to define tests that use the parameter.

Inside the test body, call `GetParam()` to retrieve the current test parameter.

Example:

```cpp
TEST_P(FooTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(FunctionUnderTest(param));
}
```

Write as many `TEST_P` tests as you need using the same fixture.
</Step>

<Step title="Instantiate the Test Suite with Parameters">
Use the `INSTANTIATE_TEST_SUITE_P` macro to associate parameters with your test suite.

Provide:
- An instantiation name (unique prefix)
- Test fixture name
- A parameter generator (e.g., `Values()`, `Range()`, `ValuesIn()`, `Bool()`, `Combine()`)

Example using `Values()`:

```cpp
INSTANTIATE_TEST_SUITE_P(MyValues,
                         FooTest,
                         ::testing::Values(1, 2, 3));
```

This creates tests:

- `MyValues/FooTest.DoesSomething/0` for parameter 1
- `MyValues/FooTest.DoesSomething/1` for parameter 2
- `MyValues/FooTest.DoesSomething/2` for parameter 3

These indexed test names can be used with the `--gtest_filter` flag.
</Step>

<Step title="Run and Verify">
Build and run your tests as usual. GoogleTest will execute each test instance with a different parameter.

You can filter tests by their full name if needed.

Example:

```bash
./my_test --gtest_filter=MyValues/FooTest.*
```
</Step>
</Steps>

---

### Generating Parameters

GoogleTest provides various functions to generate parameters:

- `Range(start, end [, step])`: Generates a range of values excluding `end`.
- `Values(v1, v2, ..., vN)`: Enumerate explicit values.
- `ValuesIn(container)`: Uses values from a container or iterator range.
- `Bool()`: Generates `{false, true}`.
- `Combine(g1, g2, ..., gN)`: Cartesian product from multiple generators.

Example of combined parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedParams,
    FooTest,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

Each generated parameter is given as a tuple.

---

### Advanced: Customizing Parameter Names

By default, test instances are suffixed by indices (0, 1, 2...). You can define a custom name generator function to make test output more readable.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams,
    FooTest,
    ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

After this, tests will have names like `NamedParams/FooTest.DoesSomething/Value1`.

---

### Troubleshooting & Tips

- **Common Mistake:** Forgetting to instantiate the test suite causes GoogleTest to create a failing placeholder test.

- **Param Type Concerns:** `T` must be copyable. If using pointers, manage lifetime carefully.

- **Multiple Instantiations:** You can instantiate the same test pattern multiple times with different parameter sets; just use different instantiation names.

- **Suppression:** If you want to declare the test but not instantiate yet, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);`.


---

## 2. Typed Tests

### Intent
Typed tests allow you to run the same test logic over multiple types, useful when testing template code or multiple implementations of an interface.

### Prerequisites
- Knowledge of C++ templates and GoogleTest fixtures.
- Include `<gtest/gtest-typed-test.h>` or `<gtest/gtest.h>`.

### Expected Outcome
Create a fixture class template parameterized on a type, associate it with a list of types, and GoogleTest will generate tests for all types.

### Time Estimate
10–20 minutes.

### Difficulty Level
Intermediate to Advanced

---

### Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Template">
Define your test fixture as a class template parameterized by type `T`.

Example:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 protected:
  // Optional setup/teardown and members
  T value_ = T();
};
```
</Step>

<Step title="Declare the List of Types to Test">
Use `::testing::Types<...>` to specify which types to test with.

Example:

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```

Then associate the type list with your fixture using the `TYPED_TEST_SUITE` macro:

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>

<Step title="Write Typed Tests with TYPED_TEST">
Use `TYPED_TEST` to write tests for your fixture.

Inside test bodies:
- Use `TypeParam` to refer to the current type in the test.
- Use `this` to access fixture members.

Example:

```cpp
TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam default_val = this->value_;
  // expect something about default_val
  SUCCEED();
}
```

Write as many typed tests as needed.
</Step>

<Step title="Build and Run">
Compile and run your tests normally. GoogleTest will generate a test instance for each type in `MyTypes`.

The test names include the type, or a readable suffix for complex types if specified.
</Step>
</Steps>

### Customizing Type Names

You can specify a custom name generator class that defines `GetName<T>(int)` to provide friendly names.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, std::string>) return "String";
    return "UnknownType";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Notes

- Type lists must be known at compile time.
- Tests run independently for each type.

---

## 3. Type-Parameterized Tests (Type-Parameterized Test Suites)

### Intent
Type-parameterized tests allow you to define test patterns without specifying types upfront, letting you instantiate the test suite with types later.

### Prerequisites
Same as for typed tests.

### Expected Outcome
Separate test pattern definition from instantiation, enabling reuse and deferred type specification.

### Time Estimate
15-25 minutes

### Difficulty Level
Advanced

---

### Step-by-Step Instructions

<Steps>
<Step title="Define a Test Fixture Template">
Define a fixture class template without associating any types yet.

Example:

```cpp
template <typename T>
class MyPatternTest : public ::testing::Test {
  // fixture members
};
```
</Step>

<Step title="Declare a Type-Parameterized Test Suite">
Declare the test suite as type-parameterized with:

```cpp
TYPED_TEST_SUITE_P(MyPatternTest);
```
</Step>

<Step title="Define Type-Parameterized Tests">
Define tests with `TYPED_TEST_P`, which resemble typed tests but are for patterns.

Example:

```cpp
TYPED_TEST_P(MyPatternTest, DoesSomething) {
  // Use TypeParam to refer to the type parameter
  TypeParam value = TypeParam();
  SUCCEED();
}
```

Define all the tests that belong in this pattern.
</Step>

<Step title="Register Tests">
Before instantiating, register the tests using `REGISTER_TYPED_TEST_SUITE_P`:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, DoesSomething, AnotherTest);
```

Include the names of all your `TYPED_TEST_P` tests.
</Step>

<Step title="Instantiate with Types">
In one or multiple translation units, instantiate the suite with one or more types:

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyPatternTest, MyTypes);
```

You can instantiate the same test suite multiple times with different type lists.
</Step>

<Step title="Build and Run">
Compile and run as usual. GoogleTest will run the pattern tests for each instantiated type.
</Step>
</Steps>

### Tips

- Avoid defining `TYPED_TEST_P` tests in anonymous namespaces.
- You can provide custom name generators during instantiation.

---

## Summary

Parameterizing tests enables maximizing test coverage while minimizing code duplication.

- Use **value-parameterized tests** when you want to test the same code with multiple runtime inputs.
- Use **typed tests** when testing the same behavior across different compile-time types.
- Use **type-parameterized tests** for flexible, reusable test patterns instantiated with types elsewhere.

Leverage the built-in parameter generators and combine them as necessary. Customize names to improve test report readability.


## References

- [GoogleTest Primer](primer.md) — for fundamental GoogleTest concepts.
- [Testing Reference](docs/reference/testing.md) — detailed API documentation.
- [Advanced GoogleTest Topics](docs/advanced.md#value-parameterized-tests) — deeper dive into parameterized tests.


---

## Example: Value-Parameterized Test with Combine

```cpp
class FlagsTest : public ::testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(FlagsTest, WorksWithAllCombinations) {
  int number = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  // Test logic using number and flag
}

INSTANTIATE_TEST_SUITE_P(AllCombos, FlagsTest,
                         ::testing::Combine(::testing::Values(1, 2, 3),
                                            ::testing::Bool()));
```

## Example: Typed Test

```cpp
template <typename T>
class NumericTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, double, long>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  TypeParam val{};
  EXPECT_EQ(val, 0);
}
```

## Example: Type-Parameterized Test Pattern

```cpp
template <typename T>
class InterfaceTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(InterfaceTest);

TYPED_TEST_P(InterfaceTest, Behavior) {
  TypeParam obj;
  EXPECT_TRUE(obj.DoSomething());
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, Behavior);

using ImplTypes = ::testing::Types<MyImpl1, MyImpl2>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, InterfaceTest, ImplTypes);
```
