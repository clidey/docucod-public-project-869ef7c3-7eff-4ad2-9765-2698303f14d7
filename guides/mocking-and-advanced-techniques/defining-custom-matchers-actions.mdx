---
title: "Defining Custom Matchers and Actions"
description: "Unlock advanced mocking through custom matchers and actions. This guide shows how to extend GoogleMock’s capabilities to handle project-specific requirements and unusual test cases."
---

# Defining Custom Matchers and Actions

Extend your GoogleMock experience by defining custom matchers and actions tailored to your project needs. This guide empowers you to enhance the flexibility and expressiveness of your tests by crafting bespoke validation logic and mock behaviors for unusual or project-specific requirements.

---

## Workflow Overview

### What This Guide Helps You Achieve

This guide teaches you how to create your own matchers and actions in GoogleMock. Custom matchers allow you to specify precise conditions your mock method arguments must meet, beyond the built-in matchers. Custom actions let you define exactly what happens when a mock method is called, enabling complex behaviors and side effects.

### Prerequisites

- Familiarity with basic GoogleMock concepts: mock classes, `EXPECT_CALL`, `ON_CALL`, built-in matchers, and actions.
- A working C++ development environment with GoogleTest and GoogleMock installed.
- Understanding of function signatures in your mock classes.

### What You'll Accomplish

By following this guide, you will:

- Write simple and parameterized custom matcher classes that integrate seamlessly with GoogleMock.
- Implement polymorphic custom matchers usable with multiple types.
- Define custom actions using lambdas, function objects, or the `ACTION` and `ACTION_P` macros.
- Create monomorphic and polymorphic actions for reusable mock behavior.

### Estimated Time

Approximately 30-45 minutes.

### Difficulty Level

Intermediate - requires comfort with C++ templates and operator overloading.

---

## Writing Custom Matchers

GoogleMock's built-in matchers cover many common needs. When you need to validate arguments against more specific criteria, custom matchers give you complete control.

### Basic Custom Matcher Class

Create a matcher class with these key members:

- `using is_gtest_matcher = void;` — identifies it as a matcher.
- `bool MatchAndExplain(const T& value, std::ostream* os) const;` — returns whether the argument matches, optionally writing explanations.
- `void DescribeTo(std::ostream* os) const;` — describes what the matcher expects.
- `void DescribeNegationTo(std::ostream* os) const;` — describes the negation of the matcher.

#### Example: DivisibleBy7 Matcher

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    const int remainder = n % 7;
    if (remainder != 0 && os != nullptr) {
      *os << "the remainder is " << remainder;
    }
    return remainder == 0;
  }

  void DescribeTo(std::ostream* os) const { *os << "is divisible by 7"; }

  void DescribeNegationTo(std::ostream* os) const { *os << "is not divisible by 7"; }
};

::testing::Matcher<int> DivisibleBy7() {
  return DivisibleBy7Matcher();
}
```

**Usage:**

```cpp
EXPECT_CALL(mock, Bar(DivisibleBy7()));
```

### Parameterized Custom Matchers

For matchers that take parameters, define additional member variables and reference them in methods.

#### Example: Absolute Value Matcher

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}

// Usage
EXPECT_THAT(x, HasAbsoluteValue(10));
```

### Polymorphic Matchers

Define templates to allow your matcher to work with multiple types.

#### Example: NotNull Matcher

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const {
    return p != nullptr;
  }

  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }

  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

---

## Writing Custom Actions

Actions specify what a mock method does when called. GoogleMock provides many built-in actions, but sometimes you need custom behaviors.

### Using Lambdas or Functors

The simplest way to define a custom action is to use a lambda or a function object with a compatible call operator.

#### Example: Multiply Argument by 7

```cpp
EXPECT_CALL(mock, Call(_))
    .WillOnce([](int x) { return x * 7; });
```

### ACTION and ACTION_P Macros

For more control or reusable definitions, use `ACTION` and `ACTION_P` macros.

#### Example: IncrementArg1 Action

```cpp
ACTION(IncrementArg1) {
  return ++(*arg1);
}

// Usage
EXPECT_CALL(mock, DoSomething(_)).WillOnce(IncrementArg1());
```

#### Parameterized Action Example

```cpp
ACTION_P(Add, n) {
  return arg0 + n;
}

EXPECT_CALL(mock, DoSomething(_)).WillOnce(Add(5));
```

### Monomorphic Actions

Implement `ActionInterface<F>` for the specific function type `F` your mock method has. Define the `Perform` method that takes a tuple of arguments.

### Polymorphic Actions

To create actions usable with multiple function types, define an implementation class with a template `Perform` method and wrap it with `MakePolymorphicAction()`.

#### Example: ReturnSecondArgument

```cpp
class ReturnSecondArgumentAction {
 public:
  template <typename Result, typename ArgsTuple>
  Result Perform(const ArgsTuple& args) const {
    return std::get<1>(args);
  }
};

PolymorphicAction<ReturnSecondArgumentAction> ReturnSecondArgument() {
  return MakePolymorphicAction(ReturnSecondArgumentAction());
}

// Usage
EXPECT_CALL(mock, Func()).WillOnce(ReturnSecondArgument());
```

---

## Using WithArgs to Adapt Argument Lists

When your action needs only certain arguments from a mock function with many parameters, use `WithArgs<N1, N2>(action)`.

Example:

```cpp
// Suppose action only needs the 2nd and 3rd arguments
EXPECT_CALL(mock, Foo)
    .WillOnce(WithArgs<1,2>(Invoke(&CustomFunc)));
```

---

## Practical Tips & Best Practices

- Use `.With(...)` to define matchers for the entire argument tuple for complex multi-argument conditions.
- Avoid over-specifying expectations to keep tests maintainable.
- Use `RetiresOnSaturation()` on expectations intended for finite calls to prevent sticky expectations from causing false errors.
- Use `ON_CALL` for default behaviors without setting strict expectations.
- Always set expectations _before_ exercising code that triggers mock methods.
- When mocking functions with move-only parameters or return types, consider lambdas or delegating to alternative methods.

---

## Troubleshooting & Common Issues

- **Warning: 'Uninteresting mock function call'**: This means a mock method call has no matching `EXPECT_CALL`. Use `NiceMock` to suppress, or add `.Times(AnyNumber())` if the calls are expected but unverified.
- **Expectation Not Satisfied**: Run your tests with `--gmock_verbose=info` to get detailed traces of mock calls and matching expectations.
- **Too Many or Too Few Actions**: Make sure that the number of `WillOnce()` actions matches your expected call count or use `WillRepeatedly()` appropriately.
- **Infinite Recursion When Delegating to Real Objects**: Use explicit base-class calls, e.g., `return foo.Foo::Func(args);` to avoid recursion.

---

## Next Steps & Related Content

- Explore [Using Matchers for Powerful Validations](https://yourdocs/guides/core-testing-patterns/using-matchers) to master argument checking.
- See [Creating and Using Mocks](https://yourdocs/guides/mocking-and-advanced-techniques/creating-and-using-mocks) for mock class design.
- Learn about [Mocking Best Practices & Death Tests](https://yourdocs/guides/mocking-and-advanced-techniques/best-practices-and-death-tests) to write robust tests.
- Use the [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html) for advanced troubleshooting.

---

For a complete understanding, review the [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) and the [Actions Reference](https://yourdocs/docs/reference/actions.md).

---