---
title: "Value-Parameterized Tests in Practice"
description: "A guide to creating tests that run over multiple sets of data. Discusses the structure of parameterized tests, combining parameters, and reducing duplication in test logic."
---

# Value-Parameterized Tests in Practice

## Overview

This guide walks you through writing and using value-parameterized tests with GoogleTest. These tests allow you to apply the same logical test across multiple data values or configurations without duplicating test code, enabling efficient and maintainable testing of your C++ classes and functions.

## What Are Value-Parameterized Tests?

Value-parameterized tests let you run the same test logic against different input values or data sets. Instead of writing separate tests for each scenario, you write a test fixture that accepts parameters and then instantiate tests for all relevant parameter values.

This approach is ideal when:

- Your code behavior depends on certain inputs or environment values.
- You want systematic coverage across sets of data without repetitive test code.
- You aim to reduce boilerplate and keep tests concise and organized.

## Prerequisites

Before starting, you should:

- Understand basic GoogleTest test writing (`TEST()`, `TEST_F()`, and fixtures).
- Have GoogleTest included in your project and properly initialized.
- Know how to write simple test fixtures and use assertions.

## Key Components of Value-Parameterized Tests

1. **Fixture Class with Parameter Type**: Your test fixture inherits from `::testing::TestWithParam<T>`, where `T` is the type of the parameter(s).
2. **Defining Parameterized Tests**: Use `TEST_P` macro to declare tests that use parameters.
3. **Instantiating Tests**: Use `INSTANTIATE_TEST_SUITE_P` macro with parameter generator(s) to create instances of the tests for specific parameter values.

## Step-by-Step Guide

### 1. Define a Value-Parameterized Test Fixture

Create a fixture class that inherits from `testing::TestWithParam<T>`. The type `T` represents the parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Fixture members and setup can be defined here.
};
```

This class works like a standard test fixture but with access to a parameter via `GetParam()`.

### 2. Write Parameterized Tests Using `TEST_P`

Declare one or more tests with the `TEST_P` macro, which binds tests to your parameterized fixture.

```cpp
TEST_P(FooTest, DoesBlah) {
  // Access parameter with GetParam().
  EXPECT_TRUE(foo.Blah(GetParam()));
}

TEST_P(FooTest, HasBlahBlah) {
  // Another example test using GetParam().
}
```

Inside these test bodies, use `GetParam()` to access the current test parameter value.

### 3. Instantiate the Test Fixture with Parameters

Use `INSTANTIATE_TEST_SUITE_P` to provide specific parameter values to the tests. You can use GoogleTest's built-in parameter generators such as `Values()`, `ValuesIn()`, `Range()`, `Bool()`, and `Combine()`.

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest, Values("meeny", "miny", "moe"));

const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
```

The first argument `InstantiationName` is a unique prefix that distinguishes this instantiation. It appears as part of the test case names in the test output.

### 4. Running and Filtering Parameterized Tests

Each parameter value generates separate test instances, named as:

- `InstantiationName/FooTest.DoesBlah/0` for the first parameter.
- `InstantiationName/FooTest.DoesBlah/1` for the second parameter, and so forth.

You can run or filter these tests individually using the full test names in the `--gtest_filter` flag.

### 5. Combining Multiple Parameter Generators

Use `Combine()` to generate a Cartesian product of multiple parameter sequences for testing with multiple parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalTest,
  Combine(Values("cat", "dog"), Values(BLACK, WHITE)));
```

This will instantiate tests with all combinations:

- ("cat", BLACK)
- ("cat", WHITE)
- ("dog", BLACK)
- ("dog", WHITE)

### 6. Custom Parameter Types with `ConvertGenerator()`

If your parameter type requires conversion from tuples or other types generated by `Combine()`, use `ConvertGenerator` to cast or transform the parameters:

```cpp
struct ParamType {
  std::string animal;
  Color color;
  ParamType(std::tuple<const char*, Color> t) : animal(std::get<0>(t)), color(std::get<1>(t)) {}
};

INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalTest,
  ConvertGenerator<ParamType::TupleT>(
      Combine(Values("cat", "dog"), Values(BLACK, WHITE))));
```

Alternatively, provide a callable converter:

```cpp
INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalTest,
  ConvertGenerator(Combine(Values("cat", "dog"), Values(BLACK, WHITE)),
                   [](const std::tuple<std::string, Color>& t) {
                     return ParamType{std::get<0>(t), std::get<1>(t)};
                   }));
```

## Practical Example

```cpp
#include <gtest/gtest.h>

class Foo {
 public:
  bool Blah(const char* param) {
    return param != nullptr && param[0] != '\0';
  }
};

class FooTest : public ::testing::TestWithParam<const char*> {
 protected:
  Foo foo;
};

TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}

TEST_P(FooTest, HasBlahBlah) {
  // Additional tests with the same parameters
  EXPECT_NE(strlen(GetParam()), 0);
}

INSTANTIATE_TEST_SUITE_P(TestStrings, FooTest, testing::Values("meeny", "miny", "moe"));

// main() is optionally linked in from gtest_main
int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

## Tips and Best Practices

- Use simple parameter types where possible for readability.
- Make sure parameters are copyable.
- Use `ValuesIn()` to feed parameters from arrays or containers for easier maintenance.
- When your test requires multiple parameters, prefer `Combine()` to create exhaustive test coverage.
- To improve test name readability, supply custom name generators as the optional last argument to `INSTANTIATE_TEST_SUITE_P`.
- Always provide unique instantiation names when instantiating the same test suite multiple times.

## Troubleshooting

**Issue:** Tests are not running or appear missing.

- Check that you have paired each `TEST_P` with an `INSTANTIATE_TEST_SUITE_P` call.
- Remember that `INSTANTIATE_TEST_SUITE_P` instantiations take place when `InitGoogleTest()` is run.
- If you want to suppress the requirement for instantiation, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

**Issue:** Parameter values are not being passed as expected.

- Verify parameter generator functions like `Values()`, `ValuesIn()`, and `Range()` are used correctly.
- Ensure the parameter type matches the types generated by your parameter generator or use `ConvertGenerator` to adjust types.

**Issue:** Test names are hard to read or contain invalid characters.

- Use a custom name generator function or functor for human-friendly and valid test names.

## Next Steps

- Explore [Typed Tests](../advanced.md#typed-tests) to run tests over different types rather than values.
- Read about [Custom Test Name Generators](reference/testing.md#INSTANTIATE_TEST_SUITE_P) to enhance the clarity of test outputs.
- Combine value-parameterized tests with typed tests for more sophisticated test coverage.
- Visit the [GoogleTest Primer](primer.md) for foundational understanding and the [Testing Reference](reference/testing.md) for macro details.

---

## References

- [GoogleTest Primer](https://google.github.io/googletest/primer.html)
- [GoogleTest Testing Reference: TEST_P and INSTANTIATE_TEST_SUITE_P](https://google.github.io/googletest/reference/testing.html#TEST_P)
- [Advanced GoogleTest: Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Mocking Basics](guides/mocking-and-mocking-patterns/mocking-basics.mdx) (for combining mocks and value-parameterized tests)
