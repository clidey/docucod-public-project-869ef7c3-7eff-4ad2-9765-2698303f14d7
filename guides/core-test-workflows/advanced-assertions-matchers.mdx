---
title: "Advanced Assertions and Matchers"
description: "Explore the expressive power of GoogleTest's assertion macros and matchers. This guide covers standard and custom assertions, matcher composition, and assertion result reporting for strong test diagnostics."
---

# Advanced Assertions and Matchers

GoogleTest provides an expressive and flexible set of assertion macros and matchers that give you robust, clear, and maintainable test diagnostics. This guide explores standard and custom assertions, predicates, matchers, and how to report assertion results effectively.

---

## 1. Understanding Assertions in GoogleTest

GoogleTest assertions verify conditions or values within your tests. Upon failure, they provide detailed diagnostic messages to help identify issues precisely.

### 1.1 Types of Assertions

| Assertion Type     | Behavior on Failure                         | Use Case                              |
|--------------------|---------------------------------------------|-------------------------------------|
| `EXPECT_*` macros  | Non-fatal failure; test continues            | When you want test to proceed       |
| `ASSERT_*` macros  | Fatal failure; current function aborts      | For essential checks that preclude further test code |

All assertions support streaming custom messages for additional context:

```cpp
EXPECT_TRUE(my_condition) << "Condition failed because ...";
```

### 1.2 Explicit Success and Failure

- `SUCCEED()`: Marks a point as successful without testing a value.
- `FAIL()`: Immediate fatal failure and function exit.
- `ADD_FAILURE()`: Non-fatal failure at a specific location.
- `ADD_FAILURE_AT(file, line)`: Records failure at specific file and line.

These are useful for documenting control flow or unreachable code blocks.

## 2. General Assertion Categories

### 2.1 Boolean Conditions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Verify *condition* is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Verify *condition* is false.

Custom predicate functions returning `bool` or `AssertionResult` can be used for more expressive checks.

### 2.2 Binary Comparisons

Assertions comparing two values (`val1`, `val2`) with operators:

| Operator  | Macro Example               | Checks                                           |
|-----------|----------------------------|-------------------------------------------------|
| `==`      | `EXPECT_EQ(val1, val2)`     | Equal values                                    |
| `!=`      | `EXPECT_NE(val1, val2)`     | Not-equal values                                |
| `<`       | `EXPECT_LT(val1, val2)`     | Less than                                      |
| `<=`      | `EXPECT_LE(val1, val2)`     | Less than or equal                             |
| `>`       | `EXPECT_GT(val1, val2)`     | Greater than                                   |
| `>=`      | `EXPECT_GE(val1, val2)`     | Greater than or equal                          |

C++ pointers are compared by address. To compare C strings by content, use string-specific assertions instead.

### 2.3 String Assertions

Focus on C strings (`char*`, `wchar_t*`):

- `EXPECT_STREQ(s1, s2)`: strings are equal (content).
- `EXPECT_STRNE(s1, s2)`: strings are not equal.
- `EXPECT_STRCASEEQ(s1, s2)`: equal ignoring case.
- `EXPECT_STRCASENE(s1, s2)`: different ignoring case.

Wide strings will output in UTF-8 for readability.

### 2.4 Floating-Point Assertions

Specialized for handling rounding and representation issues:

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`: Approximate equality for `float` (within 4 ULPs).
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`: Approximate equality for `double`.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`: Absolute difference within *abs_error*.

### 2.5 Exception Assertions

Verify code throwing behavior (requires exceptions enabled):

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW`: Throws expected exception.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW`: Throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW`: Does not throw any exception.

Example:
```cpp
EXPECT_THROW({ throw std::runtime_error("fail"); }, std::runtime_error);
```

### 2.6 Predicate Assertions

When basic macros are insufficient for complex checks, predicate assertions enhance clarity and diagnostics.

- `EXPECT_PRED1(pred, val1)` to `EXPECT_PRED5(pred, val1, ..., val5)`: Uses a boolean function or functor *pred* to test values. On failure, prints the values.

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)` to `EXPECT_PRED_FORMAT5`: Use predicate-formatters returning `AssertionResult` for fully custom failure messages.

Example of predicate formatter:

```cpp
::testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << n << " is odd";
}
```

Used as:

```cpp
EXPECT_PRED_FORMAT1(IsEven, 3);  // Will fail with message: "3 is odd"
```

## 3. Using Matchers for Expressive Assertions

GoogleTest integrates matchers (extended from GoogleMock) to enable rich, human-readable conditions.

### 3.1 Matchers With `EXPECT_THAT` and `ASSERT_THAT`

Matchers allow composition and clear failure messages. Usage:

```cpp
EXPECT_THAT(value, StartsWith("Hello"));
EXPECT_THAT(value, MatchesRegex("\d+abc"));
ASSERT_THAT(num, AllOf(Gt(5), Lt(10)));
```

If a matcher fails, the message shows the expected condition and actual value.

### 3.2 Common Matcher Functions

| Matcher               | Description                                    |
|-----------------------|------------------------------------------------|
| `Eq(value)`            | Equal to `value`                              |
| `Ne(value)`            | Not equal to `value`                          |
| `Lt(value)`, `Le(value)`, `Gt(value)`, `Ge(value)` | Comparison operators                      |
| `StrEq(str)`, `StrNe(str)`       | String equality or inequality                |
| `HasSubstr(substring)`           | Contains substring                           |
| `StartsWith(prefix)`              | Begins with prefix                           |
| `EndsWith(suffix)`               | Ends with suffix                             |
| `ContainsRegex(regex)`            | Regex matches substring                       |
| `Not(matcher)`                   | Negated matcher                             |
| `AllOf(m1, m2, ...)`            | All matchers match                             |
| `AnyOf(m1, m2, ...)`            | Any matcher matches                             |

### 3.3 Composing Matchers

Matchers can be composed for complex checks:

```cpp
EXPECT_THAT(collection, AllOf(Contains(Eq(5)), Not(Contains(Ge(10)))));
```

### 3.4 Container and Collection Matchers

Matchers to check container contents:

- `Contains(element_matcher)`: At least one element matches.
- `Each(element_matcher)`: All elements match.
- `ElementsAre(...)`: Exact elements in order.
- `UnorderedElementsAre(...)`: Exact elements, any order.
- `Pointwise(tuple_matcher, rhs_container)`: Pairwise matching of elements.

### 3.5 Pointer and Property Matchers

- `Pointee(matcher)`: Pointer points to value matching matcher.
- `Field(pointer_to_member, matcher)`: Object's field matches matcher.
- `Property(member_function_pointer, matcher)`: Result of getter matches matcher.

### 3.6 Floating-Point Matchers

- `FloatEq(value)`, `DoubleEq(value)`: Approximate floating equality.
- `FloatNear(value, epsilon)`, `DoubleNear(value, epsilon)`: Approximate within epsilon.

### 3.7 Custom Matchers

Use the `MATCHER`, `MATCHER_P`, etc. macros to define your own matchers with customized matching logic and descriptive messages.

Example:
```cpp
MATCHER(IsEven, "is an even number") { return (arg % 2) == 0; }
```

## 4. Logging Additional Information with `RecordProperty`

Record key-value data in your tests for enhanced diagnostics and rich reporting, especially useful in XML/JSON test output.

```cpp
TEST(MyTest, Example) {
  RecordProperty("MaxValue", ComputeMax());
}
```

Notes:
- Keys must be valid XML attribute names and not conflict with reserved ones (e.g., `name`, `status`).
- Properties can be recorded inside tests, test suites, or environments.

## 5. Advanced Use: Handling Fatal Failures and Subroutine Assertions

By default, `ASSERT_*` macros abort only the current function. To manage propagation:

- Use `ASSERT_NO_FATAL_FAILURE(statement)` to assert that the statement itself generated no fatal failure.
- Use `HasFatalFailure()` to detect if fatal failures happened and decide control flow.

Example:
```cpp
void Subroutine() {
  ASSERT_EQ(1, 2);
  // Does not abort entire test, only this function.
}

TEST(FooTest, Bar) {
  Subroutine();
  if (HasFatalFailure()) return;  // Abort test if subroutine failed.
  // More test code...
}
```

Alternatively, consider exception-based handling or failure-raising listeners for better propagation.

## 6. Skipping Tests

Use `GTEST_SKIP()` to skip tests during runtime conditionally:

```cpp
TEST(FooTest, MaySkip) {
  if (!IsSupported()) {
    GTEST_SKIP() << "Feature not supported";
  }
  // Test code
}
```

## 7. Summary of Practical Steps

<Steps>
<Step title="Write Assertions Using Macros">
Use the appropriate assertion macro (`EXPECT_` or `ASSERT_`) relevant to your verification goal.
</Step>
<Step title="Enhance with Custom Messages">
Stream information with `<<` for richer diagnostic outputs.
</Step>
<Step title="Use Matchers For Complex Checks">
Apply `EXPECT_THAT` with built-in or custom matchers for expressive, clear tests.
</Step>
<Step title="Log Properties for Rich Reports">
Add key-value pairs with `RecordProperty` to include additional data in test output.
</Step>
<Step title="Manage Fatal Failures">
Use `ASSERT_NO_FATAL_FAILURE` and `HasFatalFailure()` to control test flow when failures occur in subroutines.
</Step>
<Step title="Skip Tests When Needed">
Employ `GTEST_SKIP()` for conditional test skipping at runtime.
</Step>
</Steps>

## 8. Troubleshooting & Best Practices

- Avoid using `ASSERT_*` in non-void functions; they abort only the current function.
- Use predicate-format bodies to get detailed failure messages when logical conditions are complex.
- Write custom matchers using `MATCHER` macros to encapsulate domain-specific checks.
- When comparing strings, use string-specific assertions to avoid pointer comparison pitfalls.
- Use death test macros (`ASSERT_DEATH`, `EXPECT_DEATH`) for code expected to terminate the process.

## 9. Next Steps & Related Topics

- Explore [Matchers and Custom Matchers](/api-reference/assertions-and-matchers/using-matchers) for advanced usage.
- Review [Death Tests & Error Handling](/guides/core-test-workflows/death-tests-error-handling) for testing failure scenarios.
- See [Test Lifecycle and Environment Control](/api-reference/core-test-api/test-lifecycle-and-environment) for setup/teardown strategies.
- Consult the [Assertions Reference](reference/assertions.md) for the full catalog of assertion macros.

---

## Additional Code Samples

### Custom Predicate Assertion
```cpp
// Check if number is even, printing a message on failure.
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

// Usage in tests
EXPECT_PRED_FORMAT1(IsEven, value);
```

### Using `EXPECT_THAT` with a Matcher
```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;

TEST(ExampleTest, StartsWithMatcher) {
  std::string greeting = "Hello, world!";
  EXPECT_THAT(greeting, StartsWith("Hello"));
}
```

### Recording Properties
```cpp
TEST(MyTest, RecordsMax) {
  int max_val = ComputeMax();
  RecordProperty("Maximum", max_val);
  EXPECT_GT(max_val, 0);
}
```

### Skipping Tests Dynamically
```cpp
TEST(FeatureTest, Check) {
  if (!IsFeatureAvailable()) {
    GTEST_SKIP() << "Feature not available on this platform.";
  }
  // Test code
}
```
