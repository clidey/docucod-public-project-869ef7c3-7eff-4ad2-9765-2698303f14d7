---
title: "Advanced Matching Techniques"
description: "Unlock the power of expressive test conditions using matchersâ€”covering built-in, composite, and custom matchers. Includes guidance for using matchers in both GoogleTest and GoogleMock to verify objects, containers, and complex data structures."
---

# Advanced Matching Techniques

Mastering the use of matchers unlocks full control over test conditions in GoogleTest and GoogleMock, enabling verification of complex data structures, argument properties, and custom behaviors. This guide presents advanced matcher capabilities, including built-in, composite, and user-defined matchers, focusing on practical usage scenarios relevant for writing expressive and maintainable tests.

---

## 1. Understanding Matchers

Matchers provide a flexible and expressive way to specify what arguments or values are expected in your tests. Instead of simple equality checks, matchers allow you to write precise conditions that values must satisfy, improving test robustness and clarity.

### 1.1 Polymorphic vs Monomorphic Matchers

- **Polymorphic Matchers** (e.g., `Eq(5)`) are matcher factories that can match multiple types depending on context.
- **Monomorphic Matchers** (`Matcher<T>`) match values of one type `T`.

Matchers implement three key operations:
- **MatchAndExplain(value, listener)**: Checks if the value matches, providing detailed match reasons.
- **DescribeTo(ostream)**: Describes what the matcher checks.
- **DescribeNegationTo(ostream)**: Describes what it means to *not* match.

### 1.2 Using Built-in Matchers

GoogleMock provides an extensive library of built-in matchers for common needs:

| Matcher            | Description                             |
|--------------------|-------------------------------------|
| `_`                | Matches any value (wildcard)          |
| `Eq(value)`        | Value equality                       |
| `Ne(value)`        | Value inequality                     |
| `Lt(value)`, `Gt(value)`, `Le(value)`, `Ge(value)` | Comparisons                      |
| `StrEq(str)`, `StrNe(str)` | String equality/inequality               |
| `HasSubstr(substr)` | Checks substring containment         |
| `Contains(elem)`   | Container contains element            |
| `ElementsAre(...)` | Container elements exactly match      |
| `Pointee(matcher)` | Pointer points to a value matching matcher |

Many matchers accept wildcards, composition, and negation, allowing powerful conditional checks.

## 2. Composite Matchers

Composite matchers combine multiple matchers using logical operations:

- **AllOf(...)**: Matches if all child matchers succeed.
- **AnyOf(...)**: Matches if any child matcher succeeds.
- **Not(matcher)**: Matches if the matcher does *not* succeed.

<a name="example-composite"></a>Example:
```cpp
EXPECT_CALL(mock, DoThis(AllOf(Gt(5), Ne(10))));
```
This expects a call where the argument is greater than 5 and not equal to 10.

## 3. Matching Argument Tuples

Sometimes you need to validate multiple arguments collectively using `With()` clause or multi-argument matchers.

Available utilities:
- `AllArgs(m)`: Applies matcher `m` to *all* arguments as a tuple.
- `Args<N1, N2,...>(m)`: Applies matcher to a selected tuple of arguments.

Example:
```cpp
EXPECT_CALL(foo, Bar(_, _)).With(Lt());
// Checks that first argument is less than second.
```

## 4. Advanced Container Matchers

### 4.1 ElementsAre and UnorderedElementsAre

- `ElementsAre(e0, e1, ... en)`: Matches container with exact elements in order.
- `UnorderedElementsAre(e0, e1, ... en)`: Matches container with exact elements ignoring order.

Example:
```cpp
EXPECT_CALL(mock, Foo(ElementsAre(1, Gt(0), _, 5)));
```

### 4.2 ElementsAreArray and UnorderedElementsAreArray

Similar to above but take arrays, vectors, or other iterable sequences.

### 4.3 Contains

Matches if container contains at least one element matching provided matcher.

Example:
```cpp
EXPECT_THAT(my_set, Contains(Gt(10)));
```

### 4.4 Size and Distance Matchers

- `SizeIs(m)`: Matches containers whose size matches matcher `m`.
- `BeginEndDistanceIs(m)`: Matches containers based on iterator distance.

### 4.5 Nested & Complex Container Matching

You can nest container matchers for multi-dimensional containers.

Example:
```cpp
EXPECT_THAT(matrix, ElementsAre(ElementsAre(1, 2), ElementsAre(3, 4)));
```

## 5. Special Matchers for Pointers and References

- `Pointee(m)`: Matches a pointer pointing to a value matching `m`. Handles raw and smart pointers. Null pointers cause match failure.
- `Pointer(m)`: Matches the pointer itself matches `m`.
- `Ref(variable)`: Matches an argument which is a reference to a specific variable (important in verifying argument identity).

## 6. Custom Matchers

You can write your own matchers using the `MATCHER` family of macros or by implementing the matcher interface directly.

### 6.1 Using MATCHER Macro

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }

// Usage
EXPECT_CALL(mock, Foo(IsEven()));
```

The matcher auto-generates descriptions based on the name. You can provide custom descriptions and stream more info to the built-in listener.

### 6.2 Parameterized Matchers

Use `MATCHER_P`, `MATCHER_P2`, ... to add parameters:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  return (arg % divisor) == 0;
}

EXPECT_THAT(val, IsDivisibleBy(7));
```

### 6.3 Implementing the Matcher Interface

If you need more flexibility:
- Define a class with:
  - `using is_gtest_matcher = void;`
  - `bool MatchAndExplain(const T& val, std::ostream* os) const;`
  - `void DescribeTo(std::ostream* os) const;`
  - `void DescribeNegationTo(std::ostream* os) const;`
- Write a factory function returning `Matcher<T>`.

## 7. Using Matchers in Assertions

Use `EXPECT_THAT(value, matcher)` and `ASSERT_THAT(value, matcher)` to assert conditions conveniently.

Examples:
```cpp
EXPECT_THAT(string_val, StartsWith("Hello"));
EXPECT_THAT(container, Contains(Ge(5)));
```

Matchers provide rich failure messages explaining the mismatch.

## 8. Best Practices and Tips

- Prefer explicit matchers like `Eq(value)` over implicit ones to avoid subtle pitfalls.
- Use composite matchers like `AllOf`, `AnyOf` to express boolean logic.
- When matching containers, choose `ElementsAre` for ordered match and `UnorderedElementsAre` when order doesn't matter.
- Use `Pointee` to verify pointed-to values safely avoiding null pointer crashes.
- Define reusable matcher variables to avoid duplication.
- Implement custom matchers when built-in ones don't meet requirements.
- For multi-argument conditions, consider using `With` and `Args` clauses.
- Always keep matchers pure and side-effect free.

## 9. Troubleshooting

**Common Issues:**
- **Implicit conversions causing unexpected success:** Use `Eq()` explicitly.
- **Ambiguous overloads:** Use disambiguating wrappers like `TypedEq` or explicit casts.
- **Matching pointers incorrectly:** Use `Pointee()` for pointed-to value matching.
- **Too many or too few calls:** Understand cardinalities with `Times()`.

## Appendix: Useful Matcher Examples

```cpp
using ::testing::_;  // Wildcard matcher
using ::testing::Eq;
using ::testing::Gt;
using ::testing::Not;
using ::testing::ElementsAre;
using ::testing::Contains;
using ::testing::Pointee;

// Match any int greater than 0
EXPECT_CALL(mock, Foo(Gt(0)));

// Match any call with two arguments, where first is less than second
EXPECT_CALL(mock, Bar(_, _)).With(Lt());

// Match a container with exactly 3 elements: 1, any, and 3
EXPECT_CALL(mock, Process(ElementsAre(1, _, 3)));

// Match a container containing an element greater or equal to 5
EXPECT_THAT(container, Contains(Ge(5)));

// Match a pointer that points to a value equal to 42
EXPECT_CALL(mock, Baz(Pointee(Eq(42))));

// Custom parameterized matcher
MATCHER_P(IsMultipleOf, factor, "") { return (arg % factor) == 0; }
EXPECT_THAT(value, IsMultipleOf(7));
```

---

For detailed information and code reference, see the [Matchers Reference](../reference/matchers.md) and [Mocking Reference](../reference/mocking.md).

Explore usage examples and guidance in the [gMock Cookbook](../gmock_cook_book.md).

Further enhancement includes writing custom actions in the [Defining New Actions](../reference/mocking.md#quicknewactions) section.

---

# Diagram: Matchers Usage Flow

```mermaid
flowchart TD
  A[Value or Argument to be Matched] -->|Used as input| B[Matcher]
  B --> C{Matcher Type}
  C -->|Polymorphic Matcher| D[Implicitly converts to Matcher<T> depending on context]
  C -->|Monomorphic Matcher| E[Matcher<T> specific to type T]
  E --> F[MatchAndExplain(value, listener)]
  D --> F
  F -->|true/false| G[Test Outcome]
  G --> H{Composite Matcher?}
  H -->|Yes| I[Combine child matcher results with logic]
  H -->|No| J[Simple match result]
  I --> K[Report combined result with explanation]
  J --> K
  K --> L[Assertion/Expectation Pass or Fail]
```
