---
title: "Using Assertions Effectively"
description: "Explore the range of assertions provided by GoogleTest—from basic equality checks to custom predicates. Learn how and when to use fatal versus non-fatal assertions, and patterns for clear, diagnostic-rich test failures."
---

# Using Assertions Effectively

Explore the range of assertions provided by GoogleTest—from basic equality checks to custom predicates. Learn how and when to use fatal versus non-fatal assertions, and patterns for clear, diagnostic-rich test failures.

---

## Overview

When writing tests with GoogleTest, assertions are your primary tool to verify that your code behaves as expected. This guide helps you use GoogleTest assertions effectively by explaining the different types of assertions available, how to choose between them, and patterns for writing clear, informative tests.

Whether performing simple checks like equality, more complex predicate assertions, or testing for exceptions and process termination, this guide provides step-by-step instructions and best practices.

---

## 1. Understanding Assertions

### 1.1 Assertion Types: Fatal vs Non-Fatal

GoogleTest provides each assertion in two forms:

- **Fatal Assertions (`ASSERT_*`)**: On failure, these immediately abort the current function, skipping any subsequent statements. Use these when continuing the test after a failure would cause meaningless or harmful results.
- **Non-Fatal Assertions (`EXPECT_*`)**: On failure, these record the error but continue executing the test function. Use these when you want to collect multiple failure points within the same test.

### 1.2 When to Use Each

- Use `ASSERT_*` when a failure means the test cannot sensibly continue (e.g., checking that a pointer is not `nullptr` before dereferencing).
- Use `EXPECT_*` to detect multiple independent problems within one test.

<Tip>
Mixing `EXPECT_*` and `ASSERT_*` appropriately in your tests improves test robustness and clarity.
</Tip>

### 1.3 Streaming Failure Messages

GoogleTest assertions can accept streaming messages using `<<` to append context:

```cpp
EXPECT_EQ(result, expected) << "Failed for input " << input_value;
```

This enhances test failure diagnostics, making it easier to understand failures.

---

## 2. Fundamental Assertion Macros

### 2.1 Boolean Assertions

- `EXPECT_TRUE(condition)`, `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)`, `ASSERT_FALSE(condition)`

Checks if a condition is true or false.

### 2.2 Comparison Assertions

Straightforward comparison macros that print actual and expected values on failure:

- Equality and inequality: `EXPECT_EQ(val1, val2)`, `EXPECT_NE(val1, val2)` (also `ASSERT_EQ`, `ASSERT_NE`)
- Relational operators: `EXPECT_LT`, `EXPECT_LE`, `EXPECT_GT`, `EXPECT_GE`

<Tip>
For comparing C strings (null-terminated), use:
- `EXPECT_STREQ(str1, str2)` to check equality by content.
- `EXPECT_STRNE(str1, str2)` to check inequality.

Avoid using `EXPECT_EQ` directly on C strings, as it checks pointer equality.
</Tip>

### 2.3 String Equality Ignoring Case

- `EXPECT_STRCASEEQ(str1, str2)`
- `EXPECT_STRCASENE(str1, str2)`

Checks string equality/inequality ignoring letter casing.

---

## 3. Specialized Assertions

### 3.1 Floating-Point Comparisons

Due to rounding in floating-point arithmetic, exact equality is often inappropriate.

- `EXPECT_FLOAT_EQ(val1, val2)` and `ASSERT_FLOAT_EQ(val1, val2)` check that two `float` values are approximately equal within 4 ULPs.
- `EXPECT_DOUBLE_EQ(val1, val2)` and `ASSERT_DOUBLE_EQ(val1, val2)` do the same for `double` values.
- `EXPECT_NEAR(val1, val2, abs_error)` and `ASSERT_NEAR(val1, val2, abs_error)` check closeness within an absolute error margin.

<Tip>
Always prefer `EXPECT_DOUBLE_EQ` or `EXPECT_NEAR` over `EXPECT_EQ` for floating-point numbers.
</Tip>

### 3.2 Exception Assertions

Verify if code throws exceptions:

- `EXPECT_THROW(statement, exception_type)`, `ASSERT_THROW(statement, exception_type)`
- `EXPECT_ANY_THROW(statement)`, `ASSERT_ANY_THROW(statement)`
- `EXPECT_NO_THROW(statement)`, `ASSERT_NO_THROW(statement)`

You can test complex statements or code blocks for throwing or not throwing.

---

## 4. Predicate Assertions for Complex Conditions

Sometimes simple Boolean assertions are insufficient for expressing complex tests and producing clear failure messages.

### 4.1 Using Predicate Macros

- `EXPECT_PRED1(pred, val1)` through `EXPECT_PRED5(pred, val1, ..., val5)`
- `ASSERT_PRED1` through `ASSERT_PRED5`

These take predicates returning `bool`, and provide automatic printing of argument values on failure.

### 4.2 Using Predicate-Format Assertions

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)` through `EXPECT_PRED_FORMAT5(...)`
- `ASSERT_PRED_FORMAT1` through `ASSERT_PRED_FORMAT5`

Use these to provide a custom failure message by defining a *predicate-formatter* function returning `testing::AssertionResult`.

Example predicate-formatter function:

```cpp
testing::AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " evaluates to " << n << ", which is not even.";
}
```

Then use:

```cpp
EXPECT_PRED_FORMAT1(AssertIsEven, value);
```

### 4.3 Implementing Predicate-Formatters

Predicate-formatters accept argument expressions as C-strings plus their values. They provide richer failure reporting useful when simple Boolean fails are insufficient.

---

## 5. Advanced Assertion Patterns

### 5.1 Using `SCOPED_TRACE` for Better Diagnostics

When calling subroutines with assertions, failures can be hard to trace back. Use `SCOPED_TRACE` to add contextual information about the calling site:

```cpp
SCOPED_TRACE("Loop iteration " << i);
SubFunction();
```

This adds file, line, and message of the trace point to the failure message, enabling easier debugging.

### 5.2 Catching Fatal Failures in Helper Functions

Fatal assertions like `ASSERT_*` abort the current function, not the entire test. To propagate fatal failures:

- Use `HasFatalFailure()` after calling a helper function to decide if the test should return early.

```cpp
Helper();
if (HasFatalFailure()) return;
```  

- Or use richer exception-based mechanisms to turn assertions into exceptions (requires catching exceptions).

- Use `ASSERT_NO_FATAL_FAILURE(statement)` to assert that a statement runs without producing fatal failures.

---

## 6. Practical Examples

### Example 1: Equality Checking

```cpp
TEST(MyTestSuite, BasicEquality) {
  int result = ComputeAnswer();
  EXPECT_EQ(result, 42) << "Computation failed.";
}
```

On failure, output shows expected and actual values with message.

### Example 2: Floating-Point Comparison

```cpp
TEST(MyTestSuite, FloatingPointComparison) {
  double val = ComputeValue();
  EXPECT_DOUBLE_EQ(val, 3.1415) << "Value differs from Pi.";
}
```

### Example 3: Predicate Assertion

```cpp
bool IsPrime(int n) { ... }

EXPECT_PRED1(IsPrime, 7);
ASSERT_PRED1(IsPrime, 2);
```

### Example 4: Predicate-Formatter Usage

```cpp
testing::AssertionResult AssertIsPositive(const char* expr, int n) {
  if (n > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " evaluates to " << n << ", which is not positive.";
}

EXPECT_PRED_FORMAT1(AssertIsPositive, value);
```

### Example 5: Exception Testing

```cpp
EXPECT_THROW(SomeFunction(), std::runtime_error);
ASSERT_NO_THROW(AnotherFunction());
```

---

## 7. Troubleshooting & Best Practices

### 7.1 Common Pitfalls

- **Using `ASSERT_*` inside non-void functions**: fatal assertions abort the current function which must be void-returning. Using them in functions returning values causes confusing compile errors.

- **Mixing `EXPECT_EQ` with pointers expecting value comparison**: Use `EXPECT_STREQ` for C strings to compare contents.

- **Multiple death test assertions on one line**: Compiler errors occur. Place them on separate lines.

- **Not checking `HasFatalFailure()` after subroutine calls**: This can lead to undefined behavior or crashes.

### 7.2 Best Practices

- Prefer `EXPECT_*` assertions for non-critical checks and `ASSERT_*` when the test cannot continue after failure.
- Use predicate or predicate-format assertions to improve clarity with complex conditions.
- Stream helpful messages with `<<` to your assertions.
- Use `SCOPED_TRACE` to add context for failures in helper functions or loops.
- For floating-point comparisons, prefer `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR`.
- For exception-testing, prefer the `EXPECT_THROW`, `EXPECT_ANY_THROW`, `EXPECT_NO_THROW` macros.

<Tip>
Follow naming conventions: avoid underscores `_` in test suite and test names to prevent unexpected issues.
</Tip>

---

## 8. Summary

Using assertions effectively with GoogleTest involves selecting the right kind of assertion for your verification goal, adding meaningful messages, leveraging predicate assertions for complex conditions, and structuring your tests to propagate failures correctly.

Appropriate use of assertions leads to tests that are easy to read, maintain, and diagnose when failures occur.

For complete information on all assertions, see the [Assertions Reference](reference/assertions.md).

---

## 9. References

- [GoogleTest Assertions Reference](reference/assertions.md)
- [GoogleTest Primer - Writing Tests](docs/primer.md#Assertions)
- [Advanced GoogleTest Topics - Using Assertions](docs/advanced.md#More-Assertions)
- [FAQ on Assertions & Test Failures](docs/faq.md)
- GoogleTest API Reference for [`Test::HasFatalFailure()`](reference/testing.md#Test::HasFatalFailure) and other assertion-related functions

---

## 10. See Also

- [Writing Your First Test](guides/getting-started/first-cpp-test.mdx)
- [Adding Traces to Assertions (`SCOPED_TRACE`)](docs/advanced.md#Adding-Traces-to-Assertions)
- [Exception Assertions](reference/assertions.md#exceptions)
- [Predicate Assertions](reference/assertions.md#predicates)
- [Floating-Point Assertions](reference/assertions.md#floating-point)

---