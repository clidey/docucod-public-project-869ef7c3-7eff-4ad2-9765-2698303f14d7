---
title: "Working with Parameterized and Typed Tests"
description: "Step-by-step instruction for creating tests that run over multiple values or types, increasing coverage and reducing duplication. This page explains value-parameterized and type-parameterized test patterns, including common scenarios and gotchas."
---

# Working with Parameterized and Typed Tests

This guide provides clear, step-by-step instructions for creating parameterized and typed tests using GoogleTest. By leveraging these features, you can run the same test logic over a set of values or types, increasing your test coverage while reducing duplication. You'll learn how to implement value-parameterized tests, typed tests, and type-parameterized tests, along with practical tips and common pitfalls to avoid.

---

## Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Expected Outcome](#expected-outcome)
- [Time Estimate](#time-estimate)
- [Difficulty Level](#difficulty-level)

- [1. Creating Value-Parameterized Tests](#1-creating-value-parameterized-tests)
  - [Define a Fixture Inheriting from `TestWithParam`](#define-a-fixture-inheriting-from-testwithparam)
  - [Write Tests Using `TEST_P`](#write-tests-using-test_p)
  - [Instantiate Tests with Parameter Generators](#instantiate-tests-with-parameter-generators)
  - [Example: Simple Value-Parameterized Test](#example-simple-value-parameterized-test)

- [2. Writing Typed Tests](#2-writing-typed-tests)
  - [Define a Fixture Template](#define-a-fixture-template)
  - [Declare and Bind Type List](#declare-and-bind-type-list)
  - [Define Tests with `TYPED_TEST`](#define-tests-with-typed_test)
  - [Example: Typed Test for Multiple Types](#example-typed-test-for-multiple-types)

- [3. Implementing Type-Parameterized Tests](#3-implementing-type-parameterized-tests)
  - [Define Fixture Template and Declare Suite](#define-fixture-template-and-declare-suite)
  - [Write Tests Using `TYPED_TEST_P`](#write-tests-using-typed_test_p)
  - [Register and Instantiate the Test Suite](#register-and-instantiate-the-test-suite)
  - [Example: Type-Parameterized Test Suite](#example-type-parameterized-test-suite)

- [4. Practical Tips and Common Pitfalls](#4-practical-tips-and-common-pitfalls)

- [5. Troubleshooting](#5-troubleshooting)

- [6. Next Steps & Related Content](#6-next-steps--related-content)

---

## Overview

This guide helps you implement parameterized and typed tests in GoogleTest, empowering you to run tests repeatedly with diverse values or types. It explains three patterns:

- **Value-Parameterized Tests:** Run the same test code over various input values.
- **Typed Tests:** Write tests to run over a list of types known at test definition time.
- **Type-Parameterized Tests:** Write abstract test patterns that can be instantiated with types later, possibly multiple times, even across translation units.

Each pattern improves test coverage with less duplication and more maintainable code.

## Prerequisites

- Familiarity with basic GoogleTest usage (e.g., `TEST()`, `TEST_F()` macros).
- Set up GoogleTest and included `gtest/gtest.h` in your build environment.
- C++11 or later compiler.

## Expected Outcome

- You will be able to create tests that run over multiple data values or types automatically.
- Your tests will be more concise, readable, and maintainable.
- Understanding common parameter generators and macros tailored for these tests.

## Time Estimate

Approximately 15-30 minutes to implement your first parameterized or typed test suite.

## Difficulty Level

Intermediate: Requires moderate knowledge of C++ templates and GoogleTest basics.

---

## 1. Creating Value-Parameterized Tests

Value-parameterized tests let you run the same test logic against different input values to verify behavior across a spectrum of inputs.

### Define a Fixture Inheriting from `TestWithParam`

Create a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the type of the test parameter. This class can implement any necessary setup or members.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Implement common setup or helpers here.
};
```

Alternatively, in complex hierarchies, you may inherit from `Test` and `WithParamInterface` separately.

### Write Tests Using `TEST_P`

Define tests under your fixture using the `TEST_P` macro. Inside the test, retrieve the current test parameter with `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(SomeFunction(GetParam()));
}

TEST_P(FooTest, HasBlah) {
  // Another test using GetParam().
}
```

### Instantiate Tests with Parameter Generators

Use `INSTANTIATE_TEST_SUITE_P` macro to provide the parameter values for the tests. GoogleTest provides several generator functions in the `testing` namespace:

- `Values(v1, v2, ...)` — explicit list of values.
- `ValuesIn(container)` — values from an STL container or C-style array/range.
- `Range(start, end [, step])` — sequence of values in a range.
- `Bool()` — two boolean values: false and true.
- `Combine(g1, g2, ..., gN)` — Cartesian product of multiple generators.

Example instantiations:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, FooTest, testing::Values("meeny", "miny", "moe"));

// Using an array
const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(PetTests, FooTest, testing::ValuesIn(pets));
```

### Example: Simple Value-Parameterized Test

```cpp
class IntTest : public ::testing::TestWithParam<int> {};

TEST_P(IntTest, IsPositive) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveIntegers, IntTest, testing::Values(1, 2, 3, 4, 5));
```

This runs `IsPositive` for each integer 1 through 5.

---

## 2. Writing Typed Tests

Typed tests are useful when you want to run the same tests for different types. You must know the type list at definition.

### Define a Fixture Template

Create a class template fixture derived from `testing::Test` parameterized by type `T`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  using List = std::list<T>;  // Example typedef for the type T
  static T shared_;
  T value_;
};
```

### Declare and Bind Type List

List the types you want to test, then bind the list to your fixture using the macro `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

For a single type, you can omit the `Types<>` wrapper:

```cpp
TYPED_TEST_SUITE(FooTest, int);
```

### Define Tests with `TYPED_TEST`

Use `TYPED_TEST` to define tests. Inside the test, use `TypeParam` to refer to the type.

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;

  typename TestFixture::List values;
  values.push_back(n);
  // Your test logic here
}

TYPED_TEST(FooTest, HasPropertyA) {
  // Additional tests
}
```

### Example: Typed Test for Multiple Types

```cpp
template <typename T>
class NumericTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, double, long>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(TypeParam(), 0);
}

TYPED_TEST(NumericTest, CanAddOne) {
  TypeParam val = 0;
  val += 1;
  EXPECT_GE(val, 1);
}
```

---

## 3. Implementing Type-Parameterized Tests

Type-parameterized tests enable you to define abstract test patterns independent of the actual type list, allowing multiple instantiations.

### Define Fixture Template and Declare Suite

Create a fixture template as before, then declare the test suite as parameterized with `TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class FooTest : public ::testing::Test {
  // Define fixture members here
};

TYPED_TEST_SUITE_P(FooTest);
```

### Write Tests Using `TYPED_TEST_P`

Define tests using the `TYPED_TEST_P` macro.

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  // Test logic using this and members
}

TYPED_TEST_P(FooTest, HasPropertyA) {
  // More tests
}
```

### Register and Instantiate the Test Suite

Register your tests:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

Instantiate with concrete types and assign a unique prefix:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

You can instantiate the same suite multiple times with different prefixes or type lists.

### Example: Type-Parameterized Test Suite

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
}

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(container.size(), 0u);
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed, InitialSizeIsZero);

using MyContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyTypes, ContainerTest, MyContainerTypes);
```

---

## 4. Practical Tips and Common Pitfalls

- **Use `using` or `typedef` for type lists:** The macro `TYPED_TEST_SUITE` requires the list of types to be named to parse commas correctly.
- **Accessing members:** Within typed tests, use `this->` to access non-static members and `TestFixture::` prefix for static members.
- **Custom type names:** You can provide a custom naming class in `TYPED_TEST_SUITE` and `INSTANTIATE_TYPED_TEST_SUITE_P` to improve readability of test names.
- **Order matters in type-parameterized tests:** Register all tests with `REGISTER_TYPED_TEST_SUITE_P` before instantiating.
- **Unique instantiation prefixes:** Use descriptive and unique prefixes in `INSTANTIATE_*` macros to distinguish test instances.
- **Avoid missing instantiation:** Any `TEST_P` or `TYPED_TEST_P` without an instantiation leads to failing tests unless suppressed.
- **Parameter conversion:** When parameters are not implicitly convertible, use `ConvertGenerator` in value-parameterized tests.

---

## 5. Troubleshooting

- **Test Not Running:** Verify you have instantiated your parameterized or typed tests using the appropriate macros (`INSTANTIATE_TEST_SUITE_P`, `INSTANTIATE_TYPED_TEST_SUITE_P`).
- **Compilation Errors:** Ensure your fixture inheritance matches the macro used: `TEST_P` with `TestWithParam<T>`, `TYPED_TEST` with a template fixture derived from `Test`, and so on.
- **Ambiguous Type Errors:** Make sure you use `typename` before dependent types inside templates, e.g., `typename TestFixture::List`.
- **Duplicate Test Names:** Use custom name generators if your type names cause duplication.
- **No tests discovered:** When defining `TEST_P` tests, ensure instantiation is present or suppress the failure with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## 6. Next Steps & Related Content

- Explore the [GoogleTest Primer](../primer.md) to solidify your basic understanding.
- See the [Advanced GoogleTest Topics](../advanced.md#value-parameterized-tests) for deeper knowledge and patterns.
- Refer to the [Testing Reference](../reference/testing.md#INSTANTIATE_TEST_SUITE_P) for exhaustive macro documentation.
- Check the [Guides on Writing Effective Tests](https://github.com/google/googletest/tree/main/docs) for more strategies.

---

### Sample Resources
- Typed Tests Example: [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)
- Value-Parameterized Tests Example: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)
- Combination of Parameters: [sample8_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample8_unittest.cc)

---

For detailed syntax and macro explanations, see the [Testing Reference - Parameterized and Typed Tests](../reference/testing.md#parameterized-and-typed-tests).
