---
title: "Parameterizing Tests with Types and Values"
description: "How to use value-parameterized and type-parameterized test patterns in GoogleTest for efficient coverage of different code paths and input spaces."
---

# Parameterizing Tests with Types and Values

GoogleTest offers powerful mechanisms to write tests that cover multiple input scenarios and type variants without duplicating code. This guide focuses on *value-parameterized* and *type-parameterized* tests, illustrating how to define, instantiate, and use these tests effectively for comprehensive and maintainable validation of your code.

---

## Understanding Test Parameterization in GoogleTest

A common testing need is to run the same logical test with different data inputs or types to ensure broad coverage of different cases without rewriting the test. GoogleTest addresses this through:

- **Value-Parameterized Tests:** Run tests multiple times with different values as parameters.
- **Typed Tests:** Define tests templated by a fixed list of types.
- **Type-Parameterized Tests:** Define abstract test patterns that can be instantiated with different type lists, possibly multiple times.

This page explains how to use these patterns to maximize your test coverage with minimal code duplication.

---

## 1. Value-Parameterized Tests (Data-Driven Testing)

### What They Are
Value-parameterized tests let you write a test once and run it for many values, automatically invoking the test logic with each parameter instance.

### Why Use Them
- Validate function behavior with a variety of inputs.
- Test components that depend on different runtime values.
- Avoid repetitive boilerplate of writing many similar `TEST()` or `TEST_F()` cases.

### Prerequisites
- Base knowledge of GoogleTest tests and fixtures.
- `#include <gtest/gtest.h>`

### How to Implement Value-Parameterized Tests

<Steps>
<Step title="Define a Test Fixture with Parameter Type">
Create your test fixture class inheriting from `testing::TestWithParam<T>` where `T` is the parameter type. This fixture provides access to the parameter through `GetParam()`.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Your setup and helper methods here
};
```
</Step>
<Step title="Define Tests Using TEST_P">
Use `TEST_P` macro to define tests using the fixture. Use `GetParam()` to access the current test value.

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int value = GetParam();
  EXPECT_TRUE(IsValidInput(value));
}
```
</Step>
<Step title="Instantiate Test Suite with Values">
Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with a sequence of values. These values drive the repeated test executions.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyValues, FooTest, testing::Values(1, 2, 3, 100));
```

This produces tests with names reflecting the instantiation prefix and parameter index:
```
MyValues/FooTest.HandlesVariousInputs/0  // param = 1
MyValues/FooTest.HandlesVariousInputs/1  // param = 2
```
</Step>
</Steps>

### Parameter Generators
GoogleTest provides handy generators for parameters:
- `Values(...)`: explicit value list
- `ValuesIn(container)`: values from container
- `Range(start, end, step)`: values in range
- `Bool()`: tests with false, true
- `Combine(...)`: Cartesian product of multiple generators

### Example: Value-Parameterized Test with Custom Type

```cpp
class MyType {
 public:
  explicit MyType(const std::string& val) : val_(val) {}
  const std::string& value() const { return val_; }
 private:
  std::string val_;
};

// Define how GoogleTest prints MyType
void PrintTo(const MyType& obj, std::ostream* os) {
  *os << obj.value();
}

class ValueParamTest : public testing::TestWithParam<MyType> {};

TEST_P(ValueParamTest, WorksWithVariousStrings) {
  const MyType& param = GetParam();
  EXPECT_FALSE(param.value().empty());
}

INSTANTIATE_TEST_SUITE_P(
  StringParams, ValueParamTest,
  testing::Values(
    MyType("one line"),
    MyType("multi\nline"),
    MyType("a very long line with many characters")
  ));
```

### Notes and Best Practices
- If `SetUpTestSuite()` or `TearDownTestSuite()` are defined, declare them `public` to use with `TEST_P`.
- Name your instantiations uniquely when using `INSTANTIATE_TEST_SUITE_P` multiple times.
- Use parameter naming functors for meaningful test names instead of default numeric suffixes.

---

## 2. Typed Tests

### What They Are
Typed tests let you repeat the same test logic for a fixed set of types, known when writing the test.

### When to Use
- Verify that multiple related types conform to the same expected behavior.
- Test template or generic code against a set of concrete types.

### How to Implement Typed Tests

<Steps>
<Step title="Define a Fixture Class Template">
Template your fixture class by the type parameter, inheriting from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 protected:
  T value_;
};
```
</Step>
<Step title="Define Type List and Associate with Fixture">
Use `testing::Types<>` to define a list of types, then invoke `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<char, int, double>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```
</Step>
<Step title="Write Typed Tests Using TYPED_TEST">
Use `TYPED_TEST` macro to write tests. Use `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(FooTest, CanBeDefaultConstructed) {
  TypeParam n{};
  (void)n;  // Suppress unused warning
}

TYPED_TEST(FooTest, WorksWithValue) {
  TypeParam value = this->value_;
  EXPECT_TRUE(sizeof(TypeParam) > 0);
}
```
</Step>
</Steps>

### Custom Type Names
You can define a name generator class with a templated static `GetName(int)` function to generate readable test suffixes for each type.

---

## 3. Type-Parameterized Tests

### What They Are
Type-parameterized tests provide abstract, reusable test patterns that can be instantiated with different type lists later, even multiple times across translation units.

### Why Use Them
- Define generic test suites without knowing concrete types upfront.
- Enable reuse and easy extension of test patterns for new types.

### How to Implement Type-Parameterized Tests

<Steps>
<Step title="Define Fixture Class Template">
Same as typed tests, define a class template derived from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {};
```
</Step>
<Step title="Declare Type-Parameterized Test Suite">
Use `TYPED_TEST_SUITE_P` to declare the test suite (the _P suffix means pattern).

```cpp
TYPED_TEST_SUITE_P(FooTest);
```
</Step>
<Step title="Define Tests Using TYPED_TEST_P">
Use `TYPED_TEST_P` to define the test body, with `TypeParam` referring to the type parameter.

```cpp
TYPED_TEST_P(FooTest, TestA) {
  TypeParam value = 0;
  (void)value;
}

TYPED_TEST_P(FooTest, TestB) {
  EXPECT_TRUE(sizeof(TypeParam) > 0);
}
```
</Step>
<Step title="Register Test Patterns">
Register the test names defined in the suite with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, TestA, TestB);
```
</Step>
<Step title="Instantiate Test Suites with Types">
Instantiate the test suite with concrete types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```
</Step>
</Steps>

### Advanced Options
- You can instantiate the same suite multiple times with different prefixes and type lists.
- Provide a custom naming class to generate readable test names for types.

---

## Practical Tips and Common Pitfalls

- **Naming Conventions:** Avoid underscores in test suite and test names for parameterized tests to keep test names clear and filterable.
- **Unique Instantiation Names:** Use unique prefixes in `INSTANTIATE_TEST_SUITE_P` and `INSTANTIATE_TYPED_TEST_SUITE_P` to differentiate groups.
- **Parameter Name Generators:** Use custom functions or functors to generate descriptive test suffixes based on parameter values or types.
- **Public Visibility for `SetUpTestSuite`:** For `TEST_P` fixtures, declare `SetUpTestSuite` and `TearDownTestSuite` as `public`.
- **Avoid Dangling References:** When using conversion generators with `Values` producing temporary objects, ensure lifetime is managed correctly.
- **Suppressing Missing Instantiations:** If a test suite is intentionally not instantiated, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(name)` to prevent test failures.

---

## Summary Example

```cpp
// Define a value-parameterized test fixture:
class IntParamTest : public testing::TestWithParam<int> {};

// Parameterized tests:
TEST_P(IntParamTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

// Instantiate with test values:
INSTANTIATE_TEST_SUITE_P(EvenValues, IntParamTest, testing::Values(2, 4, 6));

// Typed test fixture templated by type:
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T val_{};
};

// List types:
using MyTypes = testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

// Typed test implementations:
TYPED_TEST(MyTypedTest, IsZeroInitial) {
  EXPECT_EQ(this->val_, TypeParam{});
}

// Type-parameterized test fixture:
template <typename T>
class MyTypeParamTest : public testing::Test {};

// Declare:
TYPED_TEST_SUITE_P(MyTypeParamTest);

// Define:
TYPED_TEST_P(MyTypeParamTest, IsDefaultConstructible) {
  TypeParam t{};
  (void)t;
}

// Register:
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, IsDefaultConstructible);

// Instantiate:
using ParamTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, ParamTypes);
```

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [`INSTANTIATE_TEST_SUITE_P`](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [`TYPED_TEST_SUITE`](../reference/testing.md#TYPED_TEST_SUITE)
- [`TYPED_TEST_SUITE_P`](../reference/testing.md#TYPED_TEST_SUITE_P)

---

Harness the power of parameterized tests to write efficient, scalable, and expressive GoogleTest suites that automatically cover a wide range of inputs and types, boosting confidence and reducing duplication in your testing workflows.
