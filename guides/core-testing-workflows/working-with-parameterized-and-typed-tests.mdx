---
title: "Working with Parameterized and Typed Tests"
description: "Write flexible tests that run over multiple data sets or types using value- and type-parameterized test features. Learn how to increase coverage and avoid code duplication in complex scenarios."
---

# Working with Parameterized and Typed Tests

## Overview

GoogleTest's parameterized and typed tests empower you to write flexible, reusable test logic that runs against multiple data sets or types. This approach dramatically increases your test coverage and reduces code duplication in complex testing scenarios, helping you maintain cleaner and more scalable test suites.

---

## What This Page Covers

This guide explains how to write **value-parameterized tests** and **typed/type-parameterized tests** in GoogleTest, illustrating how to leverage these features to execute the same test logic with different inputs or types. You'll learn how to define test fixtures, create test patterns, instantiate test suites with various parameters or types, and generate distinctive test names.

---

## Prerequisites

- Familiarity with basic GoogleTest usage, including `TEST`, `TEST_F`, and test fixtures.
- A working GoogleTest setup integrated into your build system.
- C++17 or later enabled in your environment (per system requirements).

---

## Expected Outcome

By following this guide, you will be able to:

- Define test fixtures for parameterized and typed test suites.
- Create and run parameterized tests over multiple value inputs.
- Develop typed and type-parameterized tests to verify behavior across different C++ types.
- Instantiate your parameterized and typed test suites properly.
- Customize test names generated from parameters or types for clarity in test output.

---

## Time Estimate

Expect to spend about 15 to 30 minutes reading through the concepts and implementing your first parameterized or typed test. More complex scenarios may take longer as you customize parameter generators and naming.

---

# 1. Value-Parameterized Tests

Value-parameterized tests allow running the same test logic multiple times with different input values, without writing separate test definitions.

### Workflow

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type. This class can have any setup and helper methods you need.

```cpp
class MyTest : public testing::TestWithParam<int> {
  // User-defined setup and members.
};
```
</Step>
<Step title="Write Parameterized Tests Using `TEST_P">
Write your tests using the `TEST_P` macro. Access the current parameter using the `GetParam()` method.

```cpp
TEST_P(MyTest, HandlesValues) {
  int value = GetParam();
  EXPECT_TRUE(value >= 0);
}
```
</Step>
<Step title="Instantiate the Test Suite with Parameter Generators">
Use `INSTANTIATE_TEST_SUITE_P` to specify the parameters your test will run on. GoogleTest offers generators such as `Values()`, `ValuesIn()`, `Range()`, `Bool()`, and `Combine()`.

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTest,
                         testing::Values(1, 2, 3));
```
</Step>
<Step title="Run and Verify">
Build and run your tests. GoogleTest will generate separate test instances with names like `MyInstantiation/MyTest.HandlesValues/0` for each parameter.
</Step>
</Steps>

### Detailed Example

```cpp
class FactorialTest : public testing::TestWithParam<int> {};

TEST_P(FactorialTest, HandlesFactorialInput) {
  int n = GetParam();
  EXPECT_GE(Factorial(n), 1);  // Some factorial check
}

INSTANTIATE_TEST_SUITE_P(ValidValues, FactorialTest, testing::Values(0, 1, 2, 3, 8));
```

### Tips

- Use `Combine()` to create Cartesian products of parameter sets for multi-dimensional testing.
- For tests using complex types, provide a custom printer function to get readable test names.
- If you define `SetUpTestSuite()` or `TearDownTestSuite()` in your fixture class, declare them `public` to enable use with `TEST_P` fixtures.


---

# 2. Typed Tests

Typed tests let you run the same tests on multiple **types** by defining a template test fixture.

This is ideal when you want to verify type-concept compliance or common behavior across different data types without duplicating code.

### Workflow

<Steps>
<Step title="Define a Templated Test Fixture">
Create a fixture template parameterized by a type. Derive it from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```
</Step>
<Step title="Specify Types and Use `TYPED_TEST_SUITE`">
Create a type list using `::testing::Types<...>` and associate it with your test fixture using `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write Typed Tests Using `TYPED_TEST">
Write tests using the `TYPED_TEST` macro. Refer to the type in your test body using `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, HasInitialValueZero) {
  EXPECT_EQ(TypeParam{}, this->value_);
}
```
</Step>
<Step title="Build and Run">
Compile and run. GoogleTest runs the test once for each type, showing names like `MyTypedTest/0.HasInitialValueZero`.
</Step>
</Steps>

### Detailed Example

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T number = T{};
};

using NumericTypes = testing::Types<int, double, long>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(this->number, TypeParam{});
}

TYPED_TEST(NumericTest, CanAddOne) {
  TypeParam x = this->number + 1;
  EXPECT_GT(x, this->number);
}
```

### Custom Type Names

You can provide a names generator class as a third argument to `TYPED_TEST_SUITE` to customize test suite names for each type:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(NumericTest, NumericTypes, MyTypeNames);
```

---

# 3. Type-Parameterized Tests

Type-parameterized tests build on typed tests, allowing you to define test patterns without knowing the type list upfront. You define the pattern once and instantiate it with various type lists later, even multiple times.

### Workflow

<Steps>
<Step title="Define a Templated Test Fixture">
Define a templated fixture class derived from `testing::Test`.

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // test helpers
};
```
</Step>
<Step title="Declare a Type-Parameterized Test Suite">
Declare the test suite with `TYPED_TEST_SUITE_P`.

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```
</Step>
<Step title="Write Tests with `TYPED_TEST_P`">
Define your test logic using `TYPED_TEST_P`. Access the type as `TypeParam`.

```cpp
TYPED_TEST_P(MyTypeParamTest, HasProperty) {
  TypeParam val{};
  EXPECT_EQ(val, val);
}
```
</Step>
<Step title="Register Test Names">
Use `REGISTER_TYPED_TEST_SUITE_P` to register the test names you defined.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, HasProperty);
```
</Step>
<Step title="Instantiate Tests with `INSTANTIATE_TYPED_TEST_SUITE_P`">
Instantiate your test suite by specifying a prefix and a list of types.

```cpp
using MyTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```
</Step>
<Step title="Build and Run">
Compile and run to execute tests for each type.
</Step>
</Steps>

### Detailed Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
}

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed, InitialSizeIsZero);

using MyContainers = testing::Types<std::vector<int>, std::list<char>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```


### Custom Names for Type-Parameterized Tests

Similar to typed tests, you can specify a names generator when instantiating:

```cpp
class TypeParamNames {
 public:
  template <typename T>
  static std::string GetName(int i) {
    // Customize based on T
  }
};

INSTANTIATE_TYPED_TEST_SUITE_P(CustomName, ContainerTest, MyContainers, TypeParamNames);
```

---

# 4. Practical Tips & Best Practices

- **Avoid duplication**: Parameterized and typed tests reduce redundant code for similar tests.
- **Unique names**: Ensure instantiation prefixes are unique to avoid conflicts in test output.
- **Custom naming**: Use naming functors or classes to generate clear and distinct test names, especially for complex parameters or types.
- **Public SetUpTestSuite**: Declare `SetUpTestSuite()` and `TearDownTestSuite()` as `public` when using `TEST_P` or `TYPED_TEST_P` fixtures.
- **Parameter lifetimes**: When using parameter generators with references (e.g., `std::string_view`), ensure the referenced objects outlive the tests.
- **Use `Combine` for multi-param tests**: Combine multiple generators for comprehensive coverage.

---

# 5. Common Pitfalls & Troubleshooting

### Tests Not Running After Instantiation

- Ensure that `INSTANTIATE_TEST_SUITE_P` is called in the same or linked translation unit.
- Parameter generators are evaluated after `InitGoogleTest()`. Avoid dynamic parameters evaluated earlier.

### Failing to Compile Test Suites

- Verify that your fixture class inherits correctly (`TestWithParam<T>` for value-parameterized, `testing::Test` for typed tests).
- For typed tests, provide a `using` alias for the list of types before instantiation.

### Duplicate or Missing Tests in Type-Parameterized Suites

- Must register all test names with `REGISTER_TYPED_TEST_SUITE_P` before instantiating.
- The list of test names must match the test definitions exactly.

### Dangling References in Parameter Generators

- Avoid passing temporary objects to parameter generators that produce references (especially with lambdas and `ConvertGenerator`).

### Name Generation Issues

- Keep generated test names alphanumeric without underscores.
- For complex types or strings, use `PrintToStringParamName` or custom functors.

---

# 6. Next Steps & Related Documentation

- Explore the [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) section for advanced parameter generation.
- Learn more about [Typed Tests](../advanced.md#typed-tests) for static type-based testing.
- Study [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for flexible test patterns.
- See the [Testing Reference](reference/testing.md) for detailed macro and class documentation.
- Review sample test files [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) and [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc) for full working examples.

---

# Additional Resources

- [GoogleTest Primer](../primer.md) - If you are new to GoogleTest, start here.
- [Using Assertions and Matchers](../core-testing-workflows/using-assertions-and-matchers.mdx) - make your tests more expressive.
- [Working with Parameterized and Typed Tests Source](https://github.com/google/googletest/blob/main/docs/advanced.md#value-parameterized-tests) - official source documentation snippet.

---

# Code Sample Recap

```cpp
// Value-Parameterized Test Example
class MyParamTest : public testing::TestWithParam<int> {};

TEST_P(MyParamTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(RangeTests, MyParamTest, testing::Range(1, 5));

// Typed Test Example
template <typename T>
class MyTypedTest : public testing::Test {};
using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  (void)val;  // Use val
}

// Type-Parameterized Test Example
template <typename T>
class MyTypeParamTest : public testing::Test {};
TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, CanDefaultConstruct) {
  TypeParam val{};
  (void)val;
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, CanDefaultConstruct);

using ParamTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, ParamTypes);
```
