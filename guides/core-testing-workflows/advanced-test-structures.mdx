---
title: "Parameterized and Typed Tests"
description: "Step-by-step walkthrough on implementing value- and type-parameterized tests. Covers use cases, design patterns, and real-world strategies for scaling test coverage across inputs and data types."
---

# Parameterized and Typed Tests

GoogleTest enhances test coverage and reduces duplication by allowing you to write tests that vary systematically across different inputs or types. This page provides a step-by-step walkthrough of implementing **value-parameterized tests** and **typed tests**, covering their use cases, design patterns, and strategies for scaling your test suites efficiently.

---

## 1. Understanding Parameterized and Typed Tests

### What You Will Learn
- How to write tests that run repeatedly with different values or types.
- How to define fixtures that accept parameters or type parameters.
- How to instantiate these tests with various parameter sets or type lists.
- Strategies to manage naming and organization of multiple test instances.

### Why Use These Tests?
- **Value-Parameterized Tests** help test logic against multiple inputs without duplicating code.
- **Typed Tests** allow you to run the same tests for multiple data types, verifying type-generic code.
- Both mechanisms improve test coverage and maintainability.

---

## 2. Value-Parameterized Tests

### Workflow Overview

Value-parameterized tests let you systematically test code with different values such as numeric ranges, strings, objects, etc.

### Prerequisites
- Familiarity with GoogleTest basic test and fixture definitions.
- C++ knowledge to define fixture classes and use template parameters.

### Expected Outcome
- You will have tests that automatically run for each value you specify, with distinct test names and results.

### Steps to Implement

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.

Example:
```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // Fixture members go here
};
```

This fixture lets tests access the current parameter via `GetParam()`.
</Step>
<Step title="Write Tests Using TEST_P">
Define your tests with `TEST_P`, passing the fixture and test names.

Inside the test, use `GetParam()` to retrieve the current parameter.

Example:
```cpp
TEST_P(MyParamTest, HandlesPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
  // Test logic with value
}
```
</Step>
<Step title="Instantiate the Test Suite with Parameters">
Use the macro `INSTANTIATE_TEST_SUITE_P` to specify parameter values.

Example to run tests over values 1, 2, and 3:
```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues, MyParamTest,
    testing::Values(1, 2, 3));
```

GoogleTest will run:
- `PositiveValues/MyParamTest.HandlesPositive/0` with `GetParam() == 1`
- `PositiveValues/MyParamTest.HandlesPositive/1` with `GetParam() == 2`
- `PositiveValues/MyParamTest.HandlesPositive/2` with `GetParam() == 3`

Use other generators like `Range()`, `ValuesIn()`, `Bool()`, or `Combine()` for complex inputs.
</Step>
<Step title="Optional: Customize Test Names">
You can provide a custom function or functor to the last argument of `INSTANTIATE_TEST_SUITE_P` that returns a name suffix based on the test parameter.

Example:
```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams, MyParamTest,
    testing::Values(1, 10, 100),
    [](const testing::TestParamInfo<MyParamTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

This makes test names like `NamedParams/MyParamTest.HandlesPositive/Val1`, improving readability.
</Step>
</Steps>

### Practical Tips
- Always instantiate all TEST_P test suites or suppress warnings with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Use `Combine()` to create Cartesian products when testing functions depending on multiple parameters.
- Be careful managing resource lifetimes with pointer or complex parameter types.

---

## 3. Typed Tests

### Workflow Overview

Typed tests run the same test code over a list of types, ideal for verifying templates or type-generic components.

### Prerequisites
- Basic understanding of template classes in C++.
- Ability to define class templates and alias type lists.

### Expected Outcome
- You get test suites automatically run once per type in a type list.

### Steps to Implement

<Steps>
<Step title="Define a Fixture Class Template">
Create a fixture that is a class template parameterized on a type:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
  // You can define member typedefs and static members
};
```
</Step>
<Step title="Create a Type List and Associate it">
Define a type list using `testing::Types<>` and associate it with your fixture using `TYPED_TEST_SUITE`.

Example:
```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write Tests Using TYPED_TEST">
Write typed tests with `TYPED_TEST` macro.

Within the test, use the special identifier `TypeParam` to refer to the current type.

Example:
```cpp
TYPED_TEST(MyTypedTest, WorksForVariousTypes) {
  TypeParam value{};
  // Use value for test logic
  EXPECT_TRUE(sizeof(value) > 0);
}
```
</Step>
<Step title="Run Tests">
Compile and run your test program normally. GoogleTest will automatically run the test suite repeatedly, once per type.
</Step>
</Steps>

### Optional: Custom Type Names

Provide a class with a static template method `GetName(int)` to customize test type suffixes during `TYPED_TEST_SUITE`.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, std::string>) return "String";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

Test cases will have names like `MyTypedTest/WorksForVariousTypes/Int`.

---

## 4. Advanced Usage and Patterns

### Type-Parameterized Tests

You can also define type-parameterized tests that are _defined once_ and instantiated multiple times with varying types later. They provide more flexibility for testing generic interfaces in libraries.

### Using ConvertGenerator<>()

In value-parameterized tests, if parameter types need explicit conversion, `ConvertGenerator<T>()` or overloads allow casting or mapping generated parameters to fixture parameter types.

### Strategies for Large Test Matrices

- Use `Combine()` to build comprehensive coverage without code duplication.
- Define helper functions or lambdas to rename tests clearly.
- Maintain clear, descriptive naming prefixes in your `INSTANTIATE_TEST_SUITE_P` macros.

---

## 5. Troubleshooting & Best Practices

### Common Issues
- **Tests Not Running:** Ensure every `TEST_P` has a corresponding `INSTANTIATE_TEST_SUITE_P` or suppress warnings via `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- **Name Conflicts:** Avoid underscores in test and suite names; they can cause filtering confusion.
- **Incorrect Parameters:** Verify parameter generator types match the test fixture parameter type or use converters.

### Best Practices
- Prefer `testing::TestWithParam<T>` for implementing value-parameterized test fixtures.
- Use explicit `SetUpTestSuite`/`TearDownTestSuite` for expensive shared resources, but be mindful they must be public with parameterized tests.
- Use typed tests to test templated code across a variety of types succinctly.

---

## 6. Examples

### Value-Parameterized Test Example

```cpp
// Fixture for ints
class IntTest : public testing::TestWithParam<int> {};

// Test using GetParam()
TEST_P(IntTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

// Instantiate with a range of values
INSTANTIATE_TEST_SUITE_P(Positives, IntTest, testing::Values(1, 10, 100));
```

This runs three tests checking that 1, 10, and 100 are positive.

---

### Typed Test Example

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T value_{};
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DefaultValueIsZero) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```

This runs the same test twice: once for `int`, once for `double`.

---

## 7. Next Steps & Related Content

- Explore [Value-Parameterized Tests in Advanced Guide](../advanced.md#value-parameterized-tests) for deeper understanding.
- Refer to [Writing Your First Tests](../guides/getting-started/writing-your-first-tests) to build foundational skills.
- Dive into [Effective Use of Assertions and Matchers](../guides/core-testing-workflows/using-assertions-matchers) to write expressive verifications.
- Understand test integration and execution flow in [Test Discovery and Execution Lifecycle](../concepts/execution-integration-behavior/test-discovery-and-lifecycle).

---

## References & Links

- [Value-Parameterized Tests — Advanced Guide](../advanced.md#value-parameterized-tests)
- [Testing Reference — Parameterized Test Macros](../reference/testing.md#TEST_P)
- [Typed Tests — Advanced Guide](../advanced.md#typed-tests)
- [GoogleTest Primer](../primer.md)


---

<Tip>
Start simple: define your parameterized fixture and one test with `TEST_P`. Instantiate with a small set of sample data to verify behavior early. Gradually expand parameter sets and use typed tests for type-generic code.
</Tip>

<Warning>
Remember that `TEST_P` tests without `INSTANTIATE_TEST_SUITE_P` instantiations cause failing tests by default. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FixtureName);` if this is intentional.
</Warning>

<Note>
Custom test naming functions enhance test output readability, especially when parameters are complex types like tuples or user classes.
</Note>

