---
title: "Organizing and Running Test Suites"
description: "Discover how to organize tests into logical groups, leverage test fixtures for efficient setup and teardown, and explore options for running specific tests or controlling test execution flow."
---

# Organizing and Running Test Suites

Effectively managing your C++ tests with GoogleTest accelerates debugging, enhances maintainability, and streamlines test execution. This guide shows you how to organize your tests into logical groups called *test suites*, use *test fixtures* to share setup and teardown code, and control which tests run and how they execute.

---

## 1. Overview

### What This Guide Helps You Achieve
- Structure tests into logical, manageable groups (*test suites*).
- Reuse common setup and cleanup via *test fixtures*.
- Execute specific tests or subsets selectively.
- Control the order and flow of test execution.

### Prerequisites
- Basic understanding of C++.
- GoogleTest framework installed and configured.
- Familiarity with writing basic tests using `TEST()` macros (see [Writing Your First Test](https://github.com/google/googletest/blob/main/docs/guides/core-testing-workflows/writing-basic-tests.mdx)).

### Expected Outcome
- Write well-organized test suites grouping related tests.
- Employ test fixtures for common test logic.
- Run all or selected tests using GoogleTest's execution controls.

### Time Estimate
- Initial setup: 15-30 minutes to refactor tests into suites and fixtures.
- Running tests selectively: instantaneous once configured.

### Difficulty Level
Intermediate — requires understanding of GoogleTest macros and test structuring.

---

## 2. Test Suites: Grouping Related Tests

GoogleTest groups logically related tests into *test suites*; this improves readability, organization, and selective execution.

### How Test Suites Work
- Each test suite is a collection of tests that share a common name.
- You create a test suite by providing the first argument to the `TEST` or `TEST_F` macros.
- Tests with the same suite name belong together.

### Example: Basic Test Suites
```cpp
TEST(MathUtils, FactorialZero) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(MathUtils, FactorialPositive) {
  EXPECT_EQ(Factorial(5), 120);
}

TEST(StringUtils, IsEmpty) {
  EXPECT_TRUE(IsEmpty(""));
}
```
In this example, `MathUtils` is a test suite with two tests. `StringUtils` is another suite.

### Running Test Suites Selectively
Run only tests from a specific suite by passing the `--gtest_filter` flag:
```bash
test_binary --gtest_filter=MathUtils.*
```

---

## 3. Test Fixtures: Sharing Setup and Teardown

When multiple tests in a suite need to use the same data or state, use *test fixtures*.

### What Is a Test Fixture?
- A C++ class derived from `testing::Test`.
- Encapsulates common setup (`SetUp()`) and cleanup (`TearDown()`) code.
- Declares shared data members.
- Each test runs with a fresh fixture instance.

### How to Define a Test Fixture
1. Define a class inheriting from `testing::Test`.
2. Add `protected` section for shared objects.
3. Override `SetUp()` and `TearDown()` to initialize and clean resources.

### Example:
```cpp
class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    q1.Enqueue(1);
    q2.Enqueue(2);
    q2.Enqueue(3);
  }

  Queue<int> q0_;  // Empty queue
  Queue<int> q1_;  // One-element queue
  Queue<int> q2_;  // Two-element queue
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueReturnsCorrectValue) {
  int* val = q1_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, 1);
  delete val;
}
```

### Using `TEST_F` Macro
- Use `TEST_F` instead of `TEST` for tests that use fixtures.
- The first parameter is the fixture class name; second is the test name.
- Access fixture members directly within the test.

### Best Practices
- Keep fixtures focused and lightweight.
- Use fixture constructors sparingly; prefer `SetUp()` for initializing resources.
- Clean up resources in `TearDown()` to prevent leaks.

---

## 4. Running Tests: Controlling Execution

GoogleTest allows you to control which tests to run and how to run them.

### Running All Tests
Simply invoke your test binary; by default, it runs all registered tests:
```bash
./my_tests
```

### Filtering Tests
Run a subset of tests by name patterns using `--gtest_filter`:
- Match suite and test names with wildcards `*` and `?`.
- Examples:
```bash
./my_tests --gtest_filter=MathUtils.*   # all tests in MathUtils suite
./my_tests --gtest_filter=QueueTest.Dequeue*  # tests starting with Dequeue in QueueTest fixture
./my_tests --gtest_filter=-QueueTest.*  # run all except QueueTest suite
```

### Rerunning Failed Tests
GoogleTest can output failed test names for rerun, which is useful after fixing bugs.

### Shuffling Test Order
Control test execution order with:
```bash
./my_tests --gtest_shuffle
./my_tests --gtest_repeat=3
```

Shuffling helps discover order dependencies.

---

## 5. Practical Tips and Common Pitfalls

- **Isolate Tests**: Each test should be independent; use fixtures to provide a clean state.
- **Avoid Shared State**: Don’t share mutable global state across tests.
- **Use `ASSERT_` vs `EXPECT_` Wisely**: Use `ASSERT_*` when continuing after failure isn’t safe.
- **Name Suites and Tests Clearly**: Use descriptive names reflecting the feature or behavior under test.
- **Beware of Overloading in Tests**: When mocking overloaded methods, be explicit to avoid ambiguity.
- **Use `RetiresOnSaturation()` in Mocks**: When expectations must stop after a set count.

---

## 6. Troubleshooting

### Tests Not Running
- Verify that tests are correctly registered with `TEST()` or `TEST_F()`.
- Ensure `RUN_ALL_TESTS()` is called in `main()`.

### Filtering Excludes Tests Unexpectedly
- Check that `--gtest_filter` patterns match test suite and test names correctly.
- Use `--gtest_list_tests` to list all tests available.

### Fixture Setup/TearDown Not Called
- Confirm you override `SetUp()` and `TearDown()` with correct capitalization.
- Ensure tests use `TEST_F()` instead of `TEST`.

### Tests Fail Due to Shared State
- Make sure fixture members are reset for each test, as GoogleTest creates fresh fixture instances.

---

## 7. Next Steps & Related Content

- Explore [Writing Your First Test](https://github.com/google/googletest/blob/main/docs/guides/core-testing-workflows/writing-basic-tests.mdx) for beginner-friendly introductions.
- Learn about [Mocking Basics](https://github.com/google/googletest/blob/main/docs/guides/mocking-and-advanced-scenarios/mocking-basics.mdx) to combine tests with mocks.
- Use [Running Tests & Interpreting Output](https://github.com/google/googletest/blob/main/docs/getting-started/configuring-using-tests/running-tests-validate-output.mdx) to leverage advanced test execution features.
- Consult the [Primer](https://github.com/google/googletest/blob/main/docs/primer.md) for detailed foundational concepts.

---

## Appendix: Sample `main()` for Running Tests

You usually do not need to write your own `main()` as GoogleTest provides one, but when custom setups are needed:

```cpp
#include <gtest/gtest.h>

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

For GoogleMock, use `testing::InitGoogleMock(&argc, argv);` instead.

---

With this guidance, you are equipped to organize well-structured tests, maximize reuse through fixtures, and customize test execution workflows efficiently.



