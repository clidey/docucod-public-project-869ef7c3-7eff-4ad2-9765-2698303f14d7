---
title: "Assertions and Custom Assertions"
description: "In-depth guide to GoogleTest's rich assertion macros and how to write custom assertions for domain-specific checks. Includes best practices for clear failure messages, distinguishing between fatal and non-fatal assertions, and leveraging advanced assertion capabilities."
---

# Assertions and Custom Assertions

## Introduction

This guide provides an in-depth look at GoogleTest's comprehensive suite of assertion macros and how to write custom assertions tailored for your domain-specific verification needs. You will learn how to clearly express test success and failure conditions, shape failure messages for enhanced clarity, and leverage the rich assertion capabilities to write robust, maintainable tests.


---

## 1. Understanding Assertions in GoogleTest

### 1.1 Purpose of Assertions

Assertions are the building blocks of tests that verify conditions or states in your code. They evaluate expressions and determine whether the test should continue or stop based on success or failure.

### 1.2 Fatal vs Non-Fatal Assertions

- **Fatal Assertions (`ASSERT_*`):** Abort the current function immediately upon failure. Use these when continuing the test after failure would yield meaningless or harmful results.
- **Non-Fatal Assertions (`EXPECT_*`):** Record the failure but continue executing the current function, allowing multiple errors to be reported in a single run.

### 1.3 Writing Effective Assertions

Use `ASSERT_*` when the subsequent test steps depend on an assumption being true, for example, when dereferencing a pointer. Use `EXPECT_*` when you want to verify multiple conditions independently within the same test.


---

## 2. Core Assertion Types and Usage

### 2.1 Boolean Assertions

Check simple Boolean conditions:

```cpp
EXPECT_TRUE(condition) << "Expected condition to be true";
ASSERT_FALSE(is_error) << "Expected no error";
```

### 2.2 Equality and Relational Assertions

Compare values for equality and relational conditions. Supports both built-in and user-defined types if streaming operators are defined.

```cpp
EXPECT_EQ(expected, actual) << "Values differ!";
ASSERT_LT(lower_bound, value);
```

- Use `EXPECT_*` to verify multiple comparisions in one test.
- Use `ASSERT_*` to guard against unsafe operations after failure.

### 2.3 String Comparisons

Compare C-style strings and wide strings by contents:

```cpp
EXPECT_STREQ("hello", str);
ASSERT_STRCASEEQ("HELLO", str);
```

### 2.4 Floating-Point Assertions

Due to floating-point imprecision, use these macro pairs for approximate equality:

```cpp
EXPECT_FLOAT_EQ(expected_float, actual_float);
ASSERT_DOUBLE_EQ(expected_double, actual_double);
EXPECT_NEAR(value, expected, abs_error);
```

They verify values are close within ULPs or an absolute tolerance.

### 2.5 Exception Assertions

Check if a statement throws or does not throw exceptions:

```cpp
EXPECT_THROW({ DoWork(); }, std::runtime_error);
ASSERT_NO_THROW({ Initialize(); });
``` 


---

## 3. Advanced Assertion Constructs

### 3.1 Predicate Assertions with Better Failure Messages

When expressions are complex and `EXPECT_TRUE()` is insufficiently descriptive, use predicate assertions to get clearer error output.

- Use `EXPECT_PRED*` macros with Boolean functions for concise code and argument printing.

- Use functions returning `::testing::AssertionResult` to customize messages:

```cpp
::testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(Fib(4)));
```

This prints detailed failure information, e.g.: 
```
Value of: IsEven(Fib(4))
  Actual: false (3 is odd)
Expected: true
```

- Use predicate-format assertions (`EXPECT_PRED_FORMAT*`) to fully customize messages and argument formatting.

### 3.2 Explicit Success and Failure

Sometimes you want to explicitly mark a test point as succeeded or failed:

```cpp
SUCCEED() << "Reached safe checkpoint.";
FAIL() << "Fatal error condition reached.";
```

- `FAIL()` is fatal and aborts the current function.
- `SUCCEED()` is documentative and always passes.

### 3.3 Skipping Tests at Runtime

You can skip the execution of tests conditionally using `GTEST_SKIP()`:

```cpp
TEST(MyTest, MaybeSkip) {
  if (!SystemSupportsFeature()) {
    GTEST_SKIP() << "Skipping due to unsupported system feature.";
  }
  ... // test logic
}
```


---

## 4. Writing Custom Assertions

GoogleTest empowers users to write expressive custom assertions that clarify test failures and encapsulate complex verification logic.

### 4.1 Simple Custom Assertions with Functions

Write a function returning `bool` or `AssertionResult` describing pass/fail:

```cpp
::testing::AssertionResult IsSorted(const std::vector<int>& v) {
  for (size_t i = 1; i < v.size(); ++i) {
    if (v[i] < v[i-1])
      return ::testing::AssertionFailure() << "Vector is not sorted at index " << i;
  }
  return ::testing::AssertionSuccess();
}

EXPECT_TRUE(IsSorted(my_vector));
```

Using `AssertionResult` allows you to stream failure details.

### 4.2 Using `SCOPED_TRACE` for Contextualized Failures

If your assertion function is called from multiple places, add context to failure messages with `SCOPED_TRACE`:

```cpp
void VerifySubsequence(const std::vector<int>& v) {
  SCOPED_TRACE("Verifying subsequence");
  EXPECT_TRUE(IsSorted(v));
}

TEST(MyTest, ChecksSubsequence) {
  std::vector<int> sub = {2, 1, 3};
  VerifySubsequence(sub);
}
```

Failure messages will include the trace point, helping narrow down the failure source.

### 4.3 Best Practices for Custom Assertions

- Always return `::testing::AssertionSuccess()` on pass, and `::testing::AssertionFailure()` with message on fail.
- Return informative messages describing why the assertion failed.
- Avoid side-effects inside assertions; assertions may be evaluated multiple times.


---

## 5. Tips and Troubleshooting

### 5.1 Assertions in Subroutines

- Assertions that generate fatal failures abort only the current function, not the entire test. To propagate fatal failures, see `ASSERT_NO_FATAL_FAILURE()` or check `HasFatalFailure()` after a subroutine.

### 5.2 Assertions in Non-Void Functions

- Fatal assertions (`ASSERT_*`, `FAIL()`) can only be used inside void-returning functions. Non-void functions should use non-fatal assertions (`EXPECT_*`, `ADD_FAILURE()`) or restructure to return results via out-parameters.

### 5.3 Common Assertion Pitfalls

- Using `ASSERT_*` when the rest of the test can run leads to early termination of logic.
- Using `EXPECT_TRUE()` on complex expressions without informative messages can make debugging hard.
- Forgetting to call `testing::InitGoogleTest()` before `RUN_ALL_TESTS()` will result in unexpected test runner behavior.

### 5.4 Verifying Assertion Side Effects

Ensure your assertions evaluate arguments exactly once to prevent surprises from side-effects.


---

## 6. Key Examples

### 6.1 Basic Assertion Example

```cpp
TEST(FactorialTest, HandlesPositive) {
  EXPECT_EQ(Factorial(3), 6);
  ASSERT_NE(Factorial(4), 0);
}
```

### 6.2 Custom Assertion with `AssertionResult`

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0)
    return testing::AssertionSuccess();
  else
    return testing::AssertionFailure() << n << " is odd";
}

TEST(NumberTest, EvenCheck) {
  EXPECT_TRUE(IsEven(4));  // Passes
  EXPECT_TRUE(IsEven(3));  // Fails with message "3 is odd"
}
```

### 6.3 Using `SCOPED_TRACE` for Tracing

```cpp
void TestSubroutine(int x) {
  SCOPED_TRACE("Testing x = " + std::to_string(x));
  EXPECT_GT(x, 0);
}

TEST(MyTest, WithTrace) {
  TestSubroutine(-1);
}
```

Failure will show "Testing x = -1" in the output for easier troubleshooting.

### 6.4 Skipping a Test Dynamically

```cpp
TEST(SystemTest, RequiresFeature) {
  if (!CheckFeature()) {
    GTEST_SKIP() << "Feature unsupported";
  }
  // Test assumes feature is present.
}
```


---

## 7. Next Steps & Related Topics

- Explore the [Assertions Reference](/docs/reference/assertions.md) for a complete list of macros.
- Learn how to write [Custom Assertions and Matchers](/api-reference/utilities-customization/custom-assertions-matchers) for tailored checks.
- Deepen your understanding of assertions' role in [GoogleTest Primer](/docs/primer.md).
- For combining assertions with mock expectations, see [Getting Started with GoogleMock](/guides/getting-started-guides/mocking-basics).



---

## References

- [GoogleTest Primer](primer.md)
- [Assertions Reference](reference/assertions.md)
- [Advanced GoogleTest Topics: Assertions](advanced.md#more-assertions)
- [Custom Assertions and Matchers Reference](api-reference/utilities-customization/custom-assertions-matchers)


---

## Summary
This guide fully equips you to confidently use GoogleTest assertions to verify your code's correctness and write custom assertions that improve clarity and maintainability. By understanding fatal vs non-fatal assertions, utilizing predicate assertions, and adding context with `SCOPED_TRACE`, you will be able to write effective, expressive tests with detailed error diagnostics.
