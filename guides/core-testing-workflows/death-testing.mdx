---
title: "Writing and Using Death Tests"
description: "A guide to testing code that is expected to exit or crash under certain conditions, using GoogleTest's death test framework. Discusses use cases, limitations, and best practices for reliable failure mode testing."
---

# Writing and Using Death Tests

A guide to testing code that is expected to exit or crash under certain conditions, using GoogleTest's death test framework. Discusses use cases, limitations, and best practices for reliable failure mode testing.

---

## 1. Understanding Death Tests

### What Are Death Tests?
Death tests verify that your program exits or crashes as expected when faced with invalid inputs or failed assertions. They are essential for testing failure modes that terminate the process, such as fatal checks, asserts, or calls to exit.

### When to Use Death Tests
Use death tests to:
- Verify precondition checks that terminate on invalid inputs.
- Confirm system behavior on fatal errors or program aborts.
- Test code paths that should never be reachable.

Remember: exceptions are _not_ considered death by these tests since they can be caught and handled. If you need to verify exceptions, use GoogleTest’s exception assertions.

---

## 2. Prerequisites

- You must have GoogleTest installed and integrated into your C++ project.
- Basic familiarity with writing and running GoogleTest tests.
- Your test suite should be compiled with death test support enabled (`GTEST_HAS_DEATH_TEST`).
- For thread safety, be cautious if your tests or environment spawn multiple threads.

---

## 3. Expected Outcome

By following this guide, you will:
- Write tests that confirm your program crashes or exits under expected conditions.
- Understand how to use GoogleTest death test macros and predicates effectively.
- Learn nuances and best practices to ensure your death tests are reliable and maintainable.

---

## 4. Time Estimate & Difficulty

- **Time Estimate:** 15-30 minutes initially to write and verify your first death tests.
- **Difficulty:** Intermediate (requires familiarity with C++ testing concepts and understanding of process termination semantics).

---

## 5. Writing Death Tests

### 5.1. Core Macros for Death Testing
GoogleTest provides the following macros:

| Macro              | Purpose                                                           |
|--------------------|-------------------------------------------------------------------|
| `ASSERT_DEATH`      | Checks if statement causes process to exit nonzero with matching stderr output (fatal, aborts current function on failure). |
| `EXPECT_DEATH`      | Same as above but non-fatal failure (continues after failure).   |
| `ASSERT_EXIT`       | Checks if statement causes exit with exit status matching predicate, and matching stderr output (fatal).
| `EXPECT_EXIT`       | Same as above but non-fatal.
| `EXPECT_DEBUG_DEATH`| Checks death only in debug mode; in optimized builds runs statement normally.


### 5.2. Simple Example
```cpp
TEST(MyDeathTest, DiesOnInvalidArgument) {
  ASSERT_DEATH({
      Foo(-1);  // Foo is expected to abort on invalid args
    }, "Invalid argument");
}
```

This verifies that calling `Foo(-1)` causes the program to exit or abort and produces an error message matching the regex `"Invalid argument"` on standard error.

### 5.3. Using ASSERT_EXIT and EXPECT_EXIT with Predicates
Sometimes you want more specific control on how the program exits.

```cpp
TEST(MyDeathTest, ExitsWithZero) {
  EXPECT_EXIT(
      NormalExitFunction(), testing::ExitedWithCode(0), "Success");
}

TEST(MyDeathTest, KilledBySignal) {
  EXPECT_EXIT(
      KillProcess(), testing::KilledBySignal(SIGKILL), "signal received");
}
```

`ExitedWithCode(int code)` and `KilledBySignal(int signal)` are predicates checking the exit status.

---

## 6. Writing Death Tests That Fail Gracefully

### 6.1. Compound Statements
You can use compound statements (braces) inside death test macros to run multiple lines:

```cpp
ASSERT_DEATH({
  int x = Init();
  FatalFunction(x);
}, "fatal failure message");
```

### 6.2. Looping Over Death Tests
Death tests inside loops are allowed. Example:

```cpp
for (int i = 0; i < 3; i++) {
  EXPECT_DEATH(DeathProneFunction(i), "expected fatal");
}
```

Use `<<` streaming to add extra context messages.

### 6.3. Avoiding Return and Throw inside Death Tests

- **Do NOT use return inside the statement;** returning inside a death test is considered failure.
- Exceptions escaping the death test are also failure conditions.

---

## 7. Death Tests and Threads

### 7.1. Death Test Styles
GoogleTest supports two death test styles controlled by `--gtest_death_test_style` flag or programmatically by setting `GTEST_FLAG_SET(death_test_style, "fast" or "threadsafe")`:

- **Fast (default):** Immediately runs the death test statement after forking. Faster but less safe when multiple threads exist.
- **Threadsafe:** Child process re-executes test binary running only the death test. Safer in multi-threaded environments but slower due to process restart.

### 7.2. Important Considerations

- Death tests should ideally run in a single-threaded context.
- If multiple threads exist, GoogleTest will warn.
- Test suites containing death tests should be named conventionally with suffix `DeathTest`.

```cpp
TEST(MyDeathTest, DiesSafely) { ... }
```

Naming helps GoogleTest order test execution to reduce thread-related issues.

---

## 8. Best Practices

- Name your death test suites with the `DeathTest` suffix for proper RUN order.
- Avoid memory deallocation in death tests to prevent heap checker failures.
- Use `EXPECT_DEATH_IF_SUPPORTED` and `ASSERT_DEATH_IF_SUPPORTED` if you want your tests to be portable across platforms without death test support.
- Be cautious with global state and environment in death tests since child processes start fresh.

---

## 9. Troubleshooting Common Issues

| Issue                                       | Cause / Solution                                                                        |
|---------------------------------------------|----------------------------------------------------------------------------------------|
| Death test never runs or hangs              | Possibly multiple threads running; consider setting death test style to "threadsafe". |
| Failure: message doesn't match              | Confirm regex matches stderr output exactly; limited regex syntax applies.             |
| Test fails because code doesn’t die         | Ensure code path triggers process termination; no exception catch masks failure.       |
| Multiple death tests on the same line       | Each death test assertion must be on its own line due to macro expansion rules.         |
| Mocks leak detected during death tests      | Use `Mock::AllowLeak()` to suppress leaks in death test contexts.                      |

---

## 10. Examples

### 10.1. Expect Program to Die with Specific Error
```cpp
TEST(NetworkDeathTest, DiesOnInvalidPort) {
  ASSERT_DEATH(Server.Listen(-1), "Invalid port number");
}
```

### 10.2. Expect Exit with Code 0 and Specific Message
```cpp
TEST(ExitTest, CleanExit) {
  EXPECT_EXIT(CleanShutdown(), testing::ExitedWithCode(0), "Shutdown complete");
}
```

### 10.3. Using Matcher Object Instead of String
```cpp
using ::testing::ContainsRegex;

EXPECT_DEATH(FailFunc(), ContainsRegex("Fatal error.*code 123"));
```

### 10.4. Looping Death Tests with Extra Info
```cpp
for (int i = 0; i < 5; ++i) {
  EXPECT_DEATH(ProcessRequest(i), "Invalid request") << "Request index: " << i;
}
```

---

## 11. Useful Tips

- Since the test statement runs in a child process, any side effects do not impact the parent process.
- If your death test needs to verify side effects, do so outside the death test assertion.
- Be mindful that `ASSERT_*()` macros abort the current function; inside death tests, avoid using assertions that might cause unexpected returns.

---

## 12. Related APIs & Documentation

- `ExitedWithCode(int)` and `KilledBySignal(int)` predicates help fine-tune exit status verification.
- Use `EXPECT_DEBUG_DEATH()` to conditionally assert death only in debug builds.
- Consult the [Assertions Reference](reference/assertions.md#death) for full macro details.
- See [Advanced Topics](docs/advanced.md#death-tests) for deeper insights.

---

## 13. Summary

Death tests in GoogleTest give you a rigorous way to verify that your program terminates correctly on fatal errors. By forking child processes and validating process exit status along with stderr output, they ensure your critical failure paths behave as expected.

Use the provided assertion macros carefully, follow naming conventions, and select an appropriate death test style to achieve safe and reliable test runs.

---

## 14. Quick Reference Code Snippets

<CodeGroup>
```cpp
// Assert that function dies and emits "Error" on stderr
ASSERT_DEATH(MyFunction(), "Error");
```
```cpp
// Expect exit code 0 and "Success" output
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
```
```cpp
// Name your death test suite with suffix for correct order
TEST(MyDeathTest, HandlesCrash) {
  EXPECT_DEATH(CrashFunc(), "fatal");
}
```
</CodeGroup>

---

## 15. Additional Resources

- [GoogleTest Primer](docs/primer.md)
- [Assertions Reference - Death Assertions Section](docs/reference/assertions.md#death)
- [Advanced GoogleTest Topics - Death Tests Section](docs/advanced.md#death-tests)
- [Integration with Build & CI Systems](overview/audience-usecases-integration/integration-points)

---

*End of guide for Writing and Using Death Tests.*
