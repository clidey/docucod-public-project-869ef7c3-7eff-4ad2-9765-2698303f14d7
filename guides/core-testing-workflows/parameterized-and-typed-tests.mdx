---
title: "Parameterized and Typed Tests"
description: "Discover techniques to efficiently test code across multiple input values or types. This guide details both value-parameterized and type-parameterized tests to maximize coverage with minimal boilerplate."
---

# Parameterized and Typed Tests

Explore techniques to efficiently test your C++ code across multiple input values or types. This guide details how to use both value-parameterized and type-parameterized tests in GoogleTest to maximize coverage while minimizing repetitive boilerplate in your test cases.

---

## Overview

### What This Guide Helps You Achieve
This guide shows you how to write tests that run the same test logic multiple times with different parameters or types, enabling comprehensive testing of your code's behavior with varied inputs.

### Prerequisites
- Familiarity with basic GoogleTest test writing using `TEST` and `TEST_F`.
- A C++ testing project set up with GoogleTest integrated.

### Outcome
By following this guide, you will be able to:
- Implement value-parameterized tests that run multiple test cases with various runtime values.
- Implement type-parameterized tests that run the same tests across different compile-time types.
- Use GoogleTest macros and utilities effectively to instantiate and name parameterized tests.

### Time Estimate
Completing and understanding this guide typically takes 15â€“30 minutes, depending on experience.

### Difficulty Level
Intermediate - assumes basic GoogleTest usage and C++ template knowledge.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to run a battery of test cases with various input values without duplicating code.

### Workflow

<Steps>
<Step title="Define a Test Fixture Class">
Derive your test fixture from `::testing::TestWithParam<T>`, where `T` is the type of parameter to test with.

```cpp
class MyTest : public ::testing::TestWithParam<int> {
  // Setup code as usual
};
```

This enables your test fixture to access the parameter via `GetParam()`.
</Step>

<Step title="Write Parameterized Tests with TEST_P">
Use the `TEST_P` macro to define your parameterized tests. Inside the test, access the input parameter with `GetParam()`.

```cpp
TEST_P(MyTest, HandlesVariousValues) {
  int value = GetParam();
  EXPECT_TRUE(ProcessValue(value));
}
```
</Step>

<Step title="Instantiate with INSTANTIATE_TEST_SUITE_P">
Use `INSTANTIATE_TEST_SUITE_P` to specify the actual parameter values or containers of values for your tests.

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTest, ::testing::Values(1, 2, 3));
```

You can use parameter generators such as:
- `Values(v1, v2, ...)` for listing explicit values.
- `ValuesIn(containerOrArray)` for container/array values.
- `Range(begin, end[, step])` for ranges.
- `Bool()` for boolean flags.
- `Combine(g1, g2, ...)` for Cartesian products of multiple generators.

Optionally, provide a generator to create custom test name suffixes.
</Step>

<Step title="Run and Analyze">
Build and run your tests. The test output shows each instantiated parameter as a separate test case, labeled accordingly.

Example test names:
```
MyInstantiation/MyTest.HandlesVariousValues/0  // for parameter 1
MyInstantiation/MyTest.HandlesVariousValues/1  // for parameter 2
MyInstantiation/MyTest.HandlesVariousValues/2  // for parameter 3
```
</Step>
</Steps>

### Code Example

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {};

TEST_P(FooTest, IsValid) {
  EXPECT_TRUE(ProcessString(GetParam()));
}

INSTANTIATE_TEST_SUITE_P(MyStrings, FooTest, ::testing::Values("meeny", "miny", "moe"));
```

### Best Practices
- Use `INSTANTIATE_TEST_SUITE_P` with meaningful prefix names to organize multiple instantiations.
- Combine multiple parameter generators with `Combine` for multidimensional input coverage.
- Use custom name generators to create human-readable test names for complex parameters.

---

## Type-Parameterized Tests

Type-parameterized tests enable running the same test logic with different types, useful when testing templates or type-dependent behavior.

### Workflow

<Steps>
<Step title="Create a Fixture Template Class">
Define your test fixture as a class template parameterized on `typename T` inheriting from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value;
};
```
</Step>

<Step title="Declare the Type List with `Types`">
Define a type list of all types you want to test.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```
</Step>

<Step title="Associate Types and Use TYPED_TEST_SUITE">
Association of your fixture with the list of types organizes them into typed test suites.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

Optionally, provide a custom name generator class with a static templated `GetName` method.
</Step>

<Step title="Write Typed Tests with TYPED_TEST">
Write test logic with `TYPED_TEST`. The type parameter is accessed as `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value;
  ... test logic ...
}
```
</Step>

<Step title="Build and Run">
Run tests as normal; GoogleTest creates one test suite and runs the typed tests with each type in the list.

Test suite names will indicate the type if a name generator is used.
</Step>
</Steps>

### Code Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T zero = T(0);
};

using NumericTypes = ::testing::Types<int, long, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, IsZeroInitially) {
  EXPECT_EQ(this->zero, TypeParam(0));
}
```

### Notes
- Typed tests are evaluated at compile-time and repeated over the type list.
- Use typed tests when the same test logic applies precisely to several types.
- For more flexible, reusable test patterns, see type-parameterized tests (available with `_P` suffix macros).

---

## Type-Parameterized (Pattern) Tests

Unlike typed tests, type-parameterized tests allow defining abstract test patterns and instantiating them in multiple translation units with different type lists.

### Key Steps

- Define the test fixture template and declare the test suite pattern with `TYPED_TEST_SUITE_P`.
- Define individual tests with `TYPED_TEST_P`.
- Register tests with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate the test suite with specific types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

This approach offers modular and reusable typed testing.

---

## Additional Tips & Common Pitfalls

### Using Custom Test Name Generators
- With value-parameterized tests, provide a lambda or functor to `INSTANTIATE_TEST_SUITE_P` to make test names descriptive.
- With typed tests, provide a class with static `GetName` method in `TYPED_TEST_SUITE` or `INSTANTIATE_TYPED_TEST_SUITE_P` to generate clear type names.

### Avoiding Confusing Test Names
Ensure generated test names contain only alphanumeric characters and underscores.

### Parameter Types
Value parameters must be copyable. Test with complex types using `ConvertGenerator` when implicit conversions are insufficient.

### Instantiation Timing
Parameter generators are evaluated after `InitGoogleTest()` but before `RUN_ALL_TESTS()`. Do not rely on values set after `InitGoogleTest()` for instantiation.

### Uninstantiated Test Suites
Suppress instantiation warnings for unused parameterized test suites using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## Troubleshooting

<AccordionGroup title="Troubleshooting Value-Parameterized Tests">
<Accordion title="Tests Are Not Instantiating">
Ensure `INSTANTIATE_TEST_SUITE_P` is called for the test suite.

Check parameter generator syntax and types.

Verify `GetParam()` matches the parameter type.
</Accordion>
<Accordion title="Test Names Are Confusing or Invalid">
Use the optional name generator argument in `INSTANTIATE_TEST_SUITE_P` to customize suffixes.

Avoid special characters in generated names.
</Accordion>
</AccordionGroup>

<AccordionGroup title="Troubleshooting Typed and Type-Parameterized Tests">
<Accordion title="Compile Errors When Defining Typed Tests">
Ensure the fixture is a class template.

Verify `TYPED_TEST_SUITE` or `TYPED_TEST_SUITE_P` macros are used properly.

Confirm correct use of `TypeParam` inside tests.
</Accordion>
<Accordion title="Duplicate or Missing Test Names in Typed Patterns">
Use `REGISTER_TYPED_TEST_SUITE_P` correctly.

Define tests before registering.
</Accordion>
</AccordionGroup>

---

## Next Steps & Related Content

- Explore [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) and [Typed Tests](../advanced.md#typed-tests) in the advanced guide for conceptual depth.
- See [Writing Effective Assertions](../core-testing-workflows/writing-assertions) to pair these techniques with strong checks.
- Use [Quickstart Guides](../getting-started) for setup and practice writing tests.

---

## References
- [GoogleTest Reference: TEST_P, INSTANTIATE_TEST_SUITE_P](../reference/testing.md#TEST_P)
- [GoogleTest Reference: TYPED_TEST_SUITE, TYPED_TEST](../reference/testing.md#TYPED_TEST)
- [Value Parameter Generators](../reference/testing.md#param-generators)

---

## Example Summary

```cpp
// Value-parameterized example
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, DoesOperate) {
  int param = GetParam();
  EXPECT_TRUE(Op(param));
}

INSTANTIATE_TEST_SUITE_P(Example, FooTest, ::testing::Values(1, 2, 3));

// Typed test example
template <typename T>
class TypedFixture : public testing::Test {
 public:
  T value_;
};

using TypesToTest = testing::Types<int, double>;
TYPED_TEST_SUITE(TypedFixture, TypesToTest);

TYPED_TEST(TypedFixture, HasDefaultValue) {
  EXPECT_EQ(TypeParam(), this->value_);
}
```
