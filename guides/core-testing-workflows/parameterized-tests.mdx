---
title: "Value and Type-Parameterized Tests"
description: "A comprehensive walkthrough for setting up parameterized and type-parameterized testsâ€”crucial for maximizing coverage and minimizing code duplication. Learn to define parameter generators, instantiate test suites, and interpret results."
---

# Value and Type-Parameterized Tests

GoogleTest offers powerful mechanisms for writing parameterized tests that promote better coverage with minimal code duplication. This page guides you through creating *value-parameterized* and *type-parameterized* tests, enabling you to automate testing with various inputs and types effectively.

---

## Overview

### What Are Parameterized Tests?
- **Value-Parameterized Tests** run the same test logic multiple times with different input values.
- **Type-Parameterized Tests** run tests for multiple types with the same test logic.

They maximize code reuse, reduce boilerplate, and ensure thorough validation across diverse scenarios.

### Prerequisites
- Familiarity with basic GoogleTest macros such as `TEST` and `TEST_F`.
- C++17-compatible compiler.
- Inclusion of `<gtest/gtest.h>` in your source files.

### Expected Outcome
After following this guide, you will be able to:
- Define a parameterized test fixture using GoogleTest's provided base classes.
- Create parameterized tests using `TEST_P` and `TYPED_TEST` macros.
- Generate and supply parameter values or types through GoogleTest's parameter generators.
- Instantiate test suites with parameter sets to automatically produce test cases.
- Customize test naming for clarity in test reports.

### Time Estimate
10 to 30 minutes depending on familiarity with testing concepts.

### Difficulty Level
Intermediate

---

## Writing Value-Parameterized Tests

Value-parameterized tests are suitable when the test logic needs to be run with a range of input values.

### 1. Define a Parameterized Fixture Class
Derive your fixture from `testing::TestWithParam<T>`, where `T` is the type of the parameter.

```cpp
class FooTest : public testing::TestWithParam<const char*> {
  // Fixture setup and members...
};
```

Alternatively, if you have an existing base test, inherit from it and `testing::WithParamInterface<T>` manually:

```cpp
class BaseTest : public testing::Test {};

class DerivedTest : public BaseTest, public testing::WithParamInterface<int> {};
```

### 2. Define Parameterized Tests Using `TEST_P`

Use the `TEST_P` macro to define different test cases in the suite. Access the parameter with `GetParam()`:

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(Process(GetParam()));
}

TEST_P(FooTest, HasFeatureX) {
  ASSERT_GT(GetParam().length(), 0);
}
```

### 3. Instantiate the Test Suite with Parameters

Use `INSTANTIATE_TEST_SUITE_P` to bind a parameter generator to the test suite:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MeenyMinyMoe, FooTest, testing::Values("meeny", "miny", "moe"));
```

#### Common Parameter Generators
- `Range(begin, end [, step])`: Generates sequence `{begin, begin+step, ...}` excluding `end`.
- `Values(v1, v2, ..., vN)`: Generates a fixed list of values.
- `ValuesIn(container)` or `ValuesIn(begin, end)`: Uses values from an array or container.
- `Bool()`: Yields `{false, true}`.
- `Combine(g1, g2, ..., gN)`: Produces the Cartesian product of several generators.

**Example:**

```cpp
const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(Pets, FooTest, testing::ValuesIn(pets));
```

> _All tests defined by `TEST_P` in the suite will be instantiated with **every** parameter provided._

### 4. Customize Test Names (Optional)

To improve test output clarity, supply a custom name generator function:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param" + std::to_string(info.param);
    });
```

#### Notes on Naming
- Generated test names must be unique, non-empty, and can only contain ASCII alphanumeric characters or underscores.
- The default name generator returns the zero-based index.

### 5. Using `ConvertGenerator` for Type Conversions

If the parameter type of your fixture does not match exactly the generator's produced type but supports explicit conversion, use `ConvertGenerator`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite,
    ConvertGenerator<std::tuple<int, bool>>(
        Combine(Values(0.1, 1.2), Bool())));
```

You can also pass a lambda to define custom conversions:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite,
    ConvertGenerator(Combine(Values(1, 2), Bool()),
                     [](const std::tuple<int, bool>& t) {
                       return MyParam(std::get<0>(t), std::get<1>(t));
                     }));
```

### 6. Running Tests

Once instantiated, tests run via `RUN_ALL_TESTS()` execute each test case separately with its parameter, producing test names reflecting their parameter values.


---

## Writing Type-Parameterized Tests

Type-parameterized tests let you test the same logic with multiple types without duplicating code.

### 1. Define a Fixture Class Template

Derive a class template from `testing::Test`:

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_;
  using List = std::list<T>;
  static T shared_;
};
```

### 2. Associate the Type List with the Fixture

Define a type list using `testing::Types<...>` and bind it using `TYPED_TEST_SUITE`:

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyFixture, MyTypes);
```

You can also provide a custom name generator class here for type suffixes.

### 3. Define Typed Tests Using `TYPED_TEST`

Write tests referring to the types via the special identifier `TypeParam`, and fixture members with explicit qualification:

```cpp
TYPED_TEST(MyFixture, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  EXPECT_FALSE(values.empty());
}

TYPED_TEST(MyFixture, HasPropertyA) {
  // Additional checks ...
}
```

### 4. Run the Tests

When tests run, each `TYPED_TEST` instantiates a separate test for every type in the list.

---

## Writing Type-Parameterized Test Suites

Type-parameterized tests can be declared without providing the types immediately, and instantiated later, enabling shared test logic for libraries or interfaces.

### 1. Define Test Fixture Template

```cpp
template <typename T>
class FooTest : public testing::Test { ... };
```

### 2. Declare Type-Parameterized Test Suite Pattern

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

### 3. Define Type-Parameterized Tests Using `TYPED_TEST_P`

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;  // Use TypeParam
  ...
}

TYPED_TEST_P(FooTest, HasPropertyA) { ... }
```

### 4. Register Test Names

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

### 5. Instantiate with Specific Types

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, FooTest, MyTypes);
```

---

## Common Pitfalls & Best Practices

- **Don't forget to instantiate your parameterized test suite.** Without instantiation, `TEST_P` suites will not run and cause failures in the verification suite.
- **Use unique instantiation names** with `INSTANTIATE_TEST_SUITE_P` and `INSTANTIATE_TYPED_TEST_SUITE_P` to differentiate multiple instantiations.
- **Ensure test names generated by custom name generators are valid.** They must contain only alphanumeric characters or underscores.
- **Manage parameter object lifetimes carefully** if your parameters involve pointers.
- **Remember that parameter generator expressions run at test initialization time,** after `InitGoogleTest()`.

---

## Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Tests Not Running - No Instantiations">
If your `TEST_P` or `TYPED_TEST_P` is defined but no tests execute, verify you called `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`. Every value-parameterized or type-parameterized test suite must be instantiated.
</Accordion>

<Accordion title="Duplicate or Invalid Test Names">
Ensure custom name generators produce valid unique names without spaces or special characters. Non-compliant names cause registration errors.
</Accordion>

<Accordion title="Parameter Lifetime Issues">
Raw pointers used as parameters require manual lifetime management. Prefer using value types or smart pointers where possible.
</Accordion>
</AccordionGroup>

---

## Next Steps & Related Content

- Explore how to use the parameter generators creatively with `Combine()` to cover multi-dimensional test spaces.
- Learn about [Writing Your First Test](../getting-started/configuration-first-run/first-test.md) to complement parameterized testing.
- Read the [Advanced GoogleTest Topics](../docs/advanced.md#value-parameterized-tests) for deeper insights and patterns.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings for optionally instantiated parameterized suites.

---

## Examples

```cpp
// Define a value-parameterized test fixture.
class FooTest : public testing::TestWithParam<int> {};

// Define tests using TEST_P.
TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

// Instantiate with Values.
INSTANTIATE_TEST_SUITE_P(PositiveValues, FooTest, testing::Values(1, 2, 3));

// Typed test example

template <typename T>
class MyFixture : public testing::Test {
 public:
  static T static_value;
  T value;
};

template <typename T>
T MyFixture<T>::static_value = T();

using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyFixture, MyTypes);

TYPED_TEST(MyFixture, DefaultConstructed)
{
  TypeParam val = this->value;  // Access fixture member
  EXPECT_EQ(val, TypeParam());
}

TYPED_TEST(MyFixture, HasStaticValue)
{
  EXPECT_EQ(MyFixture<TypeParam>::static_value, TypeParam());
}
```

---

## References

- [Testing Reference](../../reference/testing.md#value-parameterized-tests)
- [Advanced GoogleTest Topics - Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [GoogleTest Primer - Test Fixtures](../primer.md#same-data-multiple-tests)
- [Writing Your First Test](../getting-started/configuration-first-run/first-test.md)

---