---
title: "Writing Parameterized and Typed Tests"
description: "Learn how to efficiently test code with multiple input values or types using GoogleTest's value- and type-parameterized tests. This guide covers setup, execution, and use cases where parameterization brings the most value."
---

# Writing Parameterized and Typed Tests

Learn how to efficiently test your code with multiple input values or types using GoogleTest's powerful value- and type-parameterized test capabilities. This guide helps you set up, write, and run parameterized and typed tests, enabling you to cover a broad spectrum of scenarios with less code and better organization.

---

## 1. Understanding Parameterized and Typed Tests

### What Are Parameterized Tests?
Parameterized tests let you run the same test logic repeatedly with different inputs, without duplicating code. GoogleTest supports _value-parameterized tests_, where each test runs with a different parameter value drawn from specified sets or sequences.

### What Are Typed Tests?
Typed tests allow running the same test logic across multiple C++ types. This is ideal if you want to verify a template or type-agnostic code with different type parameters efficiently.

---

## 2. Prerequisites

- Familiarity with basic GoogleTest concepts: writing simple tests using `TEST()` and test fixtures using `TEST_F()`.
- A C++ environment set up with GoogleTest integrated.
- Basic understanding of C++ templates for typed tests.

Refer to the [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md) for foundational concepts if needed.

---

## 3. Writing Value-Parameterized Tests

Value-parameterized tests allow testing the same logic using different input values.

### Workflow Overview

- **Define a test fixture class** that derives from `testing::TestWithParam<T>`, where `T` is the parameter type.
- **Write tests** using `TEST_P()` macro referring to the fixture.
- **Instantiate tests** with parameter values using `INSTANTIATE_TEST_SUITE_P()`.

### Step-by-Step Guide

<Steps>
<Step title="Define Your Parameterized Test Fixture">
Create a test fixture inheriting from `testing::TestWithParam<T>`. This class can have setup, teardown, and member variables to support your test.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Fixture members and setup code.
};
```
</Step>
<Step title="Write Parameterized Tests with TEST_P">
Write your tests using `TEST_P(FooTest, TestName)`, inside which you access the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  const char* param = GetParam();
  EXPECT_TRUE(MyFunction(param));
}
```
</Step>
<Step title="Instantiate Tests with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to supply parameter values or generators.

```cpp
const char* inputs[] = {"value1", "value2", "value3"};
INSTANTIATE_TEST_SUITE_P(MyInstantiation, FooTest, ::testing::ValuesIn(inputs));
```
This creates versions of each test with parameters "value1", "value2", "value3".

You can also use other generators like `Values()`, `Range()`, or `Combine()` for multiple parameters.
</Step>
</Steps>

### Parameter Generators

| Generator       | Description                                                                                   |
|-----------------|-----------------------------------------------------------------------------------------------|
| `Values(v1, v2, ...)`   | Use a fixed list of parameter values                                                        |
| `ValuesIn(container)`   | Use values from an array, STL container, or iterator range                                    |
| `Range(begin, end [, step])` | Generate a sequence of values from begin to end (excluding end), stepping by step (default 1) |
| `Bool()`              | Generates `{false, true}`                                                                    |
| `Combine(g1, g2, ..., gN)` | Cartesian product of multiple parameter generators (tuples)                                 |

### Custom Test Names

You can customize test names by passing a name generator function or functor as the optional last argument in `INSTANTIATE_TEST_SUITE_P`. This function receives a `TestParamInfo` object and returns a `std::string` suffix (allowed characters: alphanumeric and underscore).

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest,
    ::testing::Values("a", "b"),
    [](const ::testing::TestParamInfo<const char*>& info) {
      return std::string("Param_") + info.param;
    });
```

### Best Practices

- **Always provide meaningful test names** to distinguish tests easily when filtering or debugging.
- **Use `EXPECT_*` for checks inside parameterized tests** when you want subsequent tests to continue on failure.
- Prefer `ASSERT_*` if a failed check makes continuation meaningless.

---

## 4. Writing Typed Tests

Typed tests allow running the same tests for different C++ types.

### Workflow Overview

- **Create a typed test fixture template** derived from `testing::Test`.
- **Define a type list** with the types to test.
- **Associate the fixture with the type list** using `TYPED_TEST_SUITE()`.
- **Write typed tests** using `TYPED_TEST()`.

### Step-by-Step Guide

<Steps>
<Step title="Define a Typed Test Fixture Template">
Define a class template deriving from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;  // e.g., a common typed member
};
```
</Step>
<Step title="Define the List of Types to Test">
Declare a `using` alias for the type list.

```cpp
using MyTypes = ::testing::Types<int, float, double>;
```
</Step>
<Step title="Associate Fixture and Types">
Bind the fixture with the type list via `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write the Tests using TYPED_TEST">
Write typed tests using `TYPED_TEST`, where `TypeParam` refers to the current type.

```cpp
TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```
</Step>
</Steps>

### Advanced: Custom Type Name Mapping

You can specify a class providing static template method `GetName(int index)` to customize test suite suffixes for types.

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    else if constexpr (std::is_same_v<T, float>) return "Float";
    else return "UnknownType";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, TypeNames);
```

---

## 5. Writing Type-Parameterized Tests

These differ from typed tests in that you define the test pattern once without fixing the types and instantiate it multiple times with chosen type lists.

### Workflow Overview

- **Define a template fixture** as in typed tests.
- **Declare test patterns** using `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` macros.
- **Register the patterns** using `REGISTER_TYPED_TEST_SUITE_P`.
- **Instantiate** with `INSTANTIATE_TYPED_TEST_SUITE_P` and provide type lists.

This facilitates writing generic test suites usable across different projects.

### Example Skeleton

```cpp
template <typename T>
class FooTest : public testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam value{};
  EXPECT_TRUE(IsValid(value));
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah);

using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```

---

## 6. Real-World Use Cases and Scenarios

### Scenario 1: Testing a Sorting Algorithm with Multiple Types

You want your sorting function to support various container types (`int`, `double`, `std::string`). Define a typed test suite and write generic tests against the type parameter.

### Scenario 2: Testing a Parser with Different Input Strings

Use value-parameterized tests to feed multiple input strings to the parser and verify output correctness for each input.

### Scenario 3: Complex Combinations

Use `Combine()` generator to create Cartesian products of multiple parameter sets for comprehensive coverage.

```cpp
INSTANTIATE_TEST_SUITE_P(
    AllCombinations, MyTestSuite,
    Combine(Values(1, 2), Bool(), Values("foo", "bar")));
```

---

## 7. Troubleshooting & Tips

<AccordionGroup title="Troubleshooting Common Issues">
<Accordion title="Parameters Not Passed as Expected">
Ensure that the parameter type matches the fixture's `ParamType`. Mismatched types cause compilation errors.
</Accordion>
<Accordion title="Duplicate or Invalid Test Names">
Test names generated by the optional name generator should be unique and can only contain alphanumeric characters and underscores.
</Accordion>
<Accordion title="Parameters Evaluated Too Early or Late">
Parameter generators are evaluated during `InitGoogleTest()`. Avoid side effects or dependencies on state that changes after this point.
</Accordion>
</AccordionGroup>

<Tip>
Use `PrintToStringParamName` from `testing` namespace for automatic parameter name generation if your parameter types support streaming.
</Tip>

<Tip>
Typed tests require C++11 or above due to their templated nature. Ensure your compiler supports necessary features.
</Tip>

---

## 8. Next Steps & Related Documentation

- Explore writing advanced assertions in [Assertions: Verifying Test Outcomes](../core-testing-workflows/using-assertions) to enhance your tests.
- Learn how to organize tests into suites better with [Organizing and Managing Test Suites](core-testing-workflows/organizing-test-suites).
- Combine parameterized tests with mocks using [Mocking Dependencies with GoogleMock](core-testing-workflows/mocking-with-googlemock).
- Consult the [GoogleTest Primer](../primer) for foundational test writing concepts.

---

## Appendix: Common Macros Reference

| Macro                    | Purpose                                    |
|--------------------------|--------------------------------------------|
| `TEST_P(TestFixture, TestName)`         | Defines a value-parameterized test       |
| `INSTANTIATE_TEST_SUITE_P( prefix, TestFixture, generator )` | Creates test instances with parameters |
| `TYPED_TEST_SUITE(Fixture, Types)`     | Defines typed tests for given types      |
| `TYPED_TEST(Fixture, TestName)`        | Defines individual typed test             |
| `TYPED_TEST_SUITE_P(Fixture)`           | Declares a type-parameterized test suite |
| `TYPED_TEST_P(Fixture, TestName)`       | Declares type-parameterized test          |
| `REGISTER_TYPED_TEST_SUITE_P(Fixture, Tests...)` | Registers test names for type-parameterized suite |
| `INSTANTIATE_TYPED_TEST_SUITE_P(prefix, Fixture, Types)` | Instantiates typed test suite          |

For detailed API and macro usage, see the [Parameterized & Typed Tests API Reference](../api-reference/core-testing-apis/parameterized-tests).

---

## Example: Value-Parameterized Test

```cpp
#include <gtest/gtest.h>

class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

## Example: Typed Test

```cpp
#include <gtest/gtest.h>

template <typename T>
class NumericLimitsTest : public testing::Test {
 protected:
  T zero_ = T{};
};

using MyTypes = testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, HasZeroValue) {
  EXPECT_EQ(this->zero_, TypeParam(0));
}
```

---

For more examples and detailed explanations, refer to the official GoogleTest repository and [Testing with GoogleTest documentation](https://github.com/google/googletest/tree/main/docs).


<Check>
Remember to always call `testing::InitGoogleTest(&argc, argv);` before `RUN_ALL_TESTS()` in your main function to ensure parameters and typed tests are registered correctly.
</Check>
