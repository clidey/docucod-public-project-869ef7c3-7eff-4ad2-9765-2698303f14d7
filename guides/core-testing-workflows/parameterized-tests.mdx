---
title: "Parameterized and Typed Tests"
description: "Step-by-step instructions for creating value-parameterized and type-parameterized tests. Learn how to maximize test coverage by running test logic over multiple inputs and types."
---

# Parameterized and Typed Tests

## Overview

This page provides a practical, step-by-step guide to writing and using value-parameterized and type-parameterized tests in GoogleTest. Parameterized tests maximize test coverage by running the same test logic with multiple inputs or type instantiations, helping you identify edge cases and verify your code under various conditions without redundant code.

---

## 1. Value-Parameterized Tests

Value-parameterized tests allow you to run the same set of tests repeatedly with different input parameters, enabling data-driven testing and variation over input values efficiently.

### What You Achieve
- Define a single test fixture that accepts a parameter.
- Write test *patterns* once which will execute multiple times with different parameter values.
- Instantiate the tests with diverse value sets using built-in parameter generators.

### Prerequisites
- Basic familiarity with GoogleTest test fixtures.
- C++ test environment where the parameter type is copyable.

### Step-by-Step Guide

<Steps>
<Step title="Define a Parameterized Test Fixture">
Define a test fixture class that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // Optional: Implement setup/teardown or helper functions
};
```

This fixture class provides access to the current parameter value via `GetParam()`.
</Step>

<Step title="Write Parameterized Tests Using `TEST_P`">
Define tests using `TEST_P` macro, similar to `TEST_F`, but allowing parameter access.

```cpp
TEST_P(MyParamTest, HandlesEvenNumbers) {
  int param = GetParam();
  EXPECT_EQ(param % 2, 0);
}

TEST_P(MyParamTest, HandlesPositiveNumbers) {
  EXPECT_GT(GetParam(), 0);
}
```
</Step>

<Step title="Instantiate Tests with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to create different test suites from your parameterized tests.

GoogleTest provides several parameter generators:
- `Values(...)`: Specify explicit value list.
- `ValuesIn(container)`: Provide an iterable container.
- `Range(start, end[, step])`: Provides ranges of values.
- `Bool()`: Tests with boolean values `false` and `true`.
- `Combine(g1, g2, ...)`: Cartesian product of multiple generators.

Example instantiation:

```cpp
INSTANTIATE_TEST_SUITE_P(MyIntTests, MyParamTest, testing::Values(2, 4, 6, 8));
```

This runs your tests with parameter values 2, 4, 6, and 8.
</Step>

<Step title="Optionally Generate Friendly Test Names">
Provide an optional name generator functor or function to produce descriptive test names.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, MyParamTest, testing::Values(2, 4, 6),
    [](const testing::TestParamInfo<int>& info) {
      return "Param" + std::to_string(info.param);
    });
```

This generates names like `NamedTests/MyParamTest.HandlesEvenNumbers/Param2`.
</Step>

<Step title="Run and Filter Parameterized Tests">
Run tests as usual using `RUN_ALL_TESTS()`. You can also filter using `--gtest_filter` with test names containing instance indices or custom suffixes.
</Step>
</Steps>

### Tips and Best Practices
- Use `ValuesIn` with containers when the data set is dynamic or large.
- Use `Combine` to test all combinations of multiple parameters.
- Avoid overly large parameter sets as it increases test execution time.
- Use descriptive naming for better test result readability.

### Common Pitfalls
- Forgetting to instantiate your parameterized test will cause no tests to run.
- Ensure `SetUpTestSuite()` and `TearDownTestSuite()` are public when using `TEST_P`.
- Parameters must be copyable, or managed carefully if pointers.

---

## 2. Type-Parameterized Tests

Type-parameterized tests let you write generic test patterns that run once per type, ideal for verifying templates or type traits over multiple types.

### What You Achieve
- Define tests that operate on a type parameter.
- Instantiate tests with different types individually, possibly in different translation units.
- Verify behaviors or properties expected from any compatible type.

### Prerequisites
- Familiarity with C++ templates.
- Understand the difference between typed and type-parameterized tests.

### Step-by-Step Guide

<Steps>
<Step title="Define a Type-Parameterized Test Fixture">
Create a class template derived from `testing::Test` parameterized on a type `T`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // You can define type-dependent members here.
};
```

Declare it as a type-parameterized test suite with `TYPED_TEST_SUITE_P`:

```cpp
TYPED_TEST_SUITE_P(MyTypedTest);
```
</Step>

<Step title="Define Typed Tests Using `TYPED_TEST_P`">
Write test patterns using the `TYPED_TEST_P` macro. Use `TypeParam` to reference the type parameter.

```cpp
TYPED_TEST_P(MyTypedTest, DoesSomething) {
  TypeParam value{};
  // Test behavior related to TypeParam
  EXPECT_TRUE(SomeCompileTimeCheck<TypeParam>());
}
```

You can define multiple tests.
</Step>

<Step title="Register Your Test Patterns">
Register the tests with `REGISTER_TYPED_TEST_SUITE_P`, listing all the test names.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypedTest, DoesSomething);
```
</Step>

<Step title="Instantiate Tests With Specific Types">
Instantiate the test suite with desired types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = ::testing::Types<int, float, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, MyTypedTest, MyTypes);
```

Tests will be run once per type in `MyTypes`.
</Step>
</Steps>

### Tips and Best Practices
- Use type-parameterized tests when you want the test logic independent of the set of types.
- Organize test patterns and instantiation in separate files if shared across libraries.
- Use custom type name generators when default names are verbose or ambiguous.

### Common Pitfalls
- Forgetting to register tests with `REGISTER_TYPED_TEST_SUITE_P` results in no tests running.
- Instantiation names must be unique across the test binary.

---

## 3. Advanced Parameter Generation

GoogleTest offers powerful parameter generation functions:

- `Range(start, end, step)`: Generate values within a range.
- `Values(...)`: Generate enumerated values explicitly.
- `ValuesIn(container)`: Generate values from a container or iterator range.
- `Bool()`: Generate boolean values.
- `Combine(...)`: Generate Cartesian products of multiple parameter generators.
- `ConvertGenerator<T>(gen)`:
  Convert generated parameters to a specified type `T` using static_cast or a conversion function.

Examples:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedTests, MyParamTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

This example runs tests for each combination: `(1, false)`, `(1, true)`, `(2, false)`, `(2, true)`.

---

## 4. Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="No Tests Run After Defining Parameterized Test">
Ensure you have called `INSTANTIATE_TEST_SUITE_P` for your parameterized test fixture. Without instantiation, `TEST_P` definitions won't produce executable tests.
</Accordion>
<Accordion title="Compilation Errors on Test Fixture Inheritance">
Verify your fixture inherits from `testing::TestWithParam<T>` for value-parameterized tests or is properly declared and registered for type-parameterized tests.
</Accordion>
<Accordion title="Test Names Contain Illegal Characters or Duplicates">
Use custom name generators with `INSTANTIATE_TEST_SUITE_P`. Names must contain only alphanumeric characters and underscores and must be unique per instantiation.
</Accordion>
<Accordion title="Parameter Type Must Be Copyable">
Make sure the parameter types are copyable because GoogleTest passes parameters by value. If using pointers, manage ownership carefully.
</Accordion>
</AccordionGroup>

---

## 5. Next Steps and Related Content

- Explore [Writing Assertions](../core-testing-workflows/writing-assertions.md) to validate conditions inside your tests.
- Learn [Using Matchers](../core-testing-workflows/using-matchers.md) for rich parameter and argument checking.
- Deepen knowledge of [Mocking Techniques](../core-testing-workflows/mocking-techniques.md) to combine mocks with parameterized tests.

---

For complete reference on macros and generators, consult the [Testing Reference - Parameterized Tests](../reference/testing.md#INSTANTIATE_TEST_SUITE_P).

---