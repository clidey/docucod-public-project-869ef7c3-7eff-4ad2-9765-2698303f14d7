---
title: "Parameterized and Typed Tests"
description: "Guides users through writing value- and type-parameterized tests, enabling efficient coverage of diverse input sets and type behaviors in their code."
---

# Parameterized and Typed Tests Guide

## Overview

Value-parameterized and typed tests unlock powerful test automation patterns in GoogleTest by letting you write one test logic to cover diverse input values or multiple types. This guide will walk you through creating parameterized tests with varied data sets and writing typed and type-parameterized tests to run the same test logic across multiple types efficiently.

### What You Will Learn
- How to define and use value-parameterized tests with `TEST_P` and `INSTANTIATE_TEST_SUITE_P`
- How to generate test parameter sequences with built-in generators like `Values`, `Range`, `Combine`, and `Bool`
- How to write typed tests repeating the same logic across a fixed set of types using `TYPED_TEST_SUITE` and `TYPED_TEST`
- How to leverage type-parameterized tests for abstract test patterns using `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`
- Best practices for naming tests and custom parameter name generation

---

## 1. Value-Parameterized Tests

### Purpose
Value-parameterized tests allow you to run the same test code multiple times with different parameters without duplicating test code.

### Prerequisites
- Basic knowledge of test fixtures and `TEST_F` from GoogleTest
- Include `<gtest/gtest.h>`

### How They Work
- Derive a fixture class from `testing::TestWithParam<T>`, where `T` is your parameter type
- Use `TEST_P` to define tests within this fixture
- Instantiate your test suite with parameter values using `INSTANTIATE_TEST_SUITE_P`

### Step-by-Step Instructions

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a fixture by inheriting from `::testing::TestWithParam<T>`. Example:

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional: shared setup or utilities
};
```

This fixture can access its current test parameter via `GetParam()`.
</Step>

<Step title="Write Parameterized Tests Using TEST_P">
Define one or more tests using `TEST_P`. Inside, call `GetParam()` to retrieve the parameter for each run.

```cpp
TEST_P(FooTest, HandlesPositive) {
  int val = GetParam();
  EXPECT_GT(val, 0);
}
```

Multiple tests can be defined to use the same parameters.
</Step>

<Step title="Instantiate the Test Suite with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to instantiate the tests with specific parameter sets.

Example using explicit values:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues, FooTest, ::testing::Values(1, 2, 3, 10));
```

You can also use generators:
- `Range(start, end [, step])` generates a sequence
- `ValuesIn(container)` generates from containers or arrays
- `Bool()` generates `false` and `true`
- `Combine()` generates Cartesian products of multiple parameter sets

Example using `Range`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    RangeTests, FooTest, ::testing::Range(1, 5)); // Params: 1, 2, 3, 4
```

The instantiation name `PositiveValues` prefixes the suite name in output.
</Step>

<Step title="Run Tests and Interpret Results">

Run your tests as usual. GoogleTest will run the parameterized test for each parameter value, generating unique test names with indices.

Example test names:

- `PositiveValues/FooTest.HandlesPositive/0` corresponds to parameter 1
- `PositiveValues/FooTest.HandlesPositive/1` corresponds to parameter 2

You can filter or run specific parameter instances via `--gtest_filter`.
</Step>
</Steps>

### Important Notes
- The `INSTANTIATE_TEST_SUITE_P` must be at global or namespace scope, not inside functions
- Parameters are evaluated at `InitGoogleTest()` call, so you can dynamically configure them
- If you define a `TEST_P` without instantiating it, a failing test will run in `GoogleTestVerification`. Suppress this via `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`

### Customizing Test Parameter Names
The last argument of `INSTANTIATE_TEST_SUITE_P` can be a function/functor that generates valid string suffixes for each parameter.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest, ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

Resulting test names: `NamedTests/FooTest.HandlesPositive/Val1`, ... 

Test names must only contain alphanumeric characters or underscores.

---

## 2. Typed Tests

### Purpose
Typed tests repeat the same test logic for a predefined list of types, ensuring consistent behavior for all.

### Prerequisites
- Basic understanding of C++ class templates
- Knowledge of test fixtures

### How They Work
- Define a fixture class template parameterized on a type `T`.
- Use `TYPED_TEST_SUITE` to associate a type list with the fixture.
- Use `TYPED_TEST` to define tests accessing `TypeParam` as the current type.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Class Template">

Define a template fixture deriving from `testing::Test`. For example:

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  // Example typedefs or members can use T here
  using List = std::list<T>;
  static T shared_value;
  T value_;
};
```
</Step>

<Step title="Associate a List of Types">

Create a type list using `::testing::Types` and associate it with your fixture class:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

If only one type, you can use it directly without `Types<>`.
</Step>

<Step title="Write Typed Tests With TYPED_TEST">

Write tests with `TYPED_TEST` instead of `TEST_F`. The current type is accessible via `TypeParam`:

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_value;
  typename TestFixture::List values;
  values.push_back(n);
  EXPECT_FALSE(values.empty());
}

TYPED_TEST(FooTest, HasPropertyA) {
  // Test something meaningful here
}
```

Note: Use `this->` and `TestFixture::` to access members and typedefs correctly.
</Step>

<Step title="Run Typed Tests">

Run your tests normally. GoogleTest will run each typed test for every type in the type list.

Test suite names are just the fixture template name.
</Step>
</Steps>

### Custom Type Name Generation
`TYPED_TEST_SUITE` optionally accepts a third argument - a class with a static templated `GetName` method returning a unique string per type.

Example:

```cpp
class NameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, NameGenerator);
```

---

## 3. Type-Parameterized Tests

### Purpose
Type-parameterized tests declare tests abstractly without knowing the types ahead of time, then instantiate the tests with concrete types later, supporting reusable test libraries.

### How They Work
- Define a fixture class template
- Use `TYPED_TEST_SUITE_P` to declare the test suite
- Define test patterns with `TYPED_TEST_P`
- Register tests with `REGISTER_TYPED_TEST_SUITE_P`
- Instantiate with types using `INSTANTIATE_TYPED_TEST_SUITE_P`

### Step-by-Step Instructions

<Steps>
<Step title="Declare a Type-Parameterized Test Suite">

Define the fixture template as usual.

```cpp
template <typename T>
class FooTest : public testing::Test {
  // Define shared test helpers
};

TYPED_TEST_SUITE_P(FooTest);
```
</Step>

<Step title="Define Type-Parameterized Tests">

Use `TYPED_TEST_P` for each test:

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  // Use this-> or TestFixture:: to access members if needed
}

TYPED_TEST_P(FooTest, HasPropertyA) { /* ... */ }
```
</Step>

<Step title="Register the Test Names">

Register your tests to enable instantiation:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```
</Step>

<Step title="Instantiate the Suite with Types">

Provide the list of types and instantiate:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

If only one type, provide it directly without `Types<>`.
</Step>
</Steps>

### Notes
- Type-parameterized tests allow multiple instantiations with different type lists, supporting abstract test code reuse
- Instantiation names serve as prefixes for test suite names in output

---

## Practical Tips and Best Practices

- Always make sure your parameter or type names for test instantiations are unique and valid to avoid name collisions.
- Use parameter name generators for readability of test output.
- Avoid heavy computation or side-effects in parameter generators since parameters are generated once during initialization.
- For value-parameterized tests, prefer copyable and simple parameter types. Manage resource lifetime carefully if using pointers.
- For typed/type-parameterized tests, leverage static members to share expensive setup.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if your parameterized test is sometimes not instantiated intentionally (e.g., abstract base tests).

---

## Related References

- [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md) for test fixtures and basic tests
- [Advanced GoogleTest Topics](https://github.com/google/googletest/blob/main/docs/advanced.md) for detailed parameterized tests and type-parameterized tests
- [Testing Reference testing macros](https://github.com/google/googletest/blob/main/docs/reference/testing.md#TEST_P) for macro syntax and parameter generators

---

## Summary

Value-parameterized and typed tests in GoogleTest empower you to write flexible, expressive, and reusable tests covering a wide set of values and types without duplication. Use value-parameterized tests when testing variations of inputs, typed tests to validate same logic over fixed types, and type-parameterized tests to define abstract test patterns reusable across types.

Run your tests with confidence, harness custom parameter names, and keep tests clean and scalable.

---

## Sample Code Snippet for Value-Parameterized Tests

```cpp
#include <gtest/gtest.h>

class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsPositive) {
  int val = GetParam();
  EXPECT_GT(val, 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveValues, FooTest, ::testing::Values(1, 5, 10));

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

## Sample Code Snippet for Typed Tests

```cpp
#include <gtest/gtest.h>

template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_ = T();
};

using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DefaultInitialized) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

## Sample Code Snippet for Type-Parameterized Tests

```cpp
#include <gtest/gtest.h>

template <typename T>
class AbstractTest : public testing::Test {};

TYPED_TEST_SUITE_P(AbstractTest);

TYPED_TEST_P(AbstractTest, DoesSomething) {
  TypeParam value{};
  EXPECT_EQ(value, TypeParam());
}

REGISTER_TYPED_TEST_SUITE_P(AbstractTest, DoesSomething);

using Implementations = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, AbstractTest, Implementations);

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```
