---
title: "Introduction to Mocking"
description: "A hands-on guide to creating and using mocks in GoogleTest to test interactions, control dependencies, and verify behaviors through expectations and cardinalities."
---

# Introduction to Mocking

A hands-on guide to creating and using mocks in GoogleTest to test interactions, control dependencies, and verify behaviors through expectations and cardinalities.

---

## Overview

This guide empowers you to understand and efficiently use **GoogleMock (gMock)**—the mocking framework bundled with GoogleTest—to create mock objects, specify their expected behaviors, and verify the interactions in your unit tests.

Mocking is critical when you want to isolate the code under test from its dependencies, control external effects, and scrutinize communication with collaborators.

By following this guide, you will be able to create mocks easily and write expressive, robust tests that reliably verify both the logic and the interactions of your software components.

## What You Will Learn

- How to create and define mock classes using `MOCK_METHOD`
- How to instantiate mock objects in your tests
- How to specify **expectations** with `EXPECT_CALL`, including argument matching and call cardinalities
- How to control mock behavior by setting **actions** such as return values
- How to order expectations and verify call sequences
- How to handle common pitfalls and troubleshoot failing mocks

## Prerequisites

- Basic knowledge of C++ programming and OO design principles
- Familiarity with GoogleTest and unit testing
- GoogleTest and GoogleMock installed and configured in your project

## Estimated Time

Following this guide and practicing basic scenarios should take approximately **15-30 minutes**.

## Difficulty Level

Beginner to intermediate users of GoogleTest who want to start using mocks effectively.

---

## Step 1: Creating a Mock Class

Mock classes let you simulate real interfaces and control their behaviors during tests. To create one:

1. Identify an **interface** (abstract class) you want to mock. The functions to be mocked must be **virtual**.
2. Define a **mock class** inheriting from this interface.
3. Use `MOCK_METHOD` to mock each virtual method.

### Example: Mocking a Turtle Interface

Here's how to mock a simple `Turtle` interface:

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual void GoTo(int x, int y) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};

// Mock class
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

### Important Notes:
- Place `MOCK_METHOD` declarations in the **public** section of your mock class regardless of the access level in the base class.
- Use the `override` specifier for clarity and safety.
- For **const** methods, add `(const, override)` as the last argument.

---

## Step 2: Using Mock Objects in Tests

Once you have a mock class, you can write tests that:

- Create mock instances
- Set expectations using `EXPECT_CALL`
- Exercise the system under test
- Automatically verify that all expectations are met

### Typical Workflow

1. Using the `::testing` namespace to simplify matcher and action names.
2. Instantiate mock objects.
3. Define expectations on mock methods, specifying how many times, with what arguments, etc.
4. Call the code you want to test, passing mocks as dependencies.
5. When the test finishes, mocks verify expectations automatically.

### Example Test

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using ::testing::AtLeast;

TEST(PainterTest, CallsPenDownAtLeastOnce) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown())
      .Times(AtLeast(1));

  Painter painter(&turtle);  // Painter is code under test using Turtle

  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));
}
```

The above test ensures `PenDown()` is called at least once when drawing a circle.

---

## Step 3: Setting Expectations with `EXPECT_CALL`

Expectations specify **how** mock methods are called during a test. They consist of:

- The mock object and method
- Matchers for arguments
- Call **cardinalities** (how many times to expect calls)
- Optional call order constraints
- Actions (what to do when the mock method is called)

### Basic Syntax

```cpp
EXPECT_CALL(mock_object, Method(arg_matchers...))
    .Times(cardinality)
    .WillOnce(action)
    .WillRepeatedly(action);
```

- `arg_matchers`: Describe expected argument values using literals, `_` (wildcard), or detailed matchers.
- `Times`: Defines how many times the call is expected.
- `WillOnce` and `WillRepeatedly`: Define what happens on call (return values, side effects, etc).

### Argument Matchers

You can specify expectations for method arguments in fine detail:

- Use literals for exact match: `Forward(100)` expects `Forward` to be called with exactly 100.
- Use wildcard `_` to allow any value.
- Combine matchers e.g., `Forward(::testing::Ge(50))` to require values greater than or equal to 50.

If you don't specify arguments (for non-overloaded methods), it means "any arguments".

### Cardinalities

Control how many times a method call is expected using `Times`:

- `Times(1)` (default if omitted)
- `Times(0)` to forbid a call
- `Times(AtLeast(n))`
- `Times(AtMost(n))`
- `Times(AnyNumber())`

### Actions

Control what the mock method does:

- `Return(value)`: Returns a value
- `ReturnRef(variable)`: Return a reference
- Use lambdas or functors for custom behaviors

Example:

```cpp
EXPECT_CALL(turtle, GetX())
    .WillOnce(Return(100))
    .WillOnce(Return(150))
    .WillRepeatedly(Return(200));
```
This will make `GetX()` return 100 on first call, 150 on second, and 200 on all subsequent calls.

### Ordering Constraints

Specify order of calls with:

- `.InSequence(sequence_object)`: All expectations in the same sequence are ordered.
- `.After(expectation)`: The current expectation will only match after `expectation` has been satisfied.

For example:

```cpp
{
  ::testing::InSequence seq;
  EXPECT_CALL(turtle, PenDown());
  EXPECT_CALL(turtle, Forward(100));
  EXPECT_CALL(turtle, PenUp());
}
```
Here, calls must occur in the specified order.

---

## Step 4: Specifying Default Behaviors with `ON_CALL`

`ON_CALL` lets you specify how a mock method behaves by default, without setting expectations that the method will be called.

It's useful to avoid verbose setups when you don't care about specific invocations but want your mock to behave in a controlled way.

### Syntax

```cpp
ON_CALL(mock_object, Method(arg_matchers...))
    .WillByDefault(action);
```

Unlike `EXPECT_CALL`, no cardinalities or ordering are specified.

### Example

```cpp
ON_CALL(turtle, GetX()).WillByDefault(Return(10));
```
This means that unless overridden by an `EXPECT_CALL`, `GetX()` will return 10.

---

## Step 5: Best Practices and Tips

- **Set expectations BEFORE exercising code.** Setting `EXPECT_CALL` after the mock has been used leads to undefined behavior.
- **Use matchers judiciously:** Avoid over-specifying arguments to prevent brittle tests.
- **Use `Times(0)` to verify that a method is never called.**
- **Leverage `InSequence` and `After` to encode order dependencies clearly.**
- **Use `RetiresOnSaturation()` to make expectations inactive once satisfied.**
- **Use `NiceMock` and `StrictMock` to control how uninteresting calls are treated:**
  - `NiceMock`: Suppress warnings for uninteresting calls.
  - `StrictMock`: Treat uninteresting calls as errors.
- **Put mocks for classes you don’t own in their own test-only directory to ease maintenance.**
- **Prefer interfaces for mocking over concrete classes to reduce tight coupling.**

---

## Common Pitfalls

- Failing to declare a **virtual destructor** in interfaces leads to resource leaks.
- Setting expectations **after** mock calls leads to unpredictable results.
- Over-specifying argument matchers makes tests fragile against refactoring.
- Forgetting to verify expectations can hide failures — though gMock does this automatically during destruction.
- Reusing mocks across tests without resetting leads to cross-test contamination.

---

## Troubleshooting

| Issue                                   | Cause                                                       | Solution                                                      |
|----------------------------------------|-------------------------------------------------------------|---------------------------------------------------------------|
| Unexpected mock function call failure  | Method called with unexpected arguments                      | Check argument matchers; use `--gmock_verbose=info` to debug.  |
| Too few/too many calls for expectation | Cardinality doesn't match actual calls                       | Adjust `Times()` or `WillOnce()`/`WillRepeatedly()` accordingly. |
| Uninteresting call warning              | Method called without any `EXPECT_CALL`                      | Add an `ON_CALL` default behavior or wrap mock with `NiceMock`.|
| Memory leaks detected with mocks        | Mock objects not destructed (missing virtual destructor)     | Ensure destructors are virtual and mocks are properly deleted. |

Run tests with `--gmock_verbose=info` to get detailed traces of mock interactions and help identify expectation mismatches.

---

## Next Steps & Related Resources

- Explore the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for advanced recipes such as custom matchers, mocking non-virtual methods, and delegating calls.
- Learn about matcher composition and advanced action specifications in the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) and [Actions Reference](https://google.github.io/googletest/reference/actions.html).
- Understand the difference between `NiceMock`, `NaggyMock`, and `StrictMock` to tailor mock strictness.
- Dive into sequencing and partial orderings for complex interaction tests.

---

## Summary

You now have a solid foundation to define mock classes, set expectations, specify behaviors, and verify interactions using GoogleMock. This lets you decouple tests from dependencies, focus on interaction correctness, and write more maintainable and robust tests.

Keep exploring and practicing with real interfaces and test cases to gain mastery.

---

## Additional Example: Setting Expectations with Multiple Calls and Order

```cpp
using ::testing::AtLeast;
using ::testing::InSequence;
using ::testing::_;

TEST(RobotTest, MovementSequence) {
  MockTurtle turtle;

  {
    InSequence seq; // All inside this block must occur in order

    EXPECT_CALL(turtle, PenDown());
    EXPECT_CALL(turtle, Forward(100)).Times(AtLeast(1));
    EXPECT_CALL(turtle, Turn(_));
    EXPECT_CALL(turtle, PenUp());
  }

  Robot robot(&turtle);
  robot.Patrol();
}
```

This test asserts not just which methods get called, but also the order and frequency.

---

## References

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html)
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [GoogleTest Primer](https://google.github.io/googletest/primer.html)


---

For more information, see the [GoogleTest Mock Object Definition](https://github.com/google/googletest/blob/main/docs/reference/mocking.md).

---