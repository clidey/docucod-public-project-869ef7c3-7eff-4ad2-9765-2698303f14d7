---
title: "Parameterized and Typed Tests for Code Coverage"
description: "Details how to implement value- and type-parameterized tests to efficiently expand coverage and reduce code duplication when testing algorithms and data structures."
---

# Parameterized and Typed Tests for Code Coverage

## Overview

This guide details how to implement value- and type-parameterized tests in GoogleTest to efficiently expand your code coverage while minimizing code duplication. It focuses on defining reusable test logic that runs over varying parameter values and types, ideal for testing algorithms, data structures, and interface implementations repeatedly with diverse inputs and type variations.

---

## Prerequisites

- Familiarity with basic GoogleTest test fixtures (`TEST_F`) and assertions.
- A C++17 compatible development environment set up with GoogleTest installed.
- Basic understanding of templates and type parameterization in C++.

---

## What You Will Achieve

By following this guide, you will be able to:

- Create parameterized test fixtures that run the same test logic over multiple input values.
- Use GoogleTest macros to define and instantiate parameterized test suites.
- Define typed test fixtures that execute the same tests for a list of types.
- Write type-parameterized (abstract) tests that can be instantiated with different type lists later.
- Reduce redundant code in your tests while increasing coverage breadth.

---

## Time Estimate

Approximately 30-45 minutes to understand core concepts and get a working sample in your codebase.

## Difficulty Level

Intermediate C++ knowledge recommended, beginner-friendly for GoogleTest users familiar with fixtures.


---

## 1. Value-Parameterized Tests

Value-parameterized tests allow a single test logic to be executed multiple times with different parameter values, improving test coverage across a range of inputs without code duplication.

### Workflow

1. Define a test fixture deriving from `testing::TestWithParam<T>`, where `T` is your parameter type.
2. Use the `TEST_P` macro to write your parameterized tests.
3. Instantiate the test suite with a set of parameters using `INSTANTIATE_TEST_SUITE_P` and a parameter generator.

### Step-by-Step Example

```cpp
// 1. Define the parameterized fixture class
class FooTest : public testing::TestWithParam<int> {
  // Setup/utility methods if needed
};

// 2. Define parameterized tests using TEST_P
TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0) << "Parameter " << value << " is not even.";
}

TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

// 3. Instantiate the test suite with parameters
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers,
    FooTest,
    testing::Values(2, 4, 6, 8));
```

### Notes

- Use `GetParam()` inside tests to access the current parameter.
- `Values()`, `ValuesIn()`, `Range()`, `Bool()`, and `Combine()` are available parameter generators.
- The instantiation name (`EvenNumbers`) prefixes test names for filtering and output.

---

## 2. Typed Tests

Typed tests enable you to run the same tests for a list of types. This is useful for verifying implementations of concepts or template-based classes.

### Workflow

1. Define a fixture class template parameterized by type `T`, deriving from `testing::Test`.
2. Associate a type list with this fixture via `TYPED_TEST_SUITE`.
3. Define typed tests via `TYPED_TEST` macro.

### Step-by-Step Example

```cpp
// 1. Define the fixture template
template <typename T>
class MyContainerTest : public testing::Test {
 public:
  T container_;
};

// 2. List the types to test
using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(MyContainerTest, MyTypes);

// 3. Create the typed tests
TYPED_TEST(MyContainerTest, IsEmptyInitially) {
  EXPECT_EQ(0u, this->container_.size());
}

TYPED_TEST(MyContainerTest, CanAddElement) {
  this->container_.push_back(1);
  EXPECT_EQ(1u, this->container_.size());
}
```

### Notes

- Inside `TYPED_TEST` bodies use `TypeParam` to refer to the current type.
- Use `this->` to access fixture members due to C++ templates.
- Typed tests must know the type list at test definition time.

---

## 3. Type-Parameterized Tests

Type-parameterized tests (also called type-parameterized abstract tests) allow defining test logic independently from type lists to enable reuse and multiple instantiations across translation units.

### Workflow

1. Define a fixture class template parameterized by type `T` just like typed tests.
2. Use `TYPED_TEST_SUITE_P` to declare a registered type-parameterized test suite.
3. Define tests with `TYPED_TEST_P`.
4. Register the test names with `REGISTER_TYPED_TEST_SUITE_P`.
5. Instantiate test suites with `INSTANTIATE_TYPED_TEST_SUITE_P` by providing type lists.

### Step-by-Step Example

```cpp
// 1. Define the fixture
template <typename T>
class MyAbstractTest : public testing::Test {
 public:
  T value_ = T();
};

// 2. Declare a type-parameterized test suite
TYPED_TEST_SUITE_P(MyAbstractTest);

// 3. Define type-parameterized tests
TYPED_TEST_P(MyAbstractTest, IsDefaultConstructible) {
  TypeParam val;
  (void)val;
  EXPECT_TRUE(true);  // Replace with real checks
}

TYPED_TEST_P(MyAbstractTest, HasZeroSize) {
  // Example test logic
  EXPECT_EQ(0, 0);  // Replace with real logic for TypeParam
}

// 4. Register test names
REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, IsDefaultConstructible, HasZeroSize);

// 5. Instantiate with types
using TestTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyAbstractTest, TestTypes);
```

### Notes

- This pattern allows distributing test definition and instantiation separately.
- Suited for library-style tests where types are chosen later.

---

## 4. Tips & Best Practices

- **Name your instantiations meaningfully** to easily identify parameter sets in test reports.
- Use `testing::PrintToStringParamName` or provide custom name generators for clear test names.
- When using complex parameter types, consider overriding `PrintTo()` or `AbslStringify()` for better output.
- Ensure test parameters and types are copyable and preferably default constructible.
- Avoid side-effects in parameterized tests to keep tests isolated.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you declare tests not instantiated immediately.

---

## 5. Common Pitfalls and Troubleshooting

- **Test names must not contain underscores.** GoogleTest forbids underscores in test and suite names.
- Defining `SetUpTestSuite()` or `TearDownTestSuite()` in parameterized tests requires **public** access.
- Tests may not be instantiated if `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` is missing.
- Use proper macros: `TEST_P` for value-parameterized, `TYPED_TEST` for typed tests, and `TYPED_TEST_P` for type-parameterized tests.
- Instantiations must happen at *global or namespace scope*, not inside functions.

---

## 6. Verification & Validation

- Verify instantiations by running tests with `--gtest_list_tests` to see generated test names.
- Filter and run specific parameterized tests via `--gtest_filter=InstantiationName/TestSuiteName.TestName/*`.
- Use `--gtest_repeat` to run tests multiple times ensuring consistency.

---

## 7. Next Steps & Related Documentation

- Explore [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for advanced usage.
- Review [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for further insights.
- Consult [Testing Reference: TEST_P and TYPED_TEST](reference/testing.md#TEST_P) for macro usages.
- Visit [Writing & Running Your First Test](https://github.com/google/googletest/blob/main/docs/guides/writing-tests/getting-started-basic-tests.mdx) for foundational test writing.
- Check [Troubleshooting Common Issues](../getting-started/troubleshooting-validation/troubleshooting-common-issues) if tests fail to instantiate or run.

---

## Summary

Parameterized and typed tests in GoogleTest empower you to write flexible, reusable test logic that expands coverage across multiple input values and types with minimal duplication. By mastering the `TEST_P`, `TYPED_TEST`, and `TYPED_TEST_P` patterns along with their instantiation macros, you gain scalable testing capabilities that fit a wide range of C++ testing needs.

---

## References

- [GoogleTest Primer](../primer.md)
- [Advanced GoogleTest Topics – Parameterized & Typed Tests](../advanced.md#value-parameterized-tests)
- [Testing Reference – TEST_P, INSTANTIATE_TEST_SUITE_P, TYPED_TEST, TYPED_TEST_SUITE](reference/testing.md)
- [Getting Started – Writing & Running Your First Test](../getting-started/project-setup-first-run/writing-running-first-test)
- [Troubleshooting Common Issues](../getting-started/troubleshooting-validation/troubleshooting-common-issues)

---