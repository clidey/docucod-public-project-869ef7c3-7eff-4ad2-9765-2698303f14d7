---
title: "Defining Custom Assertions and Matchers"
description: "Step-by-step guide to extending the framework with application-specific assertions and matchers. Details implementation patterns and integration tips, enabling more precise and expressive tests."
---

# Defining Custom Assertions and Matchers

Extend the power of GoogleTest by creating your own application-specific assertions and matchers. This guide leads you through the process of defining custom assertions and matchers, enabling tests that are more expressive, precise, and better convey the intent of your code.

---

## Understanding the Need for Custom Assertions and Matchers

GoogleTest’s built-in assertions and matchers cover many common cases. However, when your tests involve domain-specific types or complex validation logic, building custom assertions and matchers helps:

- Clearly express test intent
- Provide better failure diagnostics
- Increase code reuse in tests
- Improve readability and maintainability

Think of matchers as predicates that can _describe_ themselves and generate rich diagnostic messages when they fail.

---

## Basic Concepts

### Assertions vs. Matchers

- **Assertions** are statements like `EXPECT_TRUE(condition)` that verify conditions in tests.
- **Matchers** are objects that define predicate logic and can describe themselves. They are used with assertions like `EXPECT_THAT(value, matcher)`.

Matchers enable expressive statements such as:

```cpp
EXPECT_THAT(actual_value, IsEven());
EXPECT_THAT(collection, ElementsAre(1, 2, 3));
```

The key benefit: when a matcher fails, it can explain exactly why.

---

## Creating Custom Matchers

The simplest way to define a custom matcher is using GoogleTest’s `MATCHER` family of macros.

### 1. Defining a Simple Matcher

Use `MATCHER(name, description)` to create a matcher named `name` that returns `true` or `false` when applied to a value. You can use `arg` to refer to the value being matched.

#### Example: Match Even Numbers

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
```

Usage:

```cpp
EXPECT_THAT(n, IsEven());
```

This generates failure messages like:

```
Value of: n
Expected: is even
  Actual: 3
```

If you want, provide a better description: 

```cpp
MATCHER(IsEven, (negation ? "is odd" : "is even")) {
  return (arg % 2) == 0;
}
```

---

### 2. Writing Parameterized Matchers

If your matcher needs parameters, use `MATCHER_P` or `MATCHER_Pn` macros.

#### Example: Match Absolute Value

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

Failure messages will include the parameter:

```
Value of: x
Expected: has absolute value 10
  Actual: -9
```

You can define multiple parameters with `MATCHER_P2`, `MATCHER_P3` up to 10.

---

### 3. Providing Detailed Failure Explanations

Inside your matcher body, you can use `result_listener` (an ostream pointer) to explain why a match failed, improving diagnostics.

Example enhancement:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

When this matcher fails, the message shows the remainder.

---

### 4. Using Assertions Inside Matchers

You may simplify matcher code by using `EXPECT_` statements inside:

```cpp
MATCHER(IsDivisibleBy7, "") {
  EXPECT_EQ(arg % 7, 0);
  return true;
}
```

If the match fails, the assertion failure message is shown.

---

## Writing New Matcher Classes (Advanced)

For more complex matchers or reusable ones, consider implementing a matcher class directly.

The matcher class must:

- Have a typedef alias `using is_gtest_matcher = void;`
- Implement: `bool MatchAndExplain(const T& value, std::ostream* os) const`
- Implement: `void DescribeTo(std::ostream* os) const`
- Implement: `void DescribeNegationTo(std::ostream* os) const`

Example:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected)
      : expected_sum_(expected) {}

  bool MatchAndExplain(const Foo& foo, std::ostream*) const {
    return foo.bar() + foo.baz() == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  int expected_sum_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected) {
  return BarPlusBazEqMatcher(expected);
}
```

This approach offers more control and cleaner interfaces.

---

## Incorporating Composite Matchers

Custom matchers often compose other matchers:

- Accept matcher parameters
- Combine or transform calls
- Delegate description generation

For example, `DistanceFrom(target, matcher)` shows how to implement such composite matchers using internal helper classes that store sub-matchers.

---

## Using Custom Matchers in Tests

Once created, use custom matchers in GoogleTest like built-ins:

```cpp
EXPECT_THAT(value, MyMatcher(param));
```

or

```cpp
EXPECT_THAT(collection, ElementsAre(MyMatcher1(), MyMatcher2()));
```

They work seamlessly with `EXPECT_THAT`, improving test expressiveness and diagnostics.

---

## Common Pitfalls and Best Practices

- **Matchers must be pure and side-effect free.** They should not modify any state or call mock functions.
- Use **`ON_CALL()`** to define default behaviors without imposing call expectations.
- Use **`EXPECT_CALL()`** when you want to assert that specific calls happen.
- Define **specific match conditions**, do not overconstrain.
- Use **`MATCHER` macros for quick definitions**, and switch to matcher classes for reusable complex matchers.
- Provide **rich failure messages** using `result_listener` to aid debugging.

---

## Troubleshooting Custom Matchers

If your matcher doesn’t behave as expected:

- Check that `MatchAndExplain()` properly distinguishes matching and non-matching cases.
- Confirm `DescribeTo()` and `DescribeNegationTo()` provide meaningful messages.
- Avoid side effects in matcher code.
- If your matcher has parameters, ensure those parameters are properly captured and used.

For complex failure diagnostics, enabling `--gmock_verbose=info` can help trace expectations and matching results.

---

## Next Steps

- Explore the full suite of [built-in matchers](https://github.com/google/googletest/blob/main/docs/reference/matchers.md).
- Learn to write custom **actions** to define mock method behaviors.
- Review [Using Matchers](https://github.com/google/googletest/blob/main/docs/reference/mocking.md#UsingMatchers) for advanced matcher usage.
- Study [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md) recipes for practical usage patterns.

---

# References and Related Content

- [Matchers Reference](https://github.com/google/googletest/blob/main/docs/reference/matchers.md) — Comprehensive guide to built-in matchers.
- [Mocking Reference](https://github.com/google/googletest/blob/main/docs/reference/mocking.md) — Detailed reference on mocking APIs including `EXPECT_CALL`, `ON_CALL`.
- [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md) — Recipes for common mocking scenarios.
- [Writing Your First Mock and Using Expectations](https://github.com/google/googletest/blob/main/guides/getting-started/first-mock.md) — Beginner guide to mocks and expectations.

---

Use this guide to customize your testing framework effectively with GoogleTest’s extensible matcher and assertion system.
