---
title: "Common Test Scenarios & Patterns"
description: "Explore how to structure tests for real-world conditions, including value-parameterized and type-parameterized tests, death tests, and combining assertions for robust coverage."
---

# Common Test Scenarios & Patterns

Explore how to structure tests for real-world conditions, including value-parameterized and type-parameterized tests, death tests, and combining assertions for robust coverage.

---

## 1. Workflow Overview

### Task Description
This guide helps you write comprehensive and realistic test scenarios using GoogleMock by leveraging advanced patterns such as parameterized tests, death tests, and multiple assertion techniques to increase test robustness.

### Prerequisites
- Basic familiarity with GoogleTest and GoogleMock.
- A working mock class and tests that use `EXPECT_CALL` and `ON_CALL`.
- Your testing environment set up with GoogleMock included.

### Expected Outcome
After following this guide, you will be able to:
- Write tests that cover multiple input values using parameterized tests.
- Perform type-parameterized tests to test templated code.
- Implement death tests to verify code behavior under fatal conditions.
- Combine assertions effectively for thorough validation.

### Time Estimate
Approximately 30-60 minutes to grasp concepts and implement examples.

### Difficulty Level
Intermediate

---

## 2. Step-by-Step Instructions

### A. Creating Value-Parameterized Tests

1. **Identify the test cases** you want to cover with multiple input values.
2. **Define a test fixture** deriving from `::testing::TestWithParam<Type>` where `Type` is the input value type.
3. **Use `INSTANTIATE_TEST_SUITE_P`** to provide the list or range of test values.
4. **Inside your test, retrieve the parameter with `GetParam()`** and use it with your mock objects and expectations.

**Example:**
```cpp
#include <gmock/gmock.h>
using ::testing::TestWithParam;
using ::testing::Values;

class MockProcessor {
 public:
  MOCK_METHOD(bool, Process, (int value), ());
};

class ProcessorTest : public TestWithParam<int> {
 protected:
  MockProcessor mock_;
};

TEST_P(ProcessorTest, HandlesMultipleValues) {
  int value = GetParam();
  EXPECT_CALL(mock_, Process(value)).WillOnce(::testing::Return(true));

  // Exercise code that uses mock_.Process.
  bool result = mock_.Process(value);

  EXPECT_TRUE(result);
}

INSTANTIATE_TEST_SUITE_P(
    ValueTests,
    ProcessorTest,
    Values(0, 1, 2, 10, 100));
```

**Outcome:** The test runs once per specified value, verifying interactions with mock accordingly.

---

### B. Writing Type-Parameterized Tests

1. **Define a test fixture template** inheriting from `::testing::Test`.
2. **Use `TYPED_TEST_SUITE` macro** to instantiate it with the types you want.
3. **Use `TYPED_TEST` macro** to write tests valid for all specified types.
4. **In the test body, refer to `TypeParam` to access the current type.**

**Example:**
```cpp
#include <gmock/gmock.h>
using ::testing::Test;

template <typename T>
class StackTest : public Test {
 protected:
  // Assume MockStack<T> exists.
  MockStack<T> stack_;
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, PushPopWorks) {
  TypeParam value{};  // Default construct the value.
  EXPECT_CALL(this->stack_, Push(value)).Times(1);
  this->stack_.Push(value);

  EXPECT_CALL(this->stack_, Pop()).WillOnce(::testing::Return(value));
  TypeParam popped = this->stack_.Pop();
  EXPECT_EQ(value, popped);
}
```

**Outcome:** Single test logic runs over different data types ensuring template correctness and consistent mock behavior.

---

### C. Implementing Death Tests

Use death tests to verify behavior when illegal operations or fatal errors occur.

1. **Wrap the code that should cause the program to terminate inside `ASSERT_DEATH` or `EXPECT_DEATH`.**
2. **Write clear expectations and mock behaviors leading up to the fatal call.**
3. **Provide a regex to verify the error message printed during death.**

**Example:**
```cpp
TEST(FooDeathTest, CrashesOnInvalidInput) {
  MockFoo mock_foo;
  EXPECT_CALL(mock_foo, Bar(_));

  ASSERT_DEATH({
    // Code that should cause a fatal error.
    mock_foo.Bar(-1);  // Illegal value causing fatal error
  }, ".*Invalid argument.*");
}
```

**Outcome:** Your test confirms that the code properly fails and logs an error when illegal inputs are encountered.

---

### D. Combining Assertions for Robust Coverage

1. Use multiple `EXPECT_*` or `ASSERT_*` within your test to verify distinct aspects.
2. Use GoogleMock matchers to assert on arguments passed to mocked methods.
3. Use `DoAll()` action to combine side-effects and return values.
4. Use sequences (`InSequence`) to verify call order combined with argument assertions.

**Example:**
```cpp
using ::testing::_;
using ::testing::Return;
using ::testing::DoAll;
using ::testing::SaveArg;

class MockDatabase {
 public:
  MOCK_METHOD(bool, Insert, (const std::string& record), ());
};

TEST(DatabaseTest, InsertAndVerify) {
  MockDatabase mock_db;
  std::string saved_record;

  EXPECT_CALL(mock_db, Insert(_))
      .WillOnce(DoAll(SaveArg<0>(&saved_record), Return(true)));

  bool success = mock_db.Insert("User Data");
  EXPECT_TRUE(success);
  EXPECT_EQ(saved_record, "User Data");
}
```

**Outcome:** The test asserts that the mock method is called with the expected argument and that the call returns as intended.

---

## 3. Examples & Code Samples

### Value-Parameterized Test Example

```cpp
class MockCalculator {
 public:
  MOCK_METHOD(int, Add, (int a, int b), ());
};

class CalculatorTest : public ::testing::TestWithParam<std::tuple<int, int>> {
 protected:
  MockCalculator calc;
};

TEST_P(CalculatorTest, AddTest) {
  int a = std::get<0>(GetParam());
  int b = std::get<1>(GetParam());

  EXPECT_CALL(calc, Add(a, b))
      .WillOnce(::testing::Return(a + b));

  int result = calc.Add(a, b);
  EXPECT_EQ(result, a + b);
}

INSTANTIATE_TEST_SUITE_P(
    AddTests,
    CalculatorTest,
    ::testing::Values(std::make_tuple(1,1), std::make_tuple(2,3), std::make_tuple(0,5)));
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class MockContainer {
 public:
  MOCK_METHOD(void, Add, (const T& value), ());
};

template <typename T>
class ContainerTest : public ::testing::Test {
 protected:
  MockContainer<T> container;
};

typedef ::testing::Types<int, std::string> TestTypes;
TYPED_TEST_SUITE(ContainerTest, TestTypes);

TYPED_TEST(ContainerTest, AddAcceptsValue) {
  TypeParam val{};
  EXPECT_CALL(this->container, Add(val));
  this->container.Add(val);
}
```

### Death Test Example

```cpp
TEST(MockUserDeathTest, KillWhenUserNotFound) {
  MockUserManager mock_user_mgr;

  EXPECT_CALL(mock_user_mgr, DeleteUser("nonexistent"));

  ASSERT_DEATH({
    mock_user_mgr.DeleteUser("nonexistent");
  }, ".*User not found.*");
}
```

### Combining Assertions Example

```cpp
using ::testing::DoAll;
using ::testing::SaveArg;
using ::testing::Return;

class MockService {
 public:
  MOCK_METHOD(bool, UpdateConfig, (const std::string& config), ());
};

TEST(ServiceTest, UpdateAndSave) {
  MockService service;
  std::string captured_config;

  EXPECT_CALL(service, UpdateConfig(_))
      .WillOnce(DoAll(SaveArg<0>(&captured_config), Return(true)));

  bool result = service.UpdateConfig("new-config");

  EXPECT_TRUE(result);
  EXPECT_EQ(captured_config, "new-config");
}
```

---

## 4. Troubleshooting & Tips

### Common Issues
- **Parameter Mismatch in Parameterized Tests:** Ensure the type in `TestWithParam<...>` matches the type of the input test parameters.
- **Ambiguous Overloaded Methods:** Use parameter lists or `Const()` wrapper to disambiguate.
- **Death Tests Not Triggering:** Verify your test code calls the fatal condition and use correct regex matching.
- **Uninteresting Call Warnings:** Avoid writing unnecessary `EXPECT_CALL` for methods you don't need to verify; use `NiceMock` if warnings are overwhelming.

### Best Practices
- Use `ON_CALL` to specify default behaviors for mocks used by many tests, reducing boilerplate.
- Keep expectations as loose as possible to avoid brittle tests; use matchers like `_` for unimportant arguments.
- Leverage `InSequence` or `.After()` to specify ordering when it truly matters.
- Use `RetiresOnSaturation()` to relax upper-bound errors on specific calls.
- Always provide a virtual destructor in interfaces to avoid memory issues with mocks.

### Performance Considerations
- For long sequences of parameterized tests, keep test data manageable to avoid bloated test runs.
- Split complex tests into smaller, focused parameterized tests.

### Alternative Approaches
- Use `MockFunction` for mocking standalone `std::function`-type callbacks.
- Delegate to fakes or real objects using `ON_CALL(...).WillByDefault(...)` to reduce mock complexity.

---

## 5. Next Steps & Related Content

- Explore [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for more recipes.
- Review [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) for detailed macro and class documentation.
- Learn about [Matchers Library](https://google.github.io/googletest/reference/matchers.html) for argument matching strategies.
- Advance to [Advanced Mocking Techniques](./advanced-mocking) to further refine your testing skills.
- Read [gMock for Dummies](./gmock_for_dummies) if you want a beginner-friendly introduction.
- For troubleshooting, visit [Legacy gMock FAQ](./gmock_faq) and [Troubleshooting Common Issues](../../getting-started/first-test-run-validation/troubleshooting-common-issues).


---

<CardGroup cols={3}>
<Card title="gMock For Dummies">
A beginner's guide to mocking basics, mock class creation, and core usage examples.
</Card>
<Card title="gMock Cookbook">
Comprehensive recipes for advanced mocking, matchers, and actions.
</Card>
<Card title="Mocking Reference">
In-depth API reference for mocking macros, classes, and clauses.
</Card>
</CardGroup>

---

<Tip>
Start parameterized tests with small, meaningful data sets to keep your tests fast and clear.
</Tip>
<Warning>
Setting expectations after invoking the mocked code leads to undefined behavior. Always set expectations first.
</Warning>
<Note>
Death tests should be isolated from other tests to avoid side effects.
</Note>

---

```mermaid
flowchart TD
  A[Start Writing Robust Tests] --> B{Type of Test?}
  B --> |Value-Parameterized| C[Define test fixture with TestWithParam]
  B --> |Type-Parameterized| D[Define templated test fixture with TYPED_TEST_SUITE]
  B --> |Death Test| E[Use ASSERT_DEATH or EXPECT_DEATH]
  B --> |Multiple Assertions| F[Combine EXPECT_CALL and ASSERT_* checks]
  C --> G[Use INSTANTIATE_TEST_SUITE_P for values]
  D --> H[Use TYPED_TEST for test cases]
  E --> I[Check for fatal error and error messages]
  F --> J[Use DoAll() for combining actions]
  J --> K[Use SaveArg to capture parameters]
  K --> L[Use InSequence to check call order]
  L --> M[End of robust test setup]
  G --> M
  H --> M
  I --> M
  M --> N[Run Tests and Validate Expectations]
```
