---
title: "Parameterized and Typed Tests"
description: "Learn how to write parameterized tests that run over multiple values and types. This guide covers both value- and type-parameterized test suites, showcasing their practical use for robust and reusable testing of templated code."
---

# Parameterized and Typed Tests

## Overview

This guide helps you write parameterized tests in GoogleTest that run over multiple values and types. It explains how to create value-parameterized test suites with different data inputs and typed tests that repeat the same test logic for different C++ types. By mastering these patterns, you will write more robust, reusable, and scalable tests especially for templated code or code that behaves differently for various inputs.

---

## 1. Value-Parameterized Tests

### Purpose
Value-parameterized tests allow you to run the same test logic with multiple input values without duplicating test code. This is ideal for:
- Testing different inputs to functions or methods
- Verifying interface implementations across multiple scenarios
- Data-driven test scenarios where behavior depends on input values

### Prerequisites
- A test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.
- Your test environment should have GoogleTest installed and integrated.

### Workflow

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a fixture class that inherits from `testing::TestWithParam<T>` where `T` is the desired parameter type. For example:

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Optional fixture setup here
};
```

You can also inherit from an existing fixture and add `WithParamInterface<T>` for parameters.
</Step>

<Step title="Write Parameterized Tests Using TEST_P">
Define one or more tests using `TEST_P(Fixture, TestName)` instead of `TEST()` or `TEST_F()`. Within tests, access parameters via `GetParam()`:

```cpp
TEST_P(FooTest, HandlesVariousInput) {
  int value = GetParam();
  EXPECT_TRUE(value >= 0);
  // Add test logic using value
}
```
</Step>

<Step title="Instantiate the Test Suite With Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to specify the set of parameter values that GoogleTest will run:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CommonInts, FooTest,
    testing::Values(1, 2, 3, 5));
```

Here, `CommonInts` is the name of this instantiation. You can instantiate multiple times with different parameter sets.
</Step>

<Step title="Run Your Tests">
Build and run your test binary as usual. Each input value will have its own instance of the test.

You will see test names with suffixes indicating parameter indices, e.g.,
`CommonInts/FooTest.HandlesVariousInput/0`.
</Step>
</Steps>

### Parameter Generators
GoogleTest provides multiple ways to specify parameters:
- `Values(a, b, c)`: explicit list
- `ValuesIn(container)`: specify parameters via STL containers or arrays
- `Range(start, end[, step])`: numeric sequences (end exclusive)
- `Bool()`: for boolean tests
- `Combine(g1, g2, ...)`: Cartesian product of multiple generators

### Naming Instantiated Tests
You can provide a custom function or functor as the fourth argument to `INSTANTIATE_TEST_SUITE_P` to generate readable test name suffixes based on the parameter:

```cpp
INSTANTIATE_TEST_SUITE_P(CommonInts, FooTest, testing::Values(1,2,3),
  [](const testing::TestParamInfo<int>& info) {
    return "Param" + std::to_string(info.param);
  });
```

This makes test outputs more informative.

### Tips and Pitfalls
- Always place the instantiation code at namespace or global scope â€” not inside functions.
- Using raw pointers as parameters requires manual lifetime management.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you want to avoid errors due to missing instantiations.

---

## 2. Typed Tests

### Purpose
Typed tests let you run the same test logic for a set of C++ types. This is essential for:
- Validating that multiple types comply with requirements
- Testing template classes/functions across type parameters
- Reducing duplication when testing type-specific behavior

### Prerequisites
- Define a class template derived from `testing::Test`.
- Know the list of types you want to test.

### Workflow

<Steps>
<Step title="Create a Test Fixture Template">
Define a class template derived from `testing::Test`. For example:

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_{};
};
```
</Step>

<Step title="Associate Type List Using TYPED_TEST_SUITE">
Define a type list and associate it with your fixture template:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyFixture, MyTypes);
```
</Step>

<Step title="Define Typed Tests Using TYPED_TEST">
Write tests using `TYPED_TEST(FixtureName, TestName)` macro. Inside the test, refer to `TypeParam` to access the current type:

```cpp
TYPED_TEST(MyFixture, DoesSomething) {
  TypeParam val = this->value_;
  // Test different behavior for different types
  EXPECT_TRUE(std::is_default_constructible<TypeParam>::value);
}
```
</Step>

<Step title="Build and Run">
Compile and run your tests. GoogleTest will invoke each typed test with every type in your list.

The test suite names are suffixed with each type's name by default.
</Step>
</Steps>

### Custom Type Names
You can provide a class with a template static method `GetName(int)` to generate custom type names:

```cpp
class TypeNameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, char>) return "Char";
    return "Unknown";
  }
};
TYPED_TEST_SUITE(MyFixture, MyTypes, TypeNameGenerator);
```

### Notes
- Typed tests require you to know the type list at compile-time.
- You cannot access test parameters as values (unlike value-parameterized tests).

---

## 3. Type-Parameterized Tests

Type-parameterized tests combine benefits of both: you define the test suite with unknown types, register test patterns, then instantiate with any type lists you want. This is useful for shared library test definition and flexible reuse.

### Workflow

<Steps>
<Step title="Define Fixture Template and Declare with TYPED_TEST_SUITE_P">

```cpp
template <typename T>
class FooTest : public testing::Test {
  // ...
};
TYPED_TEST_SUITE_P(FooTest);
```
</Step>

<Step title="Define Type-Parameterized Tests with TYPED_TEST_P">

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam val{};
  // ...
}
TYPED_TEST_P(FooTest, HasFeature) { /* ... */ }
```
</Step>

<Step title="Register Tests with REGISTER_TYPED_TEST_SUITE_P">

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasFeature);
```
</Step>

<Step title="Instantiate Typed Test Suite with INSTANTIATE_TYPED_TEST_SUITE_P">

```cpp
using MyTypes = testing::Types<int, double, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, FooTest, MyTypes);
```
</Step>
</Steps>

### Key Points
- You can instantiate multiple type sets for the same pattern.
- Test output prefixes the instantiated suite name with the first macro argument.
- Useful for library authors defining tests independently of types they want to verify.

---

## 4. Practical Examples

### Value-Parameterized Test Example

```cpp
class StringLengthTest : public testing::TestWithParam<std::string> {};

TEST_P(StringLengthTest, LengthWorks) {
  EXPECT_GT(GetParam().length(), 0);
}

INSTANTIATE_TEST_SUITE_P(CommonStrings, StringLengthTest, 
                         testing::Values("foo", "bar", "baz"));
```

### Typed Test Example

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {
 protected:
  T value_{};
};

using NumericTypes = testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsSigned) {
  EXPECT_TRUE(std::numeric_limits<TypeParam>::is_signed);
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  void SetUp() override { container_.clear(); }
  std::vector<T> container_;
};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(TestFixture::container_.empty());
}

TYPED_TEST_P(ContainerTest, CanAddElement) {
  TestFixture::container_.push_back(TypeParam{});
  EXPECT_FALSE(TestFixture::container_.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyInitially, CanAddElement);

using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainers, ContainerTest, MyTypes);
```

---

## 5. Troubleshooting & Tips

### Common Issues
- **No Instantiations:** If you define `TEST_P` or `TYPED_TEST_P` tests but forget to instantiate, GoogleTest reports failures. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` to suppress this for abstract test definitions.

- **Name Collisions:** Avoid underscores in test and suite names to prevent collision and undefined behaviors ([see FAQ](faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)).

- **Parameter Lifetime:** Raw pointer parameters must be managed carefully to avoid dangling references.

- **Custom Naming:** Provide parameter name generators for better diagnostics.

### Best Practices
- Use `EXPECT_*` over `ASSERT_*` in parameterized tests to allow all parameters to run.
- Keep parameter sets small and meaningful to avoid excessive test runtime.
- Use `Combine` to generate all combinations of multiple parameters sparingly; large Cartesian products can cause exponential growth.
- Prefer typed tests when testing type behaviors; prefer value-parameterized tests when testing data permutations.

### Performance Considerations
Parameterized tests can increase the number of test runs dramatically. Filter tests or disable unused instantiations during fast development.

---

## 6. Next Steps & Related Content

- Explore [Test Structure and Discovery](/overview/core-concepts/test-structure-discovery) to understand test organization.
- Learn about [Writing Your First Test](/getting-started/first-test-experience/writing-your-first-test) if you are new.
- Use [Expressive Assertions and Matchers](/guides/core_workflows/assertions-matchers) to write effective validations in tests.
- Dive into [Creating Mocks](/guides/core_workflows/creating-mocks) to mock dependencies used in parameterized tests.
- For advanced patterns, read [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) in the Advanced Guide.

---

### References
- [GoogleTest Primer](primer.md)
- [Testing Reference - Parameterized and Typed Tests](reference/testing.md#value-parameterized-tests)
- [GoogleTest FAQ](docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)
- Example Typed Test source: [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)
- Example Parameterized Test source: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)

---

---

*This guide empowers you to write robust and reusable unit tests that leverage GoogleTestâ€™s flexible parameterized and typed test mechanisms, accelerating your testing workflows and enhancing code quality.*

