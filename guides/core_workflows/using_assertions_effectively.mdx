---
title: "Using Assertions Effectively"
description: "Master the core assertion macros provided by GoogleTest, understand when to use fatal and non-fatal assertions, and learn practical tips for clear, maintainable test code. Real examples illustrated for common scenarios."
---

# Using Assertions Effectively

Master the core assertion macros provided by GoogleTest, understand when to use fatal and non-fatal assertions, and learn practical tips for clear, maintainable test code. Real examples illustrated for common scenarios.

---

## 1. Overview

### What This Guide Helps You Achieve
This guide empowers you to write robust, readable, and maintainable test code by mastering GoogleTest's assertion macros. You will learn when to use fatal versus non-fatal assertions, how to add custom failure messages, and explore real-world examples that clarify common testing scenarios.

### Prerequisites
- You should have basic familiarity with C++ and GoogleTest.
- Your project must include and link against GoogleTest (`#include <gtest/gtest.h>`).

### Expected Outcome
- Understand the difference between `ASSERT_` and `EXPECT_` macros.
- Be able to use core assertions effectively to verify your code.
- Write clear custom failure messages.
- Avoid common pitfalls related to assertion usage and subroutine testing.

### Time Estimate
Approximately 10-15 minutes to read and try out examples.

### Difficulty Level
Beginner to Intermediate.

---

## 2. Core Assertion Types

GoogleTest provides a rich collection of assertion macros for verifying program behavior. Most macros come in pairs:

- `EXPECT_*`: Generates **non-fatal failures** and lets the test continue.
- `ASSERT_*`: Generates **fatal failures** and aborts the current function immediately.

Choosing the right variant impacts test flow and diagnostics.

### 2.1 Fatal vs. Non-Fatal Assertions

| Assertion Type | Behavior                                   | Use Case                                      |
|----------------|--------------------------------------------|-----------------------------------------------|
| `ASSERT_*`     | Aborts current function on failure        | Stop when continuing makes no sense (e.g., invalid preconditions) |
| `EXPECT_*`     | Records failure but continues running     | Gather multiple failures in a single test      |

**Example:**

```cpp
TEST(VectorTest, Access) {
  std::vector<int> v = {1, 2, 3};

  ASSERT_EQ(v.size(), 3) << "Vector size mismatch";  // Stop if size wrong

  // Safe to dereference elements after ASSERT above
  EXPECT_EQ(v[0], 1) << "Element 0 mismatch";
  EXPECT_EQ(v[1], 2) << "Element 1 mismatch";
  EXPECT_EQ(v[2], 3) << "Element 2 mismatch";
}
```

In this example, if the vector size is incorrect, subsequent element checks are skipped to avoid undefined behavior.

### 2.2 Basic Boolean Assertions

| Macro           | Checks Result                       | Example                  |
|-----------------|-----------------------------------|--------------------------|
| `EXPECT_TRUE(condition)`  | Condition is true                  | `EXPECT_TRUE(IsValid(x));`|
| `EXPECT_FALSE(condition)` | Condition is false                 | `EXPECT_FALSE(IsEmpty(v));`|

Fatal variants: `ASSERT_TRUE()`, `ASSERT_FALSE()`

### 2.3 Equality and Comparison Assertions

Used for most common comparisons:

| Macro                    | Meaning                                 | Example                       |
|--------------------------|-----------------------------------------|-------------------------------|
| `EXPECT_EQ(val1, val2)`  | `val1 == val2`                          | `EXPECT_EQ(result, expected);` |
| `EXPECT_NE(val1, val2)`  | `val1 != val2`                          | `EXPECT_NE(ptr, nullptr);`      |
| `EXPECT_LT(val1, val2)`  | `val1 < val2`                           | `EXPECT_LT(a, b);`              |
| `EXPECT_LE(val1, val2)`  | `val1 <= val2`                          | `EXPECT_LE(x, y);`              |
| `EXPECT_GT(val1, val2)`  | `val1 > val2`                          | `EXPECT_GT(p, q);`              |
| `EXPECT_GE(val1, val2)`  | `val1 >= val2`                          | `EXPECT_GE(m, n);`              |

Fatal versions exist: `ASSERT_EQ`, etc.

### 2.4 String Comparison Assertions

To compare C strings (null-terminated `char*`), use:

| Macro                       | Meaning                               | Example                      |
|-----------------------------|-------------------------------------|------------------------------|
| `EXPECT_STREQ(str1, str2)`  | Strings are equal                   | `EXPECT_STREQ(s1, s2);`      |
| `EXPECT_STRNE(str1, str2)`  | Strings are not equal              | `EXPECT_STRNE(s1, s2);`      |
| `EXPECT_STRCASEEQ(str1, str2)` | Strings equal ignoring case      | `EXPECT_STRCASEEQ(s1, s2);` |
| `EXPECT_STRCASENE(str1, str2)` | Strings not equal ignoring case  | `EXPECT_STRCASENE(s1, s2);` |

Fatal variants: `ASSERT_STREQ`, etc.


### 2.5 Floating-Point Assertions

Due to rounding, floating-point comparison requires specialized macros:

| Macro                 | Checks Approximately Equal Within      | Example                          |
|-----------------------|--------------------------------------|----------------------------------|
| `EXPECT_FLOAT_EQ`      | 4 ULPs for `float`                   | `EXPECT_FLOAT_EQ(a, b);`          |
| `EXPECT_DOUBLE_EQ`     | 4 ULPs for `double`                  | `EXPECT_DOUBLE_EQ(x, y);`         |
| `EXPECT_NEAR(val1, val2, abs_error)` | Difference ≤ `abs_error`       | `EXPECT_NEAR(pow(2,10), 1024, 1e-9);` |

Fatal variants exist.

### 2.6 Exception Assertions

Available if exceptions are enabled:

| Macro                     | Checks                          | Example                          |
|---------------------------|--------------------------------|----------------------------------|
| `EXPECT_THROW(statement, exception_type)` | Statement throws exception     | `EXPECT_THROW(Foo(), std::runtime_error);` |
| `EXPECT_ANY_THROW(statement)`   | Statement throws any exception  | `EXPECT_ANY_THROW(Foo());`        |
| `EXPECT_NO_THROW(statement)`    | Statement throws no exceptions  | `EXPECT_NO_THROW(Foo());`         |

Fatal variants exist.

### 2.7 Explicit Success and Failure

| Macro         | Effect                                          | Use Case                          |
|---------------|------------------------------------------------|-----------------------------------|
| `SUCCEED()`   | Reports success explicitly                      | Document why code logically succeeds |
| `FAIL()`      | Reports fatal failure, aborting current function | Mark unreachable code or unexpected paths |
| `ADD_FAILURE()` | Reports nonfatal failure                         | Record failure but continue execution     |

### 2.8 Predicate Assertions

To get detailed failure messages for complex conditions, GoogleTest provides:

- `EXPECT_PRED*` for predicates that return bool.
- `EXPECT_PRED_FORMAT*` for predicates returning `AssertionResult`, which can include detailed failure explanations.

Example:

```cpp
bool IsEven(int n) { return n % 2 == 0; }

EXPECT_PRED1(IsEven, 4);  // Succeeds
EXPECT_PRED1(IsEven, 3);  // Fails with detailed message
```

For richer messages, provide predicate-formatter functions as shown in the Advanced Guide.

### 2.9 Matching Values with EXPECT_THAT

Use `EXPECT_THAT(value, matcher)` (requires including `<gmock/gmock.h>`) to assert complex value properties with expressive matchers such as `StartsWith()`, `HasSubstr()`, or `AllOf()`. This allows readable, maintainable assertions.

---

## 3. Using Assertions in Practice

### 3.1 Writing Clear Failure Messages

All assertions can be augmented with custom failure messages via streaming `<<` operator to provide extra context:

```cpp
EXPECT_EQ(x, y) << "x and y differ for input " << input_value;
```

This is invaluable during debugging.

### 3.2 Using Assertions in Helper Functions

- Prefer non-fatal `EXPECT_*` in helper functions so tests continue and can report all issues.
- If aborting on failure is critical, consider using `ASSERT_*` **only** in test bodies or void-returning helper functions.
- Use `SCOPED_TRACE()` or `ScopedTrace` to add context when failures occur inside helpers.

Example:

```cpp
void CheckVector(const std::vector<int>& v) {
  SCOPED_TRACE("Checking vector length and elements");
  EXPECT_EQ(v.size(), 3);
  if (v.size() < 3) return;
  EXPECT_EQ(v[0], 1);
  EXPECT_EQ(v[1], 2);
  EXPECT_EQ(v[2], 3);
}
```

### 3.3 Avoiding Common Pitfalls

- Do not use `ASSERT_*` in constructors or destructors (they can’t abort entire test).
- Avoid multiple fatal `ASSERT_*` in the same function; the first failure aborts it.
- Ensure expressions in `ASSERT_*` macros are side-effect free or carefully managed as they abort the current function immediately on failure.

---

## 4. Examples

### 4.1 Fatal vs Non-Fatal Difference

```cpp
TEST(FooTest, FatalVsNonFatal) {
  int* ptr = nullptr;

  EXPECT_NE(ptr, nullptr) << "Pointer is nullptr";
  // Will continue execution, probably crashing.

  ASSERT_NE(ptr, nullptr) << "Pointer is nullptr";
  // Aborts here, safe from null dereference.
}
```

### 4.2 Checking Strings

```cpp
TEST(StringTest, CaseInsensitive) {
  const char* a = "Hello";
  const char* b = "hello";

  EXPECT_STRCASEEQ(a, b) << "Strings should be equal ignoring case";
  EXPECT_STRCASENE(a, "world") << "Strings should differ ignoring case";
}
```

### 4.3 Floating Point Assertions

```cpp
TEST(FloatTest, ApproximateEquality) {
  float x = 1.0f;
  float y = 1.00001f;

  EXPECT_FLOAT_EQ(x, y) << "Floats differ beyond 4 ULPs";
  EXPECT_NEAR(x, y, 1e-4f) << "Floats differ more than allowed error";
}
```

### 4.4 Exception Assertions

```cpp
void ThrowsRuntimeError() { throw std::runtime_error("error"); }

TEST(ExceptionTest, ThrowsExpectedException) {
  EXPECT_THROW(ThrowsRuntimeError(), std::runtime_error);
  EXPECT_ANY_THROW(ThrowsRuntimeError());
  EXPECT_NO_THROW(int x = 5; (void)x;);
}
```

---

## 5. Best Practices and Tips

- Use `EXPECT_` macros when you want to continue test execution after a failure.
- Use `ASSERT_` macros only if failure means no point continuing (e.g., resource setup).
- Always add meaningful custom failure messages with `<<` to ease debugging.
- Use `SCOPED_TRACE()` in helpers to pinpoint failure context.
- Prefer `EXPECT_THAT` with matchers for complex object validation.
- Avoid multiple death assertions on the same line.
- In death tests, manage side effects carefully as child process isolation means no shared memory.

---

## 6. Troubleshooting

### Common Issues

- **Test aborts unexpectedly after `ASSERT_*` failure**: Remember that `ASSERT_*` aborts the current function only, not the entire test suite.
- **No informative failure message**: Provide custom messages via `<<` operator.
- **Failures inside helper functions lack context**: Use `SCOPED_TRACE()` to add diagnostic traces.
- **Floating point comparisons failing due to precision**: Use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` instead of `EXPECT_EQ`.

### Validating Assertions

Use the test framework output to verify which assertion failed and at what location. GoogleTest reports file and line numbers for all failures automatically.

---

## 7. Next Steps

- Explore [Writing Your First Test](../core_workflows/writing_first_test) to get started with basic test writing.
- Understand [Organizing Test Suites and Fixtures](../core_workflows/organizing_test_suites) for grouping tests.
- Learn advanced assertions and predicate formatters in the [Advanced GoogleTest Topics](../advanced).
- Discover mocking techniques in [Getting Started with GoogleMock](../mocking_and_advanced_patterns/getting_started_with_googlemock).

---

For comprehensive details on all assertions, refer to the [Assertions Reference](../../../docs/reference/assertions.md).

