---
title: "Authoring Basic Unit Tests"
description: "A hands-on guide to writing fundamental unit tests with GoogleTest, including key assertion types, test case structure, and understanding test results."
---

# Authoring Basic Unit Tests

A hands-on guide to writing fundamental unit tests with GoogleTest, including key assertion types, test case structure, and understanding test results.

---

## 1. Introduction: Your First Step to Reliable Testing

Testing your C++ code is essential to ensure its correctness and maintainability. This guide helps you author basic unit tests using GoogleTest, focusing on writing tests that validate code behavior clearly and effectively. You'll learn how to structure tests, use the most common assertions, and interpret test results.

### Why Write Unit Tests with GoogleTest?
- Isolate and verify individual units of functionality.
- Organize tests into suites that mirror your code architecture.
- Quickly identify failures with meaningful messages.

---

## 2. Prerequisites

Before you start:

- Have GoogleTest installed and integrated into your project. Refer to [Install with CMake](../../getting-started/installation-quickstart/install-cmake) or [Install with Bazel](../../getting-started/installation-quickstart/install-bazel).
- Basic familiarity with C++ syntax and concepts.
- A simple function or class to test.

---

## 3. Expected Outcome

By the end of this guide, you will be able to:

- Create simple test cases using `TEST()`.
- Define fixture-based tests with `TEST_F()` to reuse setup code.
- Apply core assertions like `EXPECT_EQ()`, `ASSERT_TRUE()`, and others.
- Understand and analyze test outputs.

---

## 4. Time Estimate

Approximately 20–30 minutes.

---

## 5. Difficulty Level

Beginner

---

## 6. Writing Your First Test: Step-by-Step

### Step 1: Define a Simple Test Function

Use the `TEST()` macro to define a test inside a test suite.

```cpp
// Function to test
int Factorial(int n) { 
  return (n <= 1) ? 1 : n * Factorial(n - 1); 
}

// Test definition
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}
```

**What Happens:** 
- `TEST(FactorialTest, HandlesZeroInput)` creates a test named `HandlesZeroInput` in the suite `FactorialTest`.
- The assertion `EXPECT_EQ` checks that `Factorial(0)` returns 1.

### Step 2: Add More Test Cases to the Suite

```cpp
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

Tests logically related to factorial are grouped for maintainability.

### Step 3: Use Assertions Effectively

- **EXPECT_EQ(val1, val2):** Checks that `val1 == val2`. On failure, continues the test and reports.
- **ASSERT_TRUE(condition):** Checks that `condition` is true. On failure, aborts the current test function.

Choose `ASSERT_*` when failure should stop the test immediately to avoid invalid subsequent operations.

### Step 4: Organize Repeated Setup Using Fixtures

When multiple tests require the same setup, use test fixtures.

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

- `TEST_F()` uses the fixture class `QueueTest` to access consistent test state.
- Each test gets a fresh fixture instance.

### Step 5: Invoking Your Tests

Use `TEST()` and `TEST_F()` macros to declare tests—they are automatically registered.

Call `RUN_ALL_TESTS()` inside your `main` after `InitGoogleTest()` to execute all tests:

```cpp
int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This runs all tests, reports results, and returns `0` on success or `1` on failure.

---

## 7. Understanding Test Output

When you run tests, GoogleTest outputs summaries:

- Test names grouped by suites.
- PASS or FAIL status by test.
- Detailed failure messages showing:
  - Source file and line number.
  - Failed assertion explanation.

For example:

```
[ RUN      ] FactorialTest.HandlesZeroInput
[       OK ] FactorialTest.HandlesZeroInput (0 ms)
[ RUN      ] FactorialTest.HandlesPositiveInput
[  FAILED  ] FactorialTest.HandlesPositiveInput (1 ms)
...
```

---

## 8. Best Practices & Tips

- Use descriptive test suite and test names that reflect functionality.
- Prefer `EXPECT_` assertions when you want to see multiple failures in one test run.
- Use `ASSERT_` when subsequent code depends on passed assertions.
- Keep tests small and focused—each test verifies one logical behavior.
- Use fixtures to set up common objects to avoid duplication and reduce maintenance.

---

## 9. Common Pitfalls

- **Misnaming Fixtures or Setup**: Ensure `SetUp()` is spelled correctly (case-sensitive). Mistyped `Setup()` won’t be called.
- **Continuing after Fatal Failures**: Look out for dereferencing pointers after a failed `ASSERT_*`—these tests stop immediately.
- **Running Tests Without Initialization**: Always call `InitGoogleTest()` before `RUN_ALL_TESTS()`, or test filtering and flag parsing won’t work.

---

## 10. Troubleshooting

- If no tests run, check that tests are linked correctly and that `main()` calls `RUN_ALL_TESTS()`.
- For odd build errors, confirm GoogleTest is correctly installed and header paths are set.
- Use `--gtest_list_tests` command-line option to confirm tests are recognized.

---

## 11. Next Steps & Further Learning

- Explore writing [mock objects](../../guides/writing-and-running-tests/using-mock-objects) to test components in isolation.
- Learn advanced assertions and custom matchers in [Advanced Assertions and Custom Matchers](../../guides/writing-and-running-tests/advanced-assertions-matchers).
- Read about [Test Project Structure and Initialization](../../guides/getting-started/test-project-structure) for scalable test designs.

---

## 12. Additional Resources

- [GoogleTest Primer](../../docs/primer.md)
- [Assertions Reference](../../docs/reference/assertions.md)
- [Test Fixtures Documentation](../../docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests)
- [Getting Started with GoogleTest](../../getting-started/installation-quickstart/first-test)

---

## 13. Sample Full Test File Example

```cpp
#include <gtest/gtest.h>

// Function under test
int Factorial(int n) {
  return (n <= 1) ? 1 : n * Factorial(n - 1);
}

// Simple tests
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This example is ready to compile and run, serving as a minimal working baseline.

---

## 14. Summary Diagram of Test Workflow

```mermaid
flowchart TD
  A[Start: Write function to test] --> B[Create TEST() or TEST_F()]
  B --> C[Write assertions inside test body]
  C --> D[Build and link test binary]
  D --> E[Run test binary with RUN_ALL_TESTS()]
  E --> F[Test execution]
  F -->|Pass| G[Success output]
  F -->|Fail| H[Failure diagnostics and messages]
  G --> I[Iterate and add more tests]
  H --> I
```

