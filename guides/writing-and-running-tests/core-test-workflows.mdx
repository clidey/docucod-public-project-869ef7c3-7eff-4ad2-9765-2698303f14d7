---
title: "Core Test Workflows and Patterns"
description: "A practical exploration of day-to-day test case authoring, including value-parameterized tests, fatal vs. non-fatal failures, and recommended patterns for organizing and maintaining effective test suites."
---

# Core Test Workflows and Patterns

A practical exploration of day-to-day test case authoring, including value-parameterized tests, fatal vs. non-fatal failures, and recommended patterns for organizing and maintaining effective test suites.

## 1. Overview

### Purpose
This guide helps you master the core workflows for writing, organizing, and maintaining tests with GoogleTest. You'll learn how to write robust test cases, leverage value-parameterized tests for coverage with less code duplication, and understand the impact of fatal versus non-fatal failures on test flow.

### Prerequisites
- Basic familiarity with C++ and test-driven development concepts.
- GoogleTest framework installed and configured in your project.
- Understanding of basic TEST and TEST_F usage from the [GoogleTest Primer](primer.md).

### Expected Outcome
By following this guide, you will:
- Effectively write simple and fixture-based tests.
- Employ value-parameterized tests to cover multiple input conditions efficiently.
- Distinguish and apply fatal (`ASSERT_*`) vs. non-fatal (`EXPECT_*`) assertions correctly.
- Organize tests systematically for easier maintenance and debugging.

### Time Estimate
30-45 minutes to read through and practice the patterns presented.

### Difficulty Level
Intermediate â€” builds upon basic test writing to optimize and scale testing practices.

---

## 2. Writing and Organizing Tests: Step-by-Step

### 2.1 Writing Simple Tests

Simple tests validate specific scenarios with clear input and output expectations.

- Use the `TEST()` macro:

  ```cpp
  TEST(FactorialTest, HandlesZeroInput) {
    EXPECT_EQ(Factorial(0), 1);
  }
  
  TEST(FactorialTest, HandlesPositiveInput) {
    EXPECT_EQ(Factorial(1), 1);
    EXPECT_EQ(Factorial(3), 6);
  }
  ```

- **Outcome:** Each test runs isolated, reporting success or failure independently.
- **Tip:** Group logically related tests into test suites by using the same test suite name.

### 2.2 Using Test Fixtures for Shared Setup

When multiple tests require common data or setup, define a fixture class derived from `testing::Test`:

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;  // empty queue
  Queue<int> q1_;  // one element
  Queue<int> q2_;  // two elements
};
```

Define tests using `TEST_F()`:

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

- **Outcome:** Each test in a fixture runs with a fresh instance ensuring isolation.
- **Tip:** Use `ASSERT_*` in places where continuing after failure can cause undefined behavior (e.g., dereferencing a nullptr).

### 2.3 Value-Parameterized Tests

To test similar logic over a range of data, use value-parameterized tests to avoid duplicating test code.

**Workflow:**

1. Define a fixture class inheriting from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {};
```

2. Use `TEST_P()` to write tests that use the parameter with `GetParam()`:

```cpp
TEST_P(FooTest, HandlesPositiveValues) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

3. Instantiate the test suite with parameters you want to test against:

```cpp
INSTANTIATE_TEST_SUITE_P(PositiveValues,
                         FooTest,
                         testing::Values(1, 2, 3, 10));
```

- **Outcome:** GoogleTest runs the test once for each parameter, suffixed with the parameter index.
- **Tip:** Use parameter generators like `Range()`, `Values()`, `ValuesIn()` or `Combine()` for rich parameter sets.

### 2.4 Fatal vs. Non-Fatal Failures

GoogleTest assertions come in two flavors:

- `ASSERT_*`: Fatal failures that abort the current test function immediately.
- `EXPECT_*`: Non-fatal failures that continue execution allowing multiple checks per test.

**Guidelines for Use:**

- Use `ASSERT_*` when subsequent code depends on the assertion being true (e.g., a pointer being non-null).
- Use `EXPECT_*` to report errors but continue running remaining checks to identify multiple issues simultaneously.

**Example:**

```cpp
void TestDequeue(Queue<int>& q) {
  int* n = q.Dequeue();
  ASSERT_NE(n, nullptr) << "Dequeue should not return nullptr";
  EXPECT_EQ(*n, expected_value);
  delete n;
}
```

- **Pitfall:** Fatal failures in constructors or destructors are not allowed; place such checks in `SetUp()` / `TearDown()` instead.

### 2.5 Organizing Tests Effectively

- Group similar tests in suites reflecting your code structure.
- Follow naming conventions with `TestSuiteName` and `TestName` without underscores.
- Prefer test fixtures (`TEST_F`) when tests share setup or utilities.
- Employ value-parameterized tests (`TEST_P`, `INSTANTIATE_TEST_SUITE_P`) to reduce redundancy.

---

## 3. Practical Examples

### Example 1: Simple Integer Function Tests

```cpp
int Factorial(int n);

TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

### Example 2: Test Fixture with Queue

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    q1_.Enqueue(42);
  }
  Queue<int> q0_;
  Queue<int> q1_;
};

TEST_F(QueueTest, EmptyQueueReturnsNull) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);
}

TEST_F(QueueTest, EnqueueDequeue) {
  int* n = q1_.Dequeue();
  ASSERT_NE(n, nullptr) << "Expected non-null pointer";
  EXPECT_EQ(*n, 42);
  delete n;
}
```

### Example 3: Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int val = GetParam();
  EXPECT_EQ(val % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues,
                         IsEvenTest,
                         testing::Values(2, 4, 6, 8));
```

---

## 4. Troubleshooting and Best Practices

### Common Issues

- **Continuing after fatal failures:** Remember that `ASSERT_*` aborts the current function, not the whole test. Use `HasFatalFailure()` to check for failures in helper functions or propagate errors accordingly.

- **Misspelling `SetUp()` or `TearDown()`:** These are case-sensitive. Use `override` to catch mistakes at compile time.

- **Skipping Tests:** Use `GTEST_SKIP()` to skip tests at runtime when preconditions are unmet.

### Best Practices

- Prefer `EXPECT_*` to `ASSERT_*` where possible for better failure reporting.
- Arrange your test code into fixtures to share common initialization.
- Use `SCOPED_TRACE()` to add contextual trace information when invoking shared helper functions.
- Use value-parameterized tests to cover multiple inputs systematically.
- Name tests and test suites clearly to reflect what they verify.
- Regularly run tests with `--gtest_fail_fast` to catch issues early when developing.

### Performance Considerations

- Share expensive resources in `SetUpTestSuite()` and clean up in `TearDownTestSuite()` to avoid costly per-test setup.
- Use test sharding (`GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` environment variables) if running a very large suite across multiple machines.

### Alternative Approaches

- Typed and type-parameterized tests for running the same tests over different types.
- Dynamic test registration with `RegisterTest` to create tests at runtime programmatically.

---

## 5. Next Steps and Related Topics

- Explore [Advanced GoogleTest Topics](advanced.md) for deeper knowledge on typed tests, death tests, failure handling, and custom event listeners.
- Review the [Assertions Reference](reference/assertions.md) to master the wide variety of assertion macros.
- Study the [Test Cases and Fixtures API](api-reference/testing-apis/test-case-api) for detailed API methods.
- Check out the [GoogleTest Primer](primer.md) for foundational understanding.
- Use the [GoogleTest Samples](samples.md) repository for reference implementation examples.

---

## Callouts

<Tip>
When writing tests involving pointer dereferencing, always use `ASSERT_*` to verify pointers before use. This prevents undefined behavior and allows the test framework to report meaningful errors instead of crashing.
</Tip>

<Note>
You can specify parameter name generators in `INSTANTIATE_TEST_SUITE_P` to produce human-readable test names, greatly improving test report clarity.
</Note>

<Warning>
Avoid using fatal assertions like `ASSERT_*` in constructors or destructors; use `SetUp()`/`TearDown()` functions instead to prevent compilation errors and undefined test behavior.
</Warning>
