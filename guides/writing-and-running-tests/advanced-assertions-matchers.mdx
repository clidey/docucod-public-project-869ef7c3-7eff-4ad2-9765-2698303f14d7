---
title: "Advanced Assertions and Custom Matchers"
description: "Unlock the power of advanced matchers and assertions, including composing multiple conditions, writing custom matchers, and structuring expressive test conditions."
---

# Advanced Assertions and Custom Matchers

Unlock the power of advanced matchers and assertions, including composing multiple conditions, writing custom matchers, and structuring expressive test conditions.

---

## Overview

This guide focuses on advanced GoogleTest features that empower you to:

- Combine multiple assertion conditions seamlessly
- Write your own custom matchers with descriptive failure messages
- Use parameterized and polymorphic matchers for flexible test expressions
- Apply expressive test conditions that improve test readability and diagnostics

By mastering these capabilities, your test code becomes more robust, maintainable, and insightful.


## Prerequisites

- Basic familiarity with GoogleTest and GoogleMock matcher concepts.
- Experience writing simple assertions with `EXPECT_THAT` and built-in matchers.
- C++ development environment configured to build and run GoogleTest-based tests.


## What You'll Achieve

After completing this guide, you'll be able to:

- Create complex assertions that combine multiple matchers with `AllOf`, `AnyOf`, and `Not`.
- Write and use custom matchers with the `MATCHER` and `MATCHER_P` macros.
- Compose matchers to validate complex structures or properties.
- Parameterize matchers to handle varied test scenarios succinctly.


## Estimated Time

About 30 minutes, depending on your familiarity with GoogleTest matchers.


---

## Step-by-Step Instructions

### 1. Combine Multiple Conditions Using Composite Matchers

GoogleTest provides logical combinators to compose matchers:

- `AllOf(m1, m2, ... )`: Value must satisfy *all* matchers.
- `AnyOf(m1, m2, ... )`: Value must satisfy *any* matcher.
- `Not(m)`: Value must *not* satisfy matcher `m`.

These let you build expressive conditions.

#### Example

```cpp
EXPECT_THAT(value, AllOf(Ge(10), Le(20), Ne(15)));  // value in [10,20] excluding 15
EXPECT_THAT(value, AnyOf(Eq(0), Eq(100), Eq(200)));  // value is 0, 100, or 200
EXPECT_THAT(value, Not(IsNull()));                    // pointer not null
```

*Expected Result:* Failure messages clearly show which condition failed, helping you quickly debug.


### 2. Writing Custom Matchers Using `MATCHER` Macros

Use `MATCHER` and its parameterized variants to define custom reusable matchers.

#### `MATCHER` Macro

Defines a matcher with no parameters.

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

// Usage
EXPECT_THAT(n, IsEven());
```

- `arg` represents the value being matched.
- The last statement must return a `bool` indicating success.

##### Custom Description

You can customize failure messages by providing a description string (can use `negation` variable to alter message when negated):

```cpp
MATCHER(IsEven, absl::StrCat(negation ? "isn't" : "is", " even")) {
  return (arg % 2) == 0;
}
```

##### Adding Failure Explanation

Write details to `*result_listener` to give richer explanations:

```cpp
MATCHER(IsEven, "") {
  if ((arg % 2) == 0) return true;
  *result_listener << "the remainder is " << (arg % 2);
  return false;
}
```


#### `MATCHER_P` and Others

To add parameters to your matcher:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}

// Usage
EXPECT_THAT(x, HasAbsoluteValue(10));
```

You can define up to 10 parameterized arguments using `MATCHER_P2`, `MATCHER_P3`, etc.

### 3. Polymorphic Matchers for Multiple Types

GoogleTest allows matchers to be polymorphic, i.e., usable with multiple types without redefinition.

Example: `Eq(5)` works with `int`, `long`, `float`, and more.

You can make your matchers polymorphic by making `MatchAndExplain` a template on the argument's type:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;
  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

Now `NotNull()` can be used with any pointer type.

### 4. Composing Matchers for Containers and Tuples

You can match STL containers flexibly using:

- `ElementsAre(...)`: expects elements in order matching given value or matchers.
- `UnorderedElementsAre(...)`: expects elements to match the given ones in any order.
- `Contains(...)`: verifies the container has an element matching the matcher.

To match tuples or pairs element-wise, use `Pair(...)`, `FieldsAre(...)`, or `Pointwise(...)`:

```cpp
EXPECT_THAT(my_vector, ElementsAre(1, 2, 3));
EXPECT_THAT(my_set, UnorderedElementsAre(3, 1, 2));
EXPECT_THAT(my_map, Contains(Pair("key", Ge(5))));
```


### 5. Use Matchers in `EXPECT_THAT` and Assertions

Use `EXPECT_THAT(value, matcher)` or `ASSERT_THAT(value, matcher)` to test with matchers.

Example:

```cpp
EXPECT_THAT(my_string, StartsWith("Hello"));
EXPECT_THAT(my_container, Each(Gt(0)));
EXPECT_THAT(my_optional, Optional(Ge(10)));
EXPECT_THAT(my_pointer, NotNull());
```


---

## Examples & Code Samples

### Define a Basic Custom Matcher

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

TEST(NumberTest, CheckDivisibility) {
  EXPECT_THAT(21, IsDivisibleBy7());
  EXPECT_THAT(22, Not(IsDivisibleBy7()));
}
```

Failure message on mismatch:

```
Value of: 22
Expected: is divisible by 7
  Actual: 22 (the remainder is 1)
```

### Parameterized Matcher

```cpp
MATCHER_P(InRange, range, "") {
  return arg >= range.first && arg <= range.second;
}

TEST(ParamMatcherTest, RangeCheck) {
  EXPECT_THAT(5, InRange(std::make_pair(4, 6)));
  EXPECT_THAT(3, Not(InRange(std::make_pair(4, 6))));
}
```

### Composing Matchers

```cpp
EXPECT_THAT(number, AllOf(Ge(10), Le(20)));
EXPECT_THAT(ptr, NotNull());
EXPECT_THAT(str, AnyOf(HasSubstr("foo"), HasSubstr("bar")));
```

### Matcher on Container Fields

```cpp
struct Foo {
  int x;
  std::string name;
};

EXPECT_THAT(foo_object, AllOf(Field(&Foo::x, Ge(5)), Field(&Foo::name, StartsWith("J"))));
```

### Using `ResultOf` to Match Based on Computed Value

```cpp
EXPECT_THAT(foo_object, ResultOf([](const Foo& f) { return f.x + 5; }, Eq(10)));
```

### Using Matchers in `EXPECT_THAT`

```cpp
EXPECT_THAT(actual_string, StartsWith("Hello"));
EXPECT_THAT(ptr, Pointee(Ge(100)));
EXPECT_THAT(variant_value, VariantWith<int>(Gt(10)));
```


---

## Troubleshooting & Tips

### Common Issues

- **Unexpected type errors in matchers:** Use `SafeMatcherCast<T>(m)` to ensure matcher compatibility when the static types differ but conversion is safe.
- **Custom matchers not printing useful failure messages:** Add message streaming into `*result_listener` in the matcher body.
- **Failure messages not showing detailed reasons:** Use `ExplainMatchResult()` or implement `MatchAndExplain()` to provide detailed reasoning.
- **Matcher ambiguities or overload resolution errors:** Specify explicit template types or use typed matchers like `TypedEq<T>(val)`.

### Best Practices

- Keep custom matchers pure with no side-effects.
- Use descriptive failure messages with the help of `negation` and `result_listener`.
- Prefer parameterized matchers (`MATCHER_P`) for reusable tests with varying parameters.
- Compose matchers logically with `AllOf`, `AnyOf`, and `Not` for clarity.
- Use container and tuple matchers for structure-rich test objects.
- Avoid overly strict `EXPECT_CALL` constraints unless testing specific call counts.

### Performance Considerations

- Custom matchers with expensive computations should be designed carefully to minimize overhead.
- Use `MATCHER` macros to avoid boilerplate and improve compile times.

---

## Next Steps & Related Content

- Explore [Matchers Reference](../../docs/reference/matchers.md) for a comprehensive list of built-in matchers.
- Read [gMock Cookbook](../../docs/gmock_cook_book.md#NewMatchers) for advanced matcher and action usage.
- Use [Writing Basic Unit Tests](../writing-and-running-tests/basic-unit-tests.md) to solidify foundational test writing.
- Check [Mocking Reference](../../docs/reference/mocking.md) to understand mocks and expectations in depth.
- For troubleshooting complex matcher problems, consult [Troubleshooting Common Issues](../../getting-started/validation-troubleshooting/common-issues.md).

Use these advanced assertion and matcher capabilities to write expressive, maintainable tests that clearly convey your expectations and make debugging failures straightforward.
