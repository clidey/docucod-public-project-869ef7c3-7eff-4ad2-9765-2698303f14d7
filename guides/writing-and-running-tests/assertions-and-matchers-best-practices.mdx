---
title: "Assertions and Matchers: Best Practices"
description: "Guide to leveraging the full suite of GoogleTest assertions and matchers in real-life scenarios, including best practices for expressive, reliable, and maintainable test validations."
---

# Assertions and Matchers: Best Practices

Ensure your tests accurately express intent, remain maintainable, and provide informative feedback by mastering GoogleTest assertions and matchers. This guide walks you through practical best practices for leveraging GoogleTest's powerful assertion and matcher facilities in real-world testing scenarios.

---

## 1. Understanding Assertions and Matchers

### What You Want to Achieve
- Use assertions to verify conditions in tests with clear pass/fail criteria.
- Choose between fatal (`ASSERT_*`) and non-fatal (`EXPECT_*`) assertions appropriately.
- Use matchers to write expressive and flexible validations for single or composite values.
- Enhance failure messages with detailed explanations and context.

### Prerequisites
- Basic knowledge of C++ and GoogleTest framework.
- Include `<gtest/gtest.h>` and `<gmock/gmock.h>` where relevant.

### Outcome
- Write assertions and matchers that clearly express test intent.
- Produce tests with maintainable and readable validation logic.
- Generate detailed failure reports aiding swift debugging.

---

## 2. Writing Clear Assertions

### Choose Between Fatal and Non-Fatal Assertions
- **Use `ASSERT_*`** when the test cannot meaningfully continue after a failure.
  - Example: `ASSERT_EQ(expected, actual);`
- **Use `EXPECT_*`** when subsequent checks are still valuable.
  - Example: `EXPECT_TRUE(condition);`

<Tip>
Avoid fatal assertions in constructors or destructors since they cannot return early properly; use `SetUp()`/`TearDown()` instead.
</Tip>

### Add Custom Messages for Clarity
- Stream additional information to assertions to clarify failures.

```cpp
EXPECT_TRUE(value > 0) << "Value must be positive but got: " << value;
```

### Use Predicate Assertions for Complex Checks
- Define predicate functions returning `testing::AssertionResult` for detailed pass/fail information.

```cpp
testing::AssertionResult IsValid(int n) {
  if (n > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is not positive";
}

EXPECT_PRED1(IsValid, x);
```

### Use Exception Assertions When Testing Exception Behavior
- Use `EXPECT_THROW()`, `EXPECT_ANY_THROW()`, or `EXPECT_NO_THROW()` to validate exception-related behavior cleanly.

---

## 3. Leveraging Matchers for Expressive Tests

### Basic Usage of Matchers
- Use `EXPECT_THAT(value, matcher)` to assert that `value` matches criteria.

```cpp
EXPECT_THAT(result, Eq(expected_value));
EXPECT_THAT(name, StartsWith("Hello"));
```

### Use Wildcard and Generic Matchers for Flexibility
- `_` matches any value.
- `A<T>()` or `An<T>()` matches any value of type `T`.

### Compose Matchers for Complex Logic
- Combine matchers using `AllOf()`, `AnyOf()`, and `Not()`.

```cpp
EXPECT_THAT(val, AllOf(Gt(5), Ne(10)));
EXPECT_THAT(str, Not(HasSubstr("error")));
```

<Tip>
Prefer explicit use of matchers over implicit conversions (e.g. use `Eq(val)` instead of just `val`).
</Tip>

### Use Container Matchers to Inspect Collections
- Use `ElementsAre()`, `Contains()`, `Each()`, `UnorderedElementsAre()`, etc.

```cpp
EXPECT_THAT(vec, ElementsAre(1, Gt(0), _));
EXPECT_THAT(map, Contains(Key(Ge(5))));
```

### Match Object Properties and Fields
- Use `Field(&Class::member, matcher)` and `Property(&Class::method, matcher)`.

```cpp
EXPECT_THAT(foo, Field(&Foo::bar, Eq(42)));
EXPECT_THAT(user, Property(&User::GetName, StartsWith("Dr.")));
```

### Use Pointer Matchers for Indirect Values

```cpp
EXPECT_THAT(ptr, Pointee(Le(10)));
EXPECT_THAT(sp, NotNull());
```

### Use Typed and Safe Matcher Casting
- Use `SafeMatcherCast<T>(m)` when matching slightly different but compatible types.

### Write Custom Matchers When Needed
- Use `MATCHER` and `MATCHER_P` macros for concise, expressive custom matchers.
- Stream explanations for failed matches to improve diagnostics.

```cpp
MATCHER(IsEven, "checks if a number is even") {
  return (arg % 2) == 0;
}

EXPECT_THAT(value, IsEven());
```

---

## 4. Best Practices to Write Reliable Tests

### Start with Simpler Assertions and Add Detail Gradually
- Begin with simple `EXPECT_EQ()` or `EXPECT_THAT()` statements.
- Use predicate or custom matchers when the logic requires it.

### Use `SCOPED_TRACE` to Provide Context When Calling Helper Functions
- Add context information so failure reports pinpoint the invocation.

### Avoid Side Effects in Matchers and Predicates
- Keep matchers pure so they can be invoked multiple times safely.

### Use `ON_CALL` vs `EXPECT_CALL` Properly
- Use `ON_CALL` for setting default behavior without expectation.
- Use `EXPECT_CALL` only to express expected calls, keeping tests focused and less brittle.

### When Matching Non-Copyable Types
- Use `Eq(std::ref(obj))` to match references safely.

### For Move-Only Types
- Use standard `MOCK_METHOD` and match or return move-only types as usual.
- Be mindful of actions like `Return()` which copy arguments eagerly.

### Avoid Over-Specifying in Tests
- Write expectations and matchers that verify behaviour, not implementation specifics.

### Use NiceMock and StrictMock Appropriately
- Use `NiceMock` to silence irrelevant warnings.
- Use `StrictMock` to catch unplanned calls as errors.

---

## 5. Troubleshooting and Tips

### Common Pitfalls
- Using `EXPECT_*` vs `ASSERT_*` incorrectly.
- Forgetting the test fixture default constructor leading to compile errors.
- Writing matchers with side effects.
- Overusing `EXPECT_CALL` leading to brittle tests.

### How to Debug Matcher Failures
- Run tests with `--gmock_verbose=info` for call logs and matching details.
- Combine with `--gtest_stack_trace_depth=0` to reduce noise.

### Handling Disabled Tests
- Use the `DISABLED_` prefix for temporarily disabled tests.
- Use `--gtest_also_run_disabled_tests` to run disabled tests when needed.

---

## 6. Next Steps & Related Content

- Explore [GoogleTest Assertions Reference](../reference/assertions.md) for full assertion macros.
- See [Matchers Reference](../reference/matchers.md) for detailed matcher usage.
- Learn about [Mocking Techniques](../guides/mocking-and-advanced-testing/using-googlemock-effectively) to combine assertions and expectations.
- Deep dive on [Writing Custom Matchers](../guides/mocking-and-advanced-testing/customizing-mock-behavior).
- Understand [Test Lifecycle and Fixtures](../guides/writing-and-running-tests/core-test-workflows) for better test organization.

---

## Appendices: Practical Examples

### 1. Using `EXPECT_THAT` with Matchers

```cpp
#include <gmock/gmock.h>

using ::testing::StartsWith;
using ::testing::Gt;
using ::testing::HasSubstr;
...
EXPECT_THAT(username, StartsWith("user_"));
EXPECT_THAT(score, AllOf(Gt(0), Lt(100)));
EXPECT_THAT(log_message, HasSubstr("ERROR"));
```

### 2. Writing a Custom Matcher with Explanation

```cpp
MATCHER(IsEven, "Checks if a number is even") {
  if ((arg % 2) == 0) return true;
  *result_listener << "which has remainder " << (arg % 2);
  return false;
}

EXPECT_THAT(value, IsEven());
```

### 3. Matching a Field of an Object

```cpp
struct Status {
  int code;
  std::string message;
};

EXPECT_THAT(status,
            Field(&Status::code, Eq(0)));
```

### 4. Testing for Exception

```cpp
EXPECT_THROW(DoSomething(), std::runtime_error);
EXPECT_NO_THROW(DoSomething());
```

### 5. Using Container Matchers

```cpp
std::vector<int> v = {1, 2, 3};
EXPECT_THAT(v, UnorderedElementsAre(3, 2, 1));
```

---

For comprehensive details, see the official GoogleTest API and guides linked below.
