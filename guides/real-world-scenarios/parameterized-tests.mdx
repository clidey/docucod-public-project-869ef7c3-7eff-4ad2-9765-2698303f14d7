---
title: "Parameterized and Type-Parameterized Testing"
description: "Demonstrates approaches for exhaustive testing using value- and type-parameterized tests. Includes practical examples for DRY (Don’t Repeat Yourself) test suites covering multiple inputs or data types."
---

# Parameterized and Type-Parameterized Testing

GoogleTest offers powerful mechanisms to test your code thoroughly by running the same tests repeatedly with different data inputs or types. This avoids duplication and ensures coverage of edge cases and a broad set of scenarios within a DRY (Don’t Repeat Yourself) testing approach.

This guide focuses explicitly on **value-parameterized tests** and **type-parameterized tests** — two complementary techniques for exhaustive testing using parameter combinations and multiple data types.

---

## 1. Overview

### Task Description
Learn how to write GoogleTest parameterized tests that let you run the same test code multiple times with different inputs or types, ensuring robust and comprehensive test coverage with minimal repetition.

### Prerequisites
* Familiarity with basic GoogleTest usage (using `TEST()` and `TEST_F()` macros).
* A C++ development environment with GoogleTest installed.
* Understanding of test fixtures (optional but helpful).

### Expected Outcome
* Create value-parameterized test fixtures that receive a range of values.
* Instantiate tests with sets or ranges of parameters.
* Define type-parameterized test suites for running tests across different types.
* Instantiate type-parameterized tests with type lists.
* Understand how to customize test names for clarity.

### Time Estimate
Approximately 15–30 minutes to read and implement basic parameterized test examples.

### Difficulty Level
Intermediate: some knowledge of C++ templates and GoogleTest basics required.

---

## 2. Value-Parameterized Testing

Value-parameterized tests allow you to run the same test logic against multiple distinct input values automatically, for example, testing a function against different numeric inputs or strings.

### Key Concepts
* Define a test fixture by inheriting from `testing::TestWithParam<T>`, where `T` is your parameter type.
* Use the `TEST_P()` macro to define tests that access the parameter via `GetParam()`.
* Instantiate the test suite using `INSTANTIATE_TEST_SUITE_P()` with generators that produce test values.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a class derived from `::testing::TestWithParam<T>`. For example:
```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // fixture members if needed
};
```
This class provides access to the parameter via `GetParam()`.
</Step>

<Step title="Write Parameterized Tests with TEST_P">
Define your tests using the `TEST_P` macro. Inside, call `GetParam()` to get the current parameter:
```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}
```
You can write multiple tests for the same fixture.
</Step>

<Step title="Instantiate the Test Suite with Parameter Sets">
Use `INSTANTIATE_TEST_SUITE_P` to instantiate the tests with a set of parameters:
```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest,
                         ::testing::Values("meeny", "miny", "moe"));
```
Each parameter results in a distinct test instance.
</Step>

<Step title="Run Your Tests">
Compile and run your tests.
You’ll see each parameterized test run independently with names reflecting the parameter values:
```
InstantiationName/FooTest.DoesBlah/0  // for "meeny"
InstantiationName/FooTest.DoesBlah/1  // for "miny"
InstantiationName/FooTest.DoesBlah/2  // for "moe"
```
</Step>
</Steps>

### Parameter Generators
GoogleTest provides a variety of parameter generators built to supply test values conveniently:

| Generator Function             | Description                                                  |
|-------------------------------|--------------------------------------------------------------|
| `Range(begin, end[, step])`    | Yields values from `begin` to `end` (exclusive), stepped by `step`. Defaults to 1. |
| `Values(v1, v2, ..., vN)`      | Yields explicit values listed.                               |
| `ValuesIn(container)`          | Yields values from a container, C-style array, or iterator range. |
| `Bool()`                      | Yields `{false, true}`. Useful for boolean flags.
| `Combine(g1, g2, ..., gN)`    | Produces Cartesian product tuples of all combinations from generators `g1` to `gN`.

### Examples
```cpp
// Fixture for string parameters
class FooTest : public ::testing::TestWithParam<const char*> {};

TEST_P(FooTest, RecognizesInput) {
  EXPECT_TRUE(foo.Process(GetParam()));
}

INSTANTIATE_TEST_SUITE_P(
    DifferentStrings, FooTest,
    ::testing::Values("hello", "world", "foo"));

// Using Combine() to test combinations of parameters
class AnimalTest : public ::testing::TestWithParam<std::tuple<const char*, int>> {};

TEST_P(AnimalTest, VariationTest) {
  auto [animal, count] = GetParam();
  EXPECT_GT(count, 0);
}

INSTANTIATE_TEST_SUITE_P(
    AnimalVariations, AnimalTest,
    ::testing::Combine(::testing::Values("cat", "dog"), ::testing::Values(1,2)));
```

### Customizing Test Names
The fourth argument to `INSTANTIATE_TEST_SUITE_P` can be a callable that generates readable and unique test names based on parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedInst,
    FooTest,
    ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This names tests like `NamedInst/FooTest.Value1` instead of numeric suffixes.

---

## 3. Type-Parameterized Testing

Type-parameterized tests run the same tests for multiple C++ types. This is crucial when you want to verify that your template classes or functions behave correctly across different data types.

### Two Flavors
* **Typed Tests:** You specify the candidate types at test suite definition.
* **Type-Parameterized Tests:** You define abstract test patterns and instantiate them separately, useful for reusable test suites spanning translation units.

### Basic Typed Test Workflow

1. **Define a template test fixture:**
```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
  T value_;
};
```

2. **Associate types to test:**
```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

3. **Write typed tests:**
```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam val = this->value_;
  EXPECT_TRUE(FunctionUnderTest(val));
}
```

### Type-Parameterized Tests for Reusable Suites

1. Declare a type-parameterized test suite:
```cpp
TYPED_TEST_SUITE_P(FooTest);
```

2. Define tests inside it:
```cpp
TYPED_TEST_P(FooTest, HasPropertyA) { ... }
TYPED_TEST_P(FooTest, DoesBlah) { ... }
```

3. Register test names:
```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, HasPropertyA, DoesBlah);
```

4. Instantiate with types:
```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

### Example:
```cpp
template <typename T>
class FooTest : public ::testing::Test {
};

TYPED_TEST_SUITE(FooTest, ::testing::Types<int, double>);

TYPED_TEST(FooTest, IsDefaultConstructible) {
  TypeParam v{};
  (void)v;  // Suppress unused warning
  SUCCEED();
}
```

---

## 4. Practical Tips and Best Practices

* Use value-parameterized tests when the variance is in input values.
* Use type-parameterized tests to verify correctness for a set of types.
* Combine generators with `Combine()` for multi-parameter tests.
* Prefer clear, descriptive test names using custom name generators.
* Carefully manage resource ownership when using pointer parameters.
* Avoid overlapping parameter sets that cause ambiguity in tests.
* Mark tests with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if instantiation is optional.

---

## 5. Troubleshooting & Common Issues

<AccordionGroup title="Troubleshooting Parameterized Tests">
<Accordion title="Tests Not Running or Recognized">
Ensure you have:
- Defined your parameterized fixture inheriting from `TestWithParam<T>`.
- Wrapped parameterized tests with `TEST_P()` macro.
- Instantiated tests with `INSTANTIATE_TEST_SUITE_P()`.

Remember `INSTANTIATE_TEST_SUITE_P` must be called after the test definitions.
</Accordion>
<Accordion title="Duplicate Test Names or Conflicts">
Use unique prefixes in `INSTANTIATE_TEST_SUITE_P` to distinguish instantiations.
Custom name generators help avoid clashes.
</Accordion>
<Accordion title="Parameter Type Conversion Problems">
Use `ConvertGenerator<T>()` when your parameter type is not implicitly convertible from the generated type.
</Accordion>
<Accordion title="Managing Ownership of Pointer Parameters">
When passing raw pointers as parameters, ensure lifetime management to prevent dangling pointers.
Consider using smart pointers or managing the data inside the test fixture.
</Accordion>
</AccordionGroup>

<Tip>
For detailed examples and advanced use cases, review `googletest/test/googletest-param-test-test.cc` and GoogleTest samples (#7 and #8) in the repository’s samples directory.
</Tip>

---

## 6. Next Steps & Related Content

* Explore **[Typed Tests](../advanced.md#typed-tests)** for deepening type-driven testing.
* Review **[INSTANTIATE_TEST_SUITE_P](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)** details and options.
* Consult the **[GoogleTest Primer](../primer.md)** for foundational knowledge.
* Combine with other test strategies like **mocking** for comprehensive testing workflows.
* Use **custom parameter name generators** to enhance test report readability.

---

## References

- [GoogleTest Parameterized Tests Primer](https://google.github.io/googletest/advanced.html#value-parameterized-tests)
- [TEST_P Macro Reference](../reference/testing.md#TEST_P)
- [INSTANTIATE_TEST_SUITE_P Function](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [Typed Tests Overview](../advanced.md#typed-tests)
- [GoogleTest Samples](../samples.md)

---