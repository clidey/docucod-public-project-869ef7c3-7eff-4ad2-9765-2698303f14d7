---
title: "Expressive Assertions and Custom Matchers"
description: "Learn to write clear, readable assertions using GoogleTest's rich assertion macros and matchers. Discover how to create custom matchers for domain-specific verifications."
---

# Expressive Assertions and Custom Matchers

Learn to write clear, readable assertions using GoogleTest's rich assertion macros and matchers. Discover how to create custom matchers for domain-specific verifications.

---

## Overview

This guide explores GoogleTest's powerful assertion macros and matcher interfaces that enable you to write expressive, maintainable, and informative test validations. It focuses on using built-in assertions effectively, leveraging the matcher library for readable tests, and extending GoogleTest by creating your own custom matchers tailored to your domain.

### Prerequisites

- You should have GoogleTest installed and set up in your C++ project.
- Basic familiarity with writing tests using GoogleTest, especially using macros like `EXPECT_EQ` and `ASSERT_TRUE`.
- Understanding of C++ streams and some template programming will help with custom matcher creation.

### Expected Outcome

- Master writing assertions that provide clear diagnostics.
- Know when to use different categories of assertions.
- Understand how to use GoogleMock matchers in assertions.
- Be equipped to write custom predicate and matcher classes to extend GoogleTest.

### Time Estimate

Approximately 20-40 minutes to read through and apply examples.

### Difficulty Level

Intermediate

---

## 1. Rich Assertion Macros in GoogleTest

GoogleTest provides a comprehensive set of assertion macros designed to validate various conditions with clear, contextual failure messages. They come as pairs:

- `EXPECT_...` macros generate **nonfatal failures** allowing the test to continue.
- `ASSERT_...` macros generate **fatal failures** aborting current function execution immediately.

Both macro types support streaming custom failure messages using the `<<` operator.

### 1.1 Basic Boolean Assertions

Use these to check simple conditions:

```cpp
EXPECT_TRUE(condition) << "Failure message if condition is false";
ASSERT_FALSE(condition);
```

Failure messages will print the actual and expected values, aiding debugging.

### 1.2 Binary Comparisons

Compare two values using standard operators:

```cpp
EXPECT_EQ(val1, val2);  // Check val1 == val2
ASSERT_NE(val1, val2);  // Check val1 != val2
EXPECT_LT(val1, val2);  // val1 < val2
EXPECT_LE(val1, val2);  // val1 <= val2
EXPECT_GT(val1, val2);  // val1 > val2
EXPECT_GE(val1, val2);  // val1 >= val2
```

> **Tip:** Use `EXPECT_STREQ` / `ASSERT_STREQ` to compare C strings by content instead of pointer equality.

### 1.3 String Assertions

Validate equality or inequality of C strings, ignoring or respecting case.

```cpp
EXPECT_STREQ("hello", str);
EXPECT_STRNE("goodbye", str);
EXPECT_STRCASEEQ("HELLO", str);
EXPECT_STRCASENE("WORLD", str);
```

### 1.4 Floating-Point Assertions

Due to precision errors in floating-point calculations, GoogleTest offers special macros:

```cpp
EXPECT_FLOAT_EQ(float1, float2);  // within ~4 ULPs
ASSERT_DOUBLE_EQ(double1, double2);
EXPECT_NEAR(val1, val2, abs_error);
```

Use these instead of `EXPECT_EQ` for floats or doubles for reliable results.

### 1.5 Exception Assertions

Verify exceptions for code blocks:

```cpp
EXPECT_THROW({ /* code */ }, ExceptionType);
EXPECT_ANY_THROW({ /* code */ });
EXPECT_NO_THROW({ /* code */ });
```

Use when your code is expected to throw or not throw exceptions, enhancing coverage.

### 1.6 Explicit Success and Failure

- `SUCCEED()` marks a documented success (does not override overall test pass/fail).
- `FAIL()` triggers a fatal failure immediately.
- `ADD_FAILURE()` generates a nonfatal failure.

Useful for documenting unreachable code or forcing failures.

---

## 2. Asserting with GoogleMock Matchers

GoogleTest supports **matchers** to create fluent, expressive assertions that read like English and produce clear, detailed diagnostics.

### 2.1 Using `EXPECT_THAT` and `ASSERT_THAT`

These macros allow verifying values against matchers:

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(value, StartsWith("Hello"));
ASSERT_THAT(number, AllOf(Gt(5), Lt(10)));
```

Matchers enable:

- Easy composition (`AllOf`, `AnyOf`, `Not`)
- Checking complex properties with readable syntax
- Producing user-friendly failure messages

### 2.2 Built-in Matchers

GoogleTest comes with a rich library of matchers including:

- Equality and relational matchers
- String matchers: `HasSubstr`, `MatchesRegex`, `StartsWith`, etc.
- Container matchers: `Contains`, `ElementsAre`, `SizeIs`, etc.

[Explore the full Matchers Reference](matchers.md) for details.

---

## 3. Predicate Assertions for Readable Custom Checks

Sometimes you need to verify complex conditions that standard assertions don't cover well.

GoogleTest offers **predicate assertions** that print argument values automatically when failures occur.

### 3.1 Using Existing Boolean Functions

If you have a function returning `bool` for a condition, you can use the `EXPECT_PRED*` macros:

```cpp
bool IsEven(int n) { return (n % 2) == 0; }

EXPECT_PRED1(IsEven, value);
EXPECT_PRED2(IsDivisibleBy, dividend, divisor);
```

This prints argument values on failure for easier debugging.

### 3.2 Using Functions Returning `AssertionResult`

For richer messages, write the predicate function to return `testing::AssertionResult`:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess() << n << " is even";
  }
  return testing::AssertionFailure() << n << " is odd";
}
```

Usage:

```cpp
EXPECT_TRUE(IsEven(3));  // Failure prints detailed message
```

This enhances *both* `EXPECT_TRUE` and `EXPECT_FALSE` failure diagnostics.

### 3.3 Predicate-Formatter Assertions

If you want **full control** over the failure message format, or arguments that cannot be streamed to `std::ostream`, use predicate-formatter macros:

```cpp
EXPECT_PRED_FORMAT2(MyAssertFunc, arg1, arg2);
```

Where `MyAssertFunc` has signature:

```cpp
testing::AssertionResult MyAssertFunc(
    const char* expr1, const char* expr2, int val1, int val2);
```

Example from the docs:

```cpp
AssertionResult AssertMutuallyPrime(const char* m_expr, const char* n_expr, int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();
  return testing::AssertionFailure()
      << m_expr << " and " << n_expr
      << " (" << m << " and " << n << ") are not mutually prime.";
}

EXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);
```

This makes your assertions more informative and specific.

---

## 4. Writing Custom Matchers

Matchers are core to writing expressive assertions, especially when you need to encapsulate domain-specific logic or improve test readability.

### 4.1 When To Write Custom Matchers

- You want to verify a property that isn't covered by built-in matchers.
- The condition involves multiple checks.
- You want to encapsulate complex verification for reusability.
- You need clearer error messages tailored to your domain.

### 4.2 Basic Syntax for Custom Matchers

Custom matchers implement the matcher interface used by GoogleMock, providing:

- A `bool MatchAndExplain` method (for complex or informative matching)
- An `DescribeTo` and `DescribeNegationTo` method to explain what the matcher checks

A simple example matcher verifying even numbers could look like:

```cpp
class IsEvenMatcher {
 public:
  bool MatchAndExplain(int n,
                       ::testing::MatchResultListener* listener) const {
    if ((n % 2) == 0) return true;
    if (listener->IsInterested()) {
      *listener << n << " is odd";
    }
    return false;
  }

  void DescribeTo(::std::ostream* os) const {
    *os << "is even";
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os << "is odd";
  }
};

inline ::testing::PolymorphicMatcher<IsEvenMatcher> IsEven() {
  return ::testing::MakePolymorphicMatcher(IsEvenMatcher());
}
```

Use it in tests:

```cpp
EXPECT_THAT(value, IsEven());
```

### 4.3 Writing Predicate Matchers Quickly

GoogleTest provides helper utilities to write matchers for simple predicates easily.
Example:

```cpp
MATCHER(IsEven, "is an even number") {
  return (arg % 2) == 0;
}
```

This creates a matcher named `IsEven` with a description. You can use it like:

```cpp
EXPECT_THAT(value, IsEven());
```

### 4.4 Advanced Matcher Customization

For detailed control, implement the matching interface with custom logic for matching, explanation, and error message generation.

Refer to the [GoogleMock Cookbook for Writing New Matchers](../gmock_cook_book.md#NewMatchers) for a complete tutorial.

---

## 5. Practical Examples

### 5.1 Basic Assertion Example

```cpp
TEST(MyTestSuite, SimpleAssertions) {
  int a = 5;
  int b = 5;
  EXPECT_EQ(a, b) << "a and b should be equal";
  EXPECT_TRUE(a < 10);
  EXPECT_STREQ("hello", "hello");
}
```

### 5.2 Using Matchers with `EXPECT_THAT`

```cpp
#include <gmock/gmock.h>

TEST(StringMatchersTest, VerifyStringMatches) {
  std::string message = "Hello World!";
  EXPECT_THAT(message, ::testing::StartsWith("Hello"));
  EXPECT_THAT(message, ::testing::ContainsRegex("W.rld"));
}
```

### 5.3 Writing a Custom Matcher

```cpp
MATCHER(IsOdd, "is an odd number") {
  return (arg % 2) != 0;
}

TEST(MyNumberTest, CheckOdd) {
  int num = 3;
  EXPECT_THAT(num, IsOdd());
}
```

### 5.4 Using Predicate-Formatter to Assert Complex Condition

```cpp
testing::AssertionResult HasCommonElement(const char* container1_expr,
                                           const char* container2_expr,
                                           const std::vector<int>& c1,
                                           const std::vector<int>& c2) {
  for (int v : c1) {
    if (std::find(c2.begin(), c2.end(), v) != c2.end()) {
      return testing::AssertionSuccess() << "found common element: " << v;
    }
  }
  return testing::AssertionFailure() << container1_expr << " and "
                                    << container2_expr << " have no common elements.";
}

TEST(CollectionTest, CommonElementCheck) {
  std::vector<int> vec1{1, 2, 3};
  std::vector<int> vec2{4, 5, 6};
  EXPECT_PRED_FORMAT2(HasCommonElement, vec1, vec2);  // Will fail
}
```

---

## 6. Troubleshooting & Tips

### Common Issues

- **Pointer comparisons with `EXPECT_EQ` instead of content:** Use `EXPECT_STREQ` for C strings.
- **Floating-point precision errors:** Use specialized floating-point assertions like `EXPECT_FLOAT_EQ` or `EXPECT_NEAR`.
- **Complex expressions with `EXPECT_TRUE`:** Prefer predicate assertions or matchers for better error messages.
- **Fatal assertions in non-void functions:** Remember fatal assertions can only be used in void functions.

### Best Practices

- Always prefer specialized assertion macros over `EXPECT_TRUE` for clearer diagnostics.
- Use `EXPECT_THAT` with matchers to express complex validations naturally.
- Use predicate assertion functions or predicate-formatter assertions to get detailed failure messages.
- Use `SCOPED_TRACE` to add context to nested assertions.
- Define custom matchers for reusable domain-specific checks.

---

## 7. Next Steps & Related Content

- Learn basic test writing in [Writing and Running Your First Test](/guides/getting-started/quickstart-testing).
- Explore [Assertion Reference](reference/assertions.md) for a full list of assertions.
- Delve deeper into matchers with [Matchers Reference](reference/matchers.md).
- Create and use custom matchers with the [GoogleMock Cookbook](gmock_cook_book.md#NewMatchers).
- Master the art of writing parameterized and typed tests in [Parameterized and Typed Tests](/guides/practical-testing-patterns/parameterized-testing).
- Explore advanced concepts in [Advanced GoogleTest Topics](docs/advanced.md).

---