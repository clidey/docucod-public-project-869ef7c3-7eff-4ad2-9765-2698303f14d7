---
title: "Parameterized and Typed Tests"
description: "Implement test cases that run across multiple values or types in a single suite. This guide demonstrates parameterized testing for comprehensive coverage with minimal duplication."
---

# Parameterized and Typed Tests

Implement test cases that run across multiple values or types in a single suite. This guide demonstrates parameterized testing for comprehensive coverage with minimal duplication.

---

## Workflow Overview

- **Task Description**: Learn how to write tests that run repeatedly with varied input parameters or type arguments, maximizing coverage without redundant code.
- **Prerequisites**:
  - Basic familiarity with GoogleTest syntax and test fixtures.
  - Installed and integrated GoogleTest in your C++ project.
  - Knowledge of C++ templates helpful for typed tests.
- **Expected Outcome**:
  - Ability to define value-parameterized tests using different data inputs.
  - Ability to write typed tests that execute the same test logic over multiple types.
  - Mastery of advanced parameter generators and test instantiation methods.
- **Time Estimate**: 15-30 minutes for hands-on practice with basic examples.
- **Difficulty Level**: Intermediate

---

## Parameterized (Value-Parameterized) Tests

Value-parameterized tests allow running the same test logic with multiple parameter values without duplicating test code.

### Key Points:

- You create a test fixture that inherits from `::testing::TestWithParam<T>`, where `T` is the parameter type.
- Define your tests with `TEST_P` macros, accessing the parameter with `GetParam()`.
- Instantiate tests using `INSTANTIATE_TEST_SUITE_P` and supply parameter generators.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Test Fixture with Parameter Type">
Create a parameterized test fixture class deriving from `::testing::TestWithParam<T>` specifying the parameter type `T`. You can still define setup and teardown methods as usual.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture members as needed.
};
```
</Step>
<Step title="Write Parameterized Test Cases using TEST_P">
Write one or more tests using the `TEST_P` macro. Within these tests, use `GetParam()` to access the current parameter value.

```cpp
TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}
```

Expected Result: Tests are compiled but not run yet; parameter values will be provided during instantiation.
</Step>
<Step title="Instantiate Tests with Parameter Generators">
Use `INSTANTIATE_TEST_SUITE_P` at global or namespace scope to define the set of parameters your tests will run with.

Example with explicit values:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, FooTest, ::testing::Values(1, 2, 3));
```

Example with a range:

```cpp
INSTANTIATE_TEST_SUITE_P(
    ZeroToFive, FooTest, ::testing::Range(0, 5));
```

Expected Result: For each parameter, GoogleTest creates instances of each `TEST_P` test and runs them.
</Step>
<Step title="Run and Verify Tests">
Run your test binary (`RUN_ALL_TESTS()`) and verify that all parameter instances execute. Use `--gtest_list_tests` to list instantiated tests and `--gtest_filter` to run specific ones.

Expected Result: Tests run multiple times with different parameters, reporting pass/fail separately.
</Step>
</Steps>

### Parameter Generators

GoogleTest provides several ready-to-use parameter generators:

| Generator         | Description |
|-------------------|-------------|
| `Range(start, end [, step])` | Generates values from `start` up to (but not including) `end` with optional `step`.
| `Values(...)`     | Generates the explicit values passed.
| `ValuesIn(container)` | Generates values from an array, container, or iterator range.
| `Bool()`          | Generates `{false, true}`.
| `Combine(g1, g2, ..., gN)` | Produces Cartesian product tuples of multiple generators.
| `ConvertGenerator<T>(g)` or `ConvertGenerator(g, func)` | Converts generated parameters to custom types.

### Customizing Test Names

You can provide a naming function or functor as an optional fourth argument to `INSTANTIATE_TEST_SUITE_P` to generate clear test parameter suffixes for reporting.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomName, FooTest, ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param" + std::to_string(info.param);
    });
```

### Best Practices and Tips

- Always provide meaningful parameter names when values are not trivial to print (e.g., strings).
- Group related parameters logically.
- Avoid overusing parameterized tests which can mask complexity.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to silence warnings for parameterized tests not instantiated (e.g., in libraries).

---

## Typed Tests

Typed tests enable repeating the **same test logic** for different C++ types. Useful for testing template classes and generic code.

### Key Points:

- Define a test fixture class template parameterized by a type `T`.
- Use `TYPED_TEST_SUITE` to associate a type list with your test fixture.
- Define tests with `TYPED_TEST` and use the special `TypeParam` to refer to the type.

### Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Class Template">
Create a test fixture class template derived from `::testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
  // Members, helper methods...
};
```
</Step>
<Step title="Declare a Type List and Associate it to the Test Suite">
Define a type alias using `::testing::Types<...>` to list the types for testing.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>
<Step title="Write Typed Test Cases with TYPED_TEST">
Use `TYPED_TEST` to write test cases. Refer to the current type with `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // silence unused warning
  EXPECT_TRUE(std::is_default_constructible<TypeParam>::value);
}
```
</Step>
<Step title="Run Tests">
Build and run your tests. GoogleTest will instantiate and run each test for every type in the type list.

Expected Result: You see separate test results for each type-driven test case.
</Step>
</Steps>

### Typed Test Naming

Tests for each type get generated as `TestSuiteName/<type name>.TestName`. You can customize names by specifying a type name generator class as the optional third argument to `TYPED_TEST_SUITE`.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, std::string>) return "string";
  }
};
TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices

- Use typed tests to reduce code duplication over multiple types.
- Limit the type list to only relevant types to keep test runtime manageable.
- Remember typed tests require knowing your types at compile time.

---

## Type-Parameterized Tests

Type-parameterized tests allow definition of test patterns **without an upfront type-list**. You register test cases and then instantiate them with type lists later, possibly multiple times.

### Usage Summary:

- Define a fixture template class.
- Use `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` macros to define test patterns.
- Register test names with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P` providing a type list.

### When to Use

When you want reusable test patterns for multiple type lists or allow others to instantiate tests with their own types.

---

## Examples

### Value-Parameterized Tests Example

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {}

TEST_P(IsEvenTest, CheckEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

This test suite runs `CheckEven` with the parameters 2, 4, 6, and 8.

### Combining Value Generators

```cpp
class AnimalTest : public ::testing::TestWithParam<std::tuple<std::string, int>> {};

TEST_P(AnimalTest, SoundAndAge) {
  auto [animal, age] = GetParam();
  EXPECT_FALSE(animal.empty());
  EXPECT_GE(age, 0);
}

INSTANTIATE_TEST_SUITE_P(
    AnimalVariants, AnimalTest,
    ::testing::Combine(::testing::Values("cat", "dog"),
                       ::testing::Range(0, 3)));
```

Generates tests for all combinations of cat/dog with age 0,1,2.

### Typed Tests Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
 public:
  T value_;
};

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, MyTypes);

TYPED_TEST(ContainerTest, IsInitiallyEmpty) {
  EXPECT_TRUE(this->value_.empty());
}
```

Runs the same empty-container test on std::vector<int> and std::list<int>.

---

## Troubleshooting & Tips

### Common Issues

- **Test not running?** Ensure `INSTANTIATE_TEST_SUITE_P` is called for each `TEST_P` suite.
- **Compiler errors with `GetParam()`?** Check that your fixture inherits from `TestWithParam<T>` with matching `T`.
- **Parameter is of user-defined type?** Provide a `PrintTo()` function or `AbslStringify()` overload to enable readable test output.
- **Custom types and `ConvertGenerator` issues?** Explicitly specify template arguments to guide conversion.
- **Tests not instantiated but defined?** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` macro to suppress warnings.

### Best Practices

- Use `Combine` to test multiple parameter combinations efficiently.
- Use `PrintToStringParamName` or custom naming functions for clearer test names.
- Keep parameter generators simple to avoid long test runs.

### Performance Considerations

- Parameterized tests may multiply the number of tests; balance coverage vs runtime.
- Use sharding or parallelization to speed up large suites.

---

## Next Steps & Related Content

- Explore [Writing and Running Your First Test](../getting-started/first-test-experience/writing-first-test.md) for basic test writing.
- See [Test Structure](../guides/getting-started/test-structure.md) for organizing tests.
- Deep dive into [Assertions Reference](../api-reference/testing-framework/assertions-reference.md) to improve test quality.
- Learn about [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for more on generic testing.
- Check [Parameterized and Typed Tests API Reference](../api-reference/testing-framework/parameterized-and-typed-tests.md) for detailed macro usage.

---

## Additional Resources

- **Official code examples:** Sample tests in the GoogleTest repository.
- **Parameter Generators:** `Range`, `Values`, `ValuesIn`, `Bool`, `Combine`, and `ConvertGenerator` functions.
- **Test Filtering:** Using `--gtest_filter` to run specific parameter instances.
- **Global and TestSuite Setup:** Use `SetUpTestSuite()` and `TearDownTestSuite()` for expensive shared setups in fixtures.

---

By mastering parameterized and typed tests in GoogleTest, you can significantly increase test coverage, reduce code duplication, and improve maintainability of your C++ tests.