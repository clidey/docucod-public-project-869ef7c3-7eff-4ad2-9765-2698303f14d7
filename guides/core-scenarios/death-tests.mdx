---
title: "Testing for Failures: Writing Death Tests"
description: "Demonstrates how to write tests that check for correct program termination, detecting and verifying crashes or aborts as expected. Covers safe usage, recommended design patterns, and platform-specific considerations."
---

# Testing for Failures: Writing Death Tests

## Overview

This guide demonstrates how to write and use death tests in GoogleTest to verify that your program correctly terminates (crashes or aborts) under specified conditions. It focuses exclusively on writing death tests: detecting program termination, validating the exit conditions, and matching error outputs.

You will learn safe usage patterns, how death tests work under the hood across platforms, best practices for usage, and platform-specific considerations to ensure successful and predictable test behavior.

---

## Prerequisites

- Familiarity with GoogleTest basic test writing (`TEST` and `TEST_F`).
- Basic knowledge of assertions (`EXPECT_*` and `ASSERT_*`).
- A C++ environment that supports GoogleTest, with death test support enabled (`GTEST_HAS_DEATH_TEST` must be true).
- Understanding of program exit codes and signals, especially on POSIX platforms.

---

## Expected Outcome

By following this guide, you will be able to write tests that:

- Assert that a statement causes your program to exit or abort as expected.
- Verify the program's exit code or termination signal.
- Check that the error message output to `stderr` matches a regular expression or matcher.
- Write robust death tests that handle multi-threading caveats and platform differences.

---

## Time Estimate

About 20 minutes to understand the concepts and implement your first death tests.

---

## Difficulty Level

Intermediate: Requires familiarity with GoogleTest basics and some understanding of process behavior.

---

## Writing Death Tests in GoogleTest

### What Are Death Tests?

Death tests verify that a tested statement causes your program to terminate unexpectedly (for example by `abort()`, `_Exit()`, or a fatal signal) and optionally output a specific message.

Unlike ordinary tests, death tests execute the test statement in a separate child process. This isolation allows your test binary to detect and verify the termination without crashing the entire test run.

Death tests are essential when testing crash scenarios, assertions, and other fatal error handling which should terminate your program.

### Basic Syntax

GoogleTest provides several macros specifically for death tests:

- `ASSERT_DEATH(statement, regex_or_matcher)`
- `EXPECT_DEATH(statement, regex_or_matcher)`

Also, more flexible versions allow checking specific exit codes or signals:

- `ASSERT_EXIT(statement, predicate, regex_or_matcher)`
- `EXPECT_EXIT(statement, predicate, regex_or_matcher)`

Here:

- `statement` is any valid C++ statement that your code should execute and cause termination.
- `regex_or_matcher` is a regex string or a matcher (e.g., `ContainsRegex`) matched against the child process's stderr output.
- `predicate` is a function or functor that accepts an `int` exit code or status and returns `bool`.

#### Example:

```cpp
TEST(MyDeathTest, DiesWithExpectedMessage) {
  ASSERT_DEATH(
      MyFunctionThatShouldAbort(),
      "Expected fatal error message pattern.");
}

TEST(MyDeathTest, ExitsWithCodeZeroAndMessage) {
  EXPECT_EXIT(
      exit(0),
      ::testing::ExitedWithCode(0),
      "Successful termination message");
}
```

### What Happens Internally

1. The `statement` (e.g., a function call that terminates) is run in a child process.
2. The parent process waits for the child process to terminate.
3. The exit status of the child is matched against the predicate (or non-zero exit code for `EXPECT_DEATH`).
4. The child's stderr output is matched against the provided regex or matcher.
5. If any condition fails, the death test fails.

If the statement does not cause termination, or returns illegally (e.g., runs a `return` statement inside the death test code), the death test fails, with detailed error messages.

---

## Step-by-Step Instructions to Write a Death Test

<Steps>
<Step title="Step 1: Choose the Death Test Macro">
Decide whether you want to use `ASSERT_DEATH` (fatal failure on mismatch) or `EXPECT_DEATH` (non-fatal failure). For simple verification of termination by non-zero exit, choose these macros.

For finer control over the expected exit code or signal, and to verify stderr output, use `ASSERT_EXIT` or `EXPECT_EXIT` with a predicate, e.g., `ExitedWithCode(42)` or `KilledBySignal(SIGSEGV)`.

<Check>Use `ASSERT_DEATH` for critical tests that should abort the current test on failure.</Check>
<Check>Use `EXPECT_DEATH` to continue running tests even if the death test fails.</Check>
</Step>

<Step title="Step 2: Write the Statement that Should Cause Termination">
Write the code snippet that you expect to cause the program to terminate. This can be a function call, a block of code enclosed in `{ ... }`, or any valid C++ statement.

Example:
```cpp
ASSERT_DEATH(CrashFunction(), "segmentation fault");
```

Or a block:
```cpp
EXPECT_DEATH({
  Initialize();
  CHECK(condition);
}, "Check failed");
```

<Tip>Keep the death test statement simple and focused on the fatal logic you want to verify.</Tip>
</Step>

<Step title="Step 3: Choose an Appropriate Regex or Matcher for stderr Output">
Specify the error message or pattern you expect to see printed to `stderr` during termination. This should be a regular expression string or a GoogleTest matcher.

The regex supports a subset of POSIX extended regex syntax on most platforms.

Example:
```cpp
ASSERT_DEATH(..., "Invalid argument")
```

If you want to use GoogleMock matchers for more expressive matching, e.g.,
```cpp
ASSERT_DEATH(..., ::testing::ContainsRegex("invalid.*argument"));
```

<Warning>Be sure the pattern matches your error output, or the test will fail even if termination occurs.</Warning>
</Step>

<Step title="Step 4: Compile and Run Your Tests">
Compile your test binary as usual. When executing, death tests will fork or spawn child processes to run the death test code.

If you use the default "fast" death test style (default flag), the child process runs the statement immediately after forking. For safer thread handling, you may want to set the flag programmatically:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

You can do this in `main()` before `RUN_ALL_TESTS()` or in individual tests.

<Note>On Windows, death tests always run in a thread-safe manner internally.</Note>
</Step>

<Step title="Step 5: Verify Test Output and Success">
Check the test output for success or failure. A successful death test:

- The child process terminates as expected.
- The exit code or signal satisfies the predicate.
- The `stderr` output matches the expected regex or matcher.

Failures may include:

- Code did not terminate.
- Exit code or signal mismatch.
- Error message mismatch.

<Check>Use the detailed failure messages printed by GoogleTest to adjust the regex or fix the tested code.</Check>
</Step>
</Steps>

---

## Practical Examples

```cpp
// Death test that expects any non-zero exit and match "fatal error" in output
TEST(FooDeathTest, DetectsFatalError) {
  ASSERT_DEATH(Foo().CrashOnInvalidInput(-1), "fatal error");
}

// Death test expecting exit code exactly 1
TEST(ExitCodeDeathTest, ExitsWithOne) {
  EXPECT_EXIT(
      exit(1),
      ::testing::ExitedWithCode(1),
      "process exiting with code 1");
}

// Using a GoogleTest matcher for custom message matching
TEST(MatcherDeathTest, MatchesCustomError) {
  EXPECT_DEATH(
      ThrowIfBad(),
      ::testing::ContainsRegex("bad input detected"));
}

// Death test using a compound statement/block
TEST(BlockDeathTest, CompoundStatement) {
  EXPECT_DEATH({
    Setup();
    RunFatalCheck();
  }, "Fatal check failed");
}
```

---

## Best Practices and Tips

- **Name your test suites** containing death tests with the suffix `DeathTest`. This allows GoogleTest to schedule them appropriately before other tests for improved reliability.

- **Use the "threadsafe" death test style if your tests run in a multi-threaded environment** to avoid undefined behavior caused by forking while multiple threads exist.

- **Avoid side effects inside the death test statement** since memory or state changes will be lost due to running in a separate process.

- **Do not perform heap deallocations inside death tests** unless you handle them outside because the parent process won't observe these.

- **Test the stderr output carefully** with regex or matchers that tolerate minor variations in line endings or extra messages.

- **Be cautious when using return statements or exceptions inside death test statements**; such control flow causes the death test to fail.

- **If your death tests involve mocks that expect specific exit codes, use `Mock::AllowLeak()`** to prevent false leak detection failures.

- **For writing debug-mode-only death tests, use `EXPECT_DEBUG_DEATH()` and `ASSERT_DEBUG_DEATH()`**. They execute the statement and only assert on death in debug builds.

- **Use `SCOPED_TRACE` to add contextual information to failure messages inside helper functions used in death tests.**

---

## Common Pitfalls and Troubleshooting

<AccordionGroup title="Common Death Test Issues">
<Accordion title="Death Test Not Dying">
If your death test fails because the tested statement does not cause termination:

- Verify the statement indeed terminates in the expected conditions.
- Confirm no unintended exceptions or early returns are in the statement.
- Review your environment if threads or library behavior interfere with termination.
</Accordion>
<Accordion title="Exit Code or Signal Mismatch">
If the exit condition does not match your predicate:

- Use GoogleTest provided predicates like `ExitedWithCode()` or `KilledBySignal()`.
- Double check the expected exit codes from your application.
- On POSIX, termination by signals will have an exit status representing them; verify carefully.
</Accordion>
<Accordion title="Regex or Matcher Fails to Match Output">
- Adjust your regex to cover possible variations.
- Use GoogleMock matchers for more flexible checks like `ContainsRegex`.
- Check if the error message is output to `stderr` (not `stdout`).
</Accordion>
<Accordion title="Multithreaded Test Crashes or Timeouts">
- Switch to `--gtest_death_test_style=threadsafe`.
- Make sure no global threads are running when death test runs, or isolate critical code.
</Accordion>
</AccordionGroup>

---

## Platform-Specific Considerations

- **POSIX systems:** Use `fork()` or `clone()` to create child processes. The "threadsafe" style re-execs the test binary with filters; "fast" runs the statement immediately after fork.

- **Windows:** Uses `CreateProcess()` APIs. Death tests are always threadsafe internally. Handles communication with child using pipes and events.

- **Fuchsia:** Uses specific syscall mechanisms and channels for safe death test implementation.

- GoogleTest internally manages safe termination signaling and communication between parent and child.

---

## Summary

Writing death tests in GoogleTest helps ensure your program terminates correctly under fatal error conditions. Use `ASSERT_DEATH` or `EXPECT_DEATH` macros with appropriate error pattern matching and exit code predicates. Employ best practices such as naming your tests with "DeathTest", selecting the proper death test style for thread safety, and carefully constructing your regex matchers. Debug and tweak based on clear output messages and leverage the provided predicates and matchers for flexible and reliable death testing.

---

## Next Steps

- Learn how to write your first test if new to GoogleTest: [Writing Your First Test](https://google.github.io/googletest/primer.html#getting-started)
- Explore [Assert Patterns and Best Practices](../guides/core-scenarios/assertion-best-practices.md) for effective assertion usage.
- Discover how to use [Matchers for Flexible Validation](../guides/core-scenarios/using-matchers.md).
- For more advanced death test design and strategies, see the [Advanced Topics](docs/advanced.md#death-tests).
- Troubleshoot test setup and execution issues with [Common Setup Issues](../getting-started/support/common-setup-issues.md).

---

## References

- [GoogleTest Primer](docs/primer.md)
- [Assertions Reference](docs/reference/assertions.md#death)
- [Death Tests and Threads](docs/advanced.md#death-tests-and-threads)
- [Death Assertions in GoogleTest](docs/reference/assertions.md#death)
- [Writing Your First Test](guides/essential-workflows/write-and-run-basic-tests.md)
- [GoogleMock for Mocks in Death Tests](guides/essential-workflows/using-mocks.md)

---

## Appendix: Death Test Macros Cheat Sheet

| Macro               | Description                                                | Use When                                     |
|---------------------|------------------------------------------------------------|----------------------------------------------|
| `ASSERT_DEATH`       | Assert statement causes death, fails test otherwise       | Ensure critical code crashes as expected      |
| `EXPECT_DEATH`       | Like ASSERT_DEATH, but test continues after failure        | When failure shouldn't abort other tests      |
| `ASSERT_EXIT`        | Assert statement causes exit satisfying predicate and regex | Check specific exit codes/signals plus output |
| `EXPECT_EXIT`        | Like ASSERT_EXIT, but non-fatal failure                     | Specified exit code or signal testing          |
| `EXPECT_DEBUG_DEATH` | Death test that only asserts in debug mode                  | Test debug-only assertions or failures        |
| `ASSERT_DEBUG_DEATH` | Fatal version of EXPECT_DEBUG_DEATH                         | Same as above with abort on failure            |

---
