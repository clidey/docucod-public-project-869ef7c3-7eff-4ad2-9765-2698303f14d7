---
title: "Assertion Patterns and Best Practices"
description: "Covers how to select the right assertions for different test cases, use fatal vs. non-fatal assertions, and create custom assertions. Includes guidance on structuring test code for maximum clarity and maintainability."
---

# Assertion Patterns and Best Practices

This guide focuses specifically on how to select the right assertions for different test cases, understand when to use fatal vs. non-fatal assertions, and create custom assertions. It also provides advice on structuring your test code for clarity and maintainability.

---

## 1. Workflow Overview

### What This Guide Helps You Accomplish

- Choose the appropriate assertion types in GoogleTest to match your test intent.
- Understand the behavioral difference between `EXPECT_` (non-fatal) and `ASSERT_` (fatal) assertions.
- Write clear, maintainable assertions that provide useful failure information.
- Create custom assertions and predicate assertions to handle complex verification needs.

### Prerequisites

- Basic familiarity with GoogleTest and its test structure (e.g., using `TEST()` and `TEST_F()`).
- Understanding of standard assertions like `EXPECT_EQ`, `ASSERT_TRUE`, etc.
- Basic C++ proficiency.

### Expected Outcome

By following this guide, you will be able to write tests that effectively:

- Fail fast or continue based on test needs.
- Offer readable, actionable failure messages.
- Use custom and predicate assertions to validate complex states.

### Time Estimate

Approximately 15-30 minutes for reviewing and applying the patterns.

### Difficulty Level

Intermediate â€“ assumes knowledge of GoogleTest basics and C++.

---

## 2. Choosing Between Fatal and Non-fatal Assertions

### Understanding the Difference

| Assertion Type | Effect on Test Function | Usage Recommendation |
| -------------- | ---------------------- | -------------------- |
| `EXPECT_*`     | Records failure but continues running the test function. | Use when test can proceed meaningfully after failure to discover multiple problems in one test run. |
| `ASSERT_*`     | Records failure and aborts the current test function immediately (returns). | Use when subsequent code depends on the success of this check, e.g., dereferencing pointers. |

### When to Use Each

- Use `ASSERT_*` when continuing makes your test meaningless or could cause undefined behavior.
- Use `EXPECT_*` to get multiple failure reports in a single test run, improving debugging insight.
- Mixing `ASSERT_*` and `EXPECT_*` in the same test is valid; use each where appropriate.

### Example

```cpp
TEST(FooTest, FatalVsNonFatal) {
  int* ptr = GetPointer();
  ASSERT_NE(ptr, nullptr) << "Pointer should not be null";
  // Safe to dereference after ASSERT_NE passes.
  EXPECT_EQ(*ptr, 42) << "Pointer points to unexpected value";

  // Continue checking other conditions even if above fails
  EXPECT_TRUE(ValidateOtherThings());
}
```

### Tips

- Avoid `ASSERT_*` in helper functions unless they always return `void` and you want to abort that function early.
- Remember that `ASSERT_*` cannot be used in constructors or destructors (they are not `void` functions).

---

## 3. Using Standard Assertions Appropriately

### Boolean Assertions

- Use `EXPECT_TRUE(condition)` or `ASSERT_TRUE(condition)` to verify conditions that return boolean.
- Use `EXPECT_FALSE` or `ASSERT_FALSE` analogously.

### Equality and Comparison Assertions

- Use typed assertions like `EXPECT_EQ(val1, val2)` for equality because they provide rich failure messages showing actual and expected values.
- For floating-point comparisons, prefer `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ` or `EXPECT_NEAR` to handle precision and rounding issues safely.

### String Assertions

- For C-style strings, use `EXPECT_STREQ` and `EXPECT_STRNE` to compare contents, not pointer addresses.
- Use `EXPECT_STRCASEEQ` and `EXPECT_STRCASENE` for case-insensitive string comparisons.

### Exception Assertions

- Use `EXPECT_THROW()`, `EXPECT_ANY_THROW()`, and `EXPECT_NO_THROW()` to verify expected exception behavior.

### Explicit Success and Failure Macros

- Use `SUCCEED()` to mark an explicit success point.
- Use `FAIL()` to generate an immediate fatal failure.
- Use `ADD_FAILURE()` to generate a non-fatal failure without aborting the test.

### Example: Floating-Point Comparison

```cpp
TEST(FloatingPointTest, CompareDoubles) {
  double a = ComputeValue();
  double expected = 3.14;
  EXPECT_NEAR(a, expected, 0.001) << "Values differ beyond tolerance";
}
```

---

## 4. Writing Custom Assertions

GoogleTest allows you to write complex assertions that provide clearer failure information and better encapsulate test logic.

### Approaches to Custom Assertions

#### a) Predicate Assertions

- Use `EXPECT_PRED1`, `EXPECT_PRED2`, ..., up to 5 parameters, for user-defined Boolean predicates.
- GoogleTest prints the values of parameters if the predicate returns `false`.

```cpp
bool IsEven(int n) { return (n % 2) == 0; }

TEST(CustomAssertionTest, PredicateUsage) {
  EXPECT_PRED1(IsEven, 4);  // Passes
  EXPECT_PRED1(IsEven, 5);  // Fails with message showing 5
}
```

#### b) Predicate-Formatter Assertions

- These allow you to write a more descriptive failure message when your predicate fails.
- You write a function returning `AssertionResult` instead of `bool`.

```cpp
::testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << n << " is odd";
}

TEST(CustomAssertionTest, PredicateFormatterUsage) {
  EXPECT_PRED_FORMAT1(IsEven, 5);  // Prints "5 is odd"
}
```

#### c) Custom Matcher Classes

- For highly reusable or polymorphic assertions, implement a custom matcher class by adhering to the matcher interface.
- Use `MATCHER` and `MATCHER_P` macros for concise matcher definitions.

```cpp
MATCHER(IsDivisibleBy7, "checks divisibility by 7") {
  return (arg % 7) == 0;
}

TEST(CustomMatcherTest, DivisibleBy7) {
  EXPECT_THAT(14, IsDivisibleBy7());
}
```

### Tips

- When writing predicates or matchers, ensure they have no side effects.
- Provide failure messages that help quickly identify the reason for failure.

---

## 5. Structuring Test Assertions for Clarity

Good test code is clear and maintainable. Here are patterns to help you write readable and well-structured assertions.

### Use Descriptive Failure Messages

- Always append messages explaining the reason for failure using the `<<` stream operator.

Example:

```cpp
EXPECT_EQ(actual, expected) << "Mismatch computing factorial(" << n << ")";
```

### Use Scoped Traces to Differentiate Failures in Helper Code

- Use `SCOPED_TRACE("Message")` inside helper functions to add context to failure messages.

### Verify Complex Data in Steps

- If verifying complex return values, save them into local variables and write separate assertions. This isolates errors and clarifies which check fails.

Example:

```cpp
std::vector<int> result = ComputeVector();
EXPECT_EQ(result.size(), 3);
EXPECT_EQ(result[0], 1);
EXPECT_EQ(result[1], 2);
EXPECT_EQ(result[2], 3);
```

### Avoid Overloading Tests with Multiple Assertions

- Each test should ideally verify one behavior to keep diagnosis simple.

### Use `EXPECT_NO_FATAL_FAILURE` to Wrap Calls That May Fail Internally

- To assert that a call does not produce fatal failures inside, use:

```cpp
EXPECT_NO_FATAL_FAILURE(FunctionThatMayAssert());
```

### Example Pattern

```cpp
TEST(ValidationTest, ValidateInput) {
  // Assert preconditions are met.
  ASSERT_TRUE(IsValidInput(input)) << "Input is invalid";

  // Continue with checks that can reveal multiple issues.
  EXPECT_EQ(ComputeValue(input), expected_value) << "Incorrect computation";
  EXPECT_TRUE(CheckOtherCondition(input));
}
```

---

## 6. Troubleshooting & Tips

### Common Pitfalls

- Calling functions that can fail after a non-fatal assertion fails may lead to crashes.
- Forgetting to append failure messages or using vague messages.
- Using `ASSERT_*` in non-void functions or constructors (not allowed).
- Overly strict expectations on mock calls that break with implementation refactoring.

### Best Practices

- Prefer `EXPECT_*` unless a failure should terminate the test function early.
- Use `SCOPED_TRACE` to add context to failures in shared helper logic.
- Use custom predicate or matcher assertions to improve failure clarity.
- Keep assertions focused and minimal to isolate causes effectively.

### Performance Considerations

- Avoid complex assertion expressions with side effects.
- Cache computed values for repeated assertions to avoid redundant computation.

### Alternative Assertion Styles

- Use `EXPECT_THAT` with matchers for expressive and powerful assertions.

---

## 7. Next Steps & Related Content

- Explore [Matchers Reference](reference/matchers.md) to learn about powerful matchers usable in assertions.
- Review [gMock for Dummies](gmock_for_dummies.md) and [gMock Cookbook](gmock_cook_book.md) to combine mocks and assertions effectively.
- Learn more about [Custom Matchers and Actions](reference/matchers-and-advanced-assertions/custom-assertions-and-matchers.md).
- Deepen grasp of Test Structure and Lifecycles in [`Test`](reference/testing.md#Test) and [`AssertionResult`](reference/testing.md#AssertionResult).

---

# Example: Combining Assertions for Complex Validation

```cpp
// Predicate function to check if sum of two integers is even.
bool SumIsEven(int a, int b) {
  return ((a + b) % 2) == 0;
}

// Test using predicate assertions.
TEST(SumValidationTest, SumIsEven) {
  EXPECT_PRED2(SumIsEven, 2, 4);  // Passes
  EXPECT_PRED2(SumIsEven, 1, 2);  // Fails and prints values
}

// Using predicate-formatter for better message.
testing::AssertionResult AssertSumIsEven(const char* a_expr, const char* b_expr, int a, int b) {
  int sum = a + b;
  if (sum % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << "Sum of " << a_expr << " and " << b_expr << " (" << a << "+" << b << ") is odd: " << sum;
}

TEST(SumValidationTest, SumIsEvenBetterMessage) {
  EXPECT_PRED_FORMAT2(AssertSumIsEven, 1, 3);  // Prints informative failure.
}
```

---