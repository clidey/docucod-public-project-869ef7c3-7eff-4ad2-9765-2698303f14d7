---
title: "Parameterized and Type-Parameterized Tests"
description: "Guides users through testing code with multiple input values or varying generic types using GoogleTest's parameterized and type-parameterized test support. Includes practical setup, generators, and real application examples."
---

# Parameterized and Type-Parameterized Tests in GoogleTest

GoogleTest empowers you to systematically test your code against multiple input values and generic type variations without duplicating code. This guide walks you through how to write and instantiate **parameterized tests** (value-driven) and **typed tests** (type-driven), two powerful mechanisms to enhance test coverage and maintainability.

---

## 1. Overview of Parameterized and Type-Parameterized Testing

### What Does This Guide Help You Accomplish?
This guide teaches you how to write tests that run the same logic with different input data or types, enabling more thorough and concise testing.

### Prerequisites
- Familiarity with basic GoogleTest concepts such as `TEST`, `TEST_F`, and test fixtures.
- A working GoogleTest setup with `gtest/gtest.h` included.
- Basic understanding of C++ templates for typed tests.

### Expected Outcome
- Ability to define tests that run multiple times with different parameters or types.
- Mastery in generators for input values for parameterized tests.
- Understanding how to instantiate and name these test patterns.

### Time Estimate
This guide takes roughly 15-30 minutes to read and experiment with.

### Difficulty Level
Intermediate (knowledge of C++ and GoogleTest basics assumed).

---

## 2. Writing Parameterized Tests

Parameterized tests let you run the **same test logic with various input values** without manually duplicating the test code for each input.

### Step 1: Define a Parameterized Test Fixture
Create a test fixture that inherits from `::testing::TestWithParam<T>`, where `T` is the type of your parameter(s).

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // You can define data members and helper methods here
};
```

### Step 2: Write Your Tests Using `TEST_P`
Within the parameterized test, access the current parameter with `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  int value = GetParam();
  EXPECT_TRUE(value % 2 == 0);  // For example, check if even.
}
```

You can define multiple `TEST_P` test cases per fixture.

### Step 3: Instantiate the Test Suite with Parameters
Use `INSTANTIATE_TEST_SUITE_P` to generate tests with different parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(ValidValues, FooTest, ::testing::Values(2, 4, 6));
```

This creates three test instances named:
- `ValidValues/FooTest.DoesBlah/0` with param 2
- `ValidValues/FooTest.DoesBlah/1` with param 4
- `ValidValues/FooTest.DoesBlah/2` with param 6

### Step 4: Use Parameter Generators for Complex Sequences
GoogleTest provides built-in generators to create parameter sequences:
- `Values(v1, v2, ..., vN)`: Enumerated values.
- `ValuesIn(container)`: Use values from arrays or containers.
- `Range(start, end, [step])`: Numeric ranges (excluding `end`).
- `Bool()`: Tests with `false` and `true`.
- `Combine(g1, g2, ...)`: Cartesian product of multiple generators.

**Example:**

```cpp
class FlagTest : public ::testing::TestWithParam<std::tuple<bool, int>> {};

TEST_P(FlagTest, WorksForAllCombinations) {
  bool flag;
  int number;
  std::tie(flag, number) = GetParam();
  // Test your code with flag and number
}

INSTANTIATE_TEST_SUITE_P(
    AllVariations, FlagTest,
    ::testing::Combine(::testing::Bool(), ::testing::Values(0, 1, 2)));
```

This creates 6 tests with all combinations of flag and number parameters.

<Tip>
Use `Combine()` to exhaustively test multiple parameters together, helping ensure your code behaves correctly for all input combinations.
</Tip>

### Step 5: Custom Parameter Names (Recommended)
By default, parameterized test names are numbered. To generate descriptive names, provide a **name generator function or functor**.

```cpp
std::string MyParamName(const ::testing::TestParamInfo<int>& info) {
  return "Val" + std::to_string(info.param);
}

INSTANTIATE_TEST_SUITE_P(WithNamedParams, FooTest, ::testing::Values(1, 2, 3), MyParamName);
```

This results in test names like `WithNamedParams/FooTest.DoesBlah/Val1`.

<Warning>
Test names generated by `name_generator` **must be unique, non-empty, and contain only alphanumeric characters (no underscores).** Underscores are reserved for special usages in GoogleTest and can cause naming collisions.
</Warning>

---

## 3. Writing Typed Tests

Typed tests let you run the **same test logic for different C++ types**. This is useful when you want to verify that different type implementations or templates satisfy expected behaviors.

### Step 1: Define a Fixture Template
Create a class template inheriting from `::testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  void SomeHelper() {
    // Helper code common for all types
  }
  T value_;
};
```

### Step 2: Define the Types to Test
Create a type list using `::testing::Types<...>`.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
```

### Step 3: Associate the Fixture with the Types Using `TYPED_TEST_SUITE`

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Step 4: Write Typed Tests Using `TYPED_TEST`

Within the tests, `TypeParam` refers to the current test type. Use it to declare variables or customize behavior.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Just check it compiles and default constructs
  EXPECT_TRUE(std::is_default_constructible<TypeParam>::value);
}

TYPED_TEST(MyTypedTest, CanBeCopied) {
  TypeParam val1{};
  TypeParam val2 = val1;
  (void)val2;
}
```

Multiple typed tests can be added easily.

### Step 5: Optional - Use Custom Type Names for Test Output
You can provide a custom name generator class with a static template `GetName(int)` method to control the names GoogleTest outputs.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    if (std::is_same<T, char>::value) return "Char";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

This improves test readability when running typed tests.

<Note>
Many compilers implement the elaborated type names automatically, but custom naming ensures consistent output and better readability.
</Note>

---

## 4. Writing Type-Parameterized Tests

Type-parameterized tests expand upon typed tests by allowing definition of generic test patterns without specifying types upfront. To use different type lists, instantiate the test pattern one or more times.

### Step 1: Define the Fixture Template

```cpp
template <typename T>
class PatternTest : public ::testing::Test {
 public:
  void Helper() {}
};
```

### Step 2: Declare the Test Suite to be Type-Parameterized

```cpp
TYPED_TEST_SUITE_P(PatternTest);
```

### Step 3: Define Tests Using `TYPED_TEST_P`

```cpp
TYPED_TEST_P(PatternTest, DoesThing) {
  TypeParam value{};
  this->Helper();
  // test body here
}

TYPED_TEST_P(PatternTest, HasProperty) {
  EXPECT_TRUE(true);
}
```

### Step 4: Register Tests

```cpp
REGISTER_TYPED_TEST_SUITE_P(PatternTest, DoesThing, HasProperty);
```

### Step 5: Instantiate the Pattern with Desired Types

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(Instantiation1, PatternTest, MyTypes);
```

You can instantiate the same pattern multiple times with different type lists.

---

## 5. Best Practices & Common Pitfalls

### Parameterized Tests
- Always prefer `::testing::TestWithParam<T>` or its aliases for the fixture.
- Use the built-in parameter generators to make your test parameter lists manageable and expressive.
- Define custom parameter naming functions to improve test traceability.
- Avoid underscores in test suite and test names to prevent naming conflicts.

### Typed and Type-Parameterized Tests
- Use when you want to verify multiple implementations of the same interface or multiple types satisfy the same concept.
- Keep your test code agnostic of the types but use `TypeParam` for type-specific logic.
- Use custom name generators for readable type names in test output.

### Common Pitfalls
- Forgetting to instantiate parameterized or typed test suites leads to no tests running or warnings.
- Using `TEST()` or `TEST_F()` macros with parameterized tests won't work as expected.
- Using parameter types not copyable or default constructible without necessary conversions causes compilation errors.

### Troubleshooting
- If tests aren't running, verify that you have properly instantiated them using `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`.
- Naming conflicts due to underscores can silently make tests not run or report incorrectly; follow the naming guidelines strictly.
- Make sure parameter types used in fixtures are suitable for GoogleTest's expectations (copyable, printable).

---

## 6. Real-World Example

### Parameterized Test Example

```cpp
class QueueTest : public ::testing::TestWithParam<int> {
 protected:
  void SetUp() override {
    q_.Enqueue(GetParam());
  }

  Queue<int> q_;
};

TEST_P(QueueTest, DequeueReturnsEnqueuedValue) {
  int* val = q_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, GetParam());
  delete val;
}

INSTANTIATE_TEST_SUITE_P(QueueTests, QueueTest, ::testing::Values(1, 2, 3, 4));
```

### Typed Test Example

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.IsEmpty());
}

TYPED_TEST(StackTest, PushAndPop) {
  this->stack_.Push(TypeParam{});
  EXPECT_FALSE(this->stack_.IsEmpty());
  TypeParam val = this->stack_.Pop();
  (void)val;  // Silence unused warning
}
```

---

## 7. Summary

By applying parameterized and (type-)parameterized tests, you enable significant test code reuse, comprehensive coverage across inputs and types, and better test organization. This makes your testing process more maintainable and scalable.

Explore further in the [GoogleTest Primer](primer.md), the [Advanced Guide](advanced.md#value-parameterized-tests), and the [Testing Reference](reference/testing.md) for detailed API insights.

---

## 8. Additional Resources

- **Primer on GoogleTest Topics:** [docs/primer.md](primer.md)
- **Advanced Guide on Parameterized Tests:** [docs/advanced.md#value-parameterized-tests](advanced.md#value-parameterized-tests)
- **Testing Reference (Macros and APIs):** [docs/reference/testing.md](reference/testing.md)
- **FAQ on Parameterized Tests:** [docs/faq.md#typed-vs-parameterized-tests](faq.md)
- **Sample test files with parameterized tests:** [googletest/test/googletest-param-test-test.cc](googletest/test/googletest-param-test-test.cc)

---