---
title: "Parameterizing Your Tests for Broader Coverage"
description: "Introduces value- and type-parameterized testing, demonstrating how to write tests that automatically run across multiple configurations or data types. Walks through macros and patterns for effective parametrization."
---

# Parameterizing Your Tests for Broader Coverage

Welcome to the guide on parameterizing your tests within GoogleTest. This documentation focuses specifically on how to write tests that automatically run across multiple configurations or data types using value- and type-parameterized testing techniques. By leveraging these patterns, your tests become far more flexible and maintainable, covering broader scenarios without duplication.

---

## 1. What Are Parameterized Tests?

Parameterized tests allow a single test logic to run multiple times with different inputs or types. They enable you to:

- Test a piece of code with varying data values.
- Validate the same behavior across multiple data types or configurations.
- Avoid redundant, copy-pasted test code.

GoogleTest supports three advanced parametrization methods:

- **Value-Parameterized Tests:** Vary test input values.
- **Typed Tests:** Run tests over a fixed list of types.
- **Type-Parameterized Tests:** Define abstract test logic that can be instantiated with different types later.

This guide will walk you sequentially through these kinds of parameterized tests, showing practical macros and patterns.

---

## 2. Prerequisites

Before parameterizing your tests, ensure that:

- You have basic GoogleTest tests written using `TEST()` or `TEST_F()` macros.
- Your environment is set up following the system requirements, compiler support, and build tooling documented in [System Requirements](https://github.com/google/googletest/blob/main/getting-started/setup-overview/system-requirements.mdx).
- You have included GoogleTest headers, namely `<gtest/gtest.h>`.

---

## 3. Value-Parameterized Tests: Testing With Different Inputs

Value-parameterized tests let you write a test once and run it multiple times with different input values automatically. This is ideal when testing functions or classes that behave differently depending on the input.

### 3.1 Workflow Overview

- **Define a Test Fixture:** Derive a class from `testing::TestWithParam<T>`, where `T` is your parameter type.
- **Write Parameterized Test:** Use `TEST_P()` macro with the fixture to write tests that use `GetParam()` to access the parameter.
- **Instantiate Tests:** Use `INSTANTIATE_TEST_SUITE_P()` to specify the parameter values or generators for your test.

### 3.2 Step-by-Step Instructions

<Steps>
<Step title="Define Your Parameterized Test Fixture">
Create a fixture class inherited from `testing::TestWithParam<T>`. This gives your test access to a parameter of type `T` via `GetParam()`.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Optionally add members here.
};
```

This fixture will be the basis for writing parameterized tests.
</Step>

<Step title="Write Parameterized Tests Using `TEST_P`">
Write your test using the `TEST_P()` macro, which binds to your fixture. Inside the test, access inputs with `GetParam()`.

```cpp
TEST_P(FooTest, HandlesVariousValues) {
  int value = GetParam();
  EXPECT_LT(value, 100);  // Example assertion
}
```
</Step>

<Step title="Instantiate the Test with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to specify the parameters. You provide a unique instantiation name, the test fixture, and a parameter generator such as `Values()`, `Range()`, or `ValuesIn()`.

```cpp
INSTANTIATE_TEST_SUITE_P(
    IntValues, FooTest, testing::Values(1, 10, 50, 99));
```

This will create tests named like `IntValues/FooTest.HandlesVariousValues/0`, etc., corresponding to each parameter.

You can also use:
- `Range(begin, end, step)` for sequences
- `ValuesIn(container)` for external containers
- `Bool()` for testing boolean flag combinations
- `Combine()` for Cartesian product of parameters
</Step>

<Step title="Run and Verify Your Parameterized Tests">
After compilation, when you invoke your test executable, GoogleTest will run the test body once for each parameter value.

Usage example with output names:
```shell
$ ./my_param_test  
[ RUN      ] IntValues/FooTest.HandlesVariousValues/0
[       OK ] IntValues/FooTest.HandlesVariousValues/0
[ RUN      ] IntValues/FooTest.HandlesVariousValues/1
[       OK ] IntValues/FooTest.HandlesVariousValues/1
...
```
</Step>
</Steps>

### 3.3 Practical Tips

- Ensure the parameter type `T` is copyable and printable. Define a streaming operator or `PrintTo()` function if needed.
- When using string parameters, customize test names with a name generator functor or lambda to ensure test names are valid and descriptive.
- Always give unique names to each `INSTANTIATE_TEST_SUITE_P` instantiation prefix.

### 3.4 Common Pitfalls

- Forgetting to instantiate a test suite leads to a link-time warning. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);` to suppress if doing abstract tests.
- Using a test fixture constructor or destructor for setup is discouraged when parameters depend on runtime values; use `SetUp()` instead.

---

## 4. Typed Tests: Running Tests Against Multiple Types

Typed tests run the same test logic against a list of types known at compile time. This is perfect when verifying that multiple implementations or variations of a class meet a specification.

### 4.1 Workflow Overview

- **Define a Typed Test Fixture Template:** Parameterized on type `T`, derive from `testing::Test`.
- **Declare the Type List:** Use `testing::Types<A, B, C>` to specify your types.
- **Declare the Typed Test Suite:** Use `TYPED_TEST_SUITE()` with your fixture and type list.
- **Write Typed Tests:** Use `TYPED_TEST()` to write the test logic once, using the special `TypeParam` alias.
- **Run Tests:** GoogleTest will instantiate and run tests for each type.

### 4.2 Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Template">
```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
  // shared static members or functions can be added here
};
```
</Step>

<Step title="Create the Type List and Test Suite">
Define a type list and associate it with your fixture.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>

<Step title="Write the Typed Tests">
Use `TYPED_TEST()` to write test logic once.

```cpp
TYPED_TEST(MyTypedTest, DefaultConstructible) {
  TypeParam value = this->value_;
  // Tests using value
  EXPECT_TRUE(value == value);
}
```
</Step>

<Step title="Run the Typed Tests">
Compile and run as usual. Each test is run once per type.

```
[ RUN      ] MyTypedTest/0.DefaultConstructible
[       OK ] MyTypedTest/0.DefaultConstructible
[ RUN      ] MyTypedTest/1.DefaultConstructible
[       OK ] MyTypedTest/1.DefaultConstructible
[ RUN      ] MyTypedTest/2.DefaultConstructible
[       OK ] MyTypedTest/2.DefaultConstructible
```
</Step>
</Steps>

### 4.3 Best Practices

- Use meaningful type names or supply a name generator when types have long or cryptic names.
- Make sure your fixture correctly handles each type, and use `this->` qualifier if needed to access fixture members.

---

## 5. Type-Parameterized Tests: Abstract Test Patterns for Flexible Types

Type-parameterized tests extend typed tests by allowing you to write abstract test logic without specifying types upfront. You can register tests, then instantiate them with different type lists or even single types anywhere.

### 5.1 Workflow Overview

- **Define a Fixture Template:** Similar to typed tests.
- **Declare Test Suite as Parameterized:** Use `TYPED_TEST_SUITE_P()`.
- **Define Tests:** Use `TYPED_TEST_P()` to define tests.
- **Register Tests:** Call `REGISTER_TYPED_TEST_SUITE_P()` with all test names.
- **Instantiate:** Use `INSTANTIATE_TYPED_TEST_SUITE_P(prefix, suite, types)` to run tests with specific types.

### 5.2 Step-by-Step Instructions

<Steps>
<Step title="Declare the Abstract Test Suite">

```cpp
template <typename T>
class MyAbstractTest : public testing::Test {
  // Fixture members
};

TYPED_TEST_SUITE_P(MyAbstractTest);
```

</Step>

<Step title="Define the Type-Parameterized Tests">

```cpp
TYPED_TEST_P(MyAbstractTest, DoesThing) {
  TypeParam val = TypeParam();
  EXPECT_NE(val, TypeParam());
}

TYPED_TEST_P(MyAbstractTest, HandlesInput) {
  ...
}
```

</Step>

<Step title="Register Tests">

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, DoesThing, HandlesInput);
```

</Step>

<Step title="Instantiate with Specific Types">

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyAbstractTest, MyTypes);
```

</Step>
</Steps>

### 5.3 Notes

- You can instantiate the same abstract tests multiple times with different types.
- The testsâ€™ names are prefixed by the instantiation name.

---

## 6. Naming Parameterized Tests

By default, GoogleTest appends the parameter index to the test names. For better clarity, especially when parameters are complex types, specify a **custom name generator**:

- Use the built-in `testing::PrintToStringParamName` for simple printable types.
- Write a lambda or functor taking `testing::TestParamInfo<T>` and returning a string.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedTests, FooTest, testing::Values(1, 2, 3),
  [](const testing::TestParamInfo<int>& info) {
    return "Value_" + std::to_string(info.param);
  });
```

Ensure your test names:

- Are unique
- Contain only ASCII alphanumeric characters or underscores
- Do not use underscores in the test suite or test names themselves (see FAQ for rationale)

---

## 7. Practical Example: Combining Parameter Generators

Test multiple combinations of parameters by using `Combine()` which generates Cartesian products of parameter sequences.

Example:

```cpp
using ::testing::Bool;
using ::testing::Combine;
using ::testing::Values;

class ComplexTest : public testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(ComplexTest, TestAllCombinations) {
  int i = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  EXPECT_GE(i, 0);
  if (flag) {
    EXPECT_LT(i, 10);
  }
}

INSTANTIATE_TEST_SUITE_P(
    AllCombinations, ComplexTest,
    Combine(Values(0, 1, 2), Bool()));
```

This will run 6 variations with all combinations of integer and boolean parameters.

---

## 8. Troubleshooting and Tips

- **Test names invalid or clashing:** Ensure generated test names conform to allowed characters. Avoid underscores in test and test suite names.
- **Parameter types not printable:** Overload streaming operator (`<<`), or define `PrintTo()` to help GoogleTest print test parameters.
- **Tests not instantiated:** If you forget to instantiate a parameterized test suite with `INSTANTIATE_TEST_SUITE_P`, tests wonâ€™t run. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` to suppress warnings if intentional.
- **Complex parameter types:** When parameters are tuples or structs, consider a custom parameter name generator for clear test output.
- **Lifetime management for pointers:** Raw pointer parameters require care managing lifetimes.

---

## 9. Next Steps & Related Documentation

- Explore further in the [Advanced Guide](docs/advanced.md#value-parameterized-tests) for detailed explanations and multiple examples.
- Use [GoogleTest Primer](docs/primer.md) to cement foundational test writing skills.
- Understand test suite lifecycle in [Test Structure & Lifecycle](docs/reference/testing.md#Test).
- Once comfortable, evaluate using typed and type-parameterized tests for verifying interfaces and generic code.
- Inspect source tests like [googletest-list-tests-unittest_.cc](https://github.com/google/googletest/blob/main/googletest/test/googletest-list-tests-unittest_.cc) for real-world examples.

---

## 10. Summary

Parameterized testing in GoogleTest empowers you to scale and generalize your tests elegantly. By defining test fixtures and using the appropriate macros (`TEST_P`, `TYPED_TEST`, `TYPED_TEST_P`) alongside instantiation macros, you cover many inputs and types effortlessly. This guide offers you the practical steps and options to do so effectively.

---

For the latest reference and more examples, see the [Testing Reference â€“ Parameterized & Typed Tests](https://github.com/google/googletest/blob/main/docs/reference/testing.md#parameterized--typed-tests).

For any questions about naming conventions and test design, consult the [GoogleTest FAQ](https://github.com/google/googletest/blob/main/docs/faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests).


---

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path":"googletest/include/gtest/gtest-param-test.h","range":"1-232"},{"path":"googletest/include/gtest/gtest-typed-test.h","range":"1-220"},{"path":"docs/advanced.md","range":"221-537"}]} />