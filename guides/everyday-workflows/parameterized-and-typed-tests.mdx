---
title: "Value- and Type-Parameterized Tests"
description: "Learn how to create tests that run across multiple data sets and types, making your suite more versatile and comprehensive. See practical examples for both parameterized and typed test cases."
---

# Value- and Type-Parameterized Tests

GoogleTest enables you to write flexible, clean tests that run across multiple data inputs and types without duplicating code. This guide shows you how to create **value-parameterized tests** that run the same logic on different data sets, and **typed tests** that run the same test logic on different data types. These features maximize your test coverage while minimizing maintenance overhead.

---

## 1. Understanding Parameterized Tests and Typed Tests

### Value-Parameterized Tests

**What they do:** Run the same test logic repeatedly with different input values.

**Why use them:** Instead of writing multiple tests for every input scenario, you define one test and supply a set of parameters which GoogleTest will run through one by one. This reduces duplication and clarifies intent.

### Typed Tests

**What they do:** Run the same test logic for a list of types.

**Why use them:** When you want to verify your code behaves correctly across multiple types (e.g., different containers, numeric types), typed tests allow reusable test logic parameterized by type rather than data.

---

## 2. Value-Parameterized Tests: Creating Tests for Multiple Data Sets

### Workflow Overview

- **Goal:** Test the same behavior with various input values
- **Prerequisites:** Basic knowledge of GoogleTest TEST_F and test fixtures
- **Outcome:** One test defined; runs multiple times with different parameters
- **Time:** ~5-10 minutes to set up
- **Difficulty:** Intermediate

### Step-by-Step Instructions

<Steps>
<Step title="Define a Value-Parameterized Test Fixture">
Create a fixture class inheriting from `::testing::TestWithParam<T>`, where `T` is the parameter type (any copyable type).

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture code here
};
```

This creates a test fixture that can access a parameter of type `int`.
</Step>
<Step title="Write Test Code Using the Parameter">
Use the `TEST_P` macro instead of `TEST_F` to define tests using this fixture.
Inside the test, access the current parameter using `GetParam()`.

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(FunctionUnderTest(param));
}
```

The test logic will run once for each parameter value.
</Step>
<Step title="Instantiate the Test Suite with Parameters">
Use `INSTANTIATE_TEST_SUITE_P` to supply the set of parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyParams, FooTest, ::testing::Values(1, 2, 3, 42));
```

This will run the `HandlesVariousInputs` test 4 times, once for each value.
</Step>
<Step title="Run and Verify">
Build and run your tests as usual. GoogleTest will display each parameter run separately with indices.
For example:

```
MyParams/FooTest.HandlesVariousInputs/0
MyParams/FooTest.HandlesVariousInputs/1
... etc.
```
</Step>
</Steps>

### Parameter Generators

Use different parameter generators from the `::testing` namespace to create parameter sets:

- `Values(v1, v2, ..., vN)` — enumerates specific values
- `ValuesIn(container_or_begin_end)` — uses values from a container or iterator range
- `Range(start, end [, step])` — generates values in a numeric range
- `Bool()` — generates `{false, true}` for Boolean tests
- `Combine()` — combines multiple generators to produce tuples of values

### Example: Testing a Function with Multiple Inputs

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

This test runs 4 times with given even numbers.

### Tips and Best Practices

- Test parameter types must be copyable.
- Use `GetParam()` cautiously if your parameter needs ownership or complex setup.
- Use descriptive instantiation names to help identify parameter sets in output.
- When your parameters form tuples, use `std::tuple` and related utilities.

---

## 3. Typed Tests: Creating Tests That Run on Multiple Types

### Workflow Overview

- **Goal:** Repeat same tests for multiple types
- **Prerequisites:** Compile-time knowledge of types to test
- **Outcome:** One test suite tested over multiple type instantiations
- **Time:** ~10 minutes
- **Difficulty:** Intermediate to Advanced

### Step-by-Step Instructions

<Steps>
<Step title="Define a Fixture Template Parameterized by Type">
Write your test fixture as a class template parameterized by type `T` and inheriting from `::testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
};
```
</Step>
<Step title="Define the List of Types to Test">
Use `::testing::Types<...>` to list the types you want to test.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
```
</Step>
<Step title="Associate the Type List with the Test Suite">
Bind the type list to your test suite with `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

If you want custom names for each type, provide a name generator class as a third parameter.
</Step>
<Step title="Write Typed Tests Using `TYPED_TEST`">
Define your typed tests with the `TYPED_TEST` macro. Inside them, refer to the type parameter as `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, ValueIsDefaultConstructed) {
  TypeParam value = this->value_;
  EXPECT_EQ(value, TypeParam());  // Default value
}
```

Multiple typed tests can be defined within the suite.
</Step>
<Step title="Run and Verify Typed Tests">
Build and run the tests. GoogleTest will run each typed test once per type.

Test suite names will include types:

```
MyTypedTest/0.ValueIsDefaultConstructed  [int]
MyTypedTest/1.ValueIsDefaultConstructed  [double]
MyTypedTest/2.ValueIsDefaultConstructed  [char]
```
</Step>
</Steps>

### Example: Typed Tests for a Numeric Class

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T zero_ = T();
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultValueIsZero) {
  EXPECT_EQ(this->zero_, TypeParam());
}
```

### Custom Type Names

Define a class with a static template method `GetName(int)` to provide friendly type suffixes:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>()) return "int";
    if (std::is_same<T, float>()) return "float";
    return "unknown";
  }
};

TYPED_TEST_SUITE(NumericTest, NumericTypes, MyTypeNames);
```

This will make test suite names use your custom names instead of generic indices.

---

## 4. Type-Parameterized Tests: Flexible Abstract Test Patterns

Type-parameterized tests are similar to typed tests but allow you to define a test pattern without specifying the exact types upfront. They can be instantiated multiple times with different type lists.

### Workflow Overview

- Define your typed test fixture template
- Annotate with `TYPED_TEST_SUITE_P` and define test patterns using `TYPED_TEST_P`
- Register test cases with `REGISTER_TYPED_TEST_SUITE_P`
- Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P` passing different type lists

### When to Use

This is useful for library developers or interface designers that want to create reusable test patterns to validate many implementations.

### Example

```cpp
template<typename T>
class FooTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, TestA) { /* ... */ }
TYPED_TEST_P(FooTest, TestB) { /* ... */ }

REGISTER_TYPED_TEST_SUITE_P(FooTest, TestA, TestB);

using Types1 = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation1, FooTest, Types1);

using Types2 = ::testing::Types<char, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation2, FooTest, Types2);
```

Each instantiation runs the registered tests for that type list.

---

## 5. Troubleshooting & Tips

<Tip>
If you see tests not running or errors about missing instantiations, verify you have correctly registered and instantiated your parameterized or typed test suites.
</Tip>

<Tip>
Name your test suites and instantiations clearly to easily identify failures corresponding to specific parameter sets or types.
</Tip>

<Warning>
Typedef the type list with `using` or `typedef`. Directly passing a raw list to the macros will cause compilation errors.
</Warning>

<Tip>
Use `::testing::PrintToStringParamName` or custom name generators for readable test names.
</Tip>

<Tip>
When parameters are complex tuples or custom objects, consider `ConvertGenerator` to transform parameters into your desired types smoothly.
</Tip>

---

## 6. Next Steps & Related Content

- Learn about [Writing Your First Test](../getting-started/first-steps-usage/writing-your-first-test) to establish a test foundation.
- Explore [Assertions and Matchers](../guides/everyday-workflows/assertions-matchers) to validate test output precisely.
- For advanced mocking scenarios complementing parameterized tests, see [Mocking Basics](../guides/mocking-and-advanced-techniques/mocking-basics).
- Consult [System Architecture Overview](../overview/architecture-core-concepts/system-architecture-overview) for a conceptual understanding of GoogleTest workflow.

---

## 7. References

- [GoogleTest Primer](../docs/primer.md)
- [Test Parameterization APIs](../api-reference/core-testing-apis/test-parameterization.md)
- [gtest/gtest-param-test.h source](https://github.com/google/googletest/blob/main/googletest/include/gtest/gtest-param-test.h)


---

## Summary
This guide empowers you to write flexible tests that run over multiple values or types, making your test suites more robust and maintainable. You'll master writing value-parameterized tests with `TEST_P` and typed tests with `TYPED_TEST`, including how to instantiate them and control naming.

Create fewer but more powerful tests that expand coverage and reduce duplication. GoogleTest's parameterized testing features are essential tools for any modern C++ testing strategy.

---

---
