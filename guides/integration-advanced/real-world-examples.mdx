---
title: "Real-World Testing Examples and Recipes"
description: "Features sample projects and code snippets demonstrating how to apply GoogleTest and GoogleMock in authentic scenarios, including integration testing, legacy code, and CI pipelines. Guides users to adapt and extend examples for their own needs."
---

# Real-World Testing Examples and Recipes

GoogleTest and GoogleMock offer powerful tools to write tests that are robust, efficient, and maintainable. This guide presents practical sample projects and well-crafted code snippets to demonstrate how you can apply GoogleTest and GoogleMock in authentic scenarios. These real-world examples will help you not only understand the framework’s capabilities but also adapt these patterns and recipes for your own projects.

---

## What This Guide Covers

This page focuses specifically on showcasing how GoogleTest and GoogleMock are used in real-life contexts, such as:

- Integration testing complex modules
- Handling legacy code with minimal disruption
- Setting up tests within Continuous Integration (CI) pipelines

It will guide you through adapting and extending these examples to fit your unique needs, helping you accelerate your test development and improve test quality.

---

## Prerequisites

Before you dive into these examples, ensure you have:

- GoogleTest and GoogleMock properly installed and configured in your build environment.
- Familiarity with basic test writing concepts covered in the [GoogleTest Primer](primer.md).
- Understanding of mocking basics via the [gMock for Dummies](gmock_for_dummies.md) guide.
- A working knowledge of C++ and your project's testable codebase.

---

## How to Use This Guide

The examples here are designed to demonstrate realistic usage patterns, reflecting common challenges faced when introducing testing to existing or complex codebases:

- **Integration Testing**: Learn how to write tests that cover interactions between components using both GoogleTest and GoogleMock.
- **Legacy Code Testing**: Discover strategies to incrementally add tests to legacy systems with minimal refactoring.
- **CI Pipeline Integration**: See approaches to embedding your test suites in automated build and testing workflows.

Use these recipes as a starting point and customize them according to your project’s architecture and requirements.

---

## Example 1: Integration Test Combining GoogleTest and GoogleMock

Integration tests validate how different modules collaborate. Here's a practical approach combining both frameworks:

### Step 1: Define Interfaces to Mock Dependencies

```cpp
class IDataSource {
 public:
  virtual ~IDataSource() = default;
  virtual int FetchData(int id) = 0;
};

class IDataProcessor {
 public:
  virtual ~IDataProcessor() = default;
  virtual bool Process(int value) = 0;
};
```

### Step 2: Create Mock Classes Using GoogleMock

```cpp
#include <gmock/gmock.h>

class MockDataSource : public IDataSource {
 public:
  MOCK_METHOD(int, FetchData, (int id), (override));
};

class MockDataProcessor : public IDataProcessor {
 public:
  MOCK_METHOD(bool, Process, (int value), (override));
};
```

### Step 3: Write the Integration Test

```cpp
#include <gtest/gtest.h>

// Code under test
class IntegrationSystem {
 public:
  IntegrationSystem(IDataSource* ds, IDataProcessor* dp)
      : data_source_(ds), data_processor_(dp) {}

  bool Run(int id) {
    int value = data_source_->FetchData(id);
    if (value < 0) return false;
    return data_processor_->Process(value);
  }

 private:
  IDataSource* data_source_;
  IDataProcessor* data_processor_;
};

// Integration test using mocks
TEST(IntegrationSystemTest, HandlesValidData) {
  MockDataSource mock_ds;
  MockDataProcessor mock_dp;

  // Setup expectations
  EXPECT_CALL(mock_ds, FetchData(42)).WillOnce(::testing::Return(100));
  EXPECT_CALL(mock_dp, Process(100)).WillOnce(::testing::Return(true));

  IntegrationSystem system(&mock_ds, &mock_dp);

  EXPECT_TRUE(system.Run(42));
}
```

#### Outcome:
- The test independently verifies the collaboration between the data source and processor.
- Mocking isolates dependencies, making the test focused and deterministic.

---

## Example 2: Testing Legacy Code Without Major Refactoring

Legacy code often lacks testability due to tight coupling and lack of interface abstractions. This example shows how to wrap legacy code to enable testing with GoogleTest.

### Step 1: Write an Adapter for Legacy Class

```cpp
// Legacy class
class LegacyCalculator {
 public:
  int Add(int a, int b) { return a + b; }
  int Multiply(int a, int b) { return a * b; }
};

// Adapter interface
class ICalculator {
 public:
  virtual ~ICalculator() = default;
  virtual int Add(int a, int b) = 0;
  virtual int Multiply(int a, int b) = 0;
};

// Adapter implementation
class CalculatorAdapter : public ICalculator {
 public:
  explicit CalculatorAdapter(LegacyCalculator* legacy) : legacy_(legacy) {}

  int Add(int a, int b) override {
    return legacy_->Add(a, b);
  }

  int Multiply(int a, int b) override {
    return legacy_->Multiply(a, b);
  }

 private:
  LegacyCalculator* legacy_;
};
```

### Step 2: Write Tests Using the Adapter

```cpp
#include <gtest/gtest.h>

TEST(CalculatorAdapterTest, AddWorks) {
  LegacyCalculator legacy;
  CalculatorAdapter adapter(&legacy);

  EXPECT_EQ(adapter.Add(2, 3), 5);
  EXPECT_EQ(adapter.Add(-1, 1), 0);
}

TEST(CalculatorAdapterTest, MultiplyWorks) {
  LegacyCalculator legacy;
  CalculatorAdapter adapter(&legacy);

  EXPECT_EQ(adapter.Multiply(4, 5), 20);
  EXPECT_EQ(adapter.Multiply(0, 10), 0);
}
```

### Benefits:

- No need to change legacy code directly.
- Enables progressive test coverage of legacy logic.
- Facilitates more testable design moving forward.

---

## Example 3: Setting Up Tests in a Continuous Integration Pipeline

Automating test execution is vital for rapid feedback and code quality. GoogleTest is well-suited for CI environments thanks to its command-line flags and output formatting.

### Step 1: Ensure Tests Are Automated and Return Correct Exit Code

GoogleTest’s `RUN_ALL_TESTS()` returns 0 on success and 1 on failure, making it CI-friendly.

### Step 2: Run Tests with XML or JSON Output for Reporting

Example command line:

```shell
./your_tests --gtest_output=xml:report.xml
```

or

```shell
./your_tests --gtest_output=json:report.json
```

### Step 3: Integrate with CI Jobs

- Configure your CI job to execute the test binary with the above flags.
- Collect the XML/JSON reports for test result dashboards.
- Use `--gtest_filter` to selectively run tests if needed.

### Step 4: Use Test Sharding and Parallelism for Speed

Follow best practices to speed up large test suites:

- Use environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` to split tests across multiple CI machines.
- Enable parallel test execution with tools like `gtest-parallel`.

### Step 5: Handle Flaky Tests

Use `--gtest_repeat` to repeat tests and catch intermittent failures.

---

## Practical Tips for Customizing and Extending These Examples

- Use **test fixtures** (`TEST_F`) to share setup and teardown logic.
- Apply **parameterized tests** (`TEST_P`) to run your tests across varied inputs.
- Use **mocks** to isolate dependencies and verify interactions.
- Start with **simple assertions** before using complex matchers or custom matchers.
- When mocking behavior, favor `ON_CALL` to define defaults and selectively use `EXPECT_CALL` to verify interactions.
- Use **scoped traces** (`SCOPED_TRACE`) within complex tests to narrow down failure contexts.
- For legacy code, isolate and adapt before attempting extensive refactoring.
- Regularly run tests locally with `--gtest_verbose=info` in debug phases to gain insight into mock expectations and call matches.

---

## Common Pitfalls and Troubleshooting

- **Unmet Mock Expectations:** Ensure `EXPECT_CALL` statements are set *before* the code exercising the mock executes.
- **Failing to Link to gtest_main:** Without linking the ready-made `gtest_main` library, you need to provide a main function that calls `RUN_ALL_TESTS()`.
- **Test Order Dependency:** Tests should be independent; sharing state can cause flaky tests.
- **Death Tests in CI:** Run death tests sequentially or in isolated environments to avoid threading and subprocess conflicts.
- **Incorrect Output Parsing:** Verify output format flags are correctly specified for test reporters.

See [Common Setup Issues](getting-started/support/common-setup-issues.mdx) and [Getting Help & Further Resources](getting-started/support/finding-help.mdx) for deeper troubleshooting guidance.

---

## Where to Go Next

- Visit the [Writing and Running Your First Test](guides/essential-workflows/write-and-run-basic-tests) guide to solidify your foundational skills.
- Explore the [Getting Started with GoogleMock](guides/essential-workflows/using-mocks) guide to master creating and using mocks.
- Deepen your understanding of [Parameterized Tests](guides/core-scenarios/parameterized-tests) for broader coverage.
- Learn how to integrate tests effectively within build systems via [Integrating GoogleTest with CMake and Build Systems](guides/integration-advanced/cmake-and-build-system-integration).
- For advanced mock usage, consult the [gMock Cookbook](docs/gmock_cook_book.md).

---

This page is part of the Guides section, complementing core concepts articulated in the [GoogleTest Primer](primer.md) and API references.


<Check>
Remember: These examples are focused on practical scenarios to help you apply GoogleTest and GoogleMock effectively. Adapt them progressively to your codebase rather than diving deep without context.
</Check>
