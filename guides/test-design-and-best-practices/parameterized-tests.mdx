---
title: "Mastering Parameterized and Typed Tests"
description: "A systematic guide to leveraging value- and type-parameterized tests with GoogleTest, including when to use them and how to maintain clarity in your test code."
---

# Mastering Parameterized and Typed Tests

## Introduction

GoogleTest provides powerful mechanisms to write efficient and maintainable tests for varying inputs and types: *value-parameterized tests* and *typed tests*. These features allow you to write test logic once and run it with multiple sets of parameters or over various types, dramatically increasing coverage and reducing duplicated code.

This guide systematically walks you through leveraging these features to optimize your C++ testing workflow with GoogleTest. You will learn how to write, instantiate, and name parameterized and typed tests, when to use each, and how to maintain clarity and effectiveness in your test suites.

---

## What Are Parameterized and Typed Tests?

### Value-Parameterized Tests

Value-parameterized tests let you test the same logic across different input values. Instead of writing multiple tests manually, you write a single test template and instantiate it with a series of parameters. Each test run receives a different parameter value.

These are ideal when your code behavior depends on runtime values or multiple configurations, such as:

- Different function inputs
- Various command-line flags
- Testing multiple implementations of an interface with different construction parameters

### Typed Tests

Typed tests focus on checking your code against a set of types rather than values. You write test logic once as a template class, then specify a list of types for which that logic will be executed. This is particularly useful to verify:

- Multiple implementations of the same interface or concept
- Template or generic code correctness over multiple data types

### Type-Parameterized Tests

A more flexible variant of typed tests, type-parameterized tests allow you to define generic test patterns without binding to concrete types upfront, enabling reusability across translation units and projects.

---

## When to Use Value-Parameterized vs. Typed Tests

| Scenario                                        | Recommended Test Type          |
|------------------------------------------------|-------------------------------|
| Behavior varies with different input values    | Value-Parameterized Tests      |
| Behavior depends on multiple C++ types         | Typed Tests                   |
| Need to reuse type-parameterized tests as a library | Type-Parameterized Tests    |

---

## Setup and Prerequisites

Before you start:

- Include GoogleTest headers: `#include <gtest/gtest.h>`.
- Understand basics of regular `TEST`, `TEST_F` tests.
- Have C++17 support enabled in your compiler.

---

## Writing Value-Parameterized Tests

### 1. Define a Parameterized Test Fixture Class

Create a class derived from `testing::TestWithParam<T>` where `T` is the parameter type.

```cpp
class MyValueParamTest : public testing::TestWithParam<int> {
  // Optional setup and members
};
```

### 2. Write Parameterized Test Cases Using `TEST_P`

Within the test body, use `GetParam()` to access the current test's parameter value.

```cpp
TEST_P(MyValueParamTest, HandlesPositive) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}
```

### 3. Instantiate the Test Suite

Use `INSTANTIATE_TEST_SUITE_P` to specify parameter values to generate test instances.

```cpp
INSTANTIATE_TEST_SUITE_P(PositiveInts, MyValueParamTest, testing::Values(1, 2, 3));
```

GoogleTest will create separate test cases `PositiveInts/MyValueParamTest.HandlesPositive/0`, etc., each running with a different parameter.

### 4. Optional: Custom Test Names

You can provide a function or lambda to generate readable custom suffixes for each parameter instance.

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedPositiveInts, MyValueParamTest, testing::Values(1, 2, 3),
  [](const testing::TestParamInfo<int>& info) {
    return "Param" + std::to_string(info.param);
  });
```

### 5. Best Practices

- Choose parameter types thoughtfully, such as enums or structs, for readability.
- Use `testing::Combine` to test across multiple parameter combinations.
- Avoid sharing mutable state across parameterized tests unless carefully managed.

### 6. Common Pitfalls

- Forgetting to instantiate the test suite leads to no tests being run.
- Using non-copyable parameter types will cause compilation errors.
- Using underscore characters in test or suite names causes problems; avoid them.

---

## Writing Typed Tests

### 1. Define a Fixture Template

Template your fixture by a type and derive from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T value_ = T();
};
```

### 2. Specify the Types to Test

Define a type list with `::testing::Types<...>`.

```cpp
using MyTypes = testing::Types<int, double, std::string>;
```

### 3. Register the Type List

Bind the type list to your test suite with `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### 4. Write Typed Tests with `TYPED_TEST`

Use the special identifier `TypeParam` inside test bodies to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->value_;
  (void)val;  // Avoid unused warning
  SUCCEED();
}
```

### 5. Best Practices

- Name your typed tests clearly, indicating what trait or behavior they test.
- Test both normal and edge cases for each type.
- Combine typed tests with static assertions to constrain or verify types.

---

## Using Type-Parameterized Tests

This feature allows reusable type-parameterized test patterns defined once and instantiated multiple times with different type lists.

### Workflow

1. Define fixture template and tests with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`.
2. Register tests with `REGISTER_TYPED_TEST_SUITE_P`.
3. Instantiate the suite with `INSTANTIATE_TYPED_TEST_SUITE_P` for desired types.

This allows sharing tests across multiple type sets efficiently.

---

## Examples

### Value-Parameterized Testing Example

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

// Test that the parameter is an even number.
TEST_P(IsEvenTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

// Instantiate with a set of values.
INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Typed Test Example

```cpp
template <typename T>
class DefaultValueTest : public testing::Test {
 public:
  T default_value() { return T(); }
};

using TestedTypes = testing::Types<int, double, bool>;
TYPED_TEST_SUITE(DefaultValueTest, TestedTypes);

TYPED_TEST(DefaultValueTest, IsDefaultValueZeroOrFalse) {
  TypeParam val = this->default_value();
  EXPECT_TRUE(val == TypeParam() || val == 0 || val == false);
}
```

---

## Troubleshooting & Tips

### Value-Parameterized Tests

- **Test Suite Not Running:** Ensure you invoke `INSTANTIATE_TEST_SUITE_P` after `TEST_P` definitions.
- **Duplicate or Confusing Names:** Use the custom name generator parameter to produce readable, unique test names.
- **Handling Complex Parameter Types:** Provide `PrintTo` or `AbslStringify` overloads for your types to improve output readability.

### Typed Tests

- **Compilation Errors on Missing Default Constructor:** Your fixture or tested types may require accessible default constructors.
- **Avoid Underscores in Test and Suite Names:** Following [FAQ](faq.md#Why-should-test-suite-names-and-test-names-not-contain-underscore) helps prevent unforeseen conflicts.
- **Managing Test Coverage:** Typed tests run over all types supplied; reduce the list if some types are inappropriate for a test.

### General Best Practices

- Use the correct macro: `TEST_P` for value-parameterized tests, `TYPED_TEST` for typed tests.
- Keep parameter types simple and copyable.
- Use `SCOPED_TRACE` to add contextual information inside tests.
- Combine generators with `testing::Combine` for cross-product parameter spaces.

---

## Next Steps & Related Content

- **Basic Unit Tests:** To start, review [Authoring Basic Unit Tests](../writing-and-running-tests/basic-unit-tests).
- **Advanced Assertions and Matchers:** Leverage more powerful assertions for richer tests in the [Advanced Assertions and Custom Matchers](../writing-and-running-tests/advanced-assertions-matchers) guide.
- **Mocking API:** Integrate mock objects effectively after mastering parameterized tests by exploring the [Mocking API Reference](../../api-reference/core-apis/mocking).
- **Test Design Best Practices:** For strategies on organizing large test suites, visit [Test Design and Best Practices](../test-design-and-best-practices/parameterized-tests).
- **Official GoogleTest Documentation:** Refer to the [GoogleTest Primer](primer.md) for foundational knowledge and the [Testing Reference](reference/testing.md) for detailed API explanations.

---

## Resources

- [GoogleTest Value-Parameterized Tests Official Documentation](../advanced.md#value-parameterized-tests)
- [GoogleTest Typed Tests Documentation](../advanced.md#typed-tests)
- [GoogleTest Official GitHub Repository](https://github.com/google/googletest)
- [FAQ on Test Naming and Common Issues](faq.md)

---

This guide empowers you to write succinct and versatile test suites that scale with your C++ codebase. Harness the full potential of GoogleTest parameterization and typing to test smarter, not harder.
