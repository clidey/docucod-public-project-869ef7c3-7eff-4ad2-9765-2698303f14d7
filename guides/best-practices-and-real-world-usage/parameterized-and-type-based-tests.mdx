---
title: "Parameterized and Type-based Tests"
description: "Explore powerful techniques for maximizing coverage with value- and type-parameterized tests. Step-by-step examples show how to efficiently test across multiple data sets and types, reducing code duplication and boosting confidence."
---

# Parameterized and Type-based Tests

Explore powerful techniques for maximizing coverage with value- and type-parameterized tests. Step-by-step examples show how to efficiently test across multiple data sets and types, reducing code duplication and boosting confidence.

---

## 1. Understanding Parameterized and Type-based Tests

In testing, one common challenge is verifying that your code behaves correctly under many different inputs or with multiple implementations. Writing individual tests for each value or type quickly becomes tedious and error-prone.

GoogleTest offers two robust features to handle these scenarios efficiently:

- **Value-Parameterized Tests:** Run the same test logic multiple times with different input values.
- **Typed and Type-Parameterized Tests:** Run the same tests against a variety of types, useful when testing templates or interface implementations.

This page will guide you through these features with practical examples and actionable steps.

---

## 2. Value-Parameterized Tests

### What Are They?

Value-Parameterized Tests allow you to define a single test pattern and then execute it multiple times with different input parameters. This eliminates redundant test code while improving test coverage over a broad input space.

### Prerequisites

- Familiarity with defining test fixtures derived from `::testing::Test`.
- Basic understanding of C++ templates.

### How to Write Value-Parameterized Tests

Follow these steps to create and use value-parameterized tests:

<Steps>
<Step title="Define a Parameterized Test Fixture">
Create a class derived from `::testing::TestWithParam<T>`, where `T` is the type of the parameter(s) you want to vary. Commonly, `T` is a simple type like `int`, `std::string`, or a tuple for multiple parameters.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Optional test setup and helpers go here
};
```
</Step>
<Step title="Write Parameterized Test Cases">
Use the `TEST_P` macro instead of `TEST_F`. Inside your test case, use `GetParam()` to access the current parameter value.

```cpp
TEST_P(FooTest, HandlesValidInput) {
  int param = GetParam();
  EXPECT_TRUE(Foo(param).IsValid());
}
```
</Step>
<Step title="Instantiate the Test Suite With Parameter Values">
Use the `INSTANTIATE_TEST_SUITE_P` macro to specify the parameter values that will drive your tests. GoogleTest offers several convenient ways to generate these values:

- `Values(v1, v2, ..., vN)`: Explicitly list out values.
- `ValuesIn(container)`: Use an array or STL container.
- `Range(begin, end, step)`: Specify ranges.
- `Bool()`: Generate boolean values.
- `Combine()`: Create Cartesian product for multiple parameters.

Example using explicit values:

```cpp
INSTANTIATE_TEST_SUITE_P(MyTests, FooTest, ::testing::Values(1, 2, 3));
```

Example using multiple parameters:

```cpp
class MultiParamTest : public ::testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(MultiParamTest, WorksWithCombo) {
  int num = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  EXPECT_TRUE(TestSubject(num, flag).Check());
}

INSTANTIATE_TEST_SUITE_P(
    ComboTests, MultiParamTest,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```
</Step>
<Step title="Run Your Tests">
Compile and run your test executable as usual. GoogleTest will run all parameterized instances, reporting each individually.

Use the `--gtest_filter` flag with parameterized test names like `InstantiationName/TestSuiteName.TestName/Index` to run specific parameter sets.
</Step>
</Steps>

### Customizing Parameterized Test Names

By default, test names contain the index of the parameter. You can provide a custom name generator function to create more readable test names.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest,
    ::testing::Values(10, 20, 30),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

### Best Practices

- Keep parameter types simple and copyable.
- Name your instantiations uniquely.
- Use `Combine()` judiciously to avoid combinatorial explosion.
- Prefer `ValuesIn()` for container-driven parameters.

### Common Pitfalls

- Placing `INSTANTIATE_TEST_SUITE_P` inside a function scope will not work.
- Failure to instantiate a `TEST_P` suite causes GoogleTest to report an error unless suppressed with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## 3. Typed and Type-Parameterized Tests

When testing templated code or multiple class implementations of the same interface, typed tests let you write generic test logic once and then run it over a list of types.

### Typed Tests

Use typed tests if you know the fixed list of types when writing tests.

#### Steps:

<Steps>
<Step title="Define a Fixture Template">

```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
  // Optional shared resources or typedefs
};
```

</Step>
<Step title="Associate a List of Types">

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

</Step>
<Step title="Write Typed Tests Using TYPED_TEST">

```cpp
TYPED_TEST(FooTest, HandlesDefaultConstruct) {
  TypeParam value{};
  EXPECT_TRUE(IsValid(value));
}
```

`TypeParam` refers to the current type from the list.

</Step>
<Step title="Run Your Tests">
Compile and run normally. GoogleTest runs the tests once for each type.
</Step>
</Steps>

### Type-Parameterized Tests

Type-parameterized tests let you declare a generic abstract test pattern without specifying the types. Later, each implementation can instantiate these test patterns with their own types.

#### Workflow:

<Steps>
<Step title="Declare the Type-Parameterized Test Suite">

```cpp
template <typename T>
class FooTest : public ::testing::Test {
  ...
};

TYPED_TEST_SUITE_P(FooTest);
```

</Step>
<Step title="Define Typed Tests with TYPED_TEST_P">

```cpp
TYPED_TEST_P(FooTest, WorksCorrectly) {
  TypeParam value{};
  EXPECT_TRUE(IsValid(value));
}
```

You can define many tests similarly.

</Step>
<Step title="Register Test Names">

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, WorksCorrectly, AnotherTest, ...);
```

</Step>
<Step title="Instantiate With Actual Types">

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, FooTest, MyTypes);
```

</Step>
<Step title="Run Your Tests">
Run normally; GoogleTest takes care of binding types to tests.
</Step>
</Steps>

### Customizing Test Names in Typed Tests

Typed tests support providing a name generator class with a static `GetName(int)` template function to uniquely name types in test results.

Example:

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, TypeNames);
```

---

## 4. Practical Examples

### Value-Parameterized Test Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

int Factorial(int n) {
  return (n <= 1) ? 1 : n * Factorial(n - 1);
}

TEST_P(FactorialTest, HandlesPositiveInput) {
  int n = GetParam();
  EXPECT_GT(Factorial(n), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveInputs, FactorialTest,
    ::testing::Values(1, 2, 3, 8));
```

Each test instance runs with one of the specified input values.

### Typed Test Example

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {
 public:
  // Shared fixture data can be added here
};

using MyNumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyNumericTypes);

TYPED_TEST(NumericLimitsTest, IsNonNegative) {
  EXPECT_GE(std::numeric_limits<TypeParam>::min(), 0);
}
```

GoogleTest runs this test for each type in `MyNumericTypes`.

---

## 5. Troubleshooting & Tips

- **No matching test errors:** Ensure `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` is called for every `TEST_P` or `TYPED_TEST_P`.
- **Test names with underscores warning:** Avoid underscores (`_`) in test suite or test names to prevent internal clashes.
- **Parameters not generating readable test names:** Provide a custom name generator function for clarity.
- **Too many test cases via `Combine()`:** Use sparingly to avoid combinatorial explosion.
- **Managing complex parameters:** Use `ConvertGenerator` to convert parameter tuples or types into custom types expected by your fixture.

---

## 6. Next Steps & Resources

- **Explore sample tests:** See [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) for value-parameterized tests and [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc) for typed tests.
- **Learn about mocking:** Visit the [Mocking Basics guide](/guides/getting-started-workflows/mocking-basics) to combine parameterized tests with mocks.
- **Master assertions:** Review the [Assertions and Matchers guide](/guides/best-practices-and-real-world-usage/assertions-and-matchers) for verifying outcomes.
- **Consult the Testing Reference:** For macros and API details, review the [Testing Reference](docs/reference/testing.md).

---

## Summary
This page shows how to efficiently expand test coverage across input values and types using GoogleTest's powerful parameterized and typed test frameworks. Implementing these reduces code duplication and enhances confidence by systematically validating combinations and implementations.

---

## References
- [Value-Parameterized Testing](docs/advanced.md#value-parameterized-tests)
- [Typed Tests and Type-Parameterized Tests](docs/advanced.md#typed-tests)
- [GoogleTest Primer](docs/primer.md)
- Sample implementations: `sample6_unittest.cc`, `sample7_unittest.cc`, and `sample8_unittest.cc`
