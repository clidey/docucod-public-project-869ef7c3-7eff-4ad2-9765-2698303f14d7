---
title: "Optimizing Test Performance"
description: "Techniques for speeding up test execution: test selection, parallelization, resource management, and reducing test flakiness."
---

# Optimizing Test Performance

GoogleTest provides a powerful framework for writing and running tests. However, as your test suite grows, test execution time and reliability become critical factors that impact development speed and feedback quality. This guide focuses exclusively on techniques you can apply to optimize the performance of your test runs, including strategies for test selection, parallel execution, efficient resource management, and reducing the flakiness that slows down reliable feedback.

---

## 1. Overview of Performance Optimization

### What This Guide Covers
This guide helps you speed up your test execution without sacrificing reliability. You will learn how to:
- Select a subset of tests intelligently to reduce total run time.
- Run tests in parallel to utilize multi-core and distributed environments.
- Manage resources efficiently for scalable test runs.
- Identify and reduce test flakiness that causes intermittent failures and reruns.

### Prerequisites
- You should have an existing GoogleTest-based test suite.
- Familiarity with running tests programmatically or via build tools.
- Basic understanding of test fixtures and test cases.

### Expected Outcomes
By following this guide, your test suite will:
- Run faster overall.
- Provide earlier feedback on failures.
- Be more stable and less prone to flaky or intermittent failures.

### Time Estimate
Depending on your test suite size and environment, implementing these strategies typically takes a few hours to a few days.

### Difficulty Level
Intermediate: Requires some configuration and possibly build system or test runner scripting.

---

## 2. Techniques for Speeding Up Test Execution

### 2.1 Test Selection & Filtering

GoogleTest supports filtering tests at runtime, enabling you to run only relevant subsets:

- Use the `--gtest_filter` flag or `GTEST_FILTER` environment variable.
- The filter supports wildcard patterns and negative patterns for fine-grained control.

Example: Run only tests in `MathTest` except for `Addition`:

```bash
./my_tests --gtest_filter=MathTest.*-MathTest.Addition
```

**Best Practices:**
- Use naming conventions to group fast and slow tests and filter accordingly.
- Regularly run full tests on CI, but use filters during local development to speed iteration.


### 2.2 Test Parallelization

Running tests in parallel leverages multiple CPU cores or multiple machines for reduced wall-clock time.

#### Native GoogleTest Support
- GoogleTest supports sharding through environment variables:
  - `GTEST_TOTAL_SHARDS`: total shards (machines or processes).
  - `GTEST_SHARD_INDEX`: shard index (must be between 0 and `GTEST_TOTAL_SHARDS - 1`).
- When set, GoogleTest automatically partitions tests among shards.

Example:
```bash
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=0
./my_tests
```

Run the above on four machines/processes with shard indices 0 to 3 respectively.

**Tips:**
- This feature is compatible with most build and CI systems.
- Combine sharding with `--gtest_filter` for more granular control.

#### Parallel Test Runners
- Alternatively, use build tools or test runners (e.g., `ctest`, Bazel, Ninja) that support parallel test execution.
- Make sure your tests are independent and free of shared-state side effects for thread-safe parallelism.


### 2.3 Resource Management

Tests that consume external or shared resources (like files, databases, networks) can introduce bottlenecks.

**Strategies:**
- Limit concurrency for resource-heavy tests.
- Use per-test or per-thread fixtures with scoped resource allocation.
- Reuse expensive resources across tests when isolation is not compromised — e.g., using `SetUpTestSuite()` and `TearDownTestSuite()` for shared setup/teardown.


### 2.4 Reducing Test Flakiness

Flaky tests cause intermittent failures, forcing repeated runs and slowing feedback.

Common flakiness causes:
- Timing issues and race conditions.
- Reliance on external state or resources.
- Order dependencies between tests.

**Recommendations:**
- Write tests to be isolated and deterministic.
- Avoid shared mutable state between tests.
- Use GoogleTest's `SCOPED_TRACE` to enhance failure diagnostics.
- Detect flakes by running tests multiple times (`--gtest_repeat=N`).

Example:
```bash
./my_tests --gtest_repeat=100
```
Runs all tests 100 times to uncover flaky failures.


---

## 3. Step-by-Step Instructions

<Steps>
<Step title="Run a Filtered Subset of Tests">
Use the `--gtest_filter` flag to target specific tests.

```shell
./my_tests --gtest_filter=FooTest.*-FooTest.Bar
```

This runs all `FooTest` tests except `FooTest.Bar`.

**Success Criteria:** Only intended tests run as confirmed by console output.
</Step>

<Step title="Enable Test Sharding for Parallelism">
Set the environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` appropriately.

For example, on four parallel agents, assign indices 0 to 3:

```shell
export GTEST_TOTAL_SHARDS=4
export GTEST_SHARD_INDEX=0
./my_tests
```

Run similarly on shards 1, 2, 3.

**Success Criteria:** Each shard runs a disjoint subset of all tests; overall test coverage remains complete.
</Step>

<Step title="Limit Resource Contention">
Identify tests using shared resources.

Update test fixture setup to use `SetUpTestSuite()`/`TearDownTestSuite()` for shared initialization.

Refactor tests to reduce resource usage or to serialize access when required.

**Success Criteria:** Tests complete without resource errors or deadlocks.
</Step>

<Step title="Detect and Address Flaky Tests">
Run tests repeatedly using:

```shell
./my_tests --gtest_repeat=100 --gtest_break_on_failure
```

When flaky tests fail, examine output with `SCOPED_TRACE` and debug for nondeterminism.

**Success Criteria:** Flakes are identified and corrected, significantly reducing test reruns.
</Step>
</Steps>

---

## 4. Examples

### Running a Filtered and Sharded Test Invocation

```shell
export GTEST_FILTER=NetworkingTest.*
export GTEST_TOTAL_SHARDS=2
export GTEST_SHARD_INDEX=1
./my_tests
```

This runs the subset of `NetworkingTest` tests assigned to shard 1 out of 2.

### Using Shared Resource in Fixture

```c++
class DatabaseTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    db_connection_ = ConnectToTestDatabase();
  }

  static void TearDownTestSuite() {
    DisconnectFromTestDatabase(db_connection_);
    db_connection_ = nullptr;
  }

  static DatabaseConnection* db_connection_;
};

DatabaseConnection* DatabaseTest::db_connection_ = nullptr;

TEST_F(DatabaseTest, QueryWorks) {
  EXPECT_TRUE(db_connection_->Execute("SELECT 1"));
}
```

This avoids expensive reconnects for every test.

---

## 5. Troubleshooting & Tips

### Common Issues

- **Tests not running after filtering:** Check that your filter syntax matches existing test names exactly. Use `--gtest_list_tests` to verify available tests.
- **Sharding missing tests:** Ensure environment variable values are correct and shard indices are in range.
- **Resource conflicts:** Serializing tests that share external resources or applying process-level locks can help.
- **Persistent flaky failures:** Use `--gtest_repeat` to identify failures, then add more detailed logging via `SCOPED_TRACE`.

### Best Practices

- Name tests clearly and consistently to leverage filters effectively.
- Group slow tests separately to exclude during rapid iteration.
- Complement GoogleTest sharding with your build system’s job parallelism for maximum efficiency.
- Avoid global state shared across tests or reset it explicitly each time.

### Performance Considerations

- Parallelism benefits diminish if tests compete for IO or CPU. Profile test execution if gains are minimal.
- Large shared fixtures can reduce speed gains from parallelism due to setup overhead; balance accordingly.

### Alternative Approaches

- Consider incremental test runs based on changed code areas with custom scripts using test filters.
- Use build systems like Bazel or CTest with native test parallelism support when applicable.

---

## 6. Next Steps & Related Content

- Explore [Test Parameterization](../../guides/writing-effective-tests/test-parameterization.md) to run similar tests with different inputs more efficiently.
- Consult [Integrating with Build Systems and CI](../../guides/integration-tips/build-system-integration.md) for automating parallel test execution.
- Review the [Death Tests](../../guides/writing-effective-tests/death-tests.md) guide to understand safe ways to test expected failures without impacting overall performance.
- Use the [Common Assertions](../../guides/getting-started/common-assertions.md) guide to write expressive, maintainable tests that minimize debug cycles.


---

# References
- GoogleTest CLI options: [Running Tests](../../docs/advanced.md#running-test-programs-advanced-options)
- Sharding notes: [Advanced Topics - Running Test Functions on Multiple Machines](../../docs/advanced.md#distributing-test-functions-to-multiple-machines)
- Flake detection: `--gtest_repeat` flag usage in [Advanced Topics](../../docs/advanced.md#running-test-programs-advanced-options)
- Test filtering syntax: [Advanced Topics - Selecting Tests](../../docs/advanced.md#selecting-tests)

---