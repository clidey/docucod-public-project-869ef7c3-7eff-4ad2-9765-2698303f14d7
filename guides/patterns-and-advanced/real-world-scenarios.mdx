---
title: "Testing Real-World Scenarios"
description: "Walkthroughs of testing common C++ patterns and application architectures—such as dependency injection, legacy code, and boundary conditions. Includes design advice and practical code samples."
---

# Testing Real-World Scenarios with GoogleTest and GoogleMock

This guide walks you through how to apply GoogleTest and GoogleMock to test common, practical C++ coding patterns and architectural scenarios. You'll learn how to handle dependency injection, legacy code integration, boundary conditions, and more. Each section provides design advice, best practices, and practical code samples that you can incorporate directly into your tests.

---

## 1. Workflow Overview

### What This Guide Helps You Accomplish
This documentation focuses specifically on testing typical real-world use cases encountered in C++ projects. It helps you design and write effective tests for:

- Dependency injection patterns
- Legacy or third-party code with minimal interfaces
- Boundary and edge cases
- Interaction verification with complex call ordering

### Prerequisites

Before starting, make sure you have:

- Familiarity with basic GoogleTest and GoogleMock concepts such as mock classes, expectations (`EXPECT_CALL`), and matchers.
- GoogleTest and GoogleMock installed and configured in your project. Refer to the [Installation Methods](https://google.github.io/googletest/getting-started/prereqs-installation/installation-methods) and [Configuration Basics](https://google.github.io/googletest/getting-started/prereqs-installation/configuration-basics) guides.

### Expected Outcome

By completing the examples and workflows, you will:

- Understand how to create robust mocks that fit various common application designs.
- Know how to properly set expectations, default behaviors, and verify complex call sequences.
- Gain insight into handling tricky scenarios like legacy code and boundary testing.

### Estimated Time

Approximately 30–60 minutes to digest, experiment, and adapt the patterns.

### Difficulty Level
Intermediate — assumes basic knowledge of GoogleTest and GoogleMock.

---

## 2. Testing Dependency Injection

Dependency injection (DI) improves testability by allowing replacement of real collaborators with mocks. Here's how to use GoogleMock effectively with DI.

### Step-by-Step Instructions

<Steps>
<Step title="Define the Interface and Mock">
Start by having an interface (abstract base class) for the dependency, with virtual methods declared.

Use `MOCK_METHOD` in a derived mock class to override these methods.

```cpp
class Renderer {
 public:
  virtual ~Renderer() = default;
  virtual void DrawCircle(int x, int y, int radius) = 0;
};

class MockRenderer : public Renderer {
 public:
  MOCK_METHOD(void, DrawCircle, (int x, int y, int radius), (override));
};
```

Expected result: A mock class ready for injection.
</Step>

<Step title="Inject Mock into Tested Class">
Write your tested class to accept the interface pointer or reference.

```cpp
class Painter {
 public:
  explicit Painter(Renderer* renderer) : renderer_(renderer) {}
  bool DrawCircleAtOrigin(int radius) {
    renderer_->DrawCircle(0, 0, radius);
    return true;
  }
 private:
  Renderer* renderer_;
};
```
Expected result: Your class uses the injected dependency.
</Step>

<Step title="Set Expectations in Test">
In your test, create a mock object, set expectations on it, and inject it.

```cpp
TEST(PainterTest, DrawsCircleCorrectly) {
  MockRenderer mock_renderer;

  EXPECT_CALL(mock_renderer, DrawCircle(0, 0, 10)).Times(1);

  Painter painter(&mock_renderer);
  EXPECT_TRUE(painter.DrawCircleAtOrigin(10));
}
```
Expected result: Test passes when the mock's expected call happens correctly.
</Step>
</Steps>

### Tips and Best Practices

- Use `.Times()` and `.WillOnce()` to tightly control call frequency and behavior.
- Use `NiceMock` to suppress warnings for uninteresting calls if your mock is noisier than expected.

---

## 3. Handling Legacy Code and Legacy APIs

Legacy or third-party libraries often lack interfaces or have monolithic APIs. Mocking such code requires adapting or wrapping them.

### Recommended Approach

- Define an interface abstraction around the legacy code.
- Implement a wrapper class communicating with legacy objects.
- Mock the interface in your tests.

Example:

```cpp
// Legacy code (not mockable):
class LegacyService {
 public:
  int Calculate(int x);
};

// Your interface:
class ServiceInterface {
 public:
  virtual ~ServiceInterface() = default;
  virtual int Calculate(int x) = 0;
};

// Adapter/Wrapper:
class LegacyServiceAdapter : public ServiceInterface {
  LegacyService* legacy_;
 public:
  explicit LegacyServiceAdapter(LegacyService* legacy) : legacy_(legacy) {}
  int Calculate(int x) override { return legacy_->Calculate(x); }
};

// Mock implementation:
class MockService : public ServiceInterface {
 public:
  MOCK_METHOD(int, Calculate, (int x), (override));
};
```

In your tests, mock `MockService` instead of the original legacy class.

### Advantages

- You avoid modifying any legacy code.
- Your tests gain flexibility and better isolation.

---

## 4. Testing Boundary Conditions and Edge Cases

Testing how your code handles boundary conditions is crucial. Mocks can help validate reactions to error cases or limits.

### Example Scenario: Validate Behavior on Null or Empty Inputs

```cpp
class MockDatabase {
 public:
  MOCK_METHOD(bool, Connect, (const std::string& server), (override));
};

TEST(DatabaseClientTest, HandlesConnectionFailureGracefully) {
  MockDatabase mock_db;

  // Set default action to fail connection for invalid server
  ON_CALL(mock_db, Connect(_)).WillByDefault(Return(false));

  EXPECT_CALL(mock_db, Connect("bad-server"))
      .WillOnce(Return(false));

  DatabaseClient client(&mock_db);
  EXPECT_FALSE(client.Initialize("bad-server"));
}
```

### Tips

- Use `ON_CALL` to set default behavior for uninteresting calls.
- Use `EXPECT_CALL` to specify calls you expect during a test.
- Use matchers like `_` to match any parameter.

---

## 5. Complex Call Ordering and Interaction Patterns

GoogleMock lets you specify call sequences precisely.

### Using `InSequence` for Strict Call Order

```cpp
using ::testing::InSequence;

TEST(SequenceTest, CallOrderMatters) {
  MockFoo foo;
  {
    InSequence seq;

    EXPECT_CALL(foo, Initialize());
    EXPECT_CALL(foo, Execute());
    EXPECT_CALL(foo, Shutdown());
  }

  // Calls with expected order.
  foo.Initialize();
  foo.Execute();
  foo.Shutdown();
}
```

### Using `Sequence` Objects for Partial Ordering

You can specify partial orders over multiple sequences.

```cpp
Sequence s1, s2;
EXPECT_CALL(foo, Open()).InSequence(s1);
EXPECT_CALL(foo, Process()).InSequence(s2);
EXPECT_CALL(foo, Close()).InSequence(s1, s2);
```

The above means `Open()` must happen before `Close()`, and `Process()` must also happen before `Close()`, but the order between `Open()` and `Process()` is not fixed.

---

## 6. Practical Code Sample: Testing a Dependency Injection Scenario

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>
using ::testing::AtLeast;
using ::testing::_;

class Storage {
 public:
  virtual ~Storage() {}
  virtual bool Save(const std::string& data) = 0;
};

class MockStorage : public Storage {
 public:
  MOCK_METHOD(bool, Save, (const std::string& data), (override));
};

class DataProcessor {
  Storage* storage_;
 public:
  explicit DataProcessor(Storage* storage) : storage_(storage) {}
  bool Process(const std::string& data) {
    // ... do some processing ...
    return storage_->Save(data);
  }
};

TEST(DataProcessorTest, SavesProcessedData) {
  MockStorage mock_storage;

  EXPECT_CALL(mock_storage, Save(_)).Times(1).WillOnce(::testing::Return(true));

  DataProcessor processor(&mock_storage);
  EXPECT_TRUE(processor.Process("Hello"));
}
```

---

## 7. Common Pitfalls and Troubleshooting

### Common Issues

- **Uninteresting Call Warnings:** If a mock method gets called without an explicit `EXPECT_CALL`, gMock prints a warning. To silence it, either add an `EXPECT_CALL` with `.Times(AnyNumber())` or use `NiceMock<YourMock>`.

- **Unexpected Calls:** If your actual calls don't match any `EXPECT_CALL`, tests will fail. Verify your matchers and call arguments carefully.

- **Too Few or Too Many WillOnce() Clauses:** If the number of calls exceeds the number of `WillOnce` actions and no `WillRepeatedly` is specified, a warning appears. Use `WillRepeatedly` to specify default behavior for later calls.

### Best Practices

- Set expectations **before** exercising code.
- Use sequences only when call order matters.
- Avoid over-specifying matchers to prevent brittle tests.

---

## 8. Next Steps & Related Content

- Explore [Defining and Using Mock Classes](https://google.github.io/googletest/guides/mocking-techniques/defining-mocks) for deeper understanding of mock class creation.
- Read [Best Practices for Mocking and Expectations](https://google.github.io/googletest/guides/mocking-techniques/best-practices-mocking) to refine your test designs.
- Study [Introduction to Mocking](https://google.github.io/googletest/guides/mocking-techniques/intro-to-mocking) for foundational concepts.
- Review [Common Assertions](https://google.github.io/googletest/guides/getting-started/common-assertions) to combine mocks with powerful assertions.
- For detailed coverage of configuring and running tests, see the [Getting Started](https://google.github.io/googletest/getting-started-intro/product-intro) section.

---

## References

- [Mocking Reference](https://google.github.io/googletest/docs/reference/mocking.html)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html)

---