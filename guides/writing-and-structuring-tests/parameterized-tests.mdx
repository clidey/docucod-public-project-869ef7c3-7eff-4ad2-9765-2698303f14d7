---
title: "Parameterized and Type-Parameterized Tests"
description: "Master parameterized testing by running the same tests with varied data or types. This guide covers both value-parameterized and type-parameterized tests, including key patterns and sample implementations."
---

# Parameterized and Type-Parameterized Tests

Master parameterized testing by running the same tests with varied data or types. This guide covers both value-parameterized tests and type-parameterized tests, including key patterns and sample implementations.

---

## Understanding Parameterized Tests

GoogleTest helps you reduce test duplication by enabling you to run the same test logic repeatedly over different input data or types. This approach improves coverage and correctness without boilerplate code.

There are two powerful mechanisms:

- **Value-Parameterized Tests:** Run the same tests with different runtime parameters.
- **Type-Parameterized Tests:** Run tests against multiple types at compile time.

Each serves distinct needs and fits different testing scenarios.

---

## Value-Parameterized Tests

### Workflow Overview

**Purpose:** Test your code with different input values without duplicating test code.

**Prerequisites:**
- Define a test fixture class deriving from `testing::TestWithParam<T>`, where `T` is the parameter type.
- Use `TEST_P` macros to define parameterized tests.

**Expected Outcome:** You get multiple test instances, each running with one parameter.

**Time to Complete:** 10–20 minutes to understand and implement.

**Difficulty Level:** Intermediate

---

### Creating a Value-Parameterized Test Suite

<Steps>
<Step title="Define the Fixture">
Subclass `testing::TestWithParam<T>`, implementing any setup or helper members you need.

```cpp
class ExampleTest : public testing::TestWithParam<int> {
  // Optional: Add setup or utility functions here
};
```
</Step>
<Step title="Write Parameterized Tests with TEST_P">
Use the macro `TEST_P` instead of `TEST_F` or `TEST` to define tests that use parameters.
Access the parameter inside the test with `GetParam()`.

```cpp
TEST_P(ExampleTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```
</Step>
<Step title="Instantiate the Test Suite">
Use `INSTANTIATE_TEST_SUITE_P` to specify the set of parameters to run the tests with.

Choose or create a unique prefix name for this instantiation.
Use parameter generators like `Values()`, `Range()`, `Bool()`, `Combine()`, or `ValuesIn()`.

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers,
                         ExampleTest,
                         testing::Values(2, 4, 6, 8));
```
</Step>
</Steps>

---

### Common Parameter Generators

| Generator       | Description                                                    |
|-----------------|----------------------------------------------------------------|
| `Range(start, end [, step])` | Yields a sequence from `start` (inclusive) to `end` (exclusive) with optional `step`. |
| `Values(v1, v2, ..., vN)`    | Explicitly specifies parameters.
|
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Uses elements from containers or arrays.  |
| `Bool()`                     | Yields `false` and `true` for boolean tests.                    |
| `Combine(g1, g2, ..., gN)`   | Creates Cartesian product of multiple generators, combining parameters as tuples. |

---

### Naming Instantiated Tests

You can provide a **custom name generator** as the last argument of `INSTANTIATE_TEST_SUITE_P`. It must be a callable accepting `testing::TestParamInfo<ParamType>`, returning a `std::string`. This helps generate readable test names instead of default numeric suffixes.

Example of a simple custom name generator using a lambda:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, ExampleTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<ExampleTest::ParamType>& info) {
      return "Value" + std::to_string(info.param);
    });
```

**Note:** Test names must contain only alphanumeric characters and underscores.

---

### Practical Example

```cpp
// Define the fixture
class IsOddTest : public testing::TestWithParam<int> {};

// Define tests using TEST_P and GetParam()
TEST_P(IsOddTest, IsOddNumber) {
  EXPECT_EQ(GetParam() % 2, 1);
}

// Instantiate the tests with a range: 1,3,5,7,9
INSTANTIATE_TEST_SUITE_P(OddValues, IsOddTest,
                         testing::Range(1, 10, 2));
```

Running this will generate five distinct test instances, each verifying one odd value.

---

### Best Practices and Tips

- Put `INSTANTIATE_TEST_SUITE_P` at global or namespace scope, **not** inside functions.
- Name your instantiations clearly with prefixes related to the data or scenario.
- You can instantiate the same test suite with different parameter sets multiple times.
- Suppress failing uninstantiated parameterized tests by using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName)` if intentional.

---

### Troubleshooting Common Issues

<AccordionGroup title="Common Issues with Value-Parameterized Tests">
<Accordion title="Tests not running after instantiation">
Make sure `INSTANTIATE_TEST_SUITE_P` is at global scope and follows your `TEST_P` definitions. Also, verify your parameter generator produces valid values.
</Accordion>
<Accordion title="Test names are unreadable or cause errors">
Avoid underscores in test suite names and test names. Use a custom name generator to provide ergonomic test suffixes.
</Accordion>
<Accordion title="Compilation errors on fixture constructors">
Ensure your test fixture has a default constructor.
</Accordion>
</AccordionGroup>

---

## Type-Parameterized Tests

### When to Use

Use type-parameterized tests to verify that your code behaves correctly for multiple types—for example, checking containers over different element types or different numeric types.

Unlike value-parameterized tests, the types are specified at compile time.

---

### Workflow Overview

**Purpose:** Write generic tests over a list of types.

**Prerequisites:**
- Create a class template test fixture deriving from `testing::Test`.
- Define the types list using `testing::Types<...>`.
- Use `TYPED_TEST_SUITE` and `TYPED_TEST` macros.

**Expected Outcome:** A test suite with separate tests compiled and executed for each specified type.

**Time to Complete:** 20–30 minutes.

**Difficulty Level:** Intermediate

---

### Creating Typed Tests

<Steps>
<Step title="Define the Fixture Template">

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T value_;
};
```
</Step>

<Step title="Declare the Type List and Associate with Fixture">

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```
</Step>

<Step title="Define Typed Tests Using TYPED_TEST">

Inside tests, `TypeParam` gives the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  EXPECT_TRUE(std::is_default_constructible<TypeParam>::value);
}
```
</Step>
</Steps>

---

### Type-Parameterized Tests (Dynamic)

Sometimes you want to define a test pattern **without specifying the types up front**, allowing others to instantiate it with their types later. This is a slightly more advanced variant.

#### How to Define Type-Parameterized Tests

- Use `TYPED_TEST_SUITE_P` to declare an abstract test suite template.
- Use `TYPED_TEST_P` macros to define type-parameterized tests.
- Register tests using `REGISTER_TYPED_TEST_SUITE_P`.

#### How to Instantiate These Tests

- Use `INSTANTIATE_TYPED_TEST_SUITE_P` with a list of types.

Example:

```cpp
// In header or shared file:

template <typename T>
class AbstractTest : public testing::Test {};

TYPED_TEST_SUITE_P(AbstractTest);

TYPED_TEST_P(AbstractTest, TestSomething) { ... }

REGISTER_TYPED_TEST_SUITE_P(AbstractTest, TestSomething);

// In source files:

using MyTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyGroup, AbstractTest, MyTypes);
```

---

### Advantages of Type-Parameterized Tests

- Reusable test patterns, enabling different instantiations across translation units.
- Validate interface conformance of different implementations.

---

### Practical Example

```cpp
// Defines abstract test pattern
template <typename T>
class NumericTest : public testing::Test {};

TYPED_TEST_SUITE_P(NumericTest);

TYPED_TEST_P(NumericTest, IsSigned) {
  EXPECT_TRUE(std::is_signed<TypeParam>::value);
}

REGISTER_TYPED_TEST_SUITE_P(NumericTest, IsSigned);

// Instantiate for types float and double
using FloatingPointTypes = testing::Types<float, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(FloatingPoint, NumericTest, FloatingPointTypes);
```

Each test runs twice: once for `float` and once for `double`.

---

### Troubleshooting

<AccordionGroup title="Common Issues with Type-Parameterized Tests">
<Accordion title="Compile failures related to macros or missing registration">
Ensure every `TYPED_TEST_P` is matched with `REGISTER_TYPED_TEST_SUITE_P` listing the test names.
</Accordion>
<Accordion title="Cannot instantiate types in different source files">
Verify that the fixture and test declarations are in headers, test definitions in source files, and instantiations at global scope in one compilation unit.
</Accordion>
</AccordionGroup>

---

## Summary and Advanced Patterns

- Value-parameterized tests help run many data-driven test cases efficiently.
- Type-parameterized tests enable generic tests over types with compile-time checking.
- Use custom name generators to produce meaningful test names for parameterized tests.
- Abstract tests can be created once and instantiated multiple times with different parameter sets or types.

Explore provided samples like `sample7_unittest.cc` for value-parameterized and `sample6_unittest.cc` for typed and type-parameterized tests in the official repository.

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [`INSTANTIATE_TEST_SUITE_P` API](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [`TYPED_TEST_SUITE` and `TYPED_TEST` API](reference/testing.md#TYPED_TEST_SUITE)
- [GoogleTest Primer](primer.md)
- [Writing Your First Test](../guides/getting-started/writing-your-first-test.mdx)

<Tip>
Remember to always keep test names free of underscores and use meaningful, human-readable names for test parameters or types for clearer test output.
</Tip>
