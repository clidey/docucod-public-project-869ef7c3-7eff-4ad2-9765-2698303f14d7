---
title: "Value and Type-Parameterized Tests"
description: "Step-by-step patterns for creating flexible test cases that run across multiple input values and data types. Ideal for template-heavy or matrixed code, maximizing coverage efficiently."
---

# Value and Type-Parameterized Tests

Flexibility and coverage are critical when testing C++ code that operates over a range of types or input values. This page guides you step-by-step through GoogleTest's powerful patterns for creating test cases that run across multiple types or values, enabling you to maximize your test coverage efficiently.

---

## Overview

GoogleTest provides two complementary mechanisms to create flexible, reusable test code that runs against multiple types or sets of input parameters:

- **Value-Parameterized Tests**: Focus on running the same test logic repeatedly with different input values, i.e., different data passed as parameters.
- **Typed Tests and Type-Parameterized Tests**: Focus on running the same test logic with different types (e.g., `int`, `double`, custom classes).

By mastering these features, you can write compact test suites that verify correctness across a broad matrix of scenarios without duplicating code.

---

## 1. Value-Parameterized Tests

### Purpose
Write a single test template that runs against various input values, helping you verify behavior across a range without manual repetition.

### Prerequisites
- A test fixture class deriving from `testing::TestWithParam<T>`, where `T` is the type of the parameter.
- Include `<gtest/gtest.h>`.

### Workflow

<Steps>
<Step title="Define a Parameterized Fixture Class">
Derive your test class from `testing::TestWithParam<T>` where `T` is the parameter type.

```cpp
class MyTest : public ::testing::TestWithParam<int> {
  // Fixture setup if needed
};
```
</Step>

<Step title="Write Tests Using TEST_P Macro">
Define tests inside the fixture with `TEST_P` instead of `TEST` or `TEST_F`.
Use `GetParam()` to access the parameter value.

```cpp
TEST_P(MyTest, HandlesVariousValues) {
  int value = GetParam();
  EXPECT_TRUE(MyFunction(value));
}
```
</Step>

<Step title="Instantiate the Test Cases">
Use `INSTANTIATE_TEST_SUITE_P` to specify the name and the list or generator of parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTest, ::testing::Values(1, 2, 3));
```
This creates three tests running with parameters 1, 2, and 3.
</Step>
</Steps>

### Parameter Generators

GoogleTest provides built-in functions in the `::testing` namespace to generate sequences of values:

- `Values(v1, v2, ..., vN)`: Explicit list of values.
- `ValuesIn(container)`: Values from array, STL container, or iterator range.
- `Range(begin, end [, step])`: Values from `begin` up to but excluding `end`, with optional step.
- `Bool()`: Booleans {false, true}.
- `Combine(gen1, gen2, ..., genN)`: Cartesian product of multiple generators returning `std::tuple`s.

You can also use `ConvertGenerator` to cast or convert generated parameter types (see examples below).

### Example — Simple Value-Parameterized Test

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesCorrectly) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ExpectedFactorial(n));
}

INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, FactorialTest, ::testing::Values(1, 2, 3, 8));
```

This will run the test four times with inputs 1, 2, 3, and 8.

### Advanced: Combining Parameters with `Combine`

To test multiple parameters together, use `Combine` which produces the Cartesian product of values.

```cpp
INSTANTIATE_TEST_SUITE_P(
    BoolAndRange, MyTest,
    ::testing::Combine(::testing::Bool(), ::testing::Range(1, 4)));
```

This runs tests with all pairs of (boolean, integer) parameters.

### Checking Parameter Information in Test Names

You can use an optional test name generator function to produce readable test names based on parameters, ensuring results are clear and traceable.

---

## 2. Typed Tests and Type-Parameterized Tests

### Purpose
Test your code against multiple types by defining a type-parameterized test pattern that runs for all specified types.

### Types of Typed Tests
- **Typed Tests**: You list the set of types when defining the test suite.
- **Type-Parameterized Tests**: Define test patterns independently and instantiate later with the desired types.

### Workflow for Typed Tests

<Steps>
<Step title="Define a Fixture Class Template">
Define a fixture class template parameterized on a type `T`. Inherit from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
   // Members or typedefs for the fixture as needed
};
```
</Step>

<Step title="Specify List of Types">
Create a type list using `testing::Types<T1, T2, ...>`.

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
```
</Step>

<Step title="Associate the Type List with the Test Suite">
Use the macro `TYPED_TEST_SUITE` to bind the fixture to the list.

```cpp
TYPED_TEST_SUITE(FooTest, MyTypes);
```
</Step>

<Step title="Write Typed Tests Using TYPED_TEST">
Use `TYPED_TEST` to write test bodies. Use `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(FooTest, DoesSomething) {
  TypeParam value{};  // default constructed
  EXPECT_TRUE(MyFunction(value));
}
```
</Step>
</Steps>

### Workflow for Type-Parameterized Tests

<Steps>
<Step title="Define a Fixture Class Template">
Define a fixture class template as in Typed Tests.
</Step>

<Step title="Declare Type-Parameterized Test Suite">
Declare with `TYPED_TEST_SUITE_P` (note the trailing `_P`).

```cpp
TYPED_TEST_SUITE_P(FooTest);
```
</Step>

<Step title="Define Type-Parameterized Tests">
Use `TYPED_TEST_P` macros to define test patterns.

```cpp
TYPED_TEST_P(FooTest, HasFeatureX) {
  // test code with TypeParam
}
```
</Step>

<Step title="Register Test Patterns">
Register the tests you defined in this suite with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, HasFeatureX, AnotherTest);
```
</Step>

<Step title="Instantiate the Type-Parameterized Test Suite">
Instantiate the tests with `INSTANTIATE_TYPED_TEST_SUITE_P`, choosing types later.

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyGroup, FooTest, MyTypes);
```
</Step>
</Steps>

### Example — Typed Test

```cpp
template <typename T>
class NumericTest : public testing::Test {
public:
  T value{};
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(this->value, TypeParam{});
}
```

This runs three tests, one per type.

---

## Best Practices and Tips

- Prefer value-parameterized tests when you’re varying input *values*. Use typed tests when you’re varying the *types* that your code runs against.
- Always avoid underscores (`_`) in your test suite and test names to prevent compiler or runtime issues (see FAQ for rationale).
- Use descriptive instantiation names to differentiate parameter sets in test reports.
- To generate custom, readable test names for parameterized tests, provide a custom name generator as the optional fourth parameter of `INSTANTIATE_TEST_SUITE_P`.
- Remember that typed tests require default-constructible types unless you provide your own construction mechanism.
- Typed tests and type-parameterized tests don't share test fixture instances between tests. Each instantiation gets fresh fixture objects.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Challenges">
<Accordion title="Compiling Errors with Typed Tests">

Check:
- You have properly defined and registered your test suite and registered the tests before instantiating.
- You are not mixing `TEST_F` with typed test fixtures.
- Your fixture class templates have default constructors.

See GoogleTest FAQ for detailed compilation notes.

</Accordion>
<Accordion title="Tests Not Running After Instantiation">

Verify:
- You called `INSTANTIATE_TEST_SUITE_P` with a unique prefix.
- Your test filter is not filtering out all instances.
- You allowed uninstantiated parameterized tests using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when needed.

</Accordion>
</AccordionGroup>

---

## Summary

Using value-parameterized and typed tests effectively allows you to write test code that automatically covers multiple inputs and types, reducing boilerplate while increasing test breadth and reliability. By following the patterns documented here, you can introduce flexible test frameworks tailored to your projects' needs.

## Related Documentation

- [GoogleTest Primer](docs/primer.md) — foundational concepts
- [Assertions Reference](docs/reference/assertions.md) — validation methods inside tests
- [Advanced Testing Patterns](guides/advanced-patterns/parameterized-and-typed-tests.md) — contextual examples
- [GoogleTest FAQ](docs/faq.md) — common pitfalls and their fixes

## External Resources

- [GoogleTest official repository](https://github.com/google/googletest)
- [GoogleTest Typed Tests Source](googletest/include/gtest/gtest-typed-test.h)
- [GoogleTest Parameterized Tests Source](googletest/include/gtest/gtest-param-test.h)

---