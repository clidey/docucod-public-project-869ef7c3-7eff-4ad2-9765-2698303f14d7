---
title: "Integrating Tests into Continuous Integration (CI)"
description: "Guidance on integrating GoogleTest and GoogleMock into popular CI systems. Covers building and running tests automatically, capturing and analyzing test output, and troubleshooting integration issues."
---

# Integrating Tests into Continuous Integration (CI)

GoogleTest and GoogleMock provide robust C++ testing capabilities that play a critical role in automated CI workflows. This guide helps you seamlessly integrate your tests into popular Continuous Integration (CI) systems, automate building and testing, analyze results efficiently, and troubleshoot common integration challenges.

---

## 1. Workflow Overview

### Task Description

This guide walks you through the process of integrating your GoogleTest and GoogleMock tests with CI systems. You'll learn how to automate building your test binaries, running tests automatically on each commit or merge, capturing test output, interpreting results, and managing common pitfalls.

### Prerequisites

- A working GoogleTest and GoogleMock test suite in your codebase.
- Your project configured with a build system (commonly CMake) that can build your test executables.
- Access to a CI environment (e.g., Jenkins, GitHub Actions, Travis CI, GitLab CI) with basic permissions to configure build and test steps.

### Expected Outcome

By the end, your CI environment will

- Automatically build your tests on code changes.
- Run all tests and capture results.
- Generate clear pass/fail reports.
- Provide actionable feedback on failures.

### Time Estimate

30 minutes to 1 hour, depending on CI familiarity and project complexity.

### Difficulty Level

Intermediate

---

## 2. Step-by-Step Instructions

### Step 1: Prepare Your Test Executable for CI

1. Ensure your tests link with either `gtest_main` or `gmock_main` libraries, which provide the `main()` entry point.

2. Confirm your test binary returns the result of `RUN_ALL_TESTS()` to signal success or failure to the CI system.

3. Verify your test executable runs successfully from the command line, producing output indicating passed and failed tests.

### Step 2: Configure Your Build Script

- If you’re using **CMake**, ensure your `CMakeLists.txt` can produce your test executable. Example snippet:

```cmake
add_executable(my_tests test_main.cpp other_test_files.cpp)
target_link_libraries(my_tests gtest_main gmock)
add_test(NAME my_tests COMMAND my_tests)
```

- This registers your tests with CTest if supported, which can be invoked in your CI pipeline.

### Step 3: Automate Build and Test Execution in Your CI

- **Jenkins:**
  - Add a build job that runs your build commands (e.g., `cmake`, then `make` or `ninja`).
  - Add a post-build step to run your tests, e.g., `ctest --output-on-failure` or directly run your test executable.

- **GitHub Actions:**
  - Create a workflow YAML with steps to checkout code, configure CMake, build, and run tests.

  ```yaml
  jobs:
    build_test:
      runs-on: ubuntu-latest
      steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: cmake -S . -B build
      - name: Build
        run: cmake --build build
      - name: Run Tests
        run: ctest --test-dir build --output-on-failure
  ```

- **Travis CI** or **GitLab CI**:
  - Similarly configure your `.travis.yml` or `.gitlab-ci.yml` to build and run tests.

### Step 4: Capture and Report Test Output

- Use your CI system’s built-in test reporting features (e.g., JUnit XML output)
- GoogleTest supports XML output format via the `--gtest_output` flag.

Example:

```bash
./my_tests --gtest_output=xml:report.xml
```

- Configure your CI to pick up this XML report for easier visualization.

### Step 5: Enable Test Result Thresholding and Failures

- Configure your CI to fail builds automatically if any test fails based on the return code from the test executable or test framework.

- Use flags like `--gtest_break_on_failure` during debugging phases to stop on the first failure or omit it for complete test runs.

### Step 6: Troubleshoot Common Integration Issues

- If tests don’t run or are not discovered:
  - Verify test macros (`TEST()`, `TEST_F()`) exist and are linked.
  - Check that your test binary actually includes tests (via `RUN_ALL_TESTS()`).

- Link errors:
  - Confirm linkage against `gtest`, `gmock`, or their `_main` variants appropriately.

- Environment Issues:
  - Ensure any platform-specific requirements are met, such as pthread availability or compiler support.

- Output Parsing:
  - Make sure you produce XML reports for CI UI consumption if supported.

---

## 3. Practical Examples

### Example: Minimal CMake Setup for CI

```cmake
cmake_minimum_required(VERSION 3.14)
project(MyProject)

find_package(GTest REQUIRED)

add_executable(run_tests test1.cpp test2.cpp)

target_link_libraries(run_tests GTest::gtest_main GTest::gmock)

enable_testing()
add_test(NAME MyTestSuite COMMAND run_tests)
```

### Example: Running Tests with XML Output

```bash
./run_tests --gtest_output=xml:results.xml
```

Your CI platform can then ingest `results.xml`.

---

## 4. Troubleshooting & Tips

<AccordionGroup title="Common Issues in CI Integration">
<Accordion title="Tests Not Running or Discovered">
Check that your test binaries link the appropriate GoogleTest or GoogleMock main function libraries (e.g., gtest_main). Also ensure tests use the GoogleTest macros like `TEST()` or `TEST_F()` properly inside the source files.
</Accordion>
<Accordion title="Build Failures or Linker Errors">
Verify that your build system links to `gtest`, `gmock`, and their respective `_main` libraries. If you build shared libraries, set `-DGTEST_CREATE_SHARED_LIBRARY=1` and `-DGTEST_LINKED_AS_SHARED_LIBRARY=1` accordingly.
</Accordion>
<Accordion title="CI Fails but Tests Pass Locally">
Consider resource constraints or environment differences like permissions or missing dependencies. Run tests locally inside a container or VM matching the CI environment.
</Accordion>
<Accordion title="Test Output Not Showing in CI Logs">
Use the `--output-on-failure` flag with `ctest` or configure your test executable with `--gtest_output=xml` to generate reports consumable by the CI system's test reporting UI.
</Accordion>
</AccordionGroup>

<Tip>
Automate test runs on every commit to catch regressions early. Use test result XML for clearer dashboards and easier failure diagnosis.
</Tip>

<Tip>
For large projects, leverage CTest integration to manage and parallelize test execution efficiently within your CI pipeline.
</Tip>

---

## 5. Next Steps & Related Content

- Explore [Mocking Functions and Objects](https://google.github.io/googletest/gmock_cook_book.html) to enhance your tests with mocks.
- Learn about [Setting Expectations and Behaviors](https://google.github.io/googletest/gmock_cook_book.html#setting-expectations) to write precise interaction tests.
- Dive deeper into [Structuring Effective Test Suites](https://google.github.io/googletest/structuring-tests.html) to organize large test collections.
- For advanced CI setups, see [Parameterizing Your Tests](https://google.github.io/googletest/parameterized_tests.html) to run tests with multiple inputs.

---

## References

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) - A gentle introduction to writing tests.
- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) - In-depth guidance for mocking.
- [GoogleTest Build, Configure, and Validate Guide](https://google.github.io/googletest/build.html) - Details on building and configuring your tests.
- [CTest Documentation](https://cmake.org/cmake/help/latest/manual/ctest.1.html) - For advanced test running and reporting.

---

## Summary

This page equips C++ developers and CI administrators to integrate GoogleTest and GoogleMock test executions into CI pipelines seamlessly. By following the detailed steps, users automate building, running, and reporting test results for continuous validation of their codebase with reliable feedback loops.

---

*End of guide.*