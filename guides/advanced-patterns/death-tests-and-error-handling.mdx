---
title: "Death Tests and Error Handling"
description: "Complete walkthrough for writing and using death tests to ensure correct error handling and failure modes in your code. Includes best practices for managing cross-platform differences."
---

# Death Tests and Error Handling

## Workflow Overview

### Purpose
This guide walks you through writing and using **death tests** in GoogleTest, an advanced testing strategy designed to verify that your code correctly handles fatal errors and abnormal termination scenarios. It covers best practices for writing death tests, managing expectations around failure modes, and handling cross-platform considerations. Death tests are vital for ensuring your code responds safely and predictably to critical failure conditions.

### Prerequisites
- Familiarity with basic GoogleTest usage, including writing tests using `TEST()` and fixtures.
- Understanding of assertions in GoogleTest, especially `EXPECT_*` and `ASSERT_*` macros.
- Access to a development environment supporting GoogleTest with death test support enabled (`GTEST_HAS_DEATH_TEST`).

### Expected Outcome
By completing this guide, you will be able to:
- Write reliable death tests using the macros `EXPECT_DEATH()`, `ASSERT_DEATH()`, `EXPECT_EXIT()`, and `ASSERT_EXIT()`.
- Understand how death tests work internally, including their execution models and failure detection.
- Apply best practices to handle threads, exceptions, and test isolation during death tests.
- Manage platform differences related to death test execution, especially on Windows, Linux, macOS, and Fuchsia.

### Time Estimate
~20-30 minutes for an initial understanding and to write your first death test.

### Difficulty Level
Intermediate to Advanced, due to the technical nature of process management and failure modes.

---

## Writing Death Tests: Step-by-Step

### 1. Understand What Death Tests Verify
Death tests check that a certain statement or code block terminates the process as expected. They ensure your program fails correctly when encountering invalid states or precondition violations.

Key things to verify in a death test:
- The process actually dies or exits.
- The exit status matches expectations (e.g., a particular exit code or signal).
- The output to `stderr` contains appropriate error messages matching a regex or matcher.

### 2. Use the Right Macros
GoogleTest provides several macros for death tests:

- `EXPECT_DEATH(statement, matcher)`
- `ASSERT_DEATH(statement, matcher)`
- `EXPECT_EXIT(statement, predicate, matcher)`
- `ASSERT_EXIT(statement, predicate, matcher)`
- `EXPECT_DEBUG_DEATH(statement, matcher)` and `ASSERT_DEBUG_DEATH(statement, matcher)` for debug-mode only death tests.
- Conditional macros `EXPECT_DEATH_IF_SUPPORTED` and `ASSERT_DEATH_IF_SUPPORTED` to account for platforms where death tests may not be available.

**When to use:**
- Use `ASSERT_*` to abort the current test on failure.
- Use `EXPECT_*` to continue running other tests or statements even if the death test fails.

### 3. Write a Simple Death Test

```cpp
TEST(MyDeathTest, DiesOnInvalidInput) {
  ASSERT_DEATH({  
    DoSomethingRisky(-1);  
  }, "Invalid input");  
}
```

This test verifies that calling `DoSomethingRisky(-1)` causes the program to terminate with an error message matching the regex `"Invalid input"`.

### 4. Use `EXPECT_EXIT` and Predicates for More Control
In cases where you want to check the exact exit code or the kind of signal that killed the process, use `EXPECT_EXIT` with predicates like `ExitedWithCode()` or `KilledBySignal()`.

Example:

```cpp
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");

EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "blockable signal exposed");
```

### 5. Consider Debug-Mode Specialized Death Tests
The `EXPECT_DEBUG_DEATH` and `ASSERT_DEBUG_DEATH` macros differ between debug and optimized builds:
- In debug builds, they act like regular death tests (assert the process dies).
- In optimized builds, they just run the code without failing.

Useful for code paths that are only fatal in debug builds.

### 6. Handle Multi-threaded Environments Carefully
Forking in multi-threaded processes is unsafe and may cause undefined behavior. GoogleTest:
- Warns if it detects multiple threads during death tests.
- Provides a "threadsafe" death test style where the test is re-executed in a subprocess from the start, running only the targeted death test.

You can specify the style via the flag:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

The two styles:
- `fast`: quick, directly runs a forked test function.
- `threadsafe`: safer, restarts the executable with only the death test.

### 7. Avoid Common Pitfalls

- Death tests must not have multiple death assertions on the same source line.
- Avoid `return` or `throw` statements in the death test `statement`; these cause failures.
- Do not expect side effects from the death test `statement` as it runs in a separate process.
- If your death test code frees or leaks memory, be aware that the parent process doesnâ€™t see those changes.
- Mocks that may leak due to early process exits should call `Mock::AllowLeak`.

### 8. Debugging Death Tests

- When a death test fails, GoogleTest reports detailed diagnostics including exit code/status and the stderr messages.
- Use verbose failure messages to understand why the test did not die or matched the wrong output.

---

## Examples

### Basic Death Test Example

```cpp
TEST(FooDeathTest, FailsOnBadInput) {
  ASSERT_DEATH(Foo(-1), "Invalid input");
}
```

### Death Test with Exit Code Predicate

```cpp
TEST(FooDeathTest, ExitsWithZero) {
  EXPECT_EXIT(foo.ExitCleanly(), ::testing::ExitedWithCode(0), "Done");
}
```

### Using a Matcher Object

```cpp
EXPECT_DEATH(foo.CrashOnInvalid(), ::testing::ContainsRegex("crash detected"));
```

### Debug-Mode Only Death Test

```cpp
EXPECT_DEBUG_DEATH(DEBUG_ASSERT(foo.IsValid()), "Check failed");
```

### Multiple Death Tests in a Loop

```cpp
for (int i = 0; i < 3; ++i) {
  EXPECT_DEATH(CallFunctionWith(i), "Fatal failure message") << "Iteration: " << i;
}
```

---

## Troubleshooting & Tips

### Common Issues

- **Death tests are not supported on your platform:** Macros like `EXPECT_DEATH_IF_SUPPORTED` will issue warnings but compile fine; in this case, tests don't actually verify death behavior.
- **Multiple threads active warning:** The parent process will warn if there are multiple threads during the death test; use the `threadsafe` style to mitigate.
- **Test does not die as expected:** Ensure the `statement` actually causes a crash or exit; use explicit exit or crash-inducing code for narrow failures.
- **Error messages don't match regex:** Double-check your regex syntax and the actual stderr output from the tested code.

### Best Practices

- Use the `*DeathTest` suffix for test suites that contain death tests. This is important because GoogleTest runs death test suites first to reduce multi-threading issues.
- Isolate death tests from normal tests when sharing fixtures by aliasing the fixture class to maintain separation.

```cpp
using FooDeathTest = FooTest;
```

- Use `SCOPED_TRACE` to improve failure diagnostics inside subroutines called by death tests.
- Avoid memory deallocation inside death tests, or explicitly allow leaks for mocks.

### Platform Considerations

- On Windows, death tests use process creation and pipes, always run in a thread-safe manner.
- On Linux/macOS, `fork()` or `clone()` plus optionally `exec()` is used.
- Fuchsia uses its own process and exception handling APIs.

### Performance Considerations

- Threadsafe death tests are slower due to process re-execution but safer in multi-threaded contexts.
- Use the `fast` style if your test environment is single-threaded or you prefer speed.

---

## Next Steps & Related Documentation

- Continue learning with [Writing Your First Test](../../getting-started/first-test-validation/writing-your-first-test) to master fundamental test writing.
- Deep dive into [Assertions Reference](../../reference/assertions.md#death) for more on death assertions.
- Learn about test fixtures and shared resources in [Test Fixtures](../../getting-started/first-test-validation/writing-your-first-test#test-fixtures).
- Explore advanced testing patterns with [Advanced GoogleTest Topics](../../docs/advanced.md), including handling exceptions and predicate assertions.
- For integrating death tests in your CI workflow, consult [Continuous Integration Workflows](../../guides/integration-best-practices/continuous-integration-workflows).

---

## Additional Technical Insight

GoogleTest internally manages death test execution using a combination of:

- Forking or spawning a child process.
- Communicating test results and error strings via pipes.
- Interpreting child exit code or signals with predicates like `ExitedWithCode` and `KilledBySignal`.
- Running tests in two modes:
  - Fast style: child runs the test code immediately after fork.
  - Threadsafe style: child restarts the executable with specific flags to isolate the test.

Death test failure messages are captured and formatted with clear labeled output indicating actual results and expected error patterns.

---

## Quick Reference Sample

```cpp
// Basic death test that expects call to die and error message to match regex.
TEST(MyDeathTest, DiesWithMessage) {
  ASSERT_DEATH(
      FailFunction(),
      "Check failed: file .+ line [0-9]+: Fatal condition");
}

// Testing an exit with specific exit code.
TEST(MyDeathTest, ExitsWithCodeZero) {
  EXPECT_EXIT(
      ExitFunction(), testing::ExitedWithCode(0), "Success");
}

// Debug-only death test.
TEST(MyDeathTest, DebugAssertionFailure) {
  EXPECT_DEBUG_DEATH(
      DebugAssertFail(), "Check failed: .*Assertion");
}

// Death test with message stream attachment.
TEST(MyDeathTest, MultipleDeathsInLoop) {
  for (int i = 0; i < 5; ++i) {
    EXPECT_DEATH(
        FunctionThatDies(i),
        "Error code: " + std::to_string(i)) << "Failed at iteration " << i;
  }
}
```

---

For comprehensive information, also consult the public header `gtest/gtest-death-test.h` and internal implementation details in `src/gtest-death-test.cc` for understanding platform-specific behavior and flags.

---