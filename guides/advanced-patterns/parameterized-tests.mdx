---
title: "Parameterized and Typed Tests"
description: "Instruction on using parameterized and typed tests to maximize reuse and coverage, including practical project examples and advice for balancing test flexibility and clarity."
---

# Parameterized and Typed Tests

GoogleTest provides powerful features to maximize test reuse and coverage through _parameterized_ and _typed_ tests. These features allow writing test patterns that run with multiple inputs or types, reducing code duplication and improving test clarity. This guide helps you leverage these features effectively, illustrates usage with practical examples, and offers advice on balancing flexibility with readability.

---

## Workflow Overview

- **Task Description**: Learn to write parameterized (value-driven) and typed (type-driven) tests with GoogleTest to test multiple inputs or types using a single test definition.
- **Prerequisites**: Basic familiarity with GoogleTest macros like `TEST`, `TEST_F`, and understanding of C++ templates.
- **Expected Outcome**: You will be able to create reusable test fixtures that accept parameters or types, instantiate them with various values or types, and run comprehensive test suites with minimal redundancy.
- **Time Estimate**: 20-30 minutes to grasp concepts and apply basic examples.
- **Difficulty Level**: Intermediate

---

## Parameterized Tests

Value-parameterized tests allow running the same test logic with different input values, eliminating repetitive boilerplate code.

### 1. Defining a Parameterized Test Fixture

Create a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type:

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Fixture members and setup as usual
};
```

### 2. Writing Parameterized Tests Using `TEST_P`

Use `TEST_P` macro to define tests that use the parameter:

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();             // Access test parameter
  EXPECT_TRUE(YourFunction(param));
}
```

### 3. Instantiating Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to provide test values:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values(1, 2, 3, 4));
```

Each value in `Values` results in a separate test instance. Test names will include indices for distinction:

- `MyInstantiation/FooTest.HandlesVariousInputs/0` runs with parameter = 1
- `MyInstantiation/FooTest.HandlesVariousInputs/1` runs with parameter = 2

### 4. Available Parameter Generators

GoogleTest provides versatile built-in parameter generators:

| Generator       | Description                                                        |
|-----------------|--------------------------------------------------------------------|
| `Range(begin, end[, step])` | Sequence of values starting at `begin` incremented by `step` (default 1), excluding `end`. |
| `Values(v1, v2, ...)`       | Explicit list of values.                                          |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Values from containers or iterator ranges.                     |
| `Bool()`                   | Generates `false` and `true`.                                    |
| `Combine(g1, g2, ..., gN)` | Cartesian product of multiple generators producing tuples.      |

### 5. Using `GetParam()`

Inside `TEST_P`, call `GetParam()` to retrieve the current test parameter, which can be any copyable C++ type.

### 6. Customizing Parameter Test Names

To generate readable test names based on parameters, specify a **name generator** function or functor:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamesExample,
    FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

Name suffixes must be unique and contain only alphanumeric characters or underscores.

### 7. Suppressing Instantiation Errors

If you declare a parameterized test suite but do not instantiate it, GoogleTest by default considers this an error. To allow a test suite without instantiation (e.g., in a library header), tag it:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);
```

### Practical Example

```cpp
class MyTest : public testing::TestWithParam<std::string> {
};

TEST_P(MyTest, HasLength) {
  EXPECT_GT(GetParam().length(), 0);
}

INSTANTIATE_TEST_SUITE_P(StringValues,
                         MyTest,
                         testing::Values("foo", "bar", "baz"));
```

This runs the `HasLength` test with three different string parameters.

---

## Typed Tests

Typed tests repeat the same test logic across a fixed list of C++ types, useful for testing templates or type-specific behavior.

### 1. Defining a Typed Test Fixture Template

Create a fixture template class parameterized by a type `T`:

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_;
  // Common setup for T
};
```

### 2. Associating Type List with a Test Suite Using `TYPED_TEST_SUITE`

Define a `Types` list and register it:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

### 3. Writing Typed Tests Using `TYPED_TEST`

Define tests using `TYPED_TEST`. Access the current type using `TypeParam`:

```cpp
TYPED_TEST(FooTest, DoesStuff) {
  TypeParam value = this->value_;
  // Test logic using TypeParam
}
```

You can write multiple `TYPED_TEST` tests per suite.

### 4. Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container_;
};

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

This runs the same empty test logic for both `std::vector<int>` and `std::list<int>`.

---

## Type-Parameterized Tests

Type-parameterized tests are similar to typed tests but enable defining test patterns that can be instantiated with different sets of types later, possibly multiple times. This is ideal for abstract interface testing.

### 1. Declaring a Type-Parameterized Test Suite with `TYPED_TEST_SUITE_P`

Declare a template fixture:

```cpp
template <typename T>
class InterfaceTest : public testing::Test {
  void DoTest();
};

TYPED_TEST_SUITE_P(InterfaceTest);
```

### 2. Defining Test Patterns with `TYPED_TEST_P`

Define tests that refer to `TypeParam`:

```cpp
TYPED_TEST_P(InterfaceTest, SupportsOperation) {
  TypeParam obj;
  EXPECT_TRUE(obj.Operation());
}
```

You can define multiple tests.

### 3. Registering Tests using `REGISTER_TYPED_TEST_SUITE_P`

Register all tests within the suite:

```cpp
REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, SupportsOperation, OtherTest);
```

### 4. Instantiating with Type Lists

Instantiate the registered suite for specific types with `INSTANTIATE_TYPED_TEST_SUITE_P`:

```cpp
using ImplTypes = ::testing::Types<ImplA, ImplB>;
INSTANTIATE_TYPED_TEST_SUITE_P(Implementations, InterfaceTest, ImplTypes);
```

### Practical Use

This pattern lets you write tests once in a header and have multiple implementations instantiate them to verify compliance, enabling scalable interface testing.

---

## Best Practices & Tips

- **Name Tests Clearly**: Avoid underscores in test and suite names for compatibility.
- **Balance Test Coverage and Readability**: Use parameterized tests to cover cases but break tests apart when scenarios differ significantly.
- **Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` for Abstract Tests**: Prevent unwanted test failures from uninstantiated test suites.
- **Custom Test Names Aid Debugging**: Leverage name generators to produce descriptive test names conveying parameter content.
- **Verify Test Parameter Types Match**: Ensure that parameter types in fixtures match the parameter generator values.

---

## Troubleshooting

- **Tests Not Running?**
  - Confirm you have instantiated all parameterized test suites.
  - Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` if intentional.
- **Name Generator Errors**
  - Ensure your test name generator functions produce unique, valid names.
- **Parameter Type Mismatches**
  - Verify that the parameter type declared in the fixture matches those provided by the generators.
- **Compilation Errors with Typed Tests**
  - Ensure the fixture template is correctly defined and inherits from `testing::Test`.

---

## Next Steps & Related Content

- Explore the [Writing and Running Unit Tests](../core-workflows/writing-tests.md) guide for foundational test writing.
- Learn about [Using Mocks for Dependency Isolation](../core-workflows/using-mocks.md) to enhance parameterized testing.
- Delve into [Assertions and Matchers](../core-workflows/assertions-matchers.md) to improve verification expressiveness.

---

For detailed API references, consult the [Testing Reference](../reference/testing.md) and related advanced topics in the [Advanced GoogleTest Topics](../advanced.md). Access the full repository and samples at the official [GoogleTest GitHub project](https://github.com/google/googletest).

---