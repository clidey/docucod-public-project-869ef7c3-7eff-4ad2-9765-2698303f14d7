---
title: "Parameterized & Typed Tests"
description: "Expand your test coverage efficiently by using parameterized and type-parameterized tests. Understand when and how to use these advanced features to test multiple scenarios and data types without duplicating code, boosting both test clarity and maintainability."
---

# Parameterized & Typed Tests

Efficiently extend your test coverage by leveraging GoogleTest's parameterized and type-parameterized testing features. These powerful tools enable you to write a single test logic and run it across a variety of input values or data types, avoiding code duplication and improving test clarity and maintainability.

---

## Workflow Overview

### What You Will Achieve

You will learn how to define and instantiate:

- **Value-Parameterized Tests**: Execute the same test code over multiple input parameters.
- **Typed Tests**: Reuse the same test logic for various C++ types.
- **Type-Parameterized Tests**: Create abstract test patterns applicably instantiated for different types later.

### Prerequisites

- Familiarity with basic GoogleTest concepts and writing simple tests using `TEST` and `TEST_F`.
- A working GoogleTest setup integrated into your C++ project.

### Expected Outcome

By following this guide, you will be able to:

- Write succinct tests that run for multiple parameters or types.
- Use GoogleTest macros and utilities to instantiate these tests with various data sets and type lists.
- Maintain clear and well-organized tests that scale with your codebase.

### Estimated Time

About 15–30 minutes depending on familiarity with testing concepts and code compilation.

### Difficulty Level

Intermediate

---

## Value-Parameterized Tests

These tests run the same test logic multiple times, each time with a different input parameter.

### Defining Value-Parameterized Tests

1. **Create a fixture class** inheriting from `testing::TestWithParam<T>`, where `T` is the type of the parameter:

    ```cpp
    class FooTest : public ::testing::TestWithParam<int> {
      // Setup members if needed
    };
    ```

2. **Write test cases using `TEST_P`** instead of `TEST` or `TEST_F`. Access the parameter inside the test with `GetParam()`:

    ```cpp
    TEST_P(FooTest, HandlesPositiveValues) {
      int param = GetParam();
      EXPECT_GT(param, 0);
      // Test logic using param
    }
    ```

### Instantiating Value-Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to define the parameter set for your tests.

- The first argument is a unique instantiation name (used as a prefix in test names).
- The second argument is the fixture class name.
- The third argument is a parameter generator (`Values`, `Range`, `Combine`, etc.).

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,    // Instantiation name
    FooTest,            // Test suite
    ::testing::Values(1, 2, 3, 5, 8));  // Parameter set
```

### Common Parameter Generators

| Generator           | Description                                               |
|---------------------|-----------------------------------------------------------|
| `Values(...)`       | List of explicitly specified parameter values.           |
| `ValuesIn(container)`| Parameter values from a container or array.               |
| `Range(begin, end)` | Sequence of values in a range `[begin, end)`.             |
| `Bool()`            | Boolean sequence {false, true}.                            |
| `Combine(generators...)` | Cartesian product of multiple generators producing tuples. |

### Naming Parameterized Tests

By default, test instances are named as `InstantiationName/TestSuiteName.TestName/i` where `i` is the zero-based index of the parameter.

You can customize this by passing a fourth argument to `INSTANTIATE_TEST_SUITE_P` — a function or functor generating name suffixes:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, FooTest, ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Practical Tips

- Use parameterized tests to cover multiple input cases with the same logic.
- When parameters are complex structures, consider implementing `PrintToString` for better test name readability.
- `Combine` lets you test multiple independent parameters together (e.g., different configurations).

<Check>
Remember: `INSTANTIATE_TEST_SUITE_P` must be called outside any function scope and before `RUN_ALL_TESTS()`. Ensure your parameters outlive test execution.
</Check>

---

## Typed Tests

Typed tests enable you to run the same test logic with multiple C++ types.

### Defining Typed Tests

1. **Write a test fixture template** parameterized over the type:

    ```cpp
    template <typename T>
    class MyTypedTest : public testing::Test {
     public:
      T value_ = T();
    };
    ```

2. **Specify the list of types using `Types<T...>`:**

    ```cpp
    using MyTypes = ::testing::Types<int, float, double>;
    TYPED_TEST_SUITE(MyTypedTest, MyTypes);
    ```

3. **Write typed test cases** using `TYPED_TEST`. Use `TypeParam` inside the test body to refer to the current type:

    ```cpp
    TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
      TypeParam val = this->value_;
      EXPECT_EQ(val, TypeParam{});
    }
    ```

### How Typed Tests Work

- GoogleTest generates one test instantiation per type listed in `Types`.
- Typed tests provide static type safety and template testing without duplicating code.

### Customizing Type Names

You can provide a custom name generator class with a static `GetName(int index)` method to produce human-friendly test names:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    else if constexpr (std::is_same_v<T, float>) return "Float";
    else return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## Type-Parameterized Tests

These are advanced typed tests where the set of types is not fixed when defining the tests, allowing test definitions and instantiations in separate translation units.

### Defining Type-Parameterized Tests

1. **Define the fixture template:**

    ```cpp
    template <typename T>
    class MyTypeParamTest : public testing::Test {
      // Test code here
    };
    ```

2. **Declare the test suite with `TYPED_TEST_SUITE_P`:**

    ```cpp
    TYPED_TEST_SUITE_P(MyTypeParamTest);
    ```

3. **Write the test cases using `TYPED_TEST_P`:**

    ```cpp
    TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
      TypeParam val{};
      EXPECT_TRUE(val == val);
    }
    ```

4. **Register all tests:**

    ```cpp
    REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething);
    ```

### Instantiating Type-Parameterized Tests

Use `INSTANTIATE_TYPED_TEST_SUITE_P` with a list of types to instantiate the tests:

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

### Advantages

- Separate test definition from type list, supporting modularity and reusability.
- Ideal for interface compliance tests applied to multiple implementations.

---

## Examples

### Example 1: Value-Parameterized Test with Integers

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEvenness) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0) << n << " is not even";
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8, 10));
```

This runs `CheckEvenness` test for numbers 2,4,6,8,10.

### Example 2: Typed Test for Integral Types

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, long, short>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsSigned) {
  EXPECT_TRUE(std::numeric_limits<TypeParam>::is_signed);
}
```

### Example 3: Type-Parameterized Test for Interface Compliance

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 public:
  T stack_;
};

TYPED_TEST_SUITE_P(StackTest);

TYPED_TEST_P(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.empty());
}

REGISTER_TYPED_TEST_SUITE_P(StackTest, IsEmptyInitially);

using Stacks = ::testing::Types<std::stack<int>, custom::Stack<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(DefaultStacks, StackTest, Stacks);
```

---

## Troubleshooting & Tips

<AccordionGroup title="Common Pitfalls & Solutions">
<Accordion title="Tests Not Running">
Ensure that `INSTANTIATE_TEST_SUITE_P` is called in the global scope (not inside functions or local scopes).
</Accordion>
<Accordion title="Parameter Types Not Matching">
Make certain the parameter type in your fixture matches the type used in generators.
Use type aliases or `ConvertGenerator` if conversion is needed.
</Accordion>
<Accordion title="Custom Parameter Names Are Not Applied">
Verify that the custom name generator passed to `INSTANTIATE_TEST_SUITE_P` is valid and returns unique, alphanumeric test name suffixes.
</Accordion>
<Accordion title="Typed Test Names Are Difficult to Read">
Implement a custom type name generator for `TYPED_TEST_SUITE` to produce meaningful, clear test names.
</Accordion>
</AccordionGroup>

<Tip>
To get the best test readability and maintenance, always keep parameter and type lists small, meaningful, and complemented with descriptive test names.
</Tip>

---

## Next Steps & Related Content

- Explore the [GoogleTest Primer](primer.md) to solidify fundamental testing concepts.
- Learn about [Assertions & Best Practices](assertions-best-practices.md) to write effective test checks.
- Dive into [Mocking Reference](mocking.md) to integrate mocks with parameterized tests.
- Check [Organizing Large Test Suites](organizing-test-suites.md) for advanced test suite management.


---

## Summary

GoogleTest's parameterized and typed tests empower you to rapidly expand test coverage by running tests on multiple sets of values or types without duplicating code. Value-parameterized tests use `TEST_P` along with parameter generators to test across input data, while typed tests let you write templated fixtures executed for different types. Type-parameterized tests further enhance abstraction by separating test definition and instantiation. Implementing these features systematically improves test clarity, maintainability, and efficiency.
