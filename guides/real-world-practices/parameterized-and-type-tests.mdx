---
title: "Parameterized and Type-Parameterized Tests"
description: "Walkthrough of value and type parameterized tests. Learn how to write tests that adapt to multiple inputs or data types and when to use each pattern for robust test coverage."
---

# Parameterized and Type-Parameterized Tests

## Overview

GoogleTest supports powerful mechanisms for writing tests that efficiently cover multiple inputs or types by reusing test logic. This page walks you through **value-parameterized tests** and **type-parameterized tests**â€”showing how to write tests that adapt to multiple values or data types and when to choose each pattern to achieve comprehensive and maintainable test coverage.

---

## Prerequisites

Before proceeding, ensure you have:

- A working GoogleTest environment with includes to `<gtest/gtest.h>`
- Familiarity with basic test writing using `TEST` and `TEST_F`
- Understanding of test fixtures and template basics in C++ (for typed tests)


## What You Will Learn

By following this guide, you will:
- Understand how to write **value-parameterized tests** to test with multiple input values
- Learn to create **typed tests** and **type-parameterized tests** that run the same test logic on multiple types
- See when to apply each approach for best test maintainability and clarity


## Time Estimate

This guide should take approximately 15-20 minutes to read and experiment with.


---

# Value-Parameterized Tests

Value-parameterized tests enable running the same test logic with different data values.

## How It Works

1. **Define a Fixture Class**
   - Derive from `testing::TestWithParam<T>`, where `T` is the parameter type.
   - This fixture class can contain common data and functions accessible to all tests.

2. **Write Parameterized Tests**
   - Use `TEST_P` to define tests that access the parameter with `GetParam()`.

3. **Instantiate Test Suite with Parameters**
   - Use `INSTANTIATE_TEST_SUITE_P` to generate tests over a range or set of values.


## Step-by-Step Example

<Steps>
<Step title="Create Test Fixture with Parameter Type">

```cpp
class FooTest : public ::testing::TestWithParam<int> { 
  // Fixture code here
};
```

- `int` is the type of the parameter in this case.
- This fixture can also have member functions and data.

</Step>
<Step title="Define Tests Using TEST_P">

```cpp
TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0) << value << " is not even";
}
```
- `GetParam()` provides access to the test parameter.
- Assertions can use this parameter for testing.

</Step>
<Step title="Instantiate the Test Suite with Values">

```cpp
INSTANTIATE_TEST_SUITE_P(EvenValues, FooTest, testing::Values(2, 4, 6, 8));
```
- Creates test instances named `EvenValues/FooTest.IsEven/0` and so on.
- You can use other generators like `Range`, `ValuesIn`, or combinations.

</Step>
</Steps>


## Naming Your Parameterized Tests

You may supply a functor or lambda to generate custom suffixes for test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyGroup, FooTest, testing::Values(2, 4, 6),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

This helps make test output meaningful.


---

# Typed Tests

Typed tests repeat the same test logic for a fixed list of types.

## When To Use Typed Tests

- You know in advance which types you want to test.
- The tests depend on templated types rather than values.
- You want to verify type-specific behaviors or interfaces.

## How It Works

1. **Define a Fixture Class Template:**

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  // Optional typedefs or static members
  using value_type = T;
};
```

2. **Define a Type List:**

```cpp
using MyTypes = ::testing::Types<int, float, double>;
```

3. **Assign the Types to the Test Suite:**

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. **Write Typed Tests Using `TYPED_TEST`:**

```cpp
TYPED_TEST(MyTypedTest, DoesSomethingCorrectly) {
  TypeParam var{};  // TypeParam refers to current type
  // ... test logic using var ...
  EXPECT_TRUE(SomeCheck(var));
}
```


## Complete Example

```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
  static T shared;
  T value = 0;
};

using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);

TYPED_TEST(FooTest, HasDefaultValue) {
  TypeParam val = this->value;
  EXPECT_EQ(val, 0);
  this->shared = TypeParam(1);
}

TYPED_TEST(FooTest, SharedIsAccessible) {
  EXPECT_EQ(this->shared, TypeParam(1));
}
```

- Separate tests are run for each type in MyTypes.
- Use `this->` or `TestFixture::` to access members of the fixture.


---

# Type-Parameterized Tests

Type-parameterized tests let you define the test pattern *once* and instantiate it with different type lists *multiple times* or in different translation units.

## When To Use

- You want to define reusable, generic tests for an interface or concept.
- You may not know the full type list when writing the tests.
- You want to instantiate the same tests with multiple type lists without redefining them.

## How It Works

1. **Define a Fixture Class Template:**

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {
 public:
  void Helper() {}
};
```

2. **Declare a Type-Parameterized Test Suite:**

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define Tests Using `TYPED_TEST_P`:**

```cpp
TYPED_TEST_P(MyTypeParamTest, TestA) {
  TypeParam val = 0;
  this->Helper();
  EXPECT_EQ(val, 0);
}

TYPED_TEST_P(MyTypeParamTest, TestB) {
  EXPECT_TRUE(true);
}
```

4. **Register Tests:**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestA, TestB);
```

5. **Instantiate with Type Lists:**

```cpp
using MyTypes = ::testing::Types<char, int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyGroup, MyTypeParamTest, MyTypes);
```

- You can instantiate multiple times with different type lists using different prefixes.


## Advanced: Using Custom Name Generators

You can specify a custom class with a static `GetName(int)` template method for naming test instances:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "Char";
    if constexpr (std::is_same_v<T, int>) return "Int";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypeParamTest, MyTypes, MyTypeNames);
```


---

# Best Practices and Tips

- **Choose Typed Tests when your types are known upfront** and the test logic depends on types but not values.
- **Choose Value-Parameterized Tests when your test inputs are values or parameters** that influence test behavior.
- Use **Type-Parameterized Tests** to write reusable generic test suites instantiated across multiple type-lists or translation units.
- Access fixture types and members carefully within typed tests via `TypeParam`, `this->`, and `TestFixture::`.
- Avoid underscore characters in test suite and test names to prevent naming issues in generated code.
- Provide **custom test name generators** to make output more readable and diagnostics clearer.
- Remember that **static members** in fixtures live across test instances and can be used to share setup or complex type-dependent data.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if a parameterized test is defined but not instantiated.


---

# Troubleshooting

- **Tests not running or reported as missing:** Make sure `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` are called for your parameterized or typed test suites.
- **Name clash errors:** Avoid underscore characters in test names and suite names.
- **Compilation errors with `TYPED_TEST` or `TYPED_TEST_SUITE`:** Check `using` aliases for type lists are properly defined and visible.
- **Accessing fixture members in templates:** Use `this->` or `TestFixture::` prefixes within test bodies to satisfy C++ rules.
- **Multiple instantiations of type-parameterized tests:** Use unique prefixes in `INSTANTIATE_TYPED_TEST_SUITE_P` to keep test names unique.


---

# Summary

You have learned how to increase test coverage effectively by:

- Writing **Value-Parameterized Tests** for multiple input values
- Writing **Typed Tests** to test multiple types known at compile time
- Writing **Type-Parameterized Tests** for reusable test patterns instantiated with varying type lists

By integrating these techniques, your tests become more concise, maintainable, and scalable.


---

# Additional Resources

- [GoogleTest Primer (Typed and Parameterized Tests section)](/docs/primer.md#typed-tests)
- [Testing Reference on Parameterized and Typed Tests](docs/reference/testing.md#TYPED_TEST_SUITE)
- [Advanced Topics on Typed and Parameterized Tests](/docs/advanced.md#typed-tests)
- [GoogleTest Typed Tests Implementation Header](googletest/include/gtest/gtest-typed-test.h)
- [GoogleTest Typed Tests Test Examples](googletest/test/gtest-typed-test_test.cc)


---

# Links

- [Value-Parameterized Tests Guide](../advanced.md#value-parameterized-tests)
- [Typed Tests Guide](../advanced.md#typed-tests)
- [Type-Parameterized Tests Guide](../advanced.md#type-parameterized-tests)


---

# Code Samples Recap

```cpp
// Value-Parameterized Test Example
class MyValParamTest : public ::testing::TestWithParam<int> {};

TEST_P(MyValParamTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(MyInts, MyValParamTest, testing::Values(1, 2, 3));
```

```cpp
// Typed Test Example
template <typename T>
class MyTypedTest : public ::testing::Test {};

using MyTypes = ::testing::Types<int, float>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  (void)val;  // Use val
  SUCCEED();
}
```

```cpp
// Type-Parameterized Test Example
template <typename T>
class MyTypeParamTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, Test1) { SUCCEED(); }
TYPED_TEST_P(MyTypeParamTest, Test2) { SUCCEED(); }

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, Test1, Test2);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyGroup, MyTypeParamTest, MyTypes);
```
