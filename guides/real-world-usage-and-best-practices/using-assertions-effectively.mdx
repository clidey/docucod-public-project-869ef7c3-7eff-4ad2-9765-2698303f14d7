---
title: "Using Assertions Effectively"
description: "Explore the wide range of GoogleTest assertions, from simple checks to advanced predicates and user-defined conditions. Discover tips for writing clear, meaningful assertions that help diagnose failures quickly."
---

# Using Assertions Effectively

Explore the wide range of GoogleTest assertions, from simple checks to advanced predicates and user-defined conditions. Discover tips for writing clear, meaningful assertions that help diagnose failures quickly.

---

## Overview of Assertions

Assertions are the fundamental building blocks for verifying behavior in GoogleTest. They check conditions in your test code and determine whether a test passes or fails. GoogleTest provides a rich set of assertion macros, structured to offer both simplicity and flexibility to match a variety of test needs.

### Assertion Types

- **Non-fatal Assertions (`EXPECT_*`)**: Log a failure but allow the test to continue. Use when you want to detect multiple errors in one run.
- **Fatal Assertions (`ASSERT_*`)**: Abort the current function on failure. Use when further test execution doesn't make sense after a failure.

Both kinds support streaming user messages with `<<` to give more context on failure.

### Key Features

- First-class support for Boolean checks, comparisons, string and floating-point equality, exception testing, predicates, and more.
- Semantically paired macros for each assertion to control test flow on failure.
- Custom predicate assertions that enable rich failure messages beyond simple true/false results.
- Support for comparing wide and narrow strings, with case-sensitive and case-insensitive variants.
- Assertion macros that evaluate arguments exactly once, preventing side effects from repeating.

---

## Practical Guide to Using Assertions

Follow these sequential steps to use assertions effectively in your tests.

### 1. Include GoogleTest Assertions

Add the header to your test file:

```cpp
#include <gtest/gtest.h>
```

This inclusion grants access to all assertion macros.

### 2. Use Built-in Assertions for Common Checks

Use the simplest macro corresponding to your check.

- **Boolean conditions:**
  - `EXPECT_TRUE(condition)` or `ASSERT_TRUE(condition)`
  - `EXPECT_FALSE(condition)` or `ASSERT_FALSE(condition)`

- **Equality and inequality:**
  - `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
  - `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`

- **Relational comparisons:**
  - `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
  - `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
  - `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
  - `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

- **C-string comparisons:**
  - `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`
  - `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`
  - Case-insensitive variants with `EXPECT_STRCASEEQ`, `EXPECT_STRCASENE`, etc.

- **Floating-point comparisons:**
  - `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)` (for `float`)
  - `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)` (for `double`)
  - `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`

- **Exception checks:**
  - `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
  - `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`
  - `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`

### 3. Stream Messages for Enhanced Diagnosis

Add contextual information to your assertions for faster debugging:

```cpp
ASSERT_EQ(foo.size(), bar.size()) << "Size mismatch detected";
EXPECT_TRUE(IsValid(foo)) << "Foo failed validation";
```

GoogleTest will append the streamed message to the failure output.

### 4. Use Predicate Assertions for Complex Conditions

If a built-in assertion doesn’t fit (e.g., complex conditions or custom checks):

- Use `EXPECT_PRED*` or `ASSERT_PRED*` macros with your Boolean predicate:

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, 4);  // Succeeds
EXPECT_PRED1(IsEven, 5);  // Fails with detailed output
```

- For richer messages, define a predicate returning `::testing::AssertionResult`:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  else
    return testing::AssertionFailure() << n << " is odd";
}
EXPECT_TRUE(IsEven(x));
```

- For full control of failure messaging, use predicate-format assertions:

```cpp
// Predicate-formatter function signature
// testing::AssertionResult PredFormat(const char* expr1, const char* expr2, ..., T val1, T val2, ...);
EXPECT_PRED_FORMAT2(PredFormat, val1, val2);
```

### 5. Avoid Common Pitfalls

- Don't use `ASSERT_*` in constructors or destructors, as it may not behave as expected.
- Be mindful that `ASSERT_*` aborts the current function only, so in helper functions, you might want to check `HasFatalFailure()` or use macros like `ASSERT_NO_FATAL_FAILURE`.
- Use `SCOPED_TRACE` to add context when calling shared subroutines with assertions to identify failing invocations clearly.

### 6. Use Skipping Assertions

Use `GTEST_SKIP()` inside tests or setup to mark tests as skipped dynamically:

```cpp
TEST(MyTest, MaySkip) {
  if (!HasRequiredFeature()) {
    GTEST_SKIP() << "Feature not available";
  }
  ... test code ...
}
```

---

## Examples

### Simple Equality Check

```cpp
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(3), 6) << "Factorial of 3 should be 6";
}
```

### Predicate Assertion with Custom Message

```cpp
// Checks if a number is prime.
bool IsPrime(int n) { ... }

EXPECT_PRED1(IsPrime, 11) << "11 should be prime";
```

### Predicate-Formatter with Detailed Explanation

```cpp
testing::AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " evaluates to " << n << ", which is odd.";
}

EXPECT_PRED_FORMAT1(AssertIsEven, 5);
```
Output on failure:
```
5 evaluates to 5, which is odd.
```

### Using `SCOPED_TRACE` to Trace Failures in Helper Functions

```cpp
void CheckValues(int x) {
  SCOPED_TRACE(testing::Message() << "Checking value " << x);
  EXPECT_GT(x, 0);
  EXPECT_LT(x, 10);
}

TEST(MyTest, ChecksRange) {
  for (int i = -1; i <= 11; ++i) {
    CheckValues(i);
  }
}
```
Failures will include information about the value being checked.

### Floating-point Approximate Equality

```cpp
EXPECT_FLOAT_EQ(3.14159f, my_pi);
ASSERT_NEAR(3.14, my_pi, 0.01);
```

### Exception Assertion

```cpp
EXPECT_THROW(DoSomething(), std::runtime_error);
ASSERT_NO_THROW(MakeConnection());
```

### String Equality

```cpp
EXPECT_STREQ("Hello", greeting.c_str());
ASSERT_STRCASEEQ("foo", "FOO");
```

---

## Troubleshooting and Best Practices

### Common Issues

- **Unexpected test continuations after `ASSERT_*` failure in subroutines:** Remember `ASSERT_*` only aborts current function; combining with `HasFatalFailure()` checks or `ASSERT_NO_FATAL_FAILURE()` can help.

- **Failure messages are unclear:** Use predicate assertions with custom messages or `EXPECT_THAT` with matchers for clearer diagnostics.

- **Assertions with side-effects evaluated multiple times:** GoogleTest guarantees single evaluation of assertion arguments; if you notice issues, verify your predicates.

- **Disabling or skipping tests unwittingly:** Beware `DISABLED_` prefixes or filters that exclude your tests.

### Best Practices

- Use `EXPECT_*` when you want all assertions to run, `ASSERT_*` when an early exit is required.
- Leverage streaming messages to explain **why** something should be true.
- Group multiple related checks in `EXPECT_NO_FATAL_FAILURE()` to propagate fatal failures.
- Improve readability with predicate assertions and custom formats.
- Use `SCOPED_TRACE` in helper functions for better context on failures.
- Avoid fatal assertions in constructors or destructors; perform setup/teardown in respective methods.

### Performance Considerations

- Minimize expensive operations inside assertions.
- Avoid complex expressions inside sensitive assertions; compute results upfront if needed.

### Alternative Approaches

- Use `EXPECT_THAT` with gMock matchers for expressive and composable assertions.
- Use `RegisterTest()` to programmatically define tests if macro usage is insufficient.

---

## Next Steps and Related Documentation

- **Writing Your First Test** – Get started with the basic test syntax.
- **Parameterized and Typed Tests** – Learn to write flexible, data-driven tests.
- **Structuring Tests for Maintainability** – Organize your test code for scalability.
- **Matchers Reference** – Explore powerful matchers for expressive assertions.
- **Test Output and Reporting** – Learn about test results interpretation and customization.

Refer to the [GoogleTest Primer](../primer.md) for foundational concepts, and [Assertions Reference](../reference/assertions.md) for comprehensive macros and examples.

---