---
title: "Parameterized and Typed Tests"
description: "Master value- and type-parameterized tests to maximize code coverage and reduce boilerplate. See real examples demonstrating how to test functions or classes with a variety of data types and value ranges efficiently."
---

# Parameterized and Typed Tests

## Overview

This guide helps you master *value-parameterized* and *type-parameterized* tests in GoogleTest. These testing techniques let you create flexible test suites that efficiently cover a variety of input values, types, or combinations without duplicating code. By leveraging parameterization, you maximize code coverage and reduce boilerplate, making your tests easier to maintain and extend.

You will learn how to:

- Define parameterized test fixtures.
- Write tests that receive parameters.
- Instantiate tests with sequences of values or types.
- Create custom parameter name generators.
- Use combined generators for complex test cases.

This guide assumes you are familiar with basic GoogleTest concepts such as `TEST`, `TEST_F`, and test fixtures. If not, please review the [GoogleTest Primer](primer.md) and the [Writing and Running Tests](api-reference/core-testing-apis/writing-tests.md) reference first.

## Prerequisites

- GoogleTest included and properly linked in your project.
- Basic understanding of writing tests with `TEST` and `TEST_F`.
- C++11 or higher support for lambdas and type inference.

## Time Estimate

Approximately 15-30 minutes to understand and apply parameterized and typed tests.

## Difficulty Level

Intermediate. Understanding templates and test fixtures is beneficial.

---

## 1. Value-Parameterized Tests

Value-parameterized tests enable you to write a test once and run it multiple times with different input values.

### 1.1 Defining a Parameterized Test Fixture

Create a test fixture class that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
#include <gtest/gtest.h>

class FooTest : public testing::TestWithParam<int> {
  // You can add shared setup or utility functions here.
};
```

### 1.2 Writing Parameterized Tests

Use the `TEST_P` macro to define tests that access their parameter via `GetParam()`.

```cpp
TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0) << "Value " << value << " is not even";
}
```

### 1.3 Instantiating Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to specify the sets of parameter values for test cases.

GoogleTest supports various parameter generators, including:

- `Values()` - explicit list of parameters.
- `ValuesIn()` - range, array, or container-based values.
- `Range()` - numeric parameter ranges.
- `Bool()` - boolean values.
- `Combine()` - Cartesian product of multiple generators.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, FooTest, testing::Values(2, 4, 6, 8));
```

This will run the test `IsEven` four times with parameters 2, 4, 6, and 8.

### 1.4 Using Combined Generators for Multiple Parameters

If your tests take multiple parameters (as a tuple), use `Combine()` to generate all combinations.

Example:

```cpp
class AnimalColorTest : public testing::TestWithParam<std::tuple<std::string, int>> {};

TEST_P(AnimalColorTest, CombinedTest) {
  auto [animal, color] = GetParam();
  EXPECT_FALSE(animal.empty());
  EXPECT_GT(color, 0);
}

INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalColorTest,
  testing::Combine(
    testing::Values("cat", "dog"),
    testing::Values(1, 2)
  )
);
```

This will create tests for all animal and color combinations.

### 1.5 Custom Parameter Name Generation

Parameter names in test outputs must be unique, non-empty, and can contain only alphanumeric characters and underscores. The default parameter names are usually indices.

You can provide a custom function or functor that formats test parameter names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This helps produce meaningful test names in reports.

### 1.6 Best Practices

- Keep parameter types copyable.
- Avoid complex parameter types unless necessary.
- Use `Combine()` for multiple parameters but limit combinatorial explosion.
- Write clear failure messages using streamed output `<<`.

---

## 2. Type-Parameterized Tests

Type-parameterized tests allow you to write test logic once and reuse it against multiple data types.

### 2.1 Defining a Typed Test Suite

Write a fixture template class parameterized on a typename `T`, deriving from `testing::Test`.

```cpp
#include <gtest/gtest.h>

template <typename T>
class TypedTest : public testing::Test {
 protected:
  T value_{};
};
```

### 2.2 Registering Types

Define a type list with the types you want to test using `::testing::Types<...>`.

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(TypedTest, MyTypes);
```

### 2.3 Writing Typed Tests

Use the `TYPED_TEST` macro instead of `TEST_F` to define tests. Inside, refer to the current type as `TypeParam`.

```cpp
TYPED_TEST(TypedTest, DefaultValueIsZero) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam{});
}
```

### 2.4 Instantiating Typed Tests

Typed tests automatically instantiate tests for all types declared in the `TYPED_TEST_SUITE`.

### 2.5 Type-Parameterized Test Suites

Type-parameterized tests are similar but allow defining an abstract suite and instantiating it later with different type lists.

Example:

```cpp
template <typename T>
class MyTypeParameterizedTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParameterizedTest);

TYPED_TEST_P(MyTypeParameterizedTest, TestName) { ... }

REGISTER_TYPED_TEST_SUITE_P(MyTypeParameterizedTest, TestName);

using MyConcreteTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTypeParameterizedTest, MyConcreteTypes);
```

### 2.6 Customizing Type Names

To generate meaningful test suite names, provide a custom name generator class with static template method `GetName(int)`.

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "int";
    if (std::is_same<T, double>::value) return "double";
    return "unknown";
  }
};

TYPED_TEST_SUITE(TypedTest, MyTypes, TypeNames);
```

---

## 3. Examples

### 3.1 Value-Parameterized Test Example

```cpp
class IsPositiveTest : public testing::TestWithParam<int> {};

TEST_P(IsPositiveTest, ValueIsPositive) {
  int val = GetParam();
  EXPECT_GT(val, 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveValues, IsPositiveTest, testing::Values(1, 10, 100));
```

### 3.2 Value-Parameterized Test with Multiple Parameters

```cpp
class MathOpTest : public testing::TestWithParam<std::tuple<int, int>> {};

TEST_P(MathOpTest, SumIsCorrect) {
  int a, b;
  std::tie(a, b) = GetParam();
  EXPECT_EQ(a + b, b + a);
}

INSTANTIATE_TEST_SUITE_P(
    IntegerPairs, MathOpTest,
    testing::Combine(testing::Values(1, 2), testing::Values(10, 20)));
```

### 3.3 Typed Test Example

```cpp
template <typename T>
class VectorTest : public testing::Test {
 protected:
  std::vector<T> v_;
};

using MyTypes = testing::Types<int, float>;
TYPED_TEST_SUITE(VectorTest, MyTypes);

TYPED_TEST(VectorTest, IsInitiallyEmpty) {
  EXPECT_TRUE(this->v_.empty());
}
```

---

## 4. Troubleshooting & Tips

### Common Issues

- **Not running tests:** Check that you instantiated parameterized tests with `INSTANTIATE_TEST_SUITE_P`.
- **Duplicate parameter names:** Ensure custom naming functions produce unique names.
- **Dangling references in `ConvertGenerator` lambdas:** Avoid returning string views to temporary strings.
- **Incorrect test suite or test names:** Verify your test and suite names contain no underscores `_`.

### Best Practices

- Always use `GetParam()` within `TEST_P` tests to access parameters.
- Use `Combine()` sparingly to prevent test explosion.
- Make parameter types simple and copyable.
- Use custom parameter name generators to improve test result readability.

### Performance Considerations

- Sharing expensive resources across parameterized tests requires thread-safe patterns.
- Avoid heavy computations in parameter generators.

### Alternative Approaches

- For testing multiple types but fixed values, typed tests may be better aligned.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings for unused parameterized tests.

---

## 5. Next Steps & Related Content

- Explore [Writing Your First Tests](guides/getting-started-core-workflows/writing-your-first-tests) to learn basic test creation.
- Consult [Using Assertions Effectively](guides/real-world-usage-and-best-practices/using-assertions-effectively) for deeper assertion usage.
- Learn about [Test Output and Reporting](guides/performance-and-specialized-use-cases/test-output-and-reporting) to customize and interpret test results.
- Dive into [Advanced GoogleTest Topics](docs/advanced.md) for sophisticated parameterized and typed testing patterns.


---

# References
- [GoogleTest Primer](primer.md)
- [Value-Parameterized Tests - Advanced Topics](docs/advanced.md#value-parameterized-tests)
- [Testing Reference - INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [Typed Tests - API Reference](api-reference/core-testing-apis/parameterized-testing.md#typed-tests)


---