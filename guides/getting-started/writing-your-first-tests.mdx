---
title: "Writing Your First Tests"
description: "Learn how to write basic and slightly more advanced unit tests with GoogleTest, using the core test and assertion macros. This guide walks through test case structure, using assertions, and understanding test results."
---

# Writing Your First Tests

Learn how to write basic and slightly more advanced unit tests with GoogleTest, using the core test and assertion macros. This guide walks you through test case structure, using assertions, and understanding test results.

---

## 1. Introduction to Writing Tests

### What This Guide Helps You Accomplish
This guide teaches you how to write simple, effective C++ tests using GoogleTest’s core macros, including `TEST()` and `TEST_F()`. You'll learn how to:

- Structure your tests properly.
- Use assertions to verify correctness.
- Organize tests into test suites and fixtures.
- Understand and interpret test results.

### Prerequisites
- Have GoogleTest integrated in your project and properly installed.
- Basic understanding of C++ programming.
- Familiarity with your project’s code that you want to test.

### Expected Outcome
After following this guide, you will be able to write and run your first unit tests with GoogleTest, organizing them effectively, and verifying your code’s behavior automatically.

### Time Commitment
About 15-30 minutes to grasp concepts and write initial tests.

### Difficulty Level
Beginner

---

## 2. Core Concepts for Writing Tests

### Tests and Test Suites
- **Test**: A single function verifying a particular case.
- **Test Suite**: A collection of logically related tests.

Tests are defined using the `TEST()` macro:

```cpp
TEST(TestSuiteName, TestName) {
  ... test code ...
}
```

Here, `TestSuiteName` groups related tests, and `TestName` identifies the individual test.

### Naming Conventions
- Use meaningful names with no underscores for suites and tests.
- The first argument to `TEST()` is the test suite name; the second is the test’s name.
- Tests in different test suites can have the same test name.

### Assertions
Assertions verify conditions inside tests. There are two key assertion types:

- **ASSERT_***: Fatal assertion; stops the current test function if failed.
- **EXPECT_***: Non-fatal assertion; test continues despite failure.

Example:

```cpp
EXPECT_EQ(value, expected_value) << "Failure explanation";
ASSERT_TRUE(condition);
```

Use `ASSERT_*` when the test cannot proceed meaningfully after a failure, and `EXPECT_*` when you want to test multiple conditions in one test.

### Writing Your First Simple Test

Suppose you want to test a function:

```cpp
int Factorial(int n);
```

Create tests to cover basic behaviors like:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

These tests verify that the function returns expected results for sample inputs.

---

## 3. Using Test Fixtures for Shared Setup

When multiple tests require the same data or configuration, *test fixtures* let you reuse setup logic.

### What Are Test Fixtures?
Test fixtures are classes derived from `testing::Test` that hold common data and setup code.

### How to Create a Fixture

1. Define a fixture class inheriting from `testing::Test`.
2. Put shared data members and setup/cleanup code inside.
3. Write tests using the `TEST_F()` macro with the fixture.

Example:

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Setup code for each test
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

### Important Notes for Fixtures
- Each test gets a fresh fixture.
- The `SetUp()` and `TearDown()` functions can be overridden for setup/cleanup.
- Name fixture classes logically after the feature or component they test.

---

## 4. Running Tests and Interpreting Results

### Typical Test Program Structure

Your `main` function should initialize GoogleTest and run all tests:

```cpp
#include <gtest/gtest.h>

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

Alternatively, link against `gtest_main` library to avoid writing your own main.

### Expected Test Output

- Tests that pass will report success.
- Failures print detailed info including file and line number.

Example failure message:

```
/path/to/test.cc:123: Failure
Expected equality of these values:
  Factorial(3)
    Which is: 5
  6
```

### Skipping and Disabling Tests

- Tests with names prefixed by `DISABLED_` are not run.
- You can skip tests at runtime using `GTEST_SKIP()` inside test code.

### Handling Test Failures

- Fatal failures stop the current test.
- Non-fatal failures allow the test to continue, reporting all issues.

Use `ASSERT_*` for unrecoverable errors, `EXPECT_*` otherwise.

---

## 5. Best Practices for Writing Tests

- Only test one aspect or behavior per test to keep failures focused.
- Use descriptive names for test suites and test cases.
- Keep tests independent of each other; no shared global state.
- Use `EXPECT_*` assertions unless test cannot meaningfully continue.
- Prefer test fixtures (`TEST_F`) when multiple tests share setup.
- Avoid unnecessary complexity; start simple and add as needed.

---

## 6. Troubleshooting Common Issues

### Test Not Running
- Confirm tests are linked and visible.
- Check naming and that test functions are defined correctly.
- Ensure `RUN_ALL_TESTS()` is called in `main`.

### Assertion Failures
- Read failure message carefully; it shows expected vs actual values.
- Check if test setup correctly initializes data.

### Tests Crashing
- Use `ASSERT_*` instead of `EXPECT_*` if dereferencing pointers.
- Check for null pointers or invalid memory access.

### Multiple Failures
- Use `EXPECT_*` to reveal all failures in one test pass.

---

## 7. Next Steps

Once comfortable with these basics, explore:

- Writing parameterized and typed tests.
- Using mocks with GoogleMock to control dependencies.
- Advanced assertions and failure handling.
- Best practices for scaling tests and maintaining suites.

Refer to:
- [GoogleTest Primer](primer.md)
- [Creating Mock Classes and Setting Expectations](/guides/mocking-techniques/mock-classes-expectations)
- [Effective Use of Assertions and Matchers](/guides/core-testing-workflows/using-assertions-matchers)

---

## Appendix: Minimal Working Example

```cpp
#include <gtest/gtest.h>

// Function under test
int Factorial(int n) {
  if (n <= 1) return 1;
  else return n * Factorial(n - 1);
}

// Simple test case
TEST(FactorialTest, HandlesZero) {
  EXPECT_EQ(Factorial(0), 1);
}

// Using fixture
class FactorialFixture : public testing::Test {
 protected:
  void SetUp() override {
    // Setup code if needed
  }
};

TEST_F(FactorialFixture, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(5), 120);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

This example shows how to write standalone and fixture-based tests for a simple function.
