---
title: "Essential Assertions and Failure Handling"
description: "Introduces the most common assertion macros, showing how to check for equality, inequality, exception handling, and failures. Details the difference between fatal and non-fatal failures in tests."
---

# Essential Assertions and Failure Handling

## Overview

This guide introduces the core assertion macros in GoogleTest that help you verify program correctness effectively. You will learn how to use the most common assertions for equality, inequality, exceptions, and handling failures. Additionally, it clarifies the difference between fatal and non-fatal failures and how they affect test execution.

---

## What You Will Achieve

- Understand and use essential GoogleTest assertion macros such as `EXPECT_EQ`, `ASSERT_TRUE`, `EXPECT_THROW`, and `FAIL`.
- Learn to differentiate between fatal and non-fatal failures and how to control test flow accordingly.
- Apply best practices for writing clear, maintainable assertions with informative failure messages.

---

## Prerequisites

- Basic knowledge of C++ programming.
- GoogleTest installed and integrated into your project.
- Familiarity with writing simple tests using `TEST()` or `TEST_F()` macros.

---

## Time Estimate

Following this guide and practicing the examples should take approximately 20 minutes.

---

## Fatal vs Non-Fatal Failures: What They Mean For Your Tests

GoogleTest assertions come in two primary forms:

- **Fatal Failures (`ASSERT_*`, `FAIL()`)**:  Upon failure, these immediately abort the current function. Use these when continuing the test makes no sense or might lead to crashes.
- **Non-Fatal Failures (`EXPECT_*`, `ADD_FAILURE()`)**: Upon failure, these report but allow the current function to continue. They are useful when you want to gather multiple failure points in a single test.


Understanding when to use each will help you design robust tests that provide clear diagnostics without crashing unexpectedly.

---

## Common Essential Assertions

### Boolean Condition Checks

Use these to verify conditions that evaluate to true or false.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

**Example:**
```cpp
TEST(FooTest, BooleanAssertions) {
  EXPECT_TRUE(IsPrime(7));
  ASSERT_FALSE(IsPrime(8));  // Fatal, test stops here if false
}
```

### Equality and Inequality

These macros compare two values and report detailed messages on failure.

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`

**Tips:**
- Use `ASSERT_` variants if the test cannot proceed meaningfully after a failure.
- For C strings (`const char*`), use string comparison macros instead.

**Example:**
```cpp
TEST(MathTest, EqualityAssertions) {
  EXPECT_EQ(Factorial(5), 120);
  ASSERT_NE(Add(2, 2), 5);
}
```

### Relational Comparisons

Check ordering relations with these macros:

- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`  (less than)
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`  (less or equal)
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`  (greater than)
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`  (greater or equal)

**Example:**
```cpp
TEST(SortTest, Ordering) {
  EXPECT_LT(MinValue({2,3,4}), 3);
  ASSERT_GE(MaxValue({2,3,4}), 4);
}
```

### String Comparisons

GoogleTest provides specialized macros for comparing C strings by content:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`  (equal)
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`  (not equal)
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`  (case-insensitive equal)
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`  (case-insensitive not equal)

**Example:**
```cpp
TEST(StringTest, Compare) {
  EXPECT_STREQ("Hello", "Hello");
  ASSERT_STRCASEEQ("hello", "HELLO");
}
```

### Floating-Point Comparisons

Floating-point values should not be compared with exact equality due to precision limitations.

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`  (approximate float equality)
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`  (approximate double equality)
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`  (absolute difference less than `abs_error`)

**Example:**
```cpp
TEST(MathTest, FloatComparisons) {
  EXPECT_FLOAT_EQ(ComputeFloat(), 3.14159f);
  ASSERT_NEAR(ComputeDouble(), 2.71828, 0.0001);
}
```

### Exception Assertions

These are used to verify that code throws or does not throw exceptions.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`

**Example:**
```cpp
TEST(ExceptionTest, Throws) {
  EXPECT_THROW(DoSomethingRisky(), std::runtime_error);
  ASSERT_NO_THROW(SafeFunction());
}
```

---

## Explicit Success and Failure

- `SUCCEED()` to generate a success explicitly; useful for documenting intended passes.
- `FAIL()` or `ASSERT_*` macros to generate fatal assertion failures that abort the test.
- `ADD_FAILURE()` to generate a nonfatal failure allowing the test to continue.

**Example:**
```cpp
TEST(MyTest, FailExample) {
  if (unexpected_condition) {
    FAIL() << "Unexpected condition met";
  }
  SUCCEED();  // Documented success point
}
```

---

## Propagating Fatal Failures from Subroutines

Keep in mind `ASSERT_*` macros abort *only* the current function, not the entire test, so:

- After calling a subroutine that may generate fatal failures, use `HasFatalFailure()` to stop further test execution if needed.
- Alternatively, wrap subroutine calls in `ASSERT_NO_FATAL_FAILURE()` or `EXPECT_NO_FATAL_FAILURE()` macros to assert that no fatal failures occurred inside.

**Example:**
```cpp
void Helper() {
  ASSERT_EQ(1, 2);  // Fatal failure, aborts Helper() only
}

TEST(FailurePropagationTest, HandlesAssertFailure) {
  Helper();
  if (HasFatalFailure()) return;  // Stops test early

  // Safe to continue now.
  EXPECT_EQ(3, 3);
}
```

---

## Using Custom Predicate Assertions for Clearer Diagnostics

When complex Boolean conditions are difficult to read in `EXPECT_TRUE()` or `EXPECT_FALSE()`, implement predicate functions that return `testing::AssertionResult`. These provide richer failure messages while still working seamlessly with the assertions.

**Example:**
```cpp
testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

TEST(PredicateTest, ClearFailureMessage) {
  EXPECT_TRUE(IsEven(3));  // Fails with message: "3 is odd"
}
```

You can also use predicate-formatter macros for more complex predicate assertions.

See the [Advanced Guide](../advanced.md#more-assertions) for more on predicates.

---

## Tips and Best Practices

- Prefer `EXPECT_*` for non-critical failures to continue the test and gather multiple failure points.
- Use `ASSERT_*` when continuing after failure could cause undefined behavior or cascading errors.
- Stream custom messages with `<<` to provide context and help diagnose failures.
- Use specialized string comparison assertions for C strings to avoid pointer comparison pitfalls.
- When comparing floating-point numbers, use `EXPECT_FLOAT_EQ` or `EXPECT_NEAR` instead of `EXPECT_EQ`.
- Avoid putting `ASSERT_*` macros in functions that return non-void types; use `EXPECT_*` or refactor accordingly.

---

## Troubleshooting

### Assertion Not Failing as Expected

- Confirm you are using the correct assertion macro (`EXPECT_` vs `ASSERT_`).
- Check if the condition expression evaluates as expected.
- For C string comparisons, use `EXPECT_STREQ` or related macros instead of `EXPECT_EQ`.

### Unclear Failure Messages

- Use predicates returning `AssertionResult` to improve failure diagnostics.
- Stream helpful messages using `<<` to give additional context.

### Fatal Failure Not Aborting Entire Test

- Remember that fatal failures abort only the current function.
- Use mechanisms like checking `HasFatalFailure()` to stop further test logic if needed.

---

## Summary

Mastering essential assertions helps you write clear and reliable tests. Use the appropriate assertion macros to check conditions, compare values, handle exceptions, and control test flow with fatal or non-fatal failures. Custom predicates and messages add expressiveness and clarity to failure reports, saving debugging time.

---

## Related Documentation & Resources

- [Assertions Reference](reference/assertions.md) — Complete list and details of assertion macros.
- [Advanced Guide: More Assertions](docs/advanced.md#more-assertions) — For sophisticated assertions and predicate usage.
- [Writing Your First Test](guides/getting-started/writing-first-test.mdx) — How to write basic test cases.
- [GoogleTest Primer](docs/primer.md) — An introductory guide.

---

## Code Examples

```cpp
// Basic Equality and Boolean
TEST(SampleTest, Basics) {
  int a = 5, b = 5;
  EXPECT_EQ(a, b) << "a and b should be equal";
  ASSERT_TRUE(a == b) << "a must equal b (fatal)";
}

// String Comparison
TEST(SampleTest, StringComparison) {
  const char* s1 = "hello";
  const char* s2 = "hello";
  EXPECT_STREQ(s1, s2) << "Strings should match";
}

// Floating Point Comparison
TEST(SampleTest, FloatComparison) {
  float pi = 3.14159f;
  EXPECT_FLOAT_EQ(pi, 3.14159f);
  EXPECT_NEAR(pi, 3.14f, 0.01f);
}

// Exception Checking
TEST(SampleTest, Throws) {
  EXPECT_THROW(throw std::runtime_error("fail"), std::runtime_error);
  EXPECT_NO_THROW(int x = 5);
}

// Explicit Fail
TEST(SampleTest, FailExample) {
  if (unexpected_condition) {
    FAIL() << "Unexpected condition happened";
  }
  SUCCEED();
}
```
