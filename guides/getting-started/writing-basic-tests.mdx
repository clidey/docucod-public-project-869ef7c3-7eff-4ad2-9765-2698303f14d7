---
title: "Writing Your First Tests"
description: "Step-by-step instructions for authoring basic GoogleTest unit tests. Understand test structure, common assertion macros, and how to organize tests for maintainability. Includes simple examples for both functions and classes."
---

# Writing Your First Tests

## Workflow Overview

### Task Description
This guide helps you write your first basic unit tests using GoogleTest. You will learn how to structure tests using the `TEST` and `TEST_F` macros, understand common assertion macros, and organize your tests to ensure maintainability and clarity.

### Prerequisites
- A working GoogleTest development environment.
- Basic familiarity with C++ syntax.
- Your project should be configured to include GoogleTest headers and link against its libraries.

### Expected Outcome
By following this guide, you will be able to write simple tests for both functions and classes, run them, and interpret their results effectively.

### Time Estimate
Approximately 15 to 30 minutes.

### Difficulty Level
Beginner

---

## Step-by-Step Instructions

<Steps>
<Step title="Write a Basic Test Using `TEST` Macro">
Use the `TEST(TestSuiteName, TestName)` macro to define a basic test as a standalone function.

1. Choose a descriptive and valid C++ identifier for your test suite and test name without underscores.
2. Write test statements inside the macro body.
3. Use GoogleTest assertions to verify the expected behavior.

Example:
```cpp
// A simple function to test
int Factorial(int n);  // Returns factorial of n

// Tests factorial of zero.
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

// Tests factorial of positive numbers.
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

After compiling, running the tests will show if these expectations hold true.

<Check>
GoogleTest groups tests by their test suite name (`FactorialTest`). Tests within the same suite must have unique test names.
</Check>
</Step>

<Step title="Use Test Fixtures for Shared Setup with `TEST_F`">
When multiple tests require the same setup or shared objects, create a test fixture:

1. Define a class inheriting from `testing::Test`.
2. Place shared objects and setup code in the constructor or `SetUp()` method.
3. Write individual tests using `TEST_F(FixtureName, TestName)`.

Example:
```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Prepare test queues
    q0_.Clear();
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

Test fixtures ensure each test runs independently with a fresh setup.

<Info>
GoogleTest creates a new instance of the fixture class for each test, guaranteeing test isolation.
</Info>
</Step>

<Step title="Use Assertions to Verify Expected Outcomes">
Within test bodies, use assertion macros to check conditions:

- `EXPECT_*` macros generate nonfatal failures and allow tests to continue.
- `ASSERT_*` macros generate fatal failures and abort the current test.

Common assertions:
```cpp
EXPECT_EQ(val1, val2);     // Check equality
ASSERT_NE(ptr, nullptr);   // Check pointer non-nullness
EXPECT_TRUE(condition);    // Check boolean condition
EXPECT_STREQ(str1, str2);  // Check C-style string equality
...
```

Example:
```cpp
TEST(SampleTest, Equality) {
  int x = 5;
  int y = 5;
  EXPECT_EQ(x, y) << "x and y should be equal";
}
```

<Warning>
Use `ASSERT_*` if continuing the test makes no sense after failure (e.g., dereferencing a null pointer).
</Warning>
</Step>

<Step title="Build and Run Your Tests">
1. Compile your test source files with GoogleTest headers and libraries.
2. Link into an executable.
3. Run the test binary; it will automatically discover and run all tests.

Typical invocation if you have your main:
```cpp
int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

You will see concise output summarizing test results.

<Tip>
GoogleTest automatically registers your tests; no need to manually list them.
</Tip>

</Step>
</Steps>

---

## Examples & Sample Code

### Simple Test Example
```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(3), 6);
}
```

### Test Fixture Example
```cpp
class StackTest : public testing::Test {
 protected:
  StackTest() {
    s_.Push(42);
  }
  Stack<int> s_;
};

TEST_F(StackTest, IsNotEmptyAfterPush) {
  EXPECT_FALSE(s_.IsEmpty());
}

TEST_F(StackTest, ReturnsCorrectElementOnPop) {
  int val = s_.Pop();
  EXPECT_EQ(val, 42);
}
```

### Useful Assertions Reference
- `EXPECT_EQ(val1, val2);`
- `ASSERT_NE(ptr, nullptr);`
- `EXPECT_TRUE(condition);`
- `EXPECT_STREQ(str1, str2);`
- `EXPECT_THROW(statement, ExceptionType);`

For the full list, see the [Assertions Reference](reference/assertions.md).

---

## Troubleshooting & Tips

### Common Issues
- **Test Names Invalid:** Test suite and test names must be valid C++ identifiers without underscores `_` to avoid internal macro conflicts.
- **Constructor Missing Default:** When using `TEST_F`, your fixture class must have a public default constructor.
- **ASSERT_* Used in Non-void Function:** `ASSERT_*` macros can only be used in functions returning `void`.
- **Tests Not Discovered:** Ensure you call `testing::InitGoogleTest` before `RUN_ALL_TESTS()`.

### Best Practices
- Use `TEST` for simple tests without shared setup.
- Use `TEST_F` when multiple tests share setup or cleanup logic.
- Prefer `EXPECT_*` for non-fatal assertions inside tests to uncover as many failures as possible.
- Use `ASSERT_*` when subsequent code depends on the success of the assertion.

### Performance Considerations
- Keep tests isolated and independent; avoid shared mutable global state.
- Use fixtures to efficiently organize setup without duplicating code.

### Alternative Approaches
For advanced scenarios, consider value-parameterized tests or typed tests to cover multiple data variations without duplicating code. See the guides on [Parameterized and Typed Tests](/guides/core-workflows/parameterized-testing).

---

## Next Steps & Related Content

- **Run Your Tests:** Learn how to execute and filter test runs [Running Your Tests](/getting-started/first-test-run/run-tests).
- **Assertions Deep Dive:** Explore advanced assertions and matchers [Mastering Assertions and Matchers](/guides/core-workflows/assertions-and-matchers) and [Assertions Reference](reference/assertions.md).
- **Fixtures and Test Organization:** Explore fixtures in detail in [Test Macros and Fixtures](/api-reference/core-testing-api/test-macros-and-fixtures).
- **Parameterize Tests:** Check out [Parameterized and Typed Tests](/guides/core-workflows/parameterized-testing) for scalable testing approaches.
- **Mocking:** Integrate mock objects with [Using GoogleMock Basics](/guides/getting-started/using-googlemock).

For a full beginner’s experience, start with the [GoogleTest Primer](docs/primer.md).

---

## Additional Resources
- [GoogleTest Primer](docs/primer.md) — foundational concepts and workflows
- [Testing Reference](docs/reference/testing.md) — comprehensive API for test writing
- [Assertions Reference](docs/reference/assertions.md) — detailed assertion macros
- [Googletest Samples](docs/samples.md) — practical example tests
- [GoogleTest README & Build Instructions](googletest/README.md) — setup/build instructions



