---
title: "First Mock: Simulating Dependencies"
description: "Introduces mocking basics with a simple, complete workflow: creating a mock class, setting expectations, specifying behaviors, and using assertions to verify interaction. Readers will understand when and why to use mocks to isolate logic under test."
---

# First Mock: Simulating Dependencies

## Workflow Overview

This guide introduces the essentials of mocking dependencies using GoogleMock, guiding you through creating a mock class, setting expectations, defining behaviors, and verifying interactions with assertions. It is designed to help you isolate the logic under test by simulating dependencies, enabling more focused and reliable unit tests.

---

### What You Will Learn
- How to create a simple mock class from an interface or abstract class.
- How to set expectations describing how the mock is expected to be called.
- How to specify the behavior of mock methods using actions.
- How to use GoogleTest assertions to verify the correctness of your code when it interacts with mocks.

### Prerequisites
- Basic knowledge of C++ programming.
- Familiarity with virtual functions and inheritance in C++.
- GoogleTest and GoogleMock installed and configured in your environment.

### Expected Outcome
After following this guide, you will be able to write tests that use mock objects to simulate dependencies, set precise expectations on their interactions, and verify that your system under test behaves as intended.

### Time Estimate
Approximately 20-30 minutes for reading and practicing the examples.

### Difficulty Level
Beginner to Intermediate

---

## Step-by-Step Instructions

### Step 1: Define a Mock Class

Start by creating a mock class that inherits from the interface or abstract class you want to mock. Use the `MOCK_METHOD` macro to declare mock methods corresponding to the virtual functions.

**Example:** Given a pure virtual class `Foo`:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};
```

You define a mock as:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

> **Tip:** Ensure the destructor in the base class is virtual for proper cleanup.

### Step 2: Create the Mock Object

In your test, instantiate the mock object:

```cpp
MockFoo mock_foo;
```

### Step 3: Set Default Behaviors (Optional)

Use `ON_CALL` to define default responses for mock methods when you don't want to enforce strict expectations on calls.

```cpp
using ::testing::Return;

ON_CALL(mock_foo, GetSize())
    .WillByDefault(Return(1));  // Returns 1 for all calls if no expectation overrides it
```

### Step 4: Define Expectations

Use `EXPECT_CALL` to specify how the mock is expected to be used. Expectations control:
- Which methods are expected to be called.
- How many times they should be called.
- The arguments with which they are called.
- The behavior (return values or side effects) on each call.

Example:

```cpp
EXPECT_CALL(mock_foo, Describe(5))
    .Times(3)
    .WillRepeatedly(Return("Category 5"));
```

This states that `Describe()` must be called three times with the argument `5`, and will always return "Category 5".

### Step 5: Exercise the Code Under Test

Pass the mock object to the component or function being tested. Exercise the functionality that is expected to interact with the mock.

```cpp
EXPECT_EQ(MyProductionFunction(&mock_foo), "good");
```

### Step 6: Verification

When the mock object goes out of scope (is destructed), GoogleMock automatically verifies that all expectations were satisfied. If any expectation was unmet or violated, the test will fail.

You can also force verification earlier using:

```cpp
using ::testing::Mock;

Mock::VerifyAndClearExpectations(&mock_foo);
```

> **Note:** Never set new expectations after verification or exercising the mock.

---

## Practical Example

Here is a complete example illustrating the full workflow:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <string>

using ::testing::Return;
using ::testing::_;

// Interface to be mocked
class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(int type) = 0;
};

// Mock class
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
};

// Function under test
std::string MyProductionFunction(Foo* foo) {
  if (foo->GetSize() > 0) {
    return foo->Describe(5);
  }
  return "bad";
}

// Test case
TEST(MyProductionFunctionTest, ReturnsGoodWhenDescribeCalled) {
  MockFoo mock_foo;

  ON_CALL(mock_foo, GetSize()).WillByDefault(Return(1));

  EXPECT_CALL(mock_foo, Describe(5))
      .Times(3)
      .WillRepeatedly(Return("Category 5"));

  // Call MyProductionFunction multiple times to match the expectation
  EXPECT_EQ(MyProductionFunction(&mock_foo), "Category 5");
  EXPECT_EQ(MyProductionFunction(&mock_foo), "Category 5");
  EXPECT_EQ(MyProductionFunction(&mock_foo), "Category 5");
}
```

**What happens here:**
- `MockFoo` simulates `Foo`.
- `GetSize()` returns 1 by default (via `ON_CALL`).
- `Describe(5)` is expected exactly 3 times and will return "Category 5".
- The function under test calls those methods as needed.
- GoogleMock verifies all interactions at test teardown.

---

## Tips and Best Practices

- **Set expectations before exercising the mock.** Setting expectations after calls leads to undefined behavior.
- **Use matchers to keep tests flexible.** For example, `_` matches any argument, avoiding brittle tests.
- **Use `NiceMock` to suppress warnings about uninteresting calls** if you do not care about certain methods.
- **Use sequences or `.RetiresOnSaturation()` to control expectation lifetimes** for ordered or repeated calls.
- **Prefer `ON_CALL` for behavior defaults, and `EXPECT_CALL` to verify specific invocations.** Overusing `EXPECT_CALL` makes tests brittle.
- **Always have a virtual destructor in your base classes** to avoid memory and deletion issues with mocks.

---

## Troubleshooting

### Common Issues and Solutions

| Issue                                      | Cause & Solution                                                         |
|--------------------------------------------|-------------------------------------------------------------------------|
| Expectation not met error                   | Verify that the expected calls happen the expected number of times.     |
| "Uninteresting function call" warning    | Use `NiceMock` if calls are unimportant or add explicit `EXPECT_CALL`.   |
| Compilation errors on `MOCK_METHOD` macro | Check method signatures, ensure `override` and const specifiers match.  |
| Mock object not destroyed (no verification) | Ensure mock is not leaked, or call `Mock::VerifyAndClearExpectations()` explicitly. |
| Destructor not called on mock object       | Make sure base class destructor is virtual.                             |

---

## Next Steps & Related Content

- Explore the [GoogleTest Primer](primer.md) to learn more about test writing fundamentals.
- Dive into the [gMock Cookbook](gmock_cook_book.md) for advanced mocking techniques.
- Refer to the [Mock Class and Method APIs](../api-reference/mocking-and-matcher-api/mock-methods-api.md) for detailed API.
- See [Writing Your First Test](writing-and-running-first-test.md) for end-to-end test creation.
- Use [Matchers Reference](reference/matchers.md) and [Actions Reference](reference/actions.md) to refine your mock interactions.

---

# Summary
This guide equips you to simulate dependencies via mocks in C++, enabling isolation of the unit under test and verification of its interactions. By defining mock classes, setting expectations, specifying behaviors, and verifying calls with assertions, you gain control over testing complex code with external dependencies. The walkthrough is complete with practical examples, tips for robust tests, and troubleshooting advice.


