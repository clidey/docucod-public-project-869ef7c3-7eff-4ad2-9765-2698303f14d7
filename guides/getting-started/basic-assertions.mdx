---
title: "Essential Assertions and Matchers"
description: "Explore the most widely used assertions and matchers in practice, with concrete examples. Teaches the difference between various assertion macros and how to make effective use of GoogleTest's and GoogleMock's matcher libraries."
---

# Essential Assertions and Matchers

Explore the most widely used assertions and matchers in practice, with concrete examples. This guide clarifies the differences between various assertion macros and shows how to effectively use GoogleTest's and GoogleMock's matcher libraries.

---

## 1. Introduction: What You Will Achieve

This guide equips you to write powerful and expressive tests in GoogleTest by mastering assertions and matchers. You will learn:
- How to choose and use the right assertion macro
- How to distinguish between fatal and nonfatal failures
- How to leverage GoogleMock's expressive matcher library with `EXPECT_THAT`
- How to write clearer tests and failure messages using predicate and predicate-format assertions

### Prerequisites
- Basic knowledge of C++ and unit testing
- GoogleTest set up in your project with `#include <gtest/gtest.h>`

### Expected Outcome
You will be able to write robust tests that clearly state expectations and provide meaningful failure diagnostics.

### Difficulty Level
Intermediate - requires familiarity with basic testing concepts and syntax.

---

## 2. Understanding GoogleTest Assertions

GoogleTest assertions are macros that verify program states during tests. They come in two fundamental variants:

- **`EXPECT_`** assertions: Generate nonfatal failures, allowing the test to continue.
- **`ASSERT_`** assertions: Generate fatal failures, aborting the current function immediately.

Both variants serve different purposes depending on whether the test should proceed after failure.

### 2.1. Explicit Success and Failure Assertions

- `SUCCEED()` – generates a success signal (purely documentary).
- `FAIL()` – generates a fatal failure, aborting the current function.
- `ADD_FAILURE()` – generates a nonfatal failure without aborting.

**Example:**
```cpp
switch(expression) {
  case 1:
    // Some checks...
    break;
  case 2:
    // Some other checks...
    break;
  default:
    FAIL() << "Unexpected value.";
}
```

### 2.2. Boolean Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)` verifies `condition` is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)` verifies `condition` is false.

**Example:**
```cpp
EXPECT_TRUE(IsValid(input)) << "Input validation failed";
```

### 2.3. Binary Comparison Assertions

Compare two values using operators: `==, !=, <, <=, >, >=`.

| Macro       | Meaning                                     |
|-------------|---------------------------------------------|
| `EXPECT_EQ` / `ASSERT_EQ`  | Verify equality (`==`)                  |
| `EXPECT_NE` / `ASSERT_NE`  | Verify inequality (`!=`)                |
| `EXPECT_LT` / `ASSERT_LT`  | Verify less than (`<`)                  |
| `EXPECT_LE` / `ASSERT_LE`  | Verify less than or equal (`<=`)       |
| `EXPECT_GT` / `ASSERT_GT`  | Verify greater than (`>`)               |
| `EXPECT_GE` / `ASSERT_GE`  | Verify greater than or equal (`>=`)    |

**Important:**
- When comparing pointers, these macros check address equality, not content equality.
- Use string-specific assertions for C-string content comparisons.

**Example:**
```cpp
ASSERT_EQ(result.size(), expected_size) << "Size mismatch";
EXPECT_LT(value, 100);
```

### 2.4. String Comparison Assertions

Specialized for comparing **C strings** (`const char*` or `wchar_t*`):

| Macro           | Meaning                              |
|-----------------|------------------------------------|
| `EXPECT_STREQ` / `ASSERT_STREQ`  | Compare strings for equality       |
| `EXPECT_STRNE` / `ASSERT_STRNE`  | Compare strings for inequality     |
| `EXPECT_STRCASEEQ` / `ASSERT_STRCASEEQ`  | Case-insensitive equality     |
| `EXPECT_STRCASENE` / `ASSERT_STRCASENE`  | Case-insensitive inequality   |

**Note:** 
- These macros compare the contents rather than pointers.
- Wide strings are accepted and printed in UTF-8 form.

**Example:**
```cpp
EXPECT_STREQ(expected_c_str, actual_c_str);
EXPECT_STRCASEEQ("hello", "HELLO");
```

### 2.5. Floating-Point Comparisons

Due to imprecision, use special assertions for floating-point:

| Macro               | Meaning                                                 |
|---------------------|---------------------------------------------------------|
| `EXPECT_FLOAT_EQ` / `ASSERT_FLOAT_EQ`    | Compare `float` values approx. equal (within 4 ULPs)   |
| `EXPECT_DOUBLE_EQ` / `ASSERT_DOUBLE_EQ`  | Compare `double` values approx. equal (within 4 ULPs)  |
| `EXPECT_NEAR` / `ASSERT_NEAR`            | Compare within absolute error bound                     |

**Example:**
```cpp
EXPECT_DOUBLE_EQ(result, 3.1415);
EXPECT_NEAR(calculated, expected, 1e-6);
```

### 2.6. Exception Assertions

Requires exceptions enabled. Verify that code throws or does not throw exceptions.

- `EXPECT_THROW(statement, ExceptionType)` / `ASSERT_THROW(statement, ExceptionType)` verifies that `statement` throws an exception of type `ExceptionType`.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)` verifies that `statement` throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)` verifies no exception is thrown.

**Example:**
```cpp
EXPECT_THROW(FunctionThatShouldThrow(), std::runtime_error);
EXPECT_NO_THROW(SafeFunction());
```

### 2.7. Predicate Assertions for Complex Conditions

When you want to verify complex conditions with clearer failure messages than `EXPECT_TRUE`, use predicate assertions.

- `EXPECT_PREDn(pred, val1, val2, ..., valn)` / `ASSERT_PREDn(pred, ...)` where `pred` is a function or functor returning `bool`.

- `EXPECT_PRED_FORMATn(pred_fmt, val1, ...)` / `ASSERT_PRED_FORMATn(pred_fmt, ...)` where `pred_fmt` is a predicate-formatter returning `AssertionResult` that allows customized messages.

**Example:**
```cpp
bool IsPrime(int n) { ... }
EXPECT_PRED1(IsPrime, 7);

// Predicate formatter example
AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << expr << " is not even, got " << n;
}
EXPECT_PRED_FORMAT1(AssertIsEven, x);
```

### 2.8. Generalized Assertions with Matchers

Using `EXPECT_THAT(value, matcher)` and `ASSERT_THAT(value, matcher)` you can harness GoogleMock's extensive matcher library for expressive, readable assertions.

Matchers read like English and generate detailed failure messages; for example:

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(name, StartsWith("Hello"));
EXPECT_THAT(text, MatchesRegex("^\\w+\\s.*"));
ASSERT_THAT(number, AllOf(Gt(5), Lt(10)));
```

Use `EXPECT_THAT` to express complex expectations about data, collections, and strings.

---

## 3. Practical Tips & Best Practices

- Prefer `EXPECT_` over `ASSERT_` when possible to allow tests to report multiple failures.
- Use string-specific assertions for comparing C strings, not `EXPECT_EQ`.
- For comparing floating-point numbers, prefer `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` to handle rounding errors.
- Use predicate assertions or matchers for complex conditions to communicate intent clearly.
- When verifying process death or exceptions, use death tests (`EXPECT_DEATH`, `ASSERT_DEATH`) or exception assertions.
- Add custom failure messages with the `<<` operator to aid debugging.

---

## 4. Examples

### 4.1. Using Basic Assertions

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  ASSERT_GT(Factorial(5), 0) << "Result should be positive";
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
}
```

### 4.2. String Comparison

```cpp
TEST(StringTest, EqualStrings) {
  const char* expected = "hello";
  const char* actual = GetGreeting();
  EXPECT_STREQ(expected, actual) << "Greetings don't match";
}
```

### 4.3. Floating-Point Comparison

```cpp
TEST(FloatTest, ApproxEqual) {
  float result = Compute();
  EXPECT_FLOAT_EQ(result, 3.14159f);
  EXPECT_NEAR(result, 3.14f, 0.01f);
}
```

### 4.4. Exception Assertions

```cpp
TEST(ExceptionTest, ThrowsExpected) {
  EXPECT_THROW(MayThrow(), std::runtime_error);
  EXPECT_NO_THROW(DontThrow());
}
```

### 4.5. Predicate and Matcher Usage

```cpp
// Predicate example
bool IsEven(int n) { return (n % 2) == 0; }
EXPECT_PRED1(IsEven, 4);

// Matcher example
using ::testing::HasSubstr;
EXPECT_THAT("hello world", HasSubstr("world"));

// Compound matcher
EXPECT_THAT(5, ::testing::AllOf(::testing::Gt(3), ::testing::Lt(10)));
```

---

## 5. Troubleshooting & Tips

### Common Issues

- **Confusing pointer vs. content comparison:** Use `EXPECT_STREQ` or matchers for strings, not `EXPECT_EQ`.
- **Floating-point failures due to precision:** Prefer the floating-point equality macros.
- **Fatal assertions in non-void returning functions:** Fatal failures abort the current function; avoid using ASSERT_* in functions returning non-void.

### Best Practices

- Use matchers to write readable and maintainable tests.
- Stream custom failure messages with `<<` for clarity.
- Use `SCOPED_TRACE` to add contextual information when calling helper functions with assertions.

### Performance Considerations

- Avoid heavy computation inside assertion macros; precompute values when possible.

### Alternative Approaches

- When existing assertions do not suffice, create custom assertions or matchers, extending GoogleTest's framework.

---

## 6. Next Steps & Related Documentation

- Explore the full [Assertions Reference](reference/assertions.md) for exhaustive details.
- Learn about [Matchers Reference](reference/matchers.md) to leverage GoogleMock’s matcher power.
- For extending assertions, read [Defining Custom Assertions and Matchers](guides/advanced-usage-integration/custom-assertions-matchers).
- Understand test structure in [Test Structure and Lifecycle](api-reference/core-testing-apis/test-structure-and-lifecycle).
- Practice writing your first tests with [Setup Quickstart](guides/getting-started/setup-quickstart).

---

For comprehensive guidance on assertions and matchers, this page builds on foundational knowledge from the Getting Started and Core Concepts sections. It fits into your onboarding journey by enabling you to write clearer, more effective tests.
