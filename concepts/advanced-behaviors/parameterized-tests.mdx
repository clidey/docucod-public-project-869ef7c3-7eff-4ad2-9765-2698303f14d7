---
title: "Value and Type-Parameterized Testing"
description: "Discover how GoogleTest supports parameterized tests, allowing the same test logic to be run with varying data or types. Learn best practices for scalable test coverage."
---

# Value and Type-Parameterized Testing

Explore how GoogleTest empowers you to write parameterized tests, enabling a single test logic to run with different sets of input data or types. This maximizes test coverage without duplicating code, making your tests more maintainable, expressive, and scalable.

---

## Introduction to Parameterized Testing

Parameterized tests in GoogleTest allow you to write a generic test case and supply multiple inputs or types that exercise the same logic under varying conditions. This approach addresses the common challenge of repetitive test code when verifying the behavior of code with diverse inputs or template instantiations.

By adopting parameterized tests, you achieve:

- **Compactness**: One test definition covers multiple scenarios.
- **Clarity**: Group related tests logically with names and parameters.
- **Maintainability**: New cases added simply by extending parameters.
- **Coverage**: Ensure all relevant data or type variations are tested.


## Types of Parameterized Tests Supported

GoogleTest primarily offers two kinds of parameterized tests focused on input variety and type generalization:

### 1. Value-Parameterized Tests

These tests execute once per input value set supplied at runtime. They are useful when you need to verify your code against a range of data values.

- Define a test fixture inheriting from `::testing::TestWithParam<T>` where `T` is the parameter type.
- Use `INSTANTIATE_TEST_SUITE_P` (or `INSTANTIATE_TEST_CASE_P` for older versions) to specify the collection of parameter values.
- Access the current parameter within tests via `GetParam()`.

**Example:** Testing a function with different integers.

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_TRUE(IsEven(n));
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

### 2. Type-Parameterized Tests

These tests iterate over different types at compile-time, ideal for verifying templated code or algorithms that operate over various data types.

- Declare the test case templated on a type `T`.
- Derive your test fixture from `::testing::Test` specialized for the template.
- Register the types to test using `TYPED_TEST_SUITE`.
- Write test logic using `TYPED_TEST` which refers to the current type as `TypeParam`.

**Example:** Verifying container behavior over multiple types.

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
public:
  T container_;
};

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, MyTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

## Writing Value-Parameterized Tests: Step-by-Step

<Steps>
<Step title="Define a Parameterized Test Fixture">
Derive a test fixture from `::testing::TestWithParam<T>`, where `T` represents the test parameter type.
</Step>
<Step title="Write Parameterized Tests">
Use `TEST_P` macro instead of `TEST_F`, writing your test logic once and retrieving each parameter via `GetParam()`.
</Step>
<Step title="Instantiate the Parameterized Test Suite">
Use `INSTANTIATE_TEST_SUITE_P` to provide a pattern name and the set of values or generators to supply parameters.
</Step>
</Steps>


## Writing Type-Parameterized Tests: Step-by-Step

<Steps>
<Step title="Define a Templated Test Fixture">
Create a template class derived from `::testing::Test` parameterized on type `T`.
</Step>
<Step title="List Types to Test">
Define a list of types via `::testing::Types<Type1, Type2, ...>`.
</Step>
<Step title="Register the Type List">
Bind the type list to your test fixture with `TYPED_TEST_SUITE`.
</Step>
<Step title="Write Tests Using `TYPED_TEST`">
Write test cases that will be instantiated for each type, accessing current type via `TypeParam`.
</Step>
</Steps>


## Best Practices for Parameterized Tests

- **Give Descriptive Names to Parameter Instantiations:** Use the first argument in `INSTANTIATE_TEST_SUITE_P` to reflect the input data or type group meaningfully.
- **Favor Compactness Over Granularity:** Write as few parameterized tests as possible by leveraging matchers and conditions inside tests, avoiding needless proliferation.
- **Retire Expectations on Saturation in Sequences:** Combine `.RetiresOnSaturation()` and `InSequence` to avoid expectation stickiness problems.
- **Utilize Generators:** Use GoogleTest’s parameter generators such as `Values()`, `Range()`, `Bool()`, and `Combine()` for concise, expressive parameter feeding.
- **Keep Tests Simple and Focused:** Each parameterized test should verify one aspect of behavior, simplifying debugging and maintenance.

## Common Pitfalls and How to Avoid Them

- **Sticky Expectations Confusion:** When defining multiple `EXPECT_CALL`s for the same method, remember expectations are sticky; use `.RetiresOnSaturation()` or sequences.
- **Overusing Parameterized Tests:** Don’t try to cover vastly different scenarios in a single parameterized test, which can reduce readability.
- **Ambiguous Overloads in Mocked Parameterized Tests:** If mocking templated or parameterized methods, explicitly resolve overloads or use helper typedefs to avoid compiler errors.
- **Run-Time vs Compile-Time Mixing:** Type-parameterized tests are compile-time; value-parameterized tests are run-time. Don’t mix expectations on template parameters with value parameters incorrectly.

## Troubleshooting Parameterized Tests

<AccordionGroup title="Common Issues in Parameterized Tests">
<Accordion title="Why is my test not instantiated for all parameters?">
Ensure your `INSTANTIATE_TEST_SUITE_P` macro is properly placed in the test module namespace and the parameters supplied cover the intended values or types.
</Accordion>
<Accordion title="How do I debug parameterized test failures?">
Run tests with `--gtest_filter` specifying parameterized test names or indices. Use verbose flags like `--gmock_verbose=info` to get detailed mock call traces.
</Accordion>
<Accordion title="Compilation errors on mock methods in parameterized tests">
Check `MOCK_METHOD` usage with templates, especially for overloads. Use type aliases or explicit template parameters to avoid ambiguity.
</Accordion>
</AccordionGroup>

## Additional Resources

- [Writing and Running Tests: Parameterized and Typed Tests for Code Coverage](../guides/advanced-usage-integration/parameterized-typed-tests)
- [gMock Cookbook: Using Parameterized Actions and Matchers](docs/gmock_cook_book.md)
- [Mocking Reference](api-reference/mocking-framework/expectations-actions.mdx)
- [Matchers Reference](api-reference/core-api/matchers.mdx)
- [Test Discovery & Execution Flow](concepts/core-architecture/test-discovery-execution.mdx)

---

<Info>
Parameterized testing in GoogleTest bridges the gap between concise test expression and broad test coverage. By mastering value and type-parameterized tests, your testing suite will be robust, flexible, and easy to extend — essential traits for scalable, maintainable C++ testing.
</Info>

