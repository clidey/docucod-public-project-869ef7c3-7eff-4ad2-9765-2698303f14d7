---
title: "Mocking Fundamentals"
description: "Understand the rationale behind mocking, how mock classes and methods are defined, and the core principles behind specifying expectations and behaviors for test doubles."
---

# Mocking Fundamentals

GoogleMock (gMock) is a robust framework that empowers C++ developers to create *mock objects* — stand-ins for real objects — facilitating fine-grained unit testing by specifying and verifying precise object interactions. This page guides you through the core concepts behind mocking: why and when to mock, how to define mock classes and their methods, and the foundational principles of setting expectations and behaviors on mock methods.

---

## Why Mock?

Imagine testing a graphics application that controls drawing via an interface like `Turtle`, which moves around a screen. Testing the real drawing backend can be slow, unreliable, or impractical. Mock objects can step in by simulating the interface, allowing tests to verify that the program invokes the correct drawing commands, with the right arguments, and in the right order — all without rendering any actual graphics.

Mocking enables:

- **Dependency Elimination:** Isolate the unit under test by replacing complex dependencies like databases, file systems, or external services with mocks.
- **Interaction Verification:** Ensure your code interacts correctly with other parts of the system by checking method calls, arguments, and call order.
- **Failure Simulation:** Easily simulate error conditions that are difficult or impossible to induce in real dependencies.
- **Test Speed & Stability:** Skip expensive resource operations for fast and deterministic tests.

> _“Mock objects let you write *interaction-based* tests by predefining expectations about how your code uses its collaborators.”_


## Defining a Mock Class

To mock a class or interface, you create a derived class that implements mock methods in place of the originals. gMock simplifies this with the `MOCK_METHOD` macro.

### Steps to Define a Mock Class

1. **Inherit from the interface or base class** you want to mock. Ensure all methods you want to mock are virtual (pure virtual for interfaces).
2. **Use the `MOCK_METHOD` macro** inside the `public` section for each method to mock. The macro requires:
   - Return type
   - Method name
   - Parameter list (in parentheses)
   - Optional specifiers (e.g., `(const, override)`) to match the original method signature


### Example: Mocking a Turtle Interface

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual void GoTo(int x, int y) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

**Important:**
- The destructor of the base class must be virtual to avoid resource leaks.
- For const methods, include `(const)` in the specifiers.
- Use `override` to express intent and help catch signature mismatches.


### Mocking Overloaded Methods

`MOCK_METHOD` supports overloaded functions. You must provide signatures for all overloads you want to mock, to avoid hiding base class methods:

```cpp
class Foo {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int x, int y) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int x, int y), (override));
};
```

If you intentionally omit an overload, bring the others into scope with `using`:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring other Add overloads.
  MOCK_METHOD(int, Add, (int x), (override));
  // Omit other overload here.
};
```


### Mocking Class Templates

Mocking templates follows the same pattern:

```cpp
template <typename T>
class Stack {
 public:
  virtual ~Stack() {}
  virtual void Push(const T& value) = 0;
  virtual int GetSize() const = 0;
};

template <typename T>
class MockStack : public Stack<T> {
 public:
  MOCK_METHOD(void, Push, (const T& value), (override));
  MOCK_METHOD(int, GetSize, (), (const, override));
};
```

---

## Using a Mock Object in Tests

Once mocks are defined, the typical usage flow is:

1. **Create the mock objects.**
2. **Set default behaviors** with `ON_CALL` (optional).
3. **Set expectations** with `EXPECT_CALL`.
4. **Run the test exercise** code that uses the mocks.
5. **gMock automatically verifies** expectations when the mocks are destructed.


## Specifying Default Actions: `ON_CALL`

Use `ON_CALL` to specify what a mock method does *by default*, without requiring the call:

```cpp
ON_CALL(mock_turtle, GetX()).WillByDefault(Return(10));
```

This tells gMock that if `GetX()` is called but no explicit expectation matches it, it should return 10.

- `ON_CALL` does *not* create an expectation that the method must be called.
- The default action is superseded by matching `EXPECT_CALL` actions.


## Setting Expectations: `EXPECT_CALL`

`EXPECT_CALL` defines expectations on method calls:

```cpp
EXPECT_CALL(mock_turtle, Forward(100))
    .Times(AtLeast(1))
    .WillRepeatedly(Return());
```

This states that the `Forward` method with argument 100 should be called at least once.

### Key Clauses of `EXPECT_CALL`

| Clause                | Purpose                                                                                      |
|-----------------------|----------------------------------------------------------------------------------------------|
| `.Times(n)`           | Specifies the expected call count (exact, at least, at most, any number)                      |
| `.WillOnce(action)`   | Defines behavior for a single call                                                          |
| `.WillRepeatedly(action)` | Defines behavior for subsequent calls after all `WillOnce` actions are exhausted            |
| `.With(matcher)`      | Matches all arguments as a tuple for more complex constraints                                |
| `.InSequence(seq...)` | Enforces call ordering within sequence(s)                                                   |
| `.After(expectation)` | Specifies that this call happens after one or more other expectations                        |
| `.RetiresOnSaturation()`| Retires the expectation when saturated to allow others to take effect                        |

If no `.Times()` is provided, gMock infers one based on the `.WillOnce` and `.WillRepeatedly` use:
- No `.WillOnce` or `.WillRepeatedly`: `Times(1)`
- `n` `.WillOnce` clauses, no `.WillRepeatedly`: `Times(n)`
- `n` `.WillOnce` clauses, one `.WillRepeatedly`: `Times(AtLeast(n))`


### Example: Setting Expectations

```cpp
using ::testing::Return;

EXPECT_CALL(mock_turtle, GetX())
    .Times(3)
    .WillOnce(Return(10))
    .WillOnce(Return(20))
    .WillOnce(Return(30));

// The method is expected to be called exactly three times,
// returning 10, then 20, then 30.
```


### Handling Uninteresting Calls

If a mock method is called without any `EXPECT_CALL` for it, the call is considered *uninteresting*.
- By default, gMock prints a warning but allows the call.
- To suppress warnings, use `NiceMock<YourMock>`.
- To treat uninteresting calls as errors, use `StrictMock<YourMock>`.


## Managing Mock Strictness: Nice, Naggy, and Strict

Mocks can have different default behaviors for calls without explicit expectations:

| Wrapper Type                 | Behavior on Uninteresting Calls                      | Usage                                  |
|-----------------------------|-----------------------------------------------------|---------------------------------------|
| `NaggyMock<MockType>`       | Warns when uninteresting calls occur (default)      | Useful during development, warns unused calls |
| `NiceMock<MockType>`        | Silently ignores uninteresting calls                | Suppresses warnings, ideal for less strict tests |
| `StrictMock<MockType>`      | Fails test on uninteresting calls                    | Ensures no unexpected calls, use when strict enforcement needed |

Example:

```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;

NiceMock<MockTurtle> nice_turtle;
StrictMock<MockTurtle> strict_turtle;
```


## Key Principles of Expectation Matching

- **Later expectations override earlier ones**: For the same mock method, the most recently set matching expectation is chosen.
- **Match by argument matchers and `.With()` clauses**: An expectation matches a call only if argument values satisfy all matchers.
- **Sticky expectations**: Expectations remain active after saturation unless marked with `.RetiresOnSaturation()` or they belong to a sequence and an order has progressed.
- **Ordered vs. unordered calls**: Use `InSequence` or `After` to enforce call order.


## Verifying and Resetting Mocks

- gMock automatically verifies that all expectations were met when a mock object is destructed.
- You may also explicitly verify and reset expectations:

```cpp
using ::testing::Mock;

Mock::VerifyAndClearExpectations(&mock_obj);
// or
Mock::VerifyAndClear(&mock_obj);
```

Calling these functions after the mock’s use force immediate verification and clearing of expectations.


## Troubleshooting Common Issues

- **Expectations not satisfied**: Ensure you set expectations *before* exercising the code.
- **Unexpected calls**: Occur when a mock method is called with arguments that do not match any active expectation.
- **Uninteresting calls warnings**: Use `NiceMock` to suppress if intentional, otherwise add explicit expectations or `ON_CALL` default behaviors.
- **Virtual destructor requirement**: Always ensure base classes meant for mocking have virtual destructors to avoid memory issues.


## Summary Example: Full Mock Usage

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};

TEST(PainterTest, DrawsLine) {
  MockTurtle turtle;

  ON_CALL(turtle, GetX()).WillByDefault(Return(5));

  EXPECT_CALL(turtle, PenUp()).Times(1);
  EXPECT_CALL(turtle, Forward(100)).Times(AtLeast(1));

  Painter painter(&turtle);
  painter.DrawLine();
}
```

This illustrates setting default action with `ON_CALL`, explicit expectations with `EXPECT_CALL`, and verifying that calls meet expectations automatically.

---

## Additional Resources

To deepen your understanding and advance your mocking skills, consult:

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html): Beginner-friendly tutorial on basic mocking concepts.
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html): Quick reference for macros and patterns.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html): Comprehensive API documentation.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html): Practical recipes covering advanced usage.
- [Strictness Models](concepts/mocking-and-extensibility/strictness-models-nice-naggy-strict): Understand mock strictness strategies.

Deploy these concepts to create expressive, maintainable, and robust unit tests that precisely validate your code's interactions.
