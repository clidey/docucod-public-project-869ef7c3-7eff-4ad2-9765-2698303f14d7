---
title: "Custom Assertions, Actions & Matchers"
description: "Explore how GoogleTest and GoogleMock allow users to define custom assertions, actions, and matchers. Understand the architecture enabling extensibility, such as writing your own predicate assertions and composing reusable actions, to create highly tailored and expressive test verifications."
---

# Custom Assertions, Actions & Matchers

GoogleTest and GoogleMock empower you to extend your test verification capabilities by defining your own assertions, actions, and matchers. This page explores how you can write custom predicate assertions, design reusable actions to specify complex mock behaviors, and create expressive matchers to validate your test inputs with precision. Leveraging these extensibility features allows you to tailor GoogleTest to the specific requirements and nuances of your project, making your tests more readable, maintainable, and powerful.

---

## Why Extend GoogleTest?

While GoogleTest provides a comprehensive suite of built-in assertions, actions, and matchers, real-world testing scenarios often demand more specialized behaviors or validations that the default tools donâ€™t directly cover. Custom extensions allow you to:

- Encode domain-specific validation logic clearly and concisely.
- Reuse complex matching or action workflows across multiple tests.
- Provide clearer and more informative failure messages tailored to your context.
- Compose smaller building blocks into advanced verification strategies.

This section guides you through the conceptual approaches and practical steps for creating these extensions.

---

## Custom Assertions

### Understanding Predicate Assertions

GoogleTest supports predicate-style assertions, which let you verify conditions that may be more complex than simple Boolean expressions. Predicate assertions report failure messages that can include detailed explanations beyond a simple pass/fail.

### Writing a Basic Custom Assertion

You can write a standalone predicate function returning a `testing::AssertionResult`. This result can encapsulate success or failure information, including rich diagnostic messages.

```cpp
#include <gtest/gtest.h>

// Predicate function: checks if an integer is even.
testing::AssertionResult IsEven(int n) {
    if (n % 2 == 0) {
        return testing::AssertionSuccess();
    } else {
        return testing::AssertionFailure() << n << " is not even.";
    }
}

TEST(NumberTest, IsEven) {
    EXPECT_PRED1(IsEven, 4);    // Passes
    EXPECT_PRED1(IsEven, 5);    // Fails with message "5 is not even."
}
```

### Using Predicate Format Assertions

For more detailed messages that include the expressions as strings, use predicate-format assertions like `EXPECT_PRED_FORMAT1`. This lets you return messages referencing the code passed to the assertion.

```cpp
// Predicate-formatter for evenness

testing::AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess();
  }
  return testing::AssertionFailure() << expr << " evaluates to " << n << ", which is not even.";
}

TEST(NumberTest, UsingFormat) {
  EXPECT_PRED_FORMAT1(AssertIsEven, 3);  // Prints "3 evaluates to 3, which is not even."
}
```

---

## Defining Custom Actions

Actions control what a mock method does when invoked. Beyond returning values, actions can modify arguments, invoke callbacks, or execute arbitrary logic.

### Writing Simple Custom Actions Using Lambdas or Functors

The most straightforward way to define a custom action is via a lambda or callable object compatible with the mocked method signature.

```cpp
using ::testing::_;  
using ::testing::Invoke;

class MockFoo {
 public:
  MOCK_METHOD(int, Compute, (int x), ());
};

// A lambda action that doubles the input

TEST(CustomActionTest, LambdaAction) {
  MockFoo mock;
  EXPECT_CALL(mock, Compute(_))
      .WillOnce(Invoke([](int x) { return x * 2; }));

  EXPECT_EQ(mock.Compute(10), 20);
}
```

### Making Stateful or Parameterized Actions

You can create more advanced actions by defining structs or classes with a suitable call operator. This is useful for actions that maintain internal state or take parameters.

```cpp
struct MultiplyBy {
  int factor;
  explicit MultiplyBy(int f) : factor(f) {}

  int operator()(int x) const {
    return x * factor;
  }
};

TEST(CustomActionTest, StatefulAction) {
  MockFoo mock;
  EXPECT_CALL(mock, Compute(_)).WillOnce(MultiplyBy{5});

  EXPECT_EQ(mock.Compute(4), 20);
}
```

### Combining Multiple Actions

Use `DoAll()` to chain multiple actions where earlier ones perform side effects and the last provides the return value.

```cpp
using ::testing::DoAll;
using ::testing::SetArgPointee;
using ::testing::Return;

class MockBar {
 public:
  MOCK_METHOD(bool, Process, (int input, int* output), ());
};

TEST(CustomActionTest, CombineActions) {
  MockBar mock;

  EXPECT_CALL(mock, Process(_, _))
      .WillOnce(DoAll(SetArgPointee<1>(42), Return(true)));

  int result = 0;
  EXPECT_TRUE(mock.Process(7, &result));
  EXPECT_EQ(result, 42);
}
```

---

## Creating Custom Matchers

Matchers allow you to specify conditions that function arguments must satisfy. While GoogleMock provides extensive built-in matchers, custom matchers let you define domain-relevant validation rules.

### Using `MATCHER` Macros for Quick Custom Matchers

The `MATCHER` macro is the easiest way to write a custom matcher.

```cpp
MATCHER(IsPositive, "checks if the value is positive") {
  return arg > 0;
}

TEST(CustomMatcherTest, SimpleMatcher) {
  EXPECT_THAT(5, IsPositive());    // Passes
  EXPECT_THAT(-3, Not(IsPositive())); // Passes
}
```

### Parameterized Matchers with `MATCHER_P` and `MATCHER_Pn`

Parameterized matchers accept extra arguments to modulate their behavior.

```cpp
MATCHER_P(IsDivisibleBy, divisor, "checks divisibility") {
  return arg % divisor == 0;
}

TEST(CustomMatcherTest, ParameterizedMatcher) {
  EXPECT_THAT(10, IsDivisibleBy(5));    // Pass
  EXPECT_THAT(11, Not(IsDivisibleBy(5))); // Pass
}
```

### Writing Matcher Classes for Control and Performance

For extensive matchers or those used frequently, you can implement a matcher class with methods `MatchAndExplain()`, `DescribeTo()`, and `DescribeNegationTo()`.

```cpp
class BetweenMatcher {
 public:
  BetweenMatcher(int low, int high) : low_(low), high_(high) {}

  bool MatchAndExplain(int val, std::ostream* os) const {
    bool result = val >= low_ && val <= high_;
    if (!result && os) {
      *os << val << " is not between " << low_ << " and " << high_;
    }
    return result;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is between " << low_ << " and " << high_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not between " << low_ << " and " << high_;
  }

 private:
  int low_;
  int high_;
};

inline ::testing::Matcher<int> IsBetween(int low, int high) {
  return ::testing::MakeMatcher(new BetweenMatcher(low, high));
}

TEST(CustomMatcherTest, MatcherClass) {
  EXPECT_THAT(10, IsBetween(5, 15));
  EXPECT_THAT(20, Not(IsBetween(5, 15)));
}
```

### Composing Matchers

Matchers can be combined logically with operators like `AllOf()`, `AnyOf()`, and `Not()` to build complex validations.

---

## Practical Tips & Best Practices

- **Start simple:** Use `MATCHER` macros for most custom needs; move to full matcher classes only for complex or reusable matchers.
- **Descriptive messages:** Always provide meaningful descriptions to help diagnose failures.
- **Avoid side effects:** Matchers must be pure functions with no side effects as they can be invoked multiple times.
- **Use `ON_CALL` for default behavior:** Reserve `EXPECT_CALL` for verifying interactions, while `ON_CALL` sets up default mock responses.
- **Leverage existing matchers:** Build custom matchers on top of built-in ones for maintainability.
- **Consider readability:** Parameterize matchers and actions to keep test code clean and intention-revealing.

---

## Troubleshooting Custom Extensions

- **Compilation errors:** Check signature compatibility for custom actions and matchers.
- **Unexpected failures:** Verify your custom predicate or matcher produces accurate Boolean results and descriptive messages.
- **Unintuitive failures:** Use `--gmock_verbose=info` to get detailed traces for call matching and expectation evaluation.
- **Avoid using mutable state in matchers:** GoogleMock may invoke matchers multiple times or on different threads.

---

## Summary

Extending GoogleTest with custom assertions, actions, and matchers unlocks a new level of testing expressiveness. By applying these tools, you can craft precise and reusable specifications tailored exactly to your code's logic and domain, driving clearer test outcomes and easier maintenance.

For deeper insights and recipes, explore the [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md), the [Matchers Reference](../api-reference/core-testing-apis/matchers.md), and the [Actions Reference](../api-reference/mocking-apis/actions-and-advanced-mocking.md).

---

## See Also

- [Assertions Reference](../api-reference/core-testing-apis/assertions.md)
- [Matchers Reference](../api-reference/core-testing-apis/matchers.md)
- [Actions Reference](../api-reference/mocking-apis/actions-and-advanced-mocking.md)
- [Mocking Guide](../guides/mocking-guide/mocking-basics.md)
- [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md)

---