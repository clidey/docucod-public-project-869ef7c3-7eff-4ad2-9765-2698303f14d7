---
title: "Custom Assertions and Matchers"
description: "Learn how to create user-defined assertions and matchers to support project-specific validation logic, enhancing the expressiveness of your tests."
---

# Custom Assertions and Matchers

Enhance the expressiveness and precision of your GoogleTest tests by creating custom assertions and matchers tailored to your project’s specific validation requirements. This guide walks you through defining simple and parameterized matchers, implementing detailed failure explanations, composing matchers, and extending the framework to meet complex needs.

---

## Why Create Custom Assertions and Matchers?

While GoogleTest provides a rich set of built-in assertions and matchers, your project might require domain-specific validation logic, or more descriptive failure messages, that standard tools cannot provide out-of-the-box. Custom matchers let you encapsulate complex logic in reusable, readable, and maintainable components, improving test clarity and diagnostics.

Imagine validating a deeply nested object property or a mathematical invariant — custom matchers make these checks clear and concise in your tests.

---

## Basic Custom Matcher Using the `MATCHER` Macro

The simplest way to create a matcher is using the `MATCHER` macro. It defines a polymorphic matcher with a name and a lambda-like body using `arg` as the matched value.

### Syntax

```cpp
MATCHER(Name, "description") { /* return true if arg matches */ }
```

- `Name`: The matcher’s identifier (used in tests as `Name()`).
- `description`: A string describing the matcher behavior, shown in failure messages.
- Inside the body, you write logic returning `true` for a match, `false` otherwise.

### Example: Divisible By 7 Matcher

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

Usage in test:

```cpp
EXPECT_CALL(mock_foo, Bar(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

If the expectation fails, you may get a message like:

```
Value of: value
Expected: is divisible by 7
  Actual: 27
```

### Adding Custom Failure Explanation

You can stream extra detail to `*result_listener` to help understand failure reasons:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) != 0) {
    *result_listener << "remainder is " << (arg % 7);
    return false;
  }
  return true;
}
```

This enriches failure messages with specific information like the remainder value.

---

## Parameterized Matchers with `MATCHER_P` and Variants

Most matchers need parameters. GoogleTest supports parameterized matchers through macros:

| Macro         | Description                         |
| ------------- | ---------------------------------- |
| `MATCHER_P`   | Single-parameter matcher           |
| `MATCHER_P2`  | Two parameters                    |
| `MATCHER_P3` … up to `MATCHER_P10` | Multi-parameter matchers |

### Syntax Example

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

Descriptive failure messages include the parameter:

```
Value of: x
Expected: has absolute value 10
  Actual: -9
```

### Complex Description Strings

You can use `negation` and parameters in the description string:

```cpp
MATCHER_P2(InClosedRange, low, hi,
          absl::StrCat(negation ? "isn't" : "is", " between ",
                      PrintToString(low), " and ", PrintToString(hi))) {
  return low <= arg && arg <= hi;
}
```

When negated, failure messages will adapt accordingly.

---

## Implementing Matchers Via Classes

For maximum control—especially if you want the matcher to be monomorphic (only for a specific type) or need custom match logic—you can implement a matcher class manually.

### Requirements

Your matcher class should:

- Include the typedef `using is_gtest_matcher = void;`
- Implement:
  - `bool MatchAndExplain(T value, std::ostream* listener) const;`
  - `void DescribeTo(std::ostream* os) const;`
  - `void DescribeNegationTo(std::ostream* os) const;`

### Example: DivisibleBy7Matcher

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    const int remainder = n % 7;
    if (remainder != 0 && os) {
      *os << "remainder is " << remainder;
    }
    return remainder == 0;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by 7";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by 7";
  }
};

::testing::Matcher<int> DivisibleBy7() {
  return DivisibleBy7Matcher();
}
```

Use exactly like built-in matchers in `EXPECT_THAT` or `EXPECT_CALL`.

---

## Polymorphic Matchers

Unlike monomorphic matchers, polymorphic matchers adapt to various types based on context.

Example:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream* /* listener */) const {
    return p != nullptr;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is not NULL";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is NULL";
  }
};

NotNullMatcher NotNull() { return NotNullMatcher(); }
```

This matcher can be used with any pointer type.

---

## Composing Matchers for Complex Logic

You can combine multiple matchers using logical combinators like `AllOf()`, `AnyOf()`, and `Not()`. For example:

```cpp
EXPECT_CALL(mock, DoWork(AllOf(Ge(5), Le(10))));  // Expect argument in [5, 10]
EXPECT_THAT(value, Not(HasSubstr("error")));    // String does not contain "error"
```

These combinators simplify expressing compound constraints.

---

## Using Custom Matchers in Your Tests

Matchers are usable in two main scenarios:

- In mock method expectations:

  ```cpp
  EXPECT_CALL(mock_obj, MethodName(CustomMatcher()));
  ```

- In assertion macros:

  ```cpp
  EXPECT_THAT(actual_value, CustomMatcher());
  ```

They provide detailed failure messages, showing the matcher’s description and reasons for match failure.

---

## Additional Advanced Notes

- **Pure Functionality**: Matchers must be pure — no side effects allowed.
- **Type Safety**: Use `SafeMatcherCast<T>(m)` when you need type casting for matchers.
- **Multi-Argument Matchers**: Use `.With()` and tuple-based matchers like `Args<>` to constrain multiple arguments together.
- **Defining Custom Actions**: See [gMock actions documentation](https://google.github.io/googletest/gmock_cook_book.html#DefiningActions) for extending callable behaviors.

---

## Useful Resources

- [Matchers Reference](../reference/matchers.md) — comprehensive details on all built-in matchers.
- [gMock Cookbook: Writing New Matchers](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers) — detailed recipes for creating matchers.
- [gMock for Dummies](../gmock_for_dummies.md) — introductory guide to gMock, including matchers and mocks.
- [Mocking Reference](../reference/mocking.md) — details on mock-related macros.
- [Readable Failure Messages and Debugging](../concepts/core-architecture/test-assertion-model.mdx) — core concepts on interpreting test assertions.

---

## Summary

Custom assertions and matchers empower you to write clear, maintainable, and meaningful tests that accurately express the intent of your validation logic. Whether you need simple predicate matchers or full polymorphic and composite matchers, GoogleTest provides flexible tools to implement them cleanly.

Use custom matchers to capture intricate domain logic, provide richer diagnostics, and foster reusable test components, elevating the quality and robustness of your tests.

---

_This concludes the Custom Assertions and Matchers guide._

<Callout type="tip">
For consistent style and better diagnostics, always provide descriptive failure messages using the `*result_listener` or by overriding `DescribeTo` and `DescribeNegationTo`.
</Callout>
