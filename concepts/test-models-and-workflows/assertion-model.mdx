---
title: "The Assertion Model"
description: "Get to know the philosophy and mechanics behind assertions in GoogleTest—from core macros to user-defined predicates. Understand the difference between fatal and non-fatal failures and how assertion outcomes influence test flow and reporting."
---

# The Assertion Model

GoogleTest's assertion model underpins how tests verify correctness through precise checks and clear communication of success or failure. This guide demystifies the core philosophies and mechanics behind assertions—from the fundamental macros you use in everyday testing to advanced predicate-based assertions. You'll learn how GoogleTest distinguishes between **fatal** and **non-fatal** failures, why that matters for test flow, and how assertion outcomes influence the way tests execute and report results.

---

## 1. Understanding Assertions

At its core, an assertion in GoogleTest is a statement that examines a condition or expression and yields one of three outcomes:

- **Success**: The checked condition is met.
- **Non-fatal Failure**: The condition is not met, but the test continues running.
- **Fatal Failure**: The condition is not met, and the current function aborts immediately.

This behavior empowers you to control the granularity of test feedback and execution. You typically use `EXPECT_*` macros to continue testing after failures (non-fatal) and `ASSERT_*` macros to stop the current test's progress on critical failures (fatal). Consider the following illustration:

```cpp
TEST(VectorTest, SizeValidation) {
  std::vector<int> v = {1, 2, 3};

  // Non-fatal assertion: reports failure but continues.
  EXPECT_EQ(v.size(), 4) << "Vector size should be 4";

  // Fatal assertion: aborts function if failed.
  ASSERT_FALSE(v.empty()) << "Vector should not be empty";

  // The following code runs only if ASSERT_FALSE succeeds.
  EXPECT_EQ(v[0], 1);
}
```

Here, if the vector size check fails, the test logs the failure but continues to verify other conditions. If the vector is empty, the fatal assertion halts further execution within this test, preventing invalid memory access in later checks.

### Why Fatal vs Non-Fatal?

GoogleTest's design **does not use exceptions**. Consequently, a failing `ASSERT_*` macro doesn't unwind the call stack; it simply returns from the _current_ function. This means you must place fatal assertions in functions returning `void`, typically your test functions or helpers.

If you need assertions in functions returning non-void, prefer non-fatal assertions (`EXPECT_*`) or redesign the function to return `void` and use output parameters if needed.

<Tip>
Avoid placing fatal assertions in constructors or destructors—they cannot return `void` and will cause compilation errors. Instead, use `SetUp()` and `TearDown()` overrides in test fixtures for such pre/post-test setup checks.
</Tip>


## 2. Assertion Macros and Their Usage

### Assertion Macro Categories

GoogleTest offers a rich suite of assertion macros tailored for various verification needs:

- **Boolean Assertions**: Check whether an expression is true or false.
  - Example: `EXPECT_TRUE(condition)` and `ASSERT_FALSE(condition)`

- **Comparison Assertions**: Verify the relation between two values.
  - Examples: `EXPECT_EQ(val1, val2)`, `ASSERT_LT(val1, val2)`

- **String Assertions**: Special macros for C-strings and wide strings.
  - Examples: `EXPECT_STREQ(str1, str2)`, `ASSERT_STRCASEEQ(str1, str2)`

- **Floating-Point Assertions**: Handle floating-point peculiarities with ULP-based comparisons.
  - Examples: `EXPECT_FLOAT_EQ(val1, val2)`, `ASSERT_NEAR(val1, val2, abs_error)`

- **Exception Assertions**: Test whether a block of code throws or does not throw exceptions.
  - Examples: `EXPECT_THROW(statement, ExceptionType)`, `ASSERT_NO_THROW(statement)`

- **Predicate Assertions**: Use user-defined predicates or predicate-formatters to perform custom checks with informative messages.
  - Example: `EXPECT_PRED1(isEven, value)`, `ASSERT_PRED_FORMAT2(CustomPredicateFormatter, val1, val2)`

- **Death Assertions**: For verifying that certain code causes the process to terminate.
  - Examples: `EXPECT_DEATH(statement, regex_matcher)`

### Success and Failure Macros

GoogleTest also provides explicit success and failure macros for flow control within tests:

- `SUCCEED()` generates a **success** explicitly and is useful for documenting that a particular code path was reached.
- `FAIL()` generates a **fatal failure**, aborting the current function.
- `ADD_FAILURE()` generates a **non-fatal failure**, allowing the test to continue.

### Streaming Failure Messages

Every assertion macro supports appending custom failure messages using the `<<` stream operator. This ability is invaluable to add context and ease debugging:

```cpp
EXPECT_EQ(vec.size(), 5) << "Vector size mismatch; contents: " << testing::PrintToString(vec);
```

If your type does not support streaming `operator<<` directly, refer to [Teaching GoogleTest How to Print Your Values](../advanced.md#teaching-googletest-how-to-print-your-values) to enable human-readable output.


## 3. Using Predicate Assertions for Custom Conditions

Sometimes, built-in assertion macros do not provide sufficient diagnostic detail or flexibility, especially with complex conditions. GoogleTest enables you to write predicate assertions that improve failure messages dramatically.

### Basic Predicate Assertions

Macros like `EXPECT_PRED1(predicate, val)`, `EXPECT_PRED2(predicate, val1, val2)`, etc., allow you to assert arbitrary Boolean predicates:

```cpp
bool IsEven(int n) { return (n % 2) == 0; }

EXPECT_PRED1(IsEven, 4);   // Succeeds
EXPECT_PRED1(IsEven, 5);   // Fails, prints the argument values
```

However, using these can yield opaque failure messages if the predicate returns only `bool`.

### Returning AssertionResult with Messages

For richer failure details, write predicates returning `testing::AssertionResult` with optional explanatory messages:

```cpp
using ::testing::AssertionFailure;
using ::testing::AssertionSuccess;

testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0) return AssertionSuccess() << n << " is even";
  else return AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(4));  // Prints nothing on success
EXPECT_TRUE(IsEven(5));  
/*
Failure message:
Value of: IsEven(5)
  Actual: false (5 is odd)
Expected: true
*/
```

This approach yields detailed diagnostic messages at failure and even success messages when desired.

### Predicate-Formatter Assertions

For ultimate control over failure messages, use predicate-formatter macros like `EXPECT_PRED_FORMAT*()`. The predicate-formatter function receives the textual form of each argument and its value, enabling fully customized assertion output.

Example:

```cpp
testing::AssertionResult IsMultipleOf(const char* expr, int val, int divisor) {
  if (val % divisor == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " (value: " << val << ") is not multiple of " << divisor;
}

EXPECT_PRED_FORMAT2(IsMultipleOf, 10, 3);
```

### Practical Tips

- Always strive to write predicates that prevent expensive operations from repeating unnecessarily in success cases.
- Use `SCOPED_TRACE` to add contextual information if predicates are used in shared subroutines.


## 4. How Assertion Outcomes Affect Test Flow

### Fatal vs Non-Fatal Failures

Fatal failures (`ASSERT_*`, `FAIL()`) immediately abort the current **function** but do NOT terminate the entire test. This means that if you put a fatal assertion inside a helper function, the caller continues executing after that function returns.

Example pitfall:

```cpp
void Helper() {
  ASSERT_EQ(1, 2);  // Fatal failure; aborts Helper()
  // ... Won't run
}

TEST(MyTest, BugHere) {
  Helper();
  int* p = nullptr;
  *p = 5;  // Unsafe! Helper's assertion didn't abort the whole test.
}
```

### Propagating Fatal Failures

To make fatal failures behave like exceptions (stop the entire test), GoogleTest provides several mechanisms:

- **Exceptions**: You can install a listener that throws an exception on fatal failures, interrupting test flow.
- **`ASSERT_NO_FATAL_FAILURE(statement)` and `EXPECT_NO_FATAL_FAILURE(statement)` macros**: Verify that `statement` generates no new fatal failures, allowing you to gate further execution.
- **`testing::Test::HasFatalFailure()`**: Check from the test if any fatal failure happened and return early.

Example:

```cpp
TEST(FooTest, SafeSubroutine) {
  Subroutine();
  if (testing::Test::HasFatalFailure()) return;
  // Safe to continue here
}
```


## 5. Assertion Placement and Usage Guidelines

- **Assertions that generate fatal failures can only be used in `void` functions.**
- Avoid placing fatal assertions in constructors or destructors since they're non-void and will cause compilation errors.
- For functions returning a value, use non-fatal assertions or redesign to use `void` with out-parameters.
- Use `SCOPED_TRACE` to add trace context when multiple calls to the same assertion helper occur.
- Use `GTEST_SKIP()` to skip tests at runtime with an optional message when preconditions are not met.


## 6. Test Result Reporting and Logging Properties

GoogleTest logs outcomes of assertions and records test properties for use in XML or JSON reports.

- Use `EXPECT_*` for test validation and multiple failure reports.
- Use `ASSERT_*` for critical checks that must stop the test on failure.
- Record additional custom test metadata with `testing::Test::RecordProperty("key", value)` which is propagated to the XML report.

Example Usage:

```cpp
TEST(FooTest, RecordsProperties) {
  ::testing::Test::RecordProperty("MaxValue", 42);
  ...
}
```


## 7. Advanced Assertion Features

- **Floating-point comparisons** with macros like `EXPECT_FLOAT_EQ` and `EXPECT_NEAR` consider precision errors and ULP differences.
- **Exception assertions** verify if code throws expected exceptions, using `EXPECT_THROW` and `ASSERT_NO_THROW`.
- Assertions support **wide string** comparisons and streaming of custom failure messages in UTF-8 encoding.
- Use death assertions (`EXPECT_DEATH`, `ASSERT_DEATH`) to verify program behavior on fatal crashes or process exits.


## Summary

The assertion model is the backbone of GoogleTest's rich, user-friendly test validation. It balances the need to continue tests after recoverable failures with mechanisms to halt tests immediately when necessary. By leveraging simple, expressive macros and customizable predicates, GoogleTest empowers developers to write clear, informative tests that guide rapid diagnosis and robust verification.

---

For more practical guidance, see the following related topics:

- [Assertions Reference](../api-reference/core-testing-apis/assertions.md)
- [Advanced GoogleTest Topics](../docs/advanced.md#more-assertions)
- [Adding Traces to Assertions](../docs/advanced.md#adding-traces-to-assertions)
- [Parameterized and Typed Tests](../guides/core-testing-workflows/parameterized-and-typed-tests.md)


---

<Callout title="Tip">
To ensure your custom types print meaningful messages in failure reports, learn how to extend GoogleTest's printing capability via `PrintTo()`, `AbslStringify()`, or defining operator `<<`. This helps turn cryptic byte dumps into friendly diagnostics.
</Callout>

<Callout title="Warning">
Avoid using fatal assertions in constructors or destructors; instead use `SetUp()`/`TearDown()` methods or explicitly abort to prevent undefined behavior.
</Callout>