---
title: "Actions and Behavioral Customization"
description: "Understand how actions define and customize the behaviors of mocks, supporting complex test scenarios and simulation of diverse responses. Investigate how built-in and custom actions are specified and composed for advanced mocking strategies."
---

# Actions and Behavioral Customization

Understanding how actions specify and control the behavior of mock methods is key to unlocking the full power of GoogleMock. This guide unpacks how actions define what happens when a mock function is called, enabling you to simulate complex scenarios, manipulate side effects, and precisely customize responses.

---

## What Are Actions?

An **action** in GoogleMock specifies what a mock function _does_ when invoked. Unlike expectations that assert _if_ and _how often_ a function is called, actions define the _behavior_ executed on matching calls—such as returning specific values, modifying arguments, throwing exceptions, or invoking user-defined code.

Actions transform mock methods from mere markers into dynamic objects that can simulate real behavior or test edge cases effectively.


## Default and Custom Actions

- **Built-in default actions:** For mock functions that return void, built-in numeric or pointer types, or default-constructible types, GoogleMock provides a default action automatically. For example, a `bool`-returning mock returns `false` by default.

- **User-specified actions:** You can override default behavior with explicit actions when setting up mocks using `ON_CALL` or `EXPECT_CALL`.

These actions are specified using chained clauses like `.WillOnce()`, `.WillRepeatedly()`, or `.WillByDefault()`.

---

## Built-in Actions Overview

GoogleMock offers a rich set of built-in actions to cover common use cases.

### Returning Values

| Action                    | Description                                       |
| ------------------------- | ------------------------------------------------- |
| `Return()`                | Returns from a `void` mock function.              |
| `Return(value)`           | Returns a fixed value. The value is copied at setup time. |
| `ReturnArg<N>()`          | Returns the N-th argument of the mock method.     |
| `ReturnRef(variable)`     | Returns a reference to an existing variable.      |
| `ReturnRefOfCopy(value)`  | Returns a reference to a copy of value, which lives as long as the action. |
| `ReturnNew<T>(args...)`   | Returns a new pointer of type `T` created with args. Different object every call. |
| `ReturnNull()`            | Returns a null pointer.                            |
| `ReturnPointee(ptr)`      | Returns the value pointed to by `ptr`.             |
| `ReturnRoundRobin({a1,...})` | Cycles through the given values on successive calls. |

### Side Effects

| Action                        | Description                          |
| ----------------------------- | ------------------------------------ |
| `Assign(&variable, value)`    | Assigns `value` to `variable`.         |
| `DeleteArg<N>()`              | Deletes the N-th argument (pointer type). |
| `SaveArg<N>(pointer)`         | Saves the N-th argument's value into *pointer. |
| `SetArgReferee<N>(value)`    | Assigns `value` to the variable referred by argument N. |
| `SetArgPointee<N>(value)`    | Assigns `value` to the location pointed by argument N. |
| `SetArrayArgument<N>(first,last)` | Copies a range of elements into argument N, which is an array or iterator. |
| `SetErrnoAndReturn(error,value)` | Sets `errno` to `error` and returns `value`. |
| `Throw(exception)`            | Throws the given exception object.   |

### Using Callables (Functions, Functors, Lambdas)

You can specify a callable as an action to invoke custom code:

| Action                          | Description                                   |
| ------------------------------- | ---------------------------------------------- |
| `f`                           | Invokes function/functor `f` with the mock call's arguments. |
| `Invoke(f)`                   | Invokes a global/static function or functor `f`.      |
| `Invoke(object, &method)`     | Invokes a member method on the given object.         |
| `InvokeWithoutArgs(f)`        | Invokes `f` which takes no arguments.                 |
| `InvokeArgument<N>(arg1,...)` | Calls the N-th argument (function/functor) with specified args. |

`WillOnce()` accepts move-only functors (called at most once), while `WillRepeatedly()` expects copyable actions.

### Composite Actions

| Action                          | Description                                           |
| ------------------------------- | ---------------------------------------------------- |
| `DoAll(a1,a2,...,an)`          | Executes multiple actions in sequence; returns last action's result. |
| `IgnoreResult(a)`              | Executes action `a` but discards its return value.   |
| `WithArg<N>(a)`                | Executes action `a` with the N-th argument only.     |
| `WithArgs<N1,N2,...>(a)`       | Executes action `a` with selected arguments.         |
| `WithoutArgs(a)`               | Executes action `a` with no arguments.                |

---

## Specifying Actions in Tests

Actions are specified when setting up mock methods using either `ON_CALL` or `EXPECT_CALL`.

- `ON_CALL(mock, Method(args)).WillByDefault(action);` sets the default behavior for matching calls.
- `EXPECT_CALL(mock, Method(args)).WillOnce(action)[.WillRepeatedly(action)];` sets behavior and expectations.

### Example: Returning Different Values on Sequential Calls

```cpp
using ::testing::Return;

EXPECT_CALL(turtle, GetX())
    .WillOnce(Return(100))   // 1st call returns 100
    .WillOnce(Return(150))   // 2nd call returns 150
    .WillRepeatedly(Return(200));  // Subsequent calls return 200
```

### Example: Setting a Side Effect on an Output Argument

```cpp
using ::testing::SetArgPointee;
using ::testing::Return;

EXPECT_CALL(mock_mutator, Mutate(true, _))
    .WillOnce(DoAll(SetArgPointee<1>(5), Return(true)));
```

This sets the second argument to 5 and returns `true`.

---

## Best Practices and Tips

- **Use `ON_CALL` to declare default behaviors** that cover the typical use-case or fallback behavior.
- **Use `EXPECT_CALL` to set precise expectations and override default behaviors** when testing specific interactions or edge cases.
- Prefer **`WillOnce`** for specifying actions expected only once, and **`WillRepeatedly`** for all subsequent, repeated calls.
- Chain multiple `WillOnce` to simulate changing states or sequences.
- Use **`DoAll`** to combine side effects and return a value.
- When dealing with move-only types (like `std::unique_ptr`), prefer lambdas or functors for actions.
- Use `Invoke` and related actions to delegate to existing functions, methods, or lambdas for clearer tests and code reuse.
- Avoid over-specifying behavior; use `ON_CALL` generously to reduce test brittleness.
- Use `IgnoreResult` if you want to use an action returning a value in a `void` mock method or in `DoAll` before a terminating action.

---

## Troubleshooting Common Issues

- **Unintended sticky expectations:** Normal expectations don't retire automatically after saturation, causing unexpected failures on repeated calls. Fix with `.RetiresOnSaturation()`.
- **Too few or too many actions:** Warnings appear if the number of `WillOnce` actions does not match expected call count.
- **Using `Return` with move-only types in `WillRepeatedly`** causes run-time errors. Use lambdas or functors instead.
- **Uninteresting calls warnings:** Mocks print warnings when methods without `EXPECT_CALL` are called. Use `NiceMock` to suppress or add catch-all expectations.

---

## Further Reading

- [Actions Reference](../reference/actions.md) — Details and exhaustive list of built-in actions.
- [gMock Cookbook](../gmock_cook_book.md) — Practical recipes for writing custom and composite actions.
- [gMock for Dummies — Using Mocks in Tests](../gmock_for_dummies.md#using-mocks-in-tests) — User-oriented introduction including actions.

---

By mastering actions and their composition, you transform your mocks from static placeholders into powerful, dynamic participants in your test scenarios — enabling rigorous, expressive, and maintainable tests that simulate complex behaviors and interactions effectively.


---