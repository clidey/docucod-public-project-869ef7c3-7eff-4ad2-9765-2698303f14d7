---
title: "Parameterized and Typed Testing"
description: "Understand the distinction between value-parameterized and type-parameterized tests in GoogleTest. Learn how these approaches enable broad test coverage by running the same test code with multiple inputs or data types. Covers best practices for scalable, maintainable parameterized suites."
---

# Parameterized and Typed Testing

GoogleTest extends the classic test framework by enabling you to write tests that run repeatedly over a range of values or types without duplicating code. This page clarifies the distinction between **value-parameterized tests** and **typed tests**—two powerful patterns that help you broaden test coverage efficiently and scalably.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic multiple times with different input data values, exposing bugs that manifest only under specific conditions or inputs.

### When to Use
- Testing the same feature or behavior against multiple input values.
- Data-driven testing where you want to verify different inputs produce expected outcomes.
- Validating different implementations via parameters.

### How to Write

1. **Define a Test Fixture:** Derive a fixture class from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Your fixture setup goes here.
};
```

2. **Define Parameterized Tests:** Use the `TEST_P` macro similarly to a normal test but inside use `GetParam()` to retrieve the current parameter value.

```cpp
TEST_P(FooTest, HandlesParameter) {
  int param = GetParam();
  EXPECT_TRUE(ValidateBehaviour(param));
}
```

3. **Instantiate Tests:** Use `INSTANTIATE_TEST_SUITE_P` to specify parameters to run the tests with. GoogleTest provides several parameter generators:

- `Values(v1, v2, ...)` — specific values
- `ValuesIn(container)` — values from a container or array
- `Range(start, end, step)` — values in a numeric range
- `Bool()` — boolean parameters {false, true}
- `Combine(g1, g2, ...)` — cartesian product of multiple generators

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    IntValues, FooTest, testing::Values(1, 2, 3));

const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(
    PetValues, FooTest, testing::ValuesIn(pets));
```

### Naming Parameterized Tests

By default, each parameterized test instance name includes an index of the parameter. You can customize the test name suffix with a function or functor accepting a `testing::TestParamInfo<T>` and returning a valid string containing only alphanumeric characters or underscores.

Example with custom naming:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Param" + std::to_string(info.param);
    });
```

### Best Practices and Tips
- Use parameterized tests to avoid duplicating test code for many input values.
- Prefer `ValuesIn()` or `Range()` when testing with many or continuous values.
- Carefully design parameter types to be copyable or manage lifetime when using raw pointers.
- Ensure custom test names are unique and valid to avoid conflicts.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest)` to suppress warnings if no instantiation is provided (e.g., in libraries).

---

## Typed Tests

Typed tests allow you to run a suite of tests repeatedly over a set of **types** rather than values. This is especially useful when you want to verify consistent behavior or interface conformance across multiple data types.

### When to Use
- Validating the same logic on different types.
- Testing generic code or templates.
- Creating reusable test suites for type-based variations.

### How Typed Tests Differ from Value-Parameterized Tests
- Typed tests are parameterized over types, not values.
- The type list must be known and provided at test definition time.
- Typed tests define a test fixture class template parameterized by a type.

### How to Write

1. **Define a Fixture Class Template:** Create a template fixture, deriving from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
  // Additional shared data or methods here.
};
```

2. **Associate a Type List:** Declare the set of types to test using `testing::Types<>` and bind it to your fixture using `TYPED_TEST_SUITE`.

```cpp
using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Define Typed Tests:** Use `TYPED_TEST` macros for the tests; inside test bodies, the special identifier `TypeParam` represents the current type being tested.

```cpp
TYPED_TEST(MyTypedTest, HasDefaultConstructor) {
  TypeParam instance{};  // construct default instance
  (void)instance;       // avoid unused variable warning
  EXPECT_TRUE(true);    // dummy check
}
```

4. **Run:** Once compiled, GoogleTest will run all `TYPED_TEST`s for each type in your list.

### Customizing Type Names

You can provide an optional third parameter to `TYPED_TEST_SUITE` that names your types with a custom class exposing a static templated `GetName(int)` function that returns a string for each type.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, std::string>) return "string";
  }
};
TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Type-Parameterized Tests (Advanced Variant)

Type-parameterized tests build upon typed tests by allowing the test patterns to be defined *without* knowing concrete types ahead of time and *instantiated* multiple times with different type lists, potentially in different translation units.

The pattern for these tests is:

- Use `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` to declare the test pattern.
- Register all test names with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate the test pattern with `INSTANTIATE_TYPED_TEST_SUITE_P` with desired types.

This makes your tests highly reusable across projects.

---

## Example: Using Value-Parameterized Tests

```cpp
#include <gtest/gtest.h>

class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers,
                         IsEvenTest,
                         testing::Values(2, 4, 6, 8, 10));
```

This test suite runs the same test logic with each provided integer.

---

## Example: Using Typed Tests

```cpp
#include <vector>
#include <list>
#include <gtest/gtest.h>

template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container_;
};

using MyTypes = testing::Types<std::vector<int>, std::list<int>>;

TYPED_TEST_SUITE(ContainerTest, MyTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

This test runs once for `std::vector<int>` and once for `std::list<int>`, verifying container emptiness.

---

## Troubleshooting Common Issues

- **Test Names with Illegal Characters:** Parameterized tests require test names to be free from spaces or dashes. Use custom naming functions to sanitize.
- **Tests Not Executing:** Ensure you instantiate all parameterized test suites, or mark them with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if intentional.
- **Compiler Errors in `MOCK_METHOD` with Commas:** Surround complex argument types involving commas with parentheses or use type aliases.
- **Dangling References in Parameter Generators:** When using `ConvertGenerator` with lambdas, ensure captured data lifetime exceeds test execution to avoid dangling references.

---

## Summary

| Aspect                   | Value-Parameterized Tests                  | Typed Tests                              |
|--------------------------|-------------------------------------------|-----------------------------------------|
| Parameterized Over       | Values                                    | Types                                   |
| Test Fixture Base Class  | `TestWithParam<T>`                         | `Test` (templated)                       |
| Test Definition Macros   | `TEST_P`                                  | `TYPED_TEST`                            |
| Instantiation Macros     | `INSTANTIATE_TEST_SUITE_P`                 | `TYPED_TEST_SUITE`                       |
| Use Case                 | Data-driven testing with multiple inputs  | Multiple types for generic interface tests |

---

## References and Next Steps

- For detailed examples and syntax, visit [Value-Parameterized Tests](../advanced.md#value-parameterized-tests).
- Explore [Typed Tests](../advanced.md#typed-tests) for advanced use cases.
- Consult the [Testing Reference](../docs/reference/testing.md#TEST_P) for macros and attributes.
- Learn best practices in [Testing Best Practices](../guides/advanced-usage/best-practices).

---

Feel empowered to leverage parameterized and typed tests to dramatically enhance your test coverage and maintenance efficiency by avoiding duplicated test logic while safeguarding correctness across a spectrum of inputs and types.