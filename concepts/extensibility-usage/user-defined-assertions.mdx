---
title: "User-Defined and Custom Assertions"
description: "Uncover how to extend GoogleTest with your own assertion macros and behaviors, enabling domain-specific checks and better failure diagnostics tailored to your codebase."
---

# User-Defined and Custom Assertions

Extend GoogleTest by creating your own assertion macros and behaviors to perform specialized validations tailored to your codebase. Custom assertions enable domain-specific checks, better failure diagnostics, and clearer test intentions beyond what built-in assertions cover.

---

## Why Create Custom Assertions?

Built-in assertions like `EXPECT_EQ` or `ASSERT_TRUE` are powerful for common conditions, but certain projects benefit from assertions that express domain-specific logic. Custom assertions help:

- **Enhance readability:** Convert complex checks into expressive statements resembling natural language.
- **Provide richer diagnostics:** Deliver detailed, contextual failure messages that pinpoint the nature of the issue.
- **Promote code reuse:** Encapsulate commonly repeated verification logic used across various tests.

Think of custom assertions as your way to tell a clearer story about what your code is supposed to do and what exactly went wrong when a test fails.

---

## Types of Custom Assertions You Can Define

GoogleTest supports various levels of assertion customization, each offering different control and capability:

### 1. Custom Assertion Macros

You can write macros that use existing GoogleTest assertions combined with your domain logic. Ideal for simple cases where you want to package a set of assertions.

```cpp
#define ASSERT_IS_POSITIVE(value) \
  ASSERT_GT(value, 0) << "Expected a positive number, but got " << value;

// Usage
TEST(MyTest, PositiveCheck) {
  int x = GetValue();
  ASSERT_IS_POSITIVE(x);
}
```

### 2. Predicate Assertions Using Boolean Functions

Encapsulate complex conditions in a Boolean function and use `EXPECT_PRED_*` macros to automatically print argument values on failure.

```cpp
bool IsEven(int n) {
  return (n % 2) == 0;
}

EXPECT_PRED1(IsEven, number);
```

This approach provides argument values on failure, helping to understand why the assertion failed.

### 3. Predicate-Format Assertions with `AssertionResult`

Write predicate functions that return `::testing::AssertionResult`, allowing detailed success or failure messages.

```cpp
::testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0)
    return ::testing::AssertionSuccess() << n << " is even";
  else
    return ::testing::AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(number));
```

This offers rich, tailored feedback for both success and failure.

### 4. MATCHER and MATCHER_P Macros

Define reusable matchers that can be used inside `EXPECT_THAT()` for expressive and composable checks.

```cpp
MATCHER(IsDivisibleBy, "divisible by an integer") {
  return arg % (int)negation ? false : true;
}

EXPECT_THAT(value, IsDivisibleBy(3));
```

### 5. Writing Matcher Classes

For full control, implement matcher classes exposing methods like `MatchAndExplain()`, `DescribeTo()`, and `DescribeNegationTo()`. This option helps you create polymorphic or high-performance matchers.

### 6. Custom ASSERT and EXPECT Macros

You can create assertion macros that wrap the above predicates and provide a custom syntax more natural to your domain.

```cpp
#define ASSERT_IS_EVEN(value) \
  ASSERT_PRED1(IsEven, value)
```

---

## Best Practices for User-Defined Assertions

- **Keep assertions expressive:** Name your assertions clearly to reflect what is expected.
- **Provide informative failure messages:** Use `AssertionResult` or explicit messages to help users debug failures quickly.
- **Avoid side effects:** Assertions should be free of side effects and not modify program state.
- **Use streaming messages for extra context:** Allow users to append messages via `<<` operators for customized diagnostics.
- **Integrate with existing matchers:** Where applicable, build on GoogleMock matchers for consistency.
- **Verify argument evaluation count:** Make sure predicates or custom assertions evaluate arguments exactly once to avoid bugs.

---

## Example: Defining a Custom Predicate-Formatter Assertion

Suppose you want to assert that a container is sorted:

```cpp
::testing::AssertionResult IsSorted(const int* begin, const int* end) {
  if (std::is_sorted(begin, end))
    return ::testing::AssertionSuccess();

  return ::testing::AssertionFailure() << "Container is not sorted.";
}

#define ASSERT_SORTED(container) \
  ASSERT_TRUE(IsSorted(container.begin(), container.end())) << "Container: " << testing::PrintToString(container);
```

Usage:

```cpp
std::vector<int> vec = {1, 3, 2};
ASSERT_SORTED(vec);
```

Failure output will clearly state the problem and print the container contents.

---

## Integration with GoogleMock

Custom assertions can be combined with GoogleMock expectations for verifying mock method argument values in a flexible manner.

For example:

```cpp
// Define a matcher
MATCHER_P2(IsInRange, low, high, "Checks if value is in range") {
  return arg >= low && arg <= high;
}

// Use in expectation
EXPECT_CALL(mock, SomeMethod(IsInRange(5, 10)));
```

---

## Troubleshooting and Common Pitfalls

- **Unclear error message:** Provide custom descriptive messages or use `AssertionResult` with streamed explanations.
- **Evaluation side effects:** Ensure predicate functions or assertions donâ€™t have side effects since GoogleTest may evaluate arguments multiple times.
- **Overly broad matchers:** Be specific to avoid false positives in mock function argument matching.
- **Incorrect macro placement:** Define mock methods in public sections for successful mocking.

---

## Additional Resources

- [GoogleTest Assertions Reference](reference/assertions.md): Learn about built-in assertions and predicate macros.
- [GoogleMock Cookbook - Writing New Matchers](docs/gmock_cook_book.md#NewMatchers): Examples on defining custom matchers.
- [Writing Better Tests with Custom Matchers and Assertions](guides/core-testing-patterns/using-assertions-and-matchers.md)
- [GoogleTest Primer](docs/primer.md): Understand core testing concepts.

---

## Summary

User-defined and custom assertions empower you to extend GoogleTest with domain-specific verification capabilities. Whether through simple macros or advanced matcher classes, these tools let you express intent clearly, provide better diagnostics, and maintainable tests.

Embedding custom assertions within test code leads to more readable and reliable test suites, improving both the development and debugging experience.


