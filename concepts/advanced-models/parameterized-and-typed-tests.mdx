---
title: "Parameterized and Typed Test Models"
description: "Learn how GoogleTest models parameterized tests (for varying data inputs) and type-parameterized tests (for different C++ types), and how the framework internally manages test instantiation, execution, and reporting for these advanced use cases."
---

# Parameterized and Typed Test Models

GoogleTest offers powerful abstractions to help you write tests that cover a wide range of input scenarios and type variations without redundant code. This page explores two advanced testing models supported by GoogleTest:

- **Value-Parameterized Tests**: Test the same logic with different data inputs.
- **Type-Parameterized Tests**: Test the same code logic over different C++ types.

Understanding these models enables you to create more expressive, maintainable, and comprehensive C++ test suites.

---

## 1. Value-Parameterized Tests

### Purpose and Use Cases

Value-parameterized tests allow you to run the same test logic multiple times with different parameter values. This is essential when you want to verify that your code behaves correctly for various inputs, without writing repetitive test code.

Common use cases include:

- Validating behavior for a range of numeric or string inputs.
- Testing algorithms on different configurations.
- Running tests with various combinations of flags or settings.

### Defining Value-Parameterized Tests

1. **Define a Test Fixture**: Create a class derived from `testing::TestWithParam<T>` where `T` is the parameter's type.

2. **Write Tests with `TEST_P`**: Use the `TEST_P` macro with the fixture class. Inside test bodies, call `GetParam()` to access the parameter value.

3. **Instantiate the Test Suite**: Use `INSTANTIATE_TEST_SUITE_P` with a collection of parameter values generated by provided generators, such as `Values()`, `ValuesIn()`, `Range()`, `Bool()`, or `Combine()`.

### Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ReturnsCorrectFactorial) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ComputeExpectedFactorial(n));
}

INSTANTIATE_TEST_SUITE_P(ValidInputs, FactorialTest, ::testing::Values(0, 1, 2, 3, 5, 8));
```

### Parameter Generators

GoogleTest provides generators to produce test parameters:

| Generator       | Description                                                                                   |
|-----------------|-----------------------------------------------------------------------------------------------|
| `Range(start,end[,step])` | Produces values from `start` to just before `end`, optionally stepping by `step`.             |
| `Values(v1, v2, ...)`      | Produces the specified list of values.                                                      |
| `ValuesIn(container)`       | Produces values from an array, container, or iterator range.                                |
| `Bool()`                   | Produces sequence `{false, true}`.                                                          |
| `Combine(gen1, gen2, ...)`  | Produces Cartesian product of parameters from multiple generators as `std::tuple`s.          |

You can also use `ConvertGenerator` to convert generated values to custom parameter types.

### Tips and Best Practices

- The parameter type `T` must be copyable.
- Use `SCOPED_TRACE` or custom test names to differentiate parameterized tests clearly.
- Avoid heavy-weight parameter objects to keep tests fast.
- Use custom name generators in `INSTANTIATE_TEST_SUITE_P` for readable test names.


## 2. Typed Tests

### Purpose and Use Cases

Typed tests allow you to verify the same test logic against multiple types, which is particularly useful when:

- Testing templates polymorphically over types.
- Checking that different implementations of an interface behave consistently.
- Ensuring consistency across variants of containers or algorithms.

Unlike value-parameterization, which varies data input, typed tests vary type parameters.

### Defining Typed Tests

1. **Define a Test Fixture Class Template**: Create a class template derived from `testing::Test`.

2. **Associate the Test Suite with Types**: Use `TYPED_TEST_SUITE` to bind the fixture to a list of types.

3. **Write Typed Tests**: Use `TYPED_TEST` macros to write tests. Use `TypeParam` to refer to the current type.

### Example

```cpp
template <typename T>
class MyContainerTest : public testing::Test {
 protected:
  T container_;
};

using MyTypes = testing::Types<std::vector<int>, std::list<int>, std::deque<int>>;
TYPED_TEST_SUITE(MyContainerTest, MyTypes);

TYPED_TEST(MyContainerTest, IsInitiallyEmpty) {
  EXPECT_EQ(this->container_.size(), 0);
}
```

### Customizing Typed Test Names

You can provide a custom name generator class by passing a third argument to `TYPED_TEST_SUITE`. The class must have a static template function `GetName(int)` that returns a string representing the test name suffix based on the type and index.

Example for name generator:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyContainerTest, MyTypes, MyTypeNames);
```

### Type-Parameterized Tests (Advanced)

GoogleTest also supports type-parameterized tests, allowing defining tests without specifying types upfront, which are later instantiated multiple times with varying type lists.

This involves:

- Defining fixture templates with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` (declaration phase).
- Registering test names with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiating them multiple times with `INSTANTIATE_TYPED_TEST_SUITE_P` passing different type lists.

See the official API Reference for details on these macros.

## 3. GoogleTest Internals and Test Execution

GoogleTest manages parameterized and typed test cases by dynamically instantiating test objects for each parameter value or type and registers them with unique names including the parameter or type info.

This enables:

- Running any individual test in isolation.
- Filtering tests by parameter or type name.
- Reporting results with detailed context.

The framework ensures each test instance runs in a fresh fixture object, isolated from others, upholding test independence.

## 4. Practical Tips

- Always use `TEST_P` with value-parameterized tests and `TYPED_TEST` with typed tests.
- Provide meaningful test names, especially for parameterized tests, using custom suffix generators.
- Avoid underscores (`_`) in test suite and test names to prevent issues.
- Use `SCOPED_TRACE` to add context to failures in parameterized test loops.
- Separate death tests into distinct test suites named with suffix `DeathTest`.

## 5. References

For full API details, see:

- [`TEST_P` and `INSTANTIATE_TEST_SUITE_P`](reference/testing.md#TEST_P)
- [Value-Parameterized Tests](docs/advanced.md#value-parameterized-tests)
- [Typed Tests](docs/advanced.md#typed-tests)
- [Type-Parameterized Tests](docs/advanced.md#type-parameterized-tests)

---

## Mermaid Diagram: Parameterized and Typed Test Flow

```mermaid
flowchart TD
  subgraph Parameterized Test Flow
    DefineFixtureP[Test Fixture (TestWithParam<T>)]
    DefineTestsP[Write Tests with TEST_P]
    InstantiateP[Instantiate with INSTANTIATE_TEST_SUITE_P]
    CreateTestInstancesP[GoogleTest creates test instances per parameter]
    RunTestInstancesP[Run each test instance: fresh fixture + TestBody]
  end

  subgraph Typed Test Flow
    DefineFixtureT[Test Fixture Template <T>]
    AssociateTypesT[TYPED_TEST_SUITE with Type List]
    DefineTestsT[Write Typed Tests with TYPED_TEST]
    CreateTestInstancesT[GoogleTest creates instance per type]
    RunTestInstancesT[Run each typed test instance: fresh fixture + TestBody]
  end

  DefineFixtureP --> DefineTestsP --> InstantiateP --> CreateTestInstancesP --> RunTestInstancesP
  DefineFixtureT --> AssociateTypesT --> DefineTestsT --> CreateTestInstancesT --> RunTestInstancesT
```

---

## Summary

This guide helps you model complex testing requirements with parameterized inputs and varying types efficiently and consistently in GoogleTest.


<AccordionGroup title="Frequently Asked Questions">
<Accordion title="When to Use Value-Parameterized vs Typed Tests?">
Value-parameterized tests are best when testing code against **various input values** where the type is fixed. Typed tests are ideal when you want to verify behavior for **multiple types** using the same logic.
</Accordion>
<Accordion title="Can I Combine Typed and Parameterized Tests?">
GoogleTest treats these separately. However, you can nest typed tests inside parameterized test logic by using advanced test fixtures or combinations, but it increases complexity and is rarely needed.
</Accordion>
<Accordion title="How Does GoogleTest Generate Tests for Parameterized Suites?">
GoogleTest expands each parameter or type into an individual test instance registered uniquely, enabling detailed filtering and reporting.
</Accordion>
<Accordion title="Why Should Test Names Avoid Underscores?">
Underscores can cause symbol name conflicts in generated test classes. Avoiding them ensures robust test registration and avoids subtle bugs.
</Accordion>
</AccordionGroup>

<Note>
Remember that both value-parameterized and typed tests increase coverage without duplicating code, enhancing maintainability and reducing errors.
</Note>

---

## Additional Resources

- [GoogleTest Primer](docs/primer.md) - Basics of writing tests.
- [Advanced GoogleTest Topics](docs/advanced.md) - Detailed guide on parameterized and typed tests.
- [Testing Reference](docs/reference/testing.md) - API details on test macros.
- [GoogleMock Cookbook](docs/gmock_cook_book.md) - For mocking concepts adjacent to parameterized tests.

---

## Source Code Links

<Source url="https://github.com/google/googletest" paths={[{"path": "googletest/include/gtest/gtest-param-test.h", "range": "1-250"}, {"path": "googletest/include/gtest/gtest-typed-test.h", "range": "1-250"}]} />
