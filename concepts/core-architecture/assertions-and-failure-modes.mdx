---
title: "Assertions, Expectations, and Failure Modes"
description: "Understand the difference between assertions and expectations, the mechanisms for handling fatal and non-fatal failures, and how these control the flow and reporting of your test runs. Learn how to use and design for robust result handling."
---

# Assertions, Expectations, and Failure Modes

GoogleTest provides a rich set of assertion macros for verifying code correctness, enabling precise control over test flow via _fatal_ and _non-fatal_ failures. This page helps you understand the core concepts behind assertions and expectations, the mechanisms controlling test failure propagation, and strategies for robust result handling.

---

## Assertions vs. Expectations: What They Are and How They Behave

At the heart of GoogleTestâ€™s validation are *assertions* and *expectations*, which let you verify program behavior during tests:

- **Assertions** (`ASSERT_*`) generate **fatal failures** upon failure. They immediately abort the current function, preventing further execution.
- **Expectations** (`EXPECT_*`) generate **non-fatal failures** upon failure, allowing the current function to continue running.

This distinction is critical:

- Use **assertions** when failure makes further execution of the current function invalid or meaningless.
- Use **expectations** when you want the test to continue checking other conditions even if some fail.

### Why Does This Matter?

Consider verifying multiple conditions in one test. With assertions (`ASSERT_*`), failure halts execution in the current function, which can prevent cascading errors but may obscure additional problems. Expectations (`EXPECT_*`) offer more resilience because they report failures but keep the test running, giving a broader view of defects.

### Example:

```cpp
TEST(MyTest, Example) {
  EXPECT_EQ(foo(), 10);  // Continues even if fails
  ASSERT_TRUE(bar());   // Stops if false
  // Further test code...
}
```

Here, if `bar()` returns false, `ASSERT_TRUE` aborts the test function early, while `EXPECT_EQ` just reports a failure but proceeds.

---

## Failure Modes: Fatal and Non-Fatal

The two failure modes in GoogleTest assertions influence control flow drastically:

| Failure Type | Generated By      | Effect                                      |
|--------------|-------------------|---------------------------------------------|
| Fatal        | `ASSERT_*`, `FAIL()` | Aborts current function immediately; prevents further statements in that function from running |
| Non-Fatal    | `EXPECT_*`, `ADD_FAILURE()` | Logs failure but continues execution to detect other failures |

Remember:

- Fatal failures abort only the *current* function, **not** the entire test or test suite.
- Non-fatal failures allow additional assertions (or code) to run in the current function.

### Common Pitfall

When a fatal assertion is in a helper function that returns non-void, the failure aborts the function but the calling test continues executing, potentially causing undefined behavior or crashes. For instance:

```cpp
void Helper() {
  ASSERT_EQ(1, 2);  // Fatal failure here aborts Helper()
  // ...
}

TEST(MyTest, Buggy) {
  Helper();        // This fails but returns.
  int* p = nullptr;
  *p = 3;         // CRASH, unexpected continuation
}
```

Use one of the solutions described further below to correctly handle such scenarios.

---

## Expectations and Result Handling

Expectations in GoogleTest (expressed via macros like `EXPECT_CALL` in GoogleMock) serve two main purposes:

1. **Verifying behavior contracts:** Assert that certain mock methods are called with the expected arguments and frequency.
2. **Controlling mock behavior:** Define the actions mock methods perform when invoked.

**Result Handling** in assertions and expectations affects:

- When the test aborts early (fatal failure).
- What gets reported as a test failure (non-fatal failure).
- How to compose tests for clarity and maintainability.

You can **chain and customize expectations** to suit your verification needs, including cardinalities (number of calls expected), call order, and side effects.

### Best Practices for Result Handling

- Prefer `EXPECT_*` to keep tests running unless early termination is necessary.
- Use `ASSERT_*` in setup or critical validation where proceeding makes no sense upon failure.
- Use trace helpers (`SCOPED_TRACE`) to augment failure messages for deeper insights.

---

## Designing Robust Tests with Failure Propagation

Because fatal failures abort only the current function, a common design challenge is propagating failures effectively across test helper functions.

### Techniques to Propagate Fatal Failures

1. **Exception Throwing Listener:** Wrap GoogleTest with a listener that throws exceptions when fatal failures occur. Then, your test code can catch exceptions to stop the entire test.

```cpp
class ThrowListener : public testing::EmptyTestEventListener {
  void OnTestPartResult(const testing::TestPartResult& result) override {
    if (result.type() == testing::TestPartResult::kFatalFailure) {
      throw testing::AssertionException(result);
    }
  }
};

// Add listener before RUN_ALL_TESTS()
```

2. **NO_FATAL_FAILURE Macros:** Use `ASSERT_NO_FATAL_FAILURE()` or `EXPECT_NO_FATAL_FAILURE()` to explicitly check that a statement produces no fatal failures.

```cpp
ASSERT_NO_FATAL_FAILURE(HelperFunction());
```

3. **Check Fatal Failure Flags:** `HasFatalFailure()` lets you query whether any fatal failure has occurred in the current test.

```cpp
HelperFunction();
if (testing::Test::HasFatalFailure()) return;
// Continue only if no fatal failure.
```

### Important Notes

- Fatal failure will NOT halt test execution on its own beyond the current function.
- Prevent brittle tests by avoiding excessive nesting and excessive fatal checks.

---

## Explicit Success and Failure Assertions

Sometimes, your test logic may determine success or failure not by comparison but control flow.

| Macro       | Description                                             |
|-------------|---------------------------------------------------------|
| `SUCCEED()` | Generates a success signal but does not force test pass. Useful for documenting intent or ensuring a code path is reached. |
| `FAIL()`    | Immediately fails the current function fatally. Useful for unconditional failure (e.g., unexpected code paths). |
| `ADD_FAILURE()` | Generates a non-fatal failure allowing current function to continue. |

### Example Use

```cpp
switch (error_code) {
  case 0:
    SUCCEED();  // Document: success path taken
    break;
  default:
    FAIL() << "Unexpected error code: " << error_code;
}
```

---

## Practical Tips and Common Pitfalls

### Tips

- Use `EXPECT_` macros to gather multiple failures in a single test run.
- Use `ASSERT_` macros carefully to avoid partially-constructed test objects or side effects if aborted prematurely.
- Use `SCOPED_TRACE` to disambiguate failures in helper code.
- Design subroutines that return failure status explicitly or rely on `HasFatalFailure()` to signal failures.

### Pitfalls

- Do NOT rely on fatal failure aborting the entire test unless the failure is in `TEST()` function body.
- Avoid fatal assertions inside constructors/destructors. Instead, place them in `SetUp()` or `TearDown()`.
- Beware that calling `FAIL()` or `ASSERT_*` in a non-void returning function causes compiler errors.

---

## Troubleshooting Failure Handling

If your test continues after a fatal failure unexpectedly:

- Check if the failure is happening inside a helper function that returns non-void.
- If so, use one of the fatal propagation techniques.
- Verify your assertion usage complies with function return types.

If unexpected mock calls cause errors:

- Confirm if your mock object type is `NiceMock` (suppresses warnings), `NaggyMock` (default warns on uninteresting calls), or `StrictMock` (treats uninteresting calls as errors).
- Use catch leaks and verify expectations to avoid false positives.

See [googlemock/gmock-nice-strict.h](https://github.com/google/googletest/blob/main/googlemock/include/gmock/gmock-nice-strict.h) and the [GoogleMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md#NiceStrictNaggy) for guidance.

---

## Summary

Understanding assertions, expectations, and test failure modes is essential to writing effective and maintainable tests with GoogleTest and GoogleMock. By mastering the use of fatal and non-fatal failures, managing expectation lifecycles, and propagating failures thoughtfully, you control test robustness and diagnostic clarity.

---

## References
- [GoogleTest Assertions Reference](https://github.com/google/googletest/blob/main/docs/reference/assertions.md)
- [GoogleMock Mock Object Creation & Usage](https://github.com/google/googletest/blob/main/docs/reference/mocking.md)
- [GoogleMock Cookbook: Using NiceMock, StrictMock, NaggyMock](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md#NiceStrictNaggy)
- [Advanced GoogleTest Topics](https://github.com/google/googletest/blob/main/docs/advanced.md#propagating-fatal-failures)
- [GoogleMock Source: gmock-nice-strict.h](https://github.com/google/googletest/blob/main/googlemock/include/gmock/gmock-nice-strict.h)

---

For a deeper dive, also check the [Creating and Using Mocks Guide](https://github.com/google/googletest/blob/main/guides/mocking-and-advanced-techniques/creating-and-using-mocks.md) and the [Effective Use of Assertions Guide](https://github.com/google/googletest/blob/main/guides/core-testing-patterns/assertions-best-practices.md).
