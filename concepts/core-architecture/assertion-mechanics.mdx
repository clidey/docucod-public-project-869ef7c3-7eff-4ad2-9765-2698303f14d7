---
title: "Assertion Model and Failure Handling"
description: "Dive into GoogleTest’s rich set of assertion types (equality, exceptions, fatal/non-fatal) and how the framework records, reports, and reacts to failures. Understand the difference between fatal and non-fatal assertions and their role in controlling test flow."
---

# Assertion Model and Failure Handling

GoogleTest offers a comprehensive suite of assertion macros tailored to verify the correctness of your code during tests. These assertions serve as checkpoints that validate expected conditions and behaviors, reporting success or failure accordingly. Understanding the various types of assertions and how GoogleTest handles failures empowers you to write robust tests that precisely control test flow and diagnose issues swiftly.

---

## Understanding Assertions in GoogleTest

Assertions in GoogleTest come in pairs designed to cater to different test flow control requirements:

- **Fatal Assertions (ASSERT_)**: Upon failure, these immediately abort the current test function, preventing subsequent statements from executing. Use these when a failed condition invalidates further test execution.

- **Non-Fatal Assertions (EXPECT_)**: These log failure but allow the test function to continue, enabling the discovery of multiple issues within a single test run.

Both assertion types support streaming custom failure messages using the `<<` operator for richer diagnostic output.

### Why Two Types of Assertions?

Imagine validating an operation where subsequent logic depends on a verified condition. Fatal assertions help you safely halt tests early, avoiding misleading cascades. Conversely, non-fatal assertions are invaluable to collect as much failure information as possible, enhancing debugging effectiveness.

## Core Assertion Types and Usage

GoogleTest classifications of assertions include:

### 1. Boolean Assertions

- `EXPECT_TRUE(condition)` and `ASSERT_TRUE(condition)` verify that *condition* is true.
- `EXPECT_FALSE(condition)` and `ASSERT_FALSE(condition)` verify that *condition* is false.

Example:
```cpp
EXPECT_TRUE(user.IsLoggedIn()) << "User must be logged in";
ASSERT_FALSE(error_occurred) << "No errors expected at this point";
```

### 2. Equality and Comparison Assertions

These use macros such as `EXPECT_EQ(expected, actual)` and `ASSERT_LT(val1, val2)`, checking various comparison operators. When comparing C strings, special string comparison macros like `EXPECT_STREQ` ensure content equality.

Example:
```cpp
ASSERT_EQ(processed_count, kExpectedCount);
EXPECT_NE(return_code, 0) << "Return code should signify error";
```

### 3. String and Floating-point Assertions

Specialized macros exist for detailed comparisons:

- String comparisons handle C strings and wide strings considering encoding.
- Floating-point assertions (`EXPECT_FLOAT_EQ`, `EXPECT_NEAR`) account for precision and rounding errors.

### 4. Exception Assertions

If your test scenario involves exceptions, GoogleTest allows asserting whether a piece of code throws or does not throw:

- `EXPECT_THROW(statement, exception_type)`
- `EXPECT_NO_THROW(statement)`

Example:
```cpp
ASSERT_THROW(ProcessInput(nullptr), std::invalid_argument);
EXPECT_NO_THROW(ProcessInput(valid_pointer));
```

### 5. Predicate Assertions

These test custom logical conditions and provide enhanced failure diagnostics:

- `EXPECT_PRED2(predicate, val1, val2)` expects *predicate(val1,val2)* to be true.
- `EXPECT_PRED_FORMAT*` variants allow custom formatted failure messages.

## Fatal vs Non-Fatal Assertions: Effects on Test Flow

Understanding the distinction between fatal and non-fatal assertions is key to controlling test execution:

- **Fatal Assertions (`ASSERT_` prefixed macros):** Abort the current function immediately on failure, suitable for preconditions without which further testing is meaningless.
- **Non-Fatal Assertions (`EXPECT_` prefixed macros):** Log failures but continue executing the test, allowing multiple assertions in one test to be evaluated.

### When to Use Each

- Use **fatal assertions** to guard critical conditions or to enforce invariants.
- Use **non-fatal assertions** to validate multiple independent aspects within a test.

### Possible Pitfall

Be mindful that fatal assertions stop execution inside the current function only, not the entire test program, aiding localized failure containment.

## How GoogleTest Records and Reports Failures

GoogleTest captures failures with detailed context, including:

- The **source file and line number** where the assertion failed.
- A **description** of the expected condition and the actual values.
- A **custom message**, if provided via the streaming operator.

Failures generate output that aids in quick problem localization and resolution.

### Examples of Failure Output

For example, a failure in `EXPECT_EQ` might output:
```
Value of: processed_data.size()
  Actual: 4
Expected: 5
"Processed data count mismatch"
```

This clearly shows the tested value, the expected value, and an optional message.

## Assertion Macros for Explicit Success and Failure

Sometimes control flow requires explicit success or failure statements rather than expression-based checks. GoogleTest supports:

- `SUCCEED()` to record a successful assertion explicitly.
- `FAIL()` or `ADD_FAILURE()` to unconditionally fail a test; `FAIL()` is fatal, `ADD_FAILURE()` is non-fatal.

Use these macros when your testing logic depends on reaching specific lines or outcomes.

## Controlling Test Flow with Assertions: A Sample Workflow

Imagine you are testing a file parser:

```cpp
TEST(FileParserTest, ParsesValidFile) {
  FileParser parser;
  ASSERT_TRUE(parser.LoadFile("valid_file.txt")) << "File must load successfully";

  auto entries = parser.GetEntries();
  EXPECT_GT(entries.size(), 0) << "Entries should be found";

  for (const auto& entry : entries) {
    EXPECT_TRUE(entry.IsValid()) << "Entry should be valid";
  }
}
```

- `ASSERT_TRUE` ensures the file loads before continuing.
- Non-fatal `EXPECT_GT` and `EXPECT_TRUE` allow reporting multiple entry errors.

## Practical Tips and Best Practices

- Use **fatal assertions** for critical preconditions where continuing makes no sense.
- Use **non-fatal assertions** to collect multiple validation results in one test.
- Always provide **clear custom failure messages** to aid diagnosis.
- Be cautious of assertion order inside test functions to avoid misleading stops.
- Use `EXPECT_THAT` with matchers for expressive and readable assertions.

## Troubleshooting Common Assertion Issues

### Tests Stop Prematurely

Check if a fatal assertion failed. Replace it temporarily with a non-fatal assertion to gather more info.

### Assertions Fail Without Clear Messages

Add custom messages using the streaming operator `<<` to clarify failure context.

### Unexpected Test Passes Despite Failures

Verify that assertions are actually reached and not skipped due to control flow.

### Comparing Floating-point Numbers

Use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` instead of `EXPECT_EQ` to avoid false negatives caused by rounding.

## Summary

GoogleTest’s assertion framework offers a rich, nuanced way to verify conditions, enabling precise test flow control and detailed diagnostics. By choosing the appropriate assertion type and crafting clear failure messages, you ensure your tests remain effective, maintainable, and user-friendly.

---

## References and Related Documentation

- [GoogleTest Assertions Reference](../api-reference/test-and-assertion-api/assertions-api)
- [Matchers Reference](../api-reference/mocking-and-matcher-api/matcher-api)
- [Mocking Reference](../docs/reference/mocking.md)
- [gMock Cookbook](../docs/gmock_cook_book.md)
- [Writing and Running Tests Guide](../../guides/writing-tests/test-primer)

---