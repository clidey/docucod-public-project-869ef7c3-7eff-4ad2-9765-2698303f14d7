---
title: "Test Structure & Lifecycle"
description: "Learn how tests are defined, discovered, organized into suites, and executed within GoogleTest. This includes how fixture classes and test macros orchestrate setup, tear-down, and reporting cycles."
---

# Test Structure & Lifecycle

Understanding the way GoogleTest structures, discovers, and executes tests is fundamental to effective test writing and management. This guide unpacks the key elements of test definition, organization into test suites, lifecycle events, fixture usage, and execution flow within the GoogleTest framework.

---

## 1. Test Definition and Discovery

### 1.1 Writing Tests with Macros

GoogleTest uses C++ macros to define tests, which register themselves automatically.

- **`TEST(TestSuiteName, TestName)`**
  - Defines a simple test function within the named test suite.
  - Both `TestSuiteName` and `TestName` are identifiers without underscores.
  - Example:
  ```cpp
  TEST(FactorialTest, HandlesZeroInput) {
    EXPECT_EQ(Factorial(0), 1);
  }
  ```

- **`TEST_F(TestFixtureName, TestName)`**
  - Defines a test that uses a test fixture class `TestFixtureName`.
  - The fixture allows sharing setup and teardown logic and common data.
  - Example:
  ```cpp
  class QueueTest : public testing::Test {
   protected:
    QueueTest() {
      q1_.Enqueue(1);
    }
    Queue<int> q1_;
  };

  TEST_F(QueueTest, EnqueueDequeueWorks) {
    int* val = q1_.Dequeue();
    ASSERT_NE(val, nullptr);
    EXPECT_EQ(*val, 1);
    delete val;
  }
  ```

### 1.2 Naming Conventions and Constraints

- Test suite names and test names **must not contain underscores (`_`)** to avoid internal naming conflicts.
- Test full names are `TestSuiteName.TestName`.
- Tests with the same individual name but different suites are allowed.

<Note>
Avoid underscores in test and suite names to ensure stable test registration and execution across compiler and framework updates.
</Note>

### 1.3 Test Fixtures

Fixtures are classes derived from `testing::Test` that hold common setup for multiple tests.

- Each test gets a fresh fixture instance.
- Define `SetUp()` and `TearDown()` methods to prepare/clean resources.
- Use fixture data members to share data.
-
Example Fixture:
```cpp
class FooTest : public testing::Test {
protected:
  void SetUp() override {
    shared_obj_ = new ObjectType();
  }

  void TearDown() override {
    delete shared_obj_;
  }

  ObjectType* shared_obj_;
};
```

### 1.4 Types of Tests Supported

- **Simple Tests**: Use `TEST()` for standalone tests without fixtures.
- **Fixture Tests**: Use `TEST_F()` to reuse code and data.
- **Value-Parameterized Tests**: Use `TEST_P()` combined with `INSTANTIATE_TEST_SUITE_P()` to run tests with varying parameters.
- **Typed and Type-Parameterized Tests**: Use `TYPED_TEST()` and `TYPED_TEST_P()` for running tests across multiple types.

## 2. Test Suite Organization

### 2.1 Test Suites

- Collections of related tests.
- Share setup and teardown through fixtures or static methods.
- Test suite name corresponds to the fixture class name for `TEST_F()`.

### 2.2 Setup and Teardown for Suites

- Define static methods `SetUpTestSuite()` and `TearDownTestSuite()` in fixture classes to manage expensive shared resources.
- These are called once before the first test and after the last test in the suite.

Example:
```cpp
class FooTest : public testing::Test {
 public:
  static void SetUpTestSuite() {
    shared_resource_ = new Resource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

 protected:
  static Resource* shared_resource_;
};

Resource* FooTest::shared_resource_ = nullptr;
```

### 2.3 Disabled Tests

- Prefix test or suite names with `DISABLED_` to exclude from runs.
- Include disabled tests by running program with `--gtest_also_run_disabled_tests`.

### 2.4 Test Filtering and Execution Control

- Use `--gtest_filter=` to select specific tests or suites by name patterns.
- Supports include and exclude patterns separated by '-' (e.g., `FooTest.*-FooTest.Bar`).
- Use `--gtest_repeat=N` to run tests multiple times.
- Use `--gtest_shuffle` to randomize test execution order.

<Info>
Filtering and controlling test execution helps isolate, debug, and manage large test suites effectively.
</Info>

## 3. Test Execution Lifecycle

GoogleTest organizes the execution of tests according to a well-defined lifecycle to ensure isolation and accurate results.

### 3.1 Fixture Object Lifecycle

For each `TEST_F()` or parameterized `TEST_P()`:

1. Construct a test fixture object.
2. Call `SetUp()` on the fixture.
3. Run the `TestBody()` (test logic).
4. Call `TearDown()`.
5. Destroy the fixture object.

Each test is isolated by using a fresh fixture object.

### 3.2 Test Result Collection

- Failures during assertions are recorded with file, line, and message.
- Test outcome is success only if no failed assertions and no crashes.
- Fatal failures (`ASSERT_*`) abort the current test, while non-fatal failures (`EXPECT_*`) continue the test.
- Skips can be triggered via `GTEST_SKIP()`.

### 3.3 Event Callbacks

Users can hook into test lifecycle using the **Event Listener API** to monitor or customize behavior:

- `OnTestProgramStart()`, `OnTestIterationStart()`,
- `OnTestSuiteStart()`, `OnTestStart()`,
- `OnTestPartResult()`, `OnTestEnd()`, `OnTestSuiteEnd()`,
- `OnTestProgramEnd()`, and others.

These provide granular control over reporting, logging, or integration with custom tooling.

### 3.4 Test Registration

- Tests register themselves at static initialization time.
- GoogleTest maintains a global registry.
- Running tests is driven by the `RUN_ALL_TESTS()` macro, which iterates over the registry.

<Note>
Because of auto-registration, adding a test to your code is sufficient for it to be discovered and run without extra configuration.
</Note>

## 4. Illustrative Example

```cpp
#include <gtest/gtest.h>

// Fixture with shared resource.
class DatabaseTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    db_ = new DatabaseConnection("test_db");
  }

  static void TearDownTestSuite() {
    delete db_;
    db_ = nullptr;
  }

  void SetUp() override {
    db_->BeginTransaction();
  }

  void TearDown() override {
    db_->RollbackTransaction();
  }

  static DatabaseConnection* db_;
};

DatabaseConnection* DatabaseTest::db_ = nullptr;

TEST_F(DatabaseTest, CanInsertRecord) {
  bool inserted = db_->InsertRecord({"key", "value"});
  EXPECT_TRUE(inserted);
}

TEST_F(DatabaseTest, CanQueryRecord) {
  db_->InsertRecord({"foo", "bar"});
  std::string val = db_->QueryRecord("foo");
  EXPECT_EQ(val, "bar");
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

## 5. Best Practices and Tips

- Avoid underscores in test and suite names for compatibility.
- Use fixtures to share environment setup efficiently and keep tests isolated.
- Clean up shared resources properly in `TearDownTestSuite()`.
- Use `EXPECT_*` for errors you want to continue testing past; use `ASSERT_*` when failure should immediately halt.
- Utilize test filters and repetition flags to focus test runs.
- Register event listeners for rich test reporting or custom behavior.

## 6. Troubleshooting Common Issues

- **Test Not Called**: Check macro spelling (`TEST` vs `TEST_F`), fixture existence, and naming conventions.
- **Setup/TearDown Not Called**: Ensure proper casing (`SetUp()` not `Setup()`).
- **Test Suite Name Conflicts**: Avoid duplicate test suite names or fixture classes with conflicting names.
- **Ignoring `RUN_ALL_TESTS()` Return**: Always return the value of `RUN_ALL_TESTS()` from `main()` to reflect test success/failure correctly.

## 7. Diagram of Test Execution Flow

```mermaid
flowchart TD
  Start([Start Test Program]) --> Init[InitGoogleTest()]
  Init --> Register[Register Tests (auto)]
  Register --> RUN_ALL_TESTS
  RUN_ALL_TESTS --> SuiteLoop{For Each Test Suite}
  SuiteLoop -->|yes| SetupSuite[Call SetUpTestSuite()]
  SetupSuite --> TestLoop{For Each Test}
  TestLoop -->|yes| FixtureCtor[Construct Fixture Object]
  FixtureCtor --> SetUp[Test Fixture SetUp()]
  SetUp --> TestBody[TestBody()]
  TestBody --> TearDown[Test Fixture TearDown()]
  TearDown --> FixtureDtor[Destroy Fixture Object]
  FixtureDtor --> TestLoop
  TestLoop -->|no| TearDownSuite[Call TearDownTestSuite()]
  TearDownSuite --> SuiteLoop
  SuiteLoop -->|no| End([Finish and Report Results])
```

---

For further exploration, see the links in the summary below.

---

# References
- [GoogleTest Primer](primer.md) – introductory concepts and how to write simple tests.
- [Testing Reference](reference/testing.md) – detailed API for writing tests.
- [Advanced GoogleTest Topics](advanced.md) – deeper insights on test fixtures, parameterized tests, lifecycle hooks.
- [GoogleTest FAQ](faq.md) – common questions around test naming, fixture usage, and debugging.

---

# Summary
This guide introduced the lifecycle of tests in GoogleTest, from definition using macros to execution and reporting. It covered how tests are grouped in test suites, use fixtures for shared setup, and how the framework orchestrates setup, teardown, and test execution to ensure isolation and reliability.

Practical tips were provided around naming conventions, use of fixtures, and managing test execution. An example illustrated common test fixture usage, and a Mermaid diagram visualized the execution flow.

Users are encouraged to explore the Primer and Advanced Guides to deepen understanding and master test organization and lifecycle control in GoogleTest.

---

