---
title: "Assertions and Result Handling"
description: "Discover how assertions are defined, evaluated, and reported. Learn about fatal vs. non-fatal assertions, the structure of assertion results, and how user-defined assertions fit into the execution cycle."
---

# Assertions and Result Handling

GoogleTest's assertion mechanism is the cornerstone for verifying code correctness and reporting test outcomes. This guide reveals how assertions are defined, evaluated, and reported, detailing the behavior of fatal versus non-fatal assertions, the anatomy of assertion results, and the role of user-defined assertions within the testing execution cycle.

---

## Understanding Assertions

Assertions are macros embedded in test code that express expectations about the program's state. They form the primary tool for tests to detect failures or confirm expected behavior.

### Assertion Types

GoogleTest provides paired assertion macros, differing primarily in how they treat failure:

- **EXPECT_...** macros generate a *non-fatal failure* when they fail, recording the failure but allowing the current test function to continue running.
- **ASSERT_...** macros generate a *fatal failure*, immediately aborting the current function upon failure to prevent further unsafe execution.

This distinction helps you control test flow, enabling multiple verification points or early exits as needed.

### Example: Using Assertions

```cpp
TEST(MathTest, SimpleAssertions) {
  int result = Factorial(5);
  ASSERT_EQ(result, 120) << "Factorial(5) should be 120";
  EXPECT_TRUE(result > 0) << "Result must be positive";
}
```

Here, if `ASSERT_EQ` fails, the test function returns immediately, skipping the `EXPECT_TRUE` check.

### Custom Failure Messages

Append helpful diagnostics to assertions using the `<<` operator:

```cpp
EXPECT_EQ(value, expected) << "Mismatch at input index " << i;
```

This ensures failure reports contain precise context to guide debugging.

---

## Fatal vs Non-Fatal Assertions

The assertion type you choose affects test stability and diagnostic quality:

- **Fatal assertions (`ASSERT_*`)**
  - Immediately stop execution of the current test function.
  - Suitable when continuing is unsafe or meaningless (e.g., invalid pointer dereference).
  - Note: Cannot be used inside constructors or destructors.

- **Non-fatal assertions (`EXPECT_*`)**
  - Log the failure but continue executing the current test function.
  - Allows more errors to be detected and collected in one test run.

---

## The Structure of Assertion Results

Each assertion evaluates to one of four possible outcomes encapsulated in a `TestPartResult`:

- **kSuccess** — assertion passed.
- **kNonFatalFailure** — non-fatal failure (via `EXPECT_*`).
- **kFatalFailure** — fatal failure (via `ASSERT_*`).
- **kSkip** — the assertion was skipped (via `GTEST_SKIP()`).

### Detailed Information

When a failure occurs, GoogleTest provides:

- **Source location:** The file and line number where the assertion was triggered.
- **Summary message:** A concise failure description.
- **Detailed message:** The full failure message, including custom appended info.

Example failure output:

```none
/path/to/file.cc:42: Failure
Value of: foo
  Actual: 3
Expected: 5
Mismatch at index 2
```

---

## User-Defined Assertions and Predicates

GoogleTest empowers you to write custom assertions that deliver more expressive diagnostics when built-in assertions are insufficient.

### Using Predicate Assertions

Predicate assertions check complex conditions and print detailed diagnostic information.

```cpp
bool IsEven(int n) {
  return (n % 2) == 0;
}

TEST(NumberTest, CheckEven) {
  EXPECT_PRED1(IsEven, x);
}
```

If `EXPECT_PRED1` fails, it prints the actual argument values for clarity.

### AssertionResult for Rich Messages

For fine-grained control over failure messages, use functions returning `testing::AssertionResult`:

```cpp
testing::AssertionResult IsEvenDetailed(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

TEST(NumberTest, CheckEvenDetailed) {
  EXPECT_TRUE(IsEvenDetailed(x));
}
```

On failure, this will print the explanatory message.

### Predicate-Formatter Assertions

For maximum flexibility in formatting failure messages, provide predicate-formatters that take both expressions and values:

```cpp
testing::AssertionResult AssertMutuallyPrime(const char* expr1, const char* expr2, int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr1 << " and " << expr2 << " (" << m << ", " << n << ") are not mutually prime";
}

TEST(MathTest, MutuallyPrime) {
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, x, y);
}
```

This tailored formatting improves readability and debugging ease.

---

## How Assertions Fit Into the Execution Cycle

During test execution, assertions are evaluated in the context of tests and test fixtures, and their results are collected to determine the overall test outcome.

Steps in the flow:

1. **Test Invocation:** Each test runs in isolation, with fresh fixtures.
2. **Assertion Evaluation:** When an assertion runs,
   - If it succeeds, execution proceeds.
   - For non-fatal failures, the failure is logged, but the test continues.
   - For fatal failures, the current test function returns immediately.
3. **Result Recording:** All assertion results are recorded in `TestResult` objects associated with tests.
4. **Reporting:** Failures are reported with location, failure message, and summary.

User-defined assertions seamlessly integrate into this cycle by following the prescribed interface for failure reporting.

---

## Best Practices

- Use `EXPECT_*` for checks that allow the test to continue.
- Use `ASSERT_*` when a failure makes continuing unsafe or meaningless.
- Write clear and meaningful custom failure messages.
- Use predicate assertions or `AssertionResult` for complex conditions needing rich diagnostics.
- Utilize `SCOPED_TRACE` to add contextual traces when calling assertions in helper functions.
- Avoid fatal assertions inside constructors or destructors; use `SetUp`/`TearDown` methods instead.

---

## Troubleshooting Assertion Failures

- **Assertion never triggers:** Check the condition logic and ensure the test executes the relevant code path.
- **Unexpected fatal failure:** Replace `ASSERT_*` with `EXPECT_*` temporarily to continue debugging.
- **Custom assertions always passing or failing:** Validate predicate logic and proper use of `AssertionResult`.
- **Complex failure messages cluttered**: Use predicate-formatters for precise message control.

---

## Related Concepts

- **Test Lifecycle:** Understanding how assertions fit into `SetUp()`, test execution, and `TearDown()`. See [Testing Lifecycle and Execution Flow](/concepts/core-architecture/testing-lifecycle).
- **Matchers:** Assertions integrate well with matchers for expressive conditions. See [Matchers Reference](/api-reference/mocking-apis/matchers).
- **Custom Assertions:** Extend GoogleTest with custom assertions and matchers. See [Writing Custom Assertions and Matchers](/guides/advanced-testing-patterns/custom-assertions-matchers).

---

## Summary

Assertions are the essential mechanism to verify test expectations and report results in GoogleTest. Understanding the difference between fatal and non-fatal assertions, harnessing the flexibility of user-defined assertions, and structuring failure messages effectively will allow you to write clearer, more robust tests that deliver actionable feedback.

---

### Source Reference
For detailed API and usage of assertions, see the GoogleTest Assertions Reference: [Assertions Reference](reference/assertions.md)


---