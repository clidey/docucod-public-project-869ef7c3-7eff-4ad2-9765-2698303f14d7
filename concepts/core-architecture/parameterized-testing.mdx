---
title: "Parameterized and Typed Testing"
description: "Examine the value-parameterized and type-parameterized test mechanisms, which enable writing generalized tests that run over many data values and types, maximizing coverage and reducing duplication."
---

# Parameterized and Typed Testing

The GoogleTest framework offers powerful mechanisms to write generalized tests that run over a wide range of data values and types. Two core approaches enable this capability:

- **Value-Parameterized Tests**: Run the same test logic across multiple data values, allowing coverage over varying inputs without duplicating test code.
- **Type-Parameterized Tests**: Run a single test pattern across multiple data types, ensuring that type variants of a component or interface behave consistently.

These approaches maximize test coverage and significantly reduce duplication, empowering you to write concise yet comprehensive tests.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to execute the same test body repeatedly with different parameter values. This is especially useful when testing functions or classes over a range of inputs or flag configurations.

### Defining Value-Parameterized Tests

1. **Create a Test Fixture Class**

Your fixture must derive from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the parameter type. For convenience, you can inherit from `testing::TestWithParam<T>`, which combines both.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Usual fixture members
};
```


2. **Define Tests Using `TEST_P`**

Instead of `TEST_F`, use `TEST_P` to define test patterns. Access the current parameter with `GetParam()`:

```cpp
TEST_P(FooTest, HandlesValue) {
  int param = GetParam();
  EXPECT_TRUE(Process(param));
}
```


3. **Instantiate Tests With Parameters**

Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with a set of parameter values. GoogleTest provides convenient parameter generators:

| Generator           | Description                                        |
|---------------------|--------------------------------------------------|
| `Values(...)`       | Explicitly specified values                       |
| `ValuesIn(container)`| Values from array or STL container                |
| `Range(begin, end, step)` | Generates values from `begin` to `end-1` by `step` |
| `Bool()`            | Generates `false` and `true`                      |
| `Combine(g1, g2, ...)` | Cartesian product of multiple generators         |

Examples:

```cpp
INSTANTIATE_TEST_SUITE_P(IntSequence, FooTest, testing::Values(1, 2, 3));

const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(Pets, FooTest, testing::ValuesIn(pets));

INSTANTIATE_TEST_SUITE_P(FlagCombinations, FooTest, testing::Combine(testing::Bool(), testing::Bool()));
```

**Note:** The instantiation names become prefixes for test suite naming, allowing identification of parameter sets in test output.

### Accessing and Naming Parameters

- Use `GetParam()` to access the current test parameter inside `TEST_P`.
- For custom test name suffixes, provide a parameter name generator (a function/functor accepting `testing::TestParamInfo<T>` returning a `std::string`) as the last argument to `INSTANTIATE_TEST_SUITE_P`. 

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedPets, FooTest, testing::ValuesIn(pets),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return info.param;
    });
```

### Useful Tips

- The parameter generator expressions are evaluated during GoogleTest initialization (after `InitGoogleTest`). This enables dynamic parameter generation.
- If you define `TEST_P` tests without an `INSTANTIATE_TEST_SUITE_P`, GoogleTest generates a warning via a failing test in `GoogleTestVerification`. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest)` to suppress it if needed.

### Example

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

---

## Typed Tests

Typed tests allow you to write a test that runs over a pre-defined list of types. This makes it easy to verify the behavior of templates or multiple implementations of the same interface without rewriting tests for each type.

### Writing Typed Tests

1. **Create a Test Fixture Template**

Define a class template deriving from `testing::Test`, parameterized by a type:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_ = T();
};
```

2. **Associate Types With Test Suite**

Use `testing::Types` to specify the type list and `TYPED_TEST_SUITE` to register them:

```cpp
using MyTypes = testing::Types<int, char, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Define Typed Tests Using `TYPED_TEST`**

Within your typed test, use `TypeParam` to refer to the current type:

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```

4. **Run Tests**

GoogleTest automatically runs the tests once for each type in the list.

### Custom Naming

To customize type names in test results, provide an optional name generator class with a templated static `GetName(int)` method as a third argument to `TYPED_TEST_SUITE`.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, char>) return "Char";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Example

```cpp
template <typename T>
class NumericTest : public testing::Test {
 protected:
  T zero_{0};
};

using NumericTypes = testing::Types<int, double, long>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, ZeroEqualsDefault) {
  EXPECT_EQ(TypeParam(), this->zero_);
}
```

---

## Type-Parameterized Tests

Type-parameterized tests add flexibility by allowing the test pattern to be defined once and instantiated later with varying type lists. This is useful for interface verification suites and reusable test code.

### Defining Type-Parameterized Tests

1. **Define a Test Fixture Template**

Same as typed tests, create a class template inheriting from `testing::Test`:

```cpp
template <typename T>
class AbstractTest : public testing::Test {
  ...
};
```

2. **Declare the Test Suite With `TYPED_TEST_SUITE_P`**

Declare that the test suite will be type-parameterized:

```cpp
TYPED_TEST_SUITE_P(AbstractTest);
```

3. **Define Type-Parameterized Tests Using `TYPED_TEST_P`**

Use `TYPED_TEST_P` to define tests inside the suite. Use `TypeParam` to refer to the current type:

```cpp
TYPED_TEST_P(AbstractTest, DoesSomething) {
  TypeParam val{};
  EXPECT_TRUE(DoSomething(val));
}
```

Define as many tests as needed.

4. **Register Tests Using `REGISTER_TYPED_TEST_SUITE_P`**

You must register all your test names before instantiation:

```cpp
REGISTER_TYPED_TEST_SUITE_P(AbstractTest, DoesSomething, AnotherTest);
```

5. **Instantiate With Types Using `INSTANTIATE_TYPED_TEST_SUITE_P`**

Instantiate the test suite with a type list and an optional prefix:

```cpp
using MyTypes = testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, AbstractTest, MyTypes);
```

You can instantiate the same suite multiple times with different type lists or in different translation units.

### Benefits

- Perfect for interface or concept testing where valid implementations are tested against common behavior.
- Enables clean separation between test pattern definition and instantiation.

### Example

```cpp
template <typename T>
class InterfaceTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(InterfaceTest);

TYPED_TEST_P(InterfaceTest, HasDefaultConstructor) {
  TypeParam obj{};
  EXPECT_TRUE(InitializedCorrectly(obj));
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, HasDefaultConstructor);

using ImplTypes = testing::Types<Impl1, Impl2>;
INSTANTIATE_TYPED_TEST_SUITE_P(Implementations, InterfaceTest, ImplTypes);
```

---

## Common Use Cases

- **Testing Algorithms With Multiple Inputs:** Use value-parameterized tests to ensure functions behave correctly across many input values.
- **Validating Template Classes Across Types:** Use typed tests to verify a template class works correctly for all supported types.
- **Interface Conformance Testing:** Use type-parameterized tests to check that all implementations follow a shared contract.
- **Flexible Test Suite Instantiation:** Abstract tests implemented with type-parameterized tests can be instantiated in multiple translation units or projects with different type sets.

---

## Best Practices

- Always select meaningful parameter and type names to ease test report readability.
- Avoid underscores in test suite and test names to prevent name collision and errors.
- Suppress uninstantiated test suite warnings via `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when defining abstract test suites without immediate instantiation.
- Use custom name generators to create human-friendly test names for complicated types or parameter combinations.
- Ensure that your parameterized tests are well isolated to avoid side effects between parameter runs.

---

## Troubleshooting

- **No tests run or tests not instantiated:** Verify that you have called `INSTANTIATE_TEST_SUITE_P` for your parameterized tests.
- **Test names with underscores cause failures:** Rename test suites and test names to remove underscores.
- **Parameter types not matching:** Make sure your fixture inherits from `TestWithParam<T>` with the correct type `T`.
- **Custom name generator causing errors or invalid test names:** Ensure names contain only alphanumeric characters or underscores and are unique.

---

## References & Additional Reading

- [GoogleTest Primer](primer.md#value-parameterized-tests)
- [Testing Reference](reference/testing.md#TEST_P)
- [Advanced GoogleTest Topics: Parameterized Tests](advanced.md#value-parameterized-tests)
- [Typed Tests in GoogleTest](advanced.md#typed-tests)

---

By mastering value-parameterized and type-parameterized tests, you unlock powerful techniques to write concise, readable, and comprehensive tests that scale with your code and ensure robustness across data and type variations.