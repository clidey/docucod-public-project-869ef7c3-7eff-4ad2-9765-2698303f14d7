---
title: "Parameterized and Typed Test Concepts"
description: "Explore the concepts behind value-parameterized and type-parameterized tests. See how these features enable comprehensive coverage by running the same test logic with varying data and types, promoting DRY (Don't Repeat Yourself) patterns in test design."
---

# Parameterized and Typed Test Concepts

Explore the concepts behind value-parameterized and type-parameterized tests. See how these features enable comprehensive coverage by running the same test logic with varying data and types, promoting DRY (Don't Repeat Yourself) patterns in test design.

---

## Introduction to Parameterized and Typed Tests

When writing tests, you often want to verify the same behavior under different inputs or types. Instead of duplicating similar test code, GoogleTest offers **value-parameterized** and **type-parameterized** testsâ€”powerful features that let you run the same test logic repeatedly with varying parameters or types.

These tests help you:

- Increase coverage efficiently.
- Promote more maintainable, DRY test code.
- Describe clearly the range of use cases your code supports.

Understanding these concepts is crucial to leveraging GoogleTest's full capabilities in writing effective unit tests.

## Value-Parameterized Tests

### What Are They?

Value-parameterized tests allow you to write a test once and run it multiple times with different *values* as input parameters.

### How It Works

- You create a test fixture class that inherits from `::testing::TestWithParam<T>` where `T` is the parameter type.
- Define test cases using the `TEST_P` macro that use `GetParam()` to access the parameter.
- Instantiate the test suite with different parameter values using `INSTANTIATE_TEST_SUITE_P`.

### Example

```cpp
#include <gtest/gtest.h>

// Define the parameter type as int
class IsEvenTest : public ::testing::TestWithParam<int> {};

// Define the test
TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

// Instantiate test with values
INSTANTIATE_TEST_SUITE_P(EvenValues, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

In this example, the `IsEvenTest` runs four times, each with a different parameter value, verifying the behavior for multiple inputs without duplicating code.

### Parameter Generators

GoogleTest offers several parameter generators to create collections of test input values:

| Generator        | Behavior                                                |
|------------------|---------------------------------------------------------|
| `Range(begin, end[, step])` | Generates values from *begin* to just before *end*, stepping by *step* (default 1). |
| `Values(v1, v2, ..., vN)`   | Generates the explicit values listed.                   |
| `ValuesIn(container)`        | Uses elements from any container or iterator range.    |
| `Bool()`                    | Generates `false` and `true`.                          |
| `Combine(g1, g2, ..., gN)`  | Generates tuples with Cartesian product of given generators. |
| `ConvertGenerator`          | Converts generated values using static cast or a conversion function. |

### Customizing Test Names

You can specify custom test names for readability by providing a name generator function in `INSTANTIATE_TEST_SUITE_P`. This is useful when parameter values are complex or not self-explanatory.

---

## Type-Parameterized Tests

### What Are They?

Type-parameterized tests let you run the same test logic but with multiple *types* as parameters.

### How It Works

- Define a test fixture as a class template parameterized on the type.
- Use `TYPED_TEST_SUITE` to declare which types will be tested.
- Define individual tests using `TYPED_TEST` that refer to the current type as `TypeParam`.
- Optionally, use `REGISTER_TYPED_TEST_SUITE_P` and `INSTANTIATE_TYPED_TEST_SUITE_P` for more flexible type-parameterization.

### Example

```cpp
#include <gtest/gtest.h>

template <typename T>
class NumericLimitsTest : public ::testing::Test {
  // Test fixture code (if any) goes here
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsNonNegative) {
  TypeParam value = 0;
  EXPECT_GE(value, 0);
}
```

This test runs three times, once with each type `int`, `float`, and `double`.

### Typed Test Suites and Registration

- `TYPED_TEST_SUITE` binds a typed test fixture with a list of types.
- Tests are defined with `TYPED_TEST`.
- For more complex scenarios, tests and suites can be defined and registered separately, then instantiated with specific type lists.

### Customizing Type Names

You can provide a type-name generator class for readable test output that shows the type being tested, improving test report understandability.

---

## Why Use Parameterized and Typed Tests?

### Maintainability
One test structure to cover many scenarios reduces duplication and eases updates.

### Coverage and Confidence
Run tests against wide ranges of inputs or types, catching edge cases and ensuring correctness across variants.

### Expressiveness
Your test suite better documents the intended use and supported scenarios of the code.

---

## Best Practices

- Use parameterized tests to cover distinct input values rather than writing multiple similar tests.
- Use typed tests to validate templates and generic code for correctness across type instantiations.
- Combine generators wisely (e.g., use `Combine`) to test multiple parameters simultaneously.
- Keep parameter types simple and ensure custom `operator<<` implementations exist for better test output.
- Favor `INSTANTIATE_TEST_SUITE_P` and type/parameter name customization for clear test reports.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you want to allow test suites without immediate instantiation.

---

## Common Pitfalls

- **Omitting instantiation:** Value-parameterized and typed tests must be instantiated; otherwise, no tests are run.
- **Ambiguous overloads:** For overloaded mock methods, be explicit to avoid ambiguity in `EXPECT_CALL` or `ON_CALL`.
- **Reference types in parameters:** Be cautious using references or complex types; ensure proper lifetime and printability.
- **Expectations ordering:** Remember that newer `EXPECT_CALL`s override older ones; place more specific expectations after general ones.

---

## Troubleshooting

### Tests Not Running
If parameterized or typed tests are defined but not instantiated, the framework won't run any tests from them.

### Compiler Errors on Overloads
Disambiguate overloaded methods using `Const()` or explicit casting.

### Confusing Test Reports
Use clear parameter and type name generators to produce understandable test output.

### Default Action Absence
If a mock method expecting certain inputs is called with unusual parameters, ensure you set up `ON_CALL` or `EXPECT_CALL` as appropriate.

---

## Additional Resources

- [Testing Reference: Parameterized & Typed Tests](../api-reference/core-testing-apis/parameterized-testing)
- [gMock Cheat Sheet](../docs/gmock_cheat_sheet.md)
- [gMock Cookbook](../docs/gmock_cook_book.md)
- [gMock for Dummies](../docs/gmock_for_dummies.md)

---

## Diagram: How Parameterized and Typed Tests Fit

```mermaid
flowchart TD
  A[Define Parameterized Test Fixture] --> B[Use TEST_P with GetParam()]
  B --> C[Instantiate Test Suite with INSTANTIATE_TEST_SUITE_P]

  D[Define Typed Test Fixture Template] --> E[Use TYPED_TEST with TypeParam]
  E --> F[Declare Types with TYPED_TEST_SUITE]

  C & F --> G[Run Tests]
  G --> H[Observe Test Results]

  subgraph Value-Parameterized Tests
    A --> B --> C
  end

  subgraph Type-Parameterized Tests
    D --> E --> F
  end

  classDef paramTests fill:#bbf,stroke:#000,stroke-width:1px;
  class Value-ParameterizedTests,Type-ParameterizedTests paramTests;
```

This flow illustrates how tests are defined, instantiated, and executed differently for value-parameterized and type-parameterized paradigms.
