---
title: "Test Lifecycle & Discovery"
description: "Examine how GoogleTest structures the lifecycle of tests—from definition and automatic registration, through parameter handling, to execution and result collection. Learn how test suites, test cases, and typed or parameterized tests come together to support robust test organization and discovery."
---

# Test Lifecycle & Discovery

GoogleTest provides a robust framework that manages the lifecycle of tests from definition through execution and reporting. This page explores how tests are organized, discovered, and run within GoogleTest, focusing on test suites, test cases, and parameterized or typed tests, enabling you to write scalable and maintainable test programs.

---

## Overview of Test Organization

GoogleTest organizes individual tests within *test suites* (formerly known as test cases). Each test suite groups related tests, typically reflecting a unit or component of your codebase, for clear structure and maintainability.

- **Test Suite:** A container that holds a collection of tests sharing context or purpose.
- **Test:** An individual verification, defined as a function or method, that contains checks (assertions) for expected behavior.

Tests are discovered automatically by GoogleTest during program startup, removing the need for manual registration or enumerations.

## Defining Tests

GoogleTest uses various macros to define tests best suited for your needs:

### Simple Tests with `TEST`

Defines a standalone test without shared fixture:

```cpp
TEST(TestSuiteName, TestName) {
  ... // test code
}
```

- `TestSuiteName` and `TestName` must be valid C++ identifiers and should avoid underscores (`_`).
- Each test body contains assertions that determine success or failure.

### Tests with Fixtures (`TEST_F`)

Use when tests share a common setup:

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override {
    // setup code
  }
  void TearDown() override {
    // cleanup code
  }
  // shared members
};

TEST_F(MyFixture, TestName) {
  ... // test code using fixture members
}
```

Each test is executed on a fresh fixture instance, ensuring independence.

### Value-Parameterized Tests (`TEST_P`)

Run the same test logic with multiple input values:

```cpp
class ParamTest : public testing::TestWithParam<int> {};

TEST_P(ParamTest, TestName) {
  int param = GetParam();
  ...
}

INSTANTIATE_TEST_SUITE_P(InstantiationName, ParamTest, testing::Values(1, 2, 3));
```

- Use `GetParam()` in the test body to access current parameter value.
- Instantiate with parameter generators such as `Values()`, `Range()`, or `Combine()`.

### Typed Tests

Verify behavior across different types by defining:

```cpp
template<typename T>
class TypedTestSuite : public testing::Test {
  // ...
};

using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(TypedTestSuite, MyTypes);

TYPED_TEST(TypedTestSuite, TestName) {
  TypeParam val = ...;
  ...
}
```

### Type-Parameterized Tests

Extends typed tests where the type list is not known upfront:

```cpp
template<typename T>
class TypeParamTest : public testing::Test {
  ...
};

TYPED_TEST_SUITE_P(TypeParamTest);

TYPED_TEST_P(TypeParamTest, TestName) { ... }
REGISTER_TYPED_TEST_SUITE_P(TypeParamTest, TestName);

using MyTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, TypeParamTest, MyTypes);
```

## Automatic Test Registration

GoogleTest automatically registers tests defined with the above macros. It gathers all test suites and their tests in a global singleton `UnitTest` instance, which manages discovery, ordering, filtering, and execution.

For dynamic scenarios, you can programmatically register tests with `testing::RegisterTest()` providing a factory callable that returns a test fixture instance.

## Test Execution Lifecycle

The lifecycle for each test proceeds as follows:

1. **Test Suite Setup:**
   - If defined, `SetUpTestSuite()` runs before the first test of the suite.
2. **Test Instance Construction:**
   - GoogleTest creates a fresh instance of the test fixture class.
3. **Test Setup:**
   - `SetUp()` for the test fixture runs.
4. **Test Body Execution:**
   - The test code executes, making assertions.
5. **Test TearDown:**
   - `TearDown()` is called to clean up.
6. **Test Instance Destruction:**
   - The test fixture instance is deleted.
7. **Test Suite Teardown:**
   - If defined, `TearDownTestSuite()` runs after the last test of the suite.

If any fatal assertion or failure occurs during setup or test execution, subsequent steps in that phase are aborted.

### Skipping Tests

At runtime, tests or entire suites can be skipped using `GTEST_SKIP()`. Skipped tests report as such but do not run further test code.

## Filtering and Selection

GoogleTest allows running subsets of tests using the `--gtest_filter` flag. The filter supports positive and negative matching patterns using wildcards (`*` and `?`). Disabled tests (prefixed with `DISABLED_`) do not run unless `--gtest_also_run_disabled_tests` is specified.

Tests can also be sharded across multiple machines using environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` to enable distributed execution.

## Test Result Information

GoogleTest tracks detailed information about test results via the `TestInfo` and `TestResult` classes, available through the `UnitTest` singleton:

- **TestInfo:** Metadata about the test like name, type parameters, source location, and the test's execution result.
- **TestResult:** Contains outcome details including pass/fail status, skipped state, test part results (assertions), elapsed time, and user-recorded properties.

You can access the currently running test's info via:

```cpp
const testing::TestInfo* info = testing::UnitTest::GetInstance()->current_test_info();

if (info) {
  std::cout << "Test: " << info->test_suite_name() << "." << info->name() << std::endl;
}
```

## Example: Writing, Instantiating, and Running Parameterized Tests

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues, FooTest, testing::Values(2, 4, 6, 8));

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This runs the same test logic across all the specified values.

## Best Practices & Tips

- Always ensure your test fixture classes have default constructors.
- Use fixtures (`TEST_F`) when multiple tests share setup logic.
- For data-driven tests, leverage parameterized tests (`TEST_P`).
- Name your test suites and tests without underscores to avoid conflicts.
- Access the current test context with `UnitTest::current_test_info()` cautiously; it returns `nullptr` if no test runs.
- Use `SCOPED_TRACE` or `ScopedTrace` to add diagnostic context to failures in helper functions.
- Remember that tests execute independently with fresh fixtures -- state is not shared across tests.

## Troubleshooting Common Lifecycle Issues

- If `SetUpTestSuite` or `TearDownTestSuite` is not called, ensure at least one test runs in the suite (disabled tests don't count unless forced).
- Mixing `TEST` and `TEST_F` macros in the same test suite is illegal and will cause runtime failures.
- Ensure you do not define tests with identical suite and test names but different fixtures across translation units.
- When writing typed or type-parameterized tests, correctly register and instantiate test suites.

## See Also

- [GoogleTest Primer](primer.md) — Basic usage and terminology
- [Value-Parameterized Tests](advanced.md#value-parameterized-tests) — Detailed guide on parameterized testing
- [Typed Tests](advanced.md#typed-tests) — Guide on typed and type-parameterized tests
- [Assertions Reference](reference/assertions.md) — Overview of assertion macros
- [Test Structure and Lifecycle (API Reference)](api-reference/core-testing-apis/test-structure-and-lifecycle)