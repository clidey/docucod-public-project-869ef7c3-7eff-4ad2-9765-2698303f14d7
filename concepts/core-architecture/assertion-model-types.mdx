---
title: "Assertion Model and Types"
description: "Gain a deep understanding of the assertion system, including the difference between fatal and non-fatal assertions, standard assertion types, and the role of user-defined assertions. See how these fit into the overall test lifecycle for reliable result reporting."
---

# Assertion Model and Types

Understanding assertions is critical for writing effective tests, as assertions define how checks are made in test code and how their results impact test execution and reporting. This guide demystifies the assertion mechanism, differentiating fatal and non-fatal assertions, exploring standard and user-defined assertion types, and illustrating their role within the test lifecycle to ensure reliable, maintainable tests.

---

## 1. Overview of Assertions in GoogleTest

GoogleTest assertions evaluate conditions within test code to verify correctness. They are the primary means of validating expected behavior and produce reports indicating success or failure of tests.

Assertions in GoogleTest come in two fundamental types:

- **Fatal Assertions:** Terminate the current function immediately upon failure.
- **Non-Fatal Assertions:** Report failure but allow the current function to continue.

This distinction allows tests to decide between immediately stopping after a critical failure or continuing to gather multiple failures in a single test.

### Why Assertion Types Matter to Users

From a user’s perspective, choosing between fatal and non-fatal assertions affects test flow control and failure localization:

- Fatal assertions (e.g., `ASSERT_*`) ensure that a test exits if a crucial condition is violated, preventing subsequent code, which might rely on these conditions, from running and potentially causing confusing errors.

- Non-fatal assertions (e.g., `EXPECT_*`) let tests continue to execute after failures, which helps identify multiple failing conditions in the same execution.

### Example

```cpp
TEST(MyTestSuite, Example) {
  int* ptr = nullptr;

  // Fatal assertion: stops test function if pointer is null.
  ASSERT_NE(ptr, nullptr) << "Pointer should not be null";

  // The following line is only reached if ASSERT_NE passes.
  EXPECT_EQ(*ptr, 42) << "Pointer value mismatch";
}
```

In this example, if `ptr` is null, `ASSERT_NE` triggers a fatal failure and aborts the test body, preventing undefined behavior on dereferencing a null pointer.

---

## 2. Fatal vs. Non-Fatal Assertions

| Feature                      | Fatal Assertions (`ASSERT_*`)               | Non-Fatal Assertions (`EXPECT_*`)          |
|------------------------------|---------------------------------------------|---------------------------------------------|
| Behavior on failure          | Aborts current function immediately         | Reports failure, continues execution         |
| Allows test continuation     | No                                          | Yes                                          |
| Appropriate for              | Critical conditions affecting subsequent code | Non-critical checks for multiple validations |
| Usage restrictions          | Can only be used in void-returning functions | No such restriction                           |

### Important Notes

- **Fatal assertions cannot be used in constructors or destructors.** Fatal failures in these contexts do not abort the test but terminate the current function early, potentially corrupting state.

> Use `SetUp()` and `TearDown()` methods for fatal assertions instead.

- Non-fatal assertions are useful to check invariants, display multiple issues, or gather additional diagnostic information during a test.

- It is best practice to use fatal assertions when a failure means continuing is unsafe.

---

## 3. Standard Assertion Types

GoogleTest provides a rich set of standard assertions suited for common test needs. Here are key categories:

### 3.1 Boolean Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

Check if the condition is true or false respectively.

### 3.2 Equality and Comparison Assertions

- Equality and inequality:
  - `EXPECT_EQ(expected, actual)` / `ASSERT_EQ(expected, actual)`
  - `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`

- Relational:
  - `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
  - `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
  - `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
  - `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

These check the specified comparison between two values.

### 3.3 String Comparisons

Specifically to compare C strings by content, not pointer:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)` — checks equality
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)` — checks inequality
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)` — case-insensitive equality
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)` — case-insensitive inequality

### 3.4 Floating-Point Comparisons

Floating-point comparisons need special care due to arithmetic precision.

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`

These assertions compare values within acceptable floating-point tolerance.

### 3.5 Exception Assertions

Require exceptions enabled in the build.

- `EXPECT_THROW(statement, ExceptionType)` / `ASSERT_THROW(statement, ExceptionType)`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`

Verify that a statement throws or doesn't throw exceptions as expected.

### 3.6 Predicate Assertions

Allow assertions on arbitrary conditions via predicates:

- `EXPECT_PRED1(predicate, val)` through `EXPECT_PRED5(...)`
- `ASSERT_PRED1(predicate, val)` through `ASSERT_PRED5(...)`
- Similarly, `EXPECT_PRED_FORMATn` and `ASSERT_PRED_FORMATn` provide better failure messages.

This enables assertions for complex or custom validation logic.

### 3.7 Other Assertions

- Explicit success: `SUCCEED()`
- Explicit failure: `FAIL()`
- Add non-fatal failure: `ADD_FAILURE()`
- Generate failures at specific source locations: `ADD_FAILURE_AT(file, line)`

---

## 4. User-Defined Assertions

Users can create custom assertions to express domain-specific test validations with readable failure messages.

### 4.1 Writing Boolean Functions

A user defines a function returning `bool` to be used with predicate assertions:

```cpp
bool IsValidUserName(const std::string& name) { ... }
EXPECT_PRED1(IsValidUserName, "Alice");
```

The message on failure is less informative because only `false` is known.

### 4.2 Using `AssertionResult` for Richer Messages

GoogleTest provides `::testing::AssertionResult` to create assertions that produce detailed messages on success and failure.

Example:

```cpp
#include <gtest/gtest.h>

::testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return ::testing::AssertionSuccess() << n << " is even";
  } else {
    return ::testing::AssertionFailure() << n << " is odd";
  }
}

TEST(TestSuite, IsEvenTest) {
  EXPECT_TRUE(IsEven(3));  // Will print "3 is odd" on failure
}
```

### 4.3 Using Predicate-Formatters

Predicate-formatters produce the best diagnostics and accept source expressions as arguments, enabling them to report exactly which expressions failed.

Signature:

```cpp
testing::AssertionResult PredicateFormatter(const char* expr1, ..., T1 val1, ...);
```

Example:

```cpp
::testing::AssertionResult AssertBetween(const char* val_expr, int val,
                                          const char* low_expr, int low,
                                          const char* high_expr, int high) {
  if (val >= low && val <= high) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure()
      << val_expr << " (" << val << ") is not between "
      << low_expr << " and " << high_expr << " (" << low << ", " << high << ")";
}
...
EXPECT_PRED_FORMAT3(AssertBetween, 4, 1, 5);  // Failure message shows expr and value
```

---

## 5. Assertions in the Test Lifecycle

Assertions integrate closely with the test lifecycle:

- Tests are composed of multiple assertions checking conditions.
- Upon failure, assertions record outcomes to the test result.
- Fatal assertions abort the current test function to avoid cascading errors.
- Non-fatal assertions allow multiple failure points in a single test.
- Destructors of test fixtures and global teardown guarantee verification and cleanup.

Failures reported by assertions are summarized in the test output and influence the overall pass/fail status.

### Best Practices

- Use fatal assertions for preconditions necessary for correct test execution.
- Use non-fatal assertions where continued execution is useful to gather multiple failures.
- Avoid fatal assertions in constructors or destructors.
- Design tests to verify one logical behavior per test for clearer diagnostics.

---

## 6. Additional Tips and Troubleshooting

- **Evaluating Assertions Exactly Once:** Arguments to assertions are evaluated a single time, preventing side effects from happening multiple times unexpectedly.

- **Using Streaming in Assertions:** You can append custom messages with the `<<` operator:

  ```cpp
  EXPECT_EQ(value, expected) << "Extra info if it fails";
  ```

- **Asserting on Expressions Inside Subroutines:** When checking complex conditions in functions called by tests, use predicate assertions or `SCOPED_TRACE` to provide meaningful failure context.

- **Fatal Assertions Cannot Abort Entire Test:** Fatal assertions abort only the current function, not the entire test process. To propagate failures, check with `HasFatalFailure()` or structure test code accordingly.

- **Avoid Fatal Assertions in Constructors/Destructors:** Use `SetUp()` and `TearDown()` instead.

- **Skipping Tests:** Use `GTEST_SKIP()` to skip tests at runtime when preconditions are unmet.

---

## 7. Related Assertions and Extensions

- [`EXPECT_THAT(value, matcher)`](../reference/assertions.md#EXPECT_THAT) allows expressive assertions with matchers.
- [Custom Assertion Helpers](../guides/getting-started/assertions-basics.md#custom-assertions) for advanced failure messages.
- See [Assertion Reference](../reference/assertions.md) for a full comprehensive list of assertions.

---

## 8. Summary

Assertions are the core verification mechanism in GoogleTest, enabling thorough checks with clear pass/fail outcomes. Differentiating fatal from non-fatal assertions empowers users to control test flow. GoogleTest supports a wide range of built-in assertion types and also lets users define rich, custom assertions to best express their test intentions.

With proper use of assertions, users can write reliable, maintainable, and informative tests that provide precise feedback on code correctness.

---

## Appendices - Example Assertions

### Basic Bool Assertion

```cpp
EXPECT_TRUE(is_ready);
ASSERT_FALSE(has_error);
```

### Equality Assertion

```cpp
EXPECT_EQ(expected_value, actual_value);
ASSERT_NE(nullptr, ptr);
```

### String Equality

```cpp
EXPECT_STREQ("foo", str);
ASSERT_STRNE(c_str1, c_str2);
```

### Floating Point Approximation

```cpp
EXPECT_FLOAT_EQ(3.1415f, computed_pi);
ASSERT_NEAR(expected, value, 0.01);
```

### Exception Checking

```cpp
EXPECT_THROW(DoTask(), std::runtime_error);
ASSERT_NO_THROW(Initialize());
```

### Using Custom Predicates

```cpp
bool IsPrime(int n) { ... }
EXPECT_PRED1(IsPrime, 17);
```

### Using Rich Custom Assertions

```cpp
::testing::AssertionResult IsSorted(const std::vector<int>& vec) {
  for (size_t i = 1; i < vec.size(); ++i) {
    if (vec[i] < vec[i-1]) {
      return ::testing::AssertionFailure() << "at index " << i;
    }
  }
  return ::testing::AssertionSuccess();
}
EXPECT_TRUE(IsSorted(numbers_vector));
```
