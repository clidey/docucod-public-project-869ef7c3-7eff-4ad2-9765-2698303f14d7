---
title: "Nice, Naggy, and Strict: Mock Class Modes"
description: "Describes the NiceMock, NaggyMock, and StrictMock paradigms. Covers the motivations behind allowing, warning on, or disallowing unexpected calls, and how these strategies foster different testing approaches for legacy and new code."
---

# Nice, Naggy, and Strict: Mock Class Modes

This document explains the paradigms of `NiceMock`, `NaggyMock`, and `StrictMock` within GoogleMock. These modes define different behaviors for how mock objects handle unexpected or uninteresting calls, thereby enabling different testing strategies that suit both legacy and new code bases.

---

## Introduction to Mock Modes

GoogleMock provides three primary wrappers that modify a mock object's behavior with respect to uninteresting calls, i.e., calls to mocked methods for which no explicit expectations (`EXPECT_CALL`s) have been set:

- **NiceMock<T>**: Suppresses warnings on uninteresting calls.
- **NaggyMock<T>**: Prints warnings on uninteresting calls (default behavior).
- **StrictMock<T>**: Treats uninteresting calls as test failures.

These wrappers are template classes that you use by wrapping your mock class type. Each creates a subclass of the original mock with altered strictness for uninteresting calls. They inherit all constructors of the mock they wrap, preserving flexible instantiation.

---

## Motivation Behind Different Modes

When a method on a mock object is invoked without an associated expectation, GoogleMock considers this an uninteresting call:

- **Default (Naggy) Behavior**: Prints a warning to alert you that the test did not explicitly expect this call. This warning is helpful for catching scenarios where an unexpected interaction occurs.
- **Nice Mock Behavior**: Suppresses such warnings, allowing uninteresting calls silently. This mode helps reduce test noise when you know certain calls are irrelevant and do not want to clutter test output.
- **Strict Mock Behavior**: Errors on such calls, promoting a fully specified test where every interaction is captured with explicit expectations. Useful for new or critical tests aiming for very precise contract enforcement.

---

## How to Use NiceMock, NaggyMock, and StrictMock

Suppose you have a mock class `MockFoo`:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
  MOCK_METHOD(int, Calculate, (int x), (const));
};
```

### Creating NiceMock

Use `NiceMock<MockFoo>` to suppress warnings about unexpected calls:

```cpp
#include <gmock/gmock.h>
using ::testing::NiceMock;

TEST(MyTest, NiceMockExample) {
  NiceMock<MockFoo> nice_foo;

  EXPECT_CALL(nice_foo, DoThis());
  // Only DoThis() is expected; other calls won't produce warnings.
  nice_foo.DoThis();
  nice_foo.Calculate(5);  // No warning, silently allowed.
}
```

### Creating NaggyMock

`NaggyMock<MockFoo>` is almost identical to `MockFoo`. This is the default behavior:

```cpp
#include <gmock/gmock.h>
using ::testing::NaggyMock;

TEST(MyTest, NaggyMockExample) {
  NaggyMock<MockFoo> naggy_foo;

  EXPECT_CALL(naggy_foo, DoThis());
  naggy_foo.DoThis();
  naggy_foo.Calculate(5);  // Produces a warning about uninteresting call.
}
```

### Creating StrictMock

Use `StrictMock<MockFoo>` to treat uninteresting calls as failures:

```cpp
#include <gmock/gmock.h>
using ::testing::StrictMock;

TEST(MyTest, StrictMockExample) {
  StrictMock<MockFoo> strict_foo;

  EXPECT_CALL(strict_foo, DoThis());
  strict_foo.DoThis();
  strict_foo.Calculate(5);  // Test fails: unexpected call.
}
```

---

## Important Notes and Best Practices

- **Current Default**: Plain mock classes (`MockFoo`) behave like `NaggyMock` by default, emitting warnings on uninteresting calls.
- **Future Direction**: GoogleMock plans to switch the default to `NiceMock` for better test maintainability.
- **Construction**: `NiceMock`, `NaggyMock`, and `StrictMock` are transparent subclasses. They forward arguments to the wrapped mock's constructors seamlessly.
- **Limitations**:
  - Only works for mock methods defined directly by the `MOCK_METHOD` macros in the original mock class `T`. Mock methods inherited from base classes might not respect these modes.
  - Nesting these wrappers (e.g., `NiceMock<StrictMock<MockFoo>>`) is unsupported.
  - The mock class should have a virtual destructor for correct behavior.

---

## Under the Hood: Uninteresting Calls Handling

Each mock instance tracks how it reacts to uninteresting calls using `testing::Mock::AllowUninterestingCalls`, `WarnUninterestingCalls`, or `FailUninterestingCalls` internally when wrapped with `NiceMock`, `NaggyMock`, or `StrictMock` respectively. The lifecycle of this registration is tied to the wrapper's construction and destruction, ensuring behavior changes only while the wrapper exists.

---

## Example Scenario: Transitioning Legacy Tests

Legacy tests often rely on naggy mocks, tolerating warnings but not failures for uninteresting calls. When hardening tests, you might want to use `StrictMock` to enforce all interactions are explicitly specified, catching unintended behavior.

```cpp
// Legacy code with naggy mock.
NaggyMock<MockFoo> mock_foo;
EXPECT_CALL(mock_foo, DoSomething());
// New calls to unexpected methods produce warnings but tests pass.

// New approach for strict verification.
StrictMock<MockFoo> strict_mock_foo;
EXPECT_CALL(strict_mock_foo, DoSomething());
// Unexpected calls now cause test failures.
```

For gradual migration, switch to `NiceMock` first to suppress spurious warnings, then gradually tighten with expectations and eventually consider `StrictMock`.

---

## FAQ

### Q: Can I nest NiceMock, NaggyMock, and StrictMock?

No. Nesting is not supported and can cause undefined behavior.

### Q: What happens if a mock method is declared in a base class?

The strictness modifiers might not affect mock methods inherited from base classes due to C++'s type model and compiler limitations.

### Q: What if my mock class has no virtual destructor?

Behavior with `NiceMock` and `StrictMock` might be incorrect. Make sure your mock classes have virtual destructors.

### Q: How can I verify mocks early?

Use `Mock::VerifyAndClearExpectations(&mock_obj);` to check expectations before destruction.

### Q: How to suppress warnings for specific methods?

Use `EXPECT_CALL(mock_obj, SomeMethod(_)).Times(AnyNumber());` to declare you don't care about calls to that method.

---

## Summary

`NiceMock`, `NaggyMock`, and `StrictMock` provide flexible ways to control how strictly your tests enforce that mocks only receive expected calls. This helps balance test maintainability and strictness tailored to your codebase's maturity and testing philosophy.

---

## References and Related Documentation

- [gMock Cookbook: The Nice, the Strict, and the Naggy](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy)
- [Mocking Reference: Expectation Order and Strictness](https://google.github.io/googletest/reference/mocking.html#strict-nice-and-naggy-mocks)
- [gMock for Dummies: Using Mocks in Tests](https://google.github.io/googletest/gmock_for_dummies.html)
- [EXPECT_CALL macro](https://google.github.io/googletest/reference/mocking.html#expect_call)
- [ON_CALL macro](https://google.github.io/googletest/reference/mocking.html#on_call)

---

## Code Location

The `NiceMock`, `NaggyMock`, and `StrictMock` templates are implemented in the header:

`googlemock/include/gmock/gmock-nice-strict.h`

with unit tests in:

`googlemock/test/gmock-nice-strict_test.cc`

---

## Appendix: Sample Full Code

```cpp
#include <gmock/gmock.h>
using ::testing::NiceMock;
using ::testing::NaggyMock;
using ::testing::StrictMock;

class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
  MOCK_METHOD(int, Calculate, (int x), (const));
};

// Using a NiceMock
NiceMock<MockFoo> nice_foo;
ice_foo.DoThis();  // Allowed with no warning or failure

// Using a NaggyMock
NaggyMock<MockFoo> naggy_foo;
naggy_foo.DoThis();  // Prints warning if uninteresting call

// Using a StrictMock
StrictMock<MockFoo> strict_foo;
strict_foo.DoThis();  // Errors if uninteresting call

// Declaring expectations
EXPECT_CALL(nice_foo, DoThis()).Times(1);
EXPECT_CALL(strict_foo, Calculate(42)).WillOnce(::testing::Return(999));

```
