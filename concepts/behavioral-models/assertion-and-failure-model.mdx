---
title: "Assertion and Failure Model"
description: "Learn the difference between fatal and non-fatal failures, how assertion mechanisms work under the hood, and how detailed messages are constructed to aid troubleshooting. Discover how this model improves developer feedback and test clarity."
---

# Assertion and Failure Model

The assertion and failure model in GoogleTest is central to providing clear, informative test feedback and enabling developers to effectively identify issues in their code. Understanding the distinction between fatal and non-fatal failures, how assertions communicate results, and how failure messages are constructed is crucial to mastering GoogleTest.

---

## Overview of Failures

GoogleTest assertions come in two flavors that determine how test execution proceeds upon a failure:

- **Non-fatal failures**: Indicated by macros prefixed with `EXPECT_`, these failures report the problem but allow the test function to continue running. This helps collect multiple failures in a single test run.

- **Fatal failures**: Indicated by macros prefixed with `ASSERT_` and explicit failures like `FAIL()`, these abort the current function immediately upon failure to prevent further execution in erroneous cases.

This distinction is pivotal in structuring tests, enabling flexible handling of errors, and providing contextual information to fix issues efficiently.

<Tip>
Use non-fatal assertions (`EXPECT_*`) when itâ€™s valuable to check multiple conditions in a single test, and fatal assertions (`ASSERT_*`) when a failing condition renders subsequent test logic invalid or meaningless.
</Tip>

---

## Assertion Mechanism Workflow

When an assertion macro executes, the following process occurs:

1. **Condition Evaluation**: The assertion expression or predicate is evaluated once, to ensure no unintended side effects or multiple computations.

2. **Result Reporting**: Based on the evaluation:

   - If the assertion passes, execution resumes normally.
   - On failure, a failure result is constructed including:
     - The source location (file and line number)
     - A detailed failure message
     - Optionally, the OS-specific stack trace

3. **Test Part Result Object**: A `TestPartResult` instance captures the failure or success details.

4. **Listener Notification**: The failure is reported to the current test result context and any event listeners are notified.

5. **Control Flow Handling**:

   - For fatal failures (`ASSERT_*`, `FAIL()`), the enclosing function returns immediately.
   - For non-fatal failures (`EXPECT_*`, `ADD_FAILURE()`), execution continues.

6. **Optional Debugger Interaction**: Flags like `--gtest_break_on_failure` cause a break-point on failures to aid debugging.

7. **Exception Behavior**: When enabled, fatal failures can throw exceptions to integrate with other frameworks or debugging tools.

This structured flow guarantees precise failure localization and detailed diagnostics.

---

## Constructing Detailed Failure Messages

GoogleTest enriches failure feedback by printing comprehensive and actionable messages. Key components of these messages include:

- **Expression Text**: The actual expression or statement that led to the failure.

- **Evaluated Values**: The runtime values of variables or expressions involved, printed intelligently for clarity.

- **User-Provided Messages**: Custom failure messages can be streamed into assertions using `<<` operator to clarify the context.

- **Stack Trace**: When enabled, a call stack overview is appended to help track the failure origin.

- **Differencing Output for Strings and Containers**: For string equality or container comparisons, GoogleTest shows unified diffs highlighting mismatches.

- **Assertion-Specific Explanations**: Predicates returning `AssertionResult` objects can provide success/failure verdicts along with tailored explanation strings.

For example, `EXPECT_EQ(foo, bar)` failure reports both sides with their values:

```none
Expected equality of these values:
  foo
    Which is: 5
  bar
    Which is: 6
```

<Tip>
To improve failure clarity, consider using predicate assertions (`EXPECT_PRED*`) with custom functions that generate descriptive messages about the failure.
</Tip>

---

## Using Assertion Macros Effectively

### Explicit Success and Failure Assertions

GoogleTest provides explicit assertion macros that convey test control flow directly:

- `SUCCEED()` records a success at a point where passing is significant.
- `FAIL()` generates a fatal failure and aborts the current function.
- `ADD_FAILURE()` creates a non-fatal failure allowing test continuation.

These facilitate fine-grained control over test outcomes in dynamic control flows.

### Boolean Condition Assertions

- `EXPECT_TRUE(condition)` and `EXPECT_FALSE(condition)` verify Boolean conditions and produce detailed diagnostics on failure, including the evaluated condition and optionally user messages.

### Binary Comparison Assertions

GoogleTest supports comprehensive binary comparison assertions (`EXPECT_EQ`, `EXPECT_NE`, `EXPECT_LT`, etc.) that verify relational properties between two values and print both expressions and their evaluated runtime results in case of failure.

Note the special handling of C strings: `EXPECT_STREQ` and friends compare string content rather than memory pointers.

### Floating-Point Assertions

Due to inexact floating-point arithmetic, GoogleTest provides tolerant assertions:

- `EXPECT_FLOAT_EQ` and `EXPECT_DOUBLE_EQ`: Check approximate equality within a ULP (units in the last place) tolerance.
- `EXPECT_NEAR`: Checks equality within a given absolute error.

These assertions print informative messages about the magnitude of differences encountered.

### Exception Assertions

If your build supports exceptions, GoogleTest can verify whether code throws expected exceptions, or none, using `EXPECT_THROW`, `EXPECT_NO_THROW`, and related macros.

### Predicate and Predicate-Format Assertions

GoogleTest supports using custom predicate functions or predicate-formatter functions that provide richly detailed and contextual failure messages, surpassing what boolean asserts alone can do.

For example, a predicate returning `AssertionResult` can include values and explanations on failure.

---

## Propagation and Management of Fatal Failures

It is important to note that fatal assertions (`ASSERT_*`, `FAIL()`) only abort the function they occur in, not the entire test. This behavior means that if fatal assertions are placed inside helper functions, execution may continue unexpectedly after these helpers, leading to cascading failures or crashes.

GoogleTest offers mechanisms to manage this:

- **Using `ASSERT_NO_FATAL_FAILURE(statement)`**: Verifies the statement did not generate any fatal failures in the current thread.

- **Using `HasFatalFailure()` and `HasNonfatalFailure()`**: Static predicates can be checked between statements to conditionally return early from tests if failures occur.

- **Exception Throwing Listeners**: You can add listeners that throw exceptions on the first fatal failure to explicitly abort test execution within nested calls.

<Tip>
Design your test helper functions to return early or propagate failure status if fatal assertions occur, using these mechanisms.
</Tip>

---

## Logging Additional Information

GoogleTest allows recording arbitrary key-value properties during test execution with `RecordProperty(key, value)`. These properties are included in XML/JSON test result reports and help in linking external data or test metadata to test outcomes.

Properties must have keys that do not conflict with reserved XML attribute names used by GoogleTest.

---

## Skipping Tests

You can skip test execution dynamically at runtime using the `GTEST_SKIP()` macro. This marks the current test as skipped and bypasses the remaining test logic, providing a clear message.

Skipping is useful to manage conditional test execution based on runtime state or unmet preconditions.

---

## Practical Example: An Assertion Failure Message

Consider the assertion:

```cpp
EXPECT_EQ(5, 2 * 3);
```

The failure message will include:

```none
Expected equality of these values:
  5
  2 * 3
    Which is: 6
```

This shows both the expressions and their evaluated values clearly, aiding diagnosis.

---

## Summary

The GoogleTest assertion and failure model provides:

- Clear differentiation of failure types for graceful test continuation or early abort.
- Detailed messages combining expression content, runtime values, custom user messages, and stack traces.
- Tools to control and propagate failures properly through the test call stack.
- Facilities to express complex Boolean conditions with expressive predicate assertions.
- Integration with external test tools through property recording and output reporting.

Understanding and leveraging this model empowers developers to write precise, maintainable, and informative tests that accelerate debugging and improve test reliability.

---

## Code and Concepts References

For more details, see:

- [Assertions Reference](reference/assertions.md): Comprehensive list and usage of all assertion macros.
- [Advanced GoogleTest Topics](docs/advanced.md): Explains custom assertion messages, predicate assertions, skipping, and failure propagation.
- [Testing Reference](api_reference/core_testing_api/assertions_and_failures.md): API details and internals of GoogleTest's assertion and result classes.
- [Scoped Test Part Result Reporter](gtest/gtest-spi.h): Utilities for testing failed assertions.

These documents complement the understanding of GoogleTest's assertion and failure model, guiding effective test writing and troubleshooting.

---

## Visual Overview

```mermaid
flowchart TD
  A[Start: Run Test] --> B{Assertion}
  B -->|Pass| C[Continue Execution]
  B -->|Fail Non-fatal (EXPECT_*)| D[Record Failure]
  D --> C
  B -->|Fail Fatal (ASSERT_* / FAIL())| E[Record Failure]
  E --> F[Abort Current Function]
  F --> G{Function Caller?}
  G -->|Yes| F
  G -->|No| H[End Test]
```

This diagram illustrates the process from executing an assertion to failure handling and control flow implications.

---