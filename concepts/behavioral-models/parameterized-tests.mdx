---
title: "Parameterized & Typed Tests"
description: "Examine how tests can be dynamically configured with varying input values or types. Understand when to use value-parameterized or type-parameterized tests to maximize coverage and flexibility."
---

# Parameterized & Typed Tests in GoogleTest

GoogleTest empowers you to write more flexible and comprehensive tests by allowing test cases to be dynamically configured with different input values or types. This page explains two powerful test parametrization techniques:

- **Value-Parameterized Tests**: Run the same test logic with different values (parameters).
- **Typed Tests**: Repeat the same test logic for different C++ types.

These features increase coverage and reduce redundant code by abstracting common test logic.

---

## Value-Parameterized Tests

Value-parameterized tests let you run a suite of tests for various parameters without manually duplicating the test code for each value.

### When to Use

- When you want to verify behavior over diverse data inputs.
- When testing code influenced by multiple configuration flags.
- Testing different implementations of an interface.

### Defining a Value-Parameterized Test

1. **Create a Fixture Class**

   The class must inherit from `testing::TestWithParam<T>`, where `T` is the type of the parameter.

   ```cpp
   class MyTest : public testing::TestWithParam<int> {
     // Optional shared setup can go here
   };
   ```

2. **Write Tests Using `TEST_P` Macro**

   These tests access parameters via `GetParam()`.

   ```cpp
   TEST_P(MyTest, HandlesPositiveNumbers) {
     int value = GetParam();
     EXPECT_GT(value, 0);
   }
   ```

3. **Instantiate Test Suites with Parameters**

   Use `INSTANTIATE_TEST_SUITE_P` to specify parameter values or sequences for the tests.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       PositiveValues, MyTest, testing::Values(1, 5, 10));
   ```

### Parameter Generators

GoogleTest provides generators to supply parameter values:

| Generator             | Description                                                  |
|-----------------------|--------------------------------------------------------------|
| `Range(start, end[,step])` | Generates sequences from `start` to just before `end`, stepping by `step`. Default step is 1. |
| `Values(v1, v2, ..., vN)`  | List of explicit values.                                   |
| `ValuesIn(container)` | Values drawn from a container or iterator range.              |
| `Bool()`              | Generates boolean values `false` and `true`.                  |
| `Combine(g1, g2, ..., gN)`| Cartesian product of multiple generators, producing tuples.    |
| `ConvertGenerator<T>(gen[, func])` | Converts generated parameters to a different type using optional conversion function. |

### Example: Value-Parameterized Test

```cpp
class NumberTest : public ::testing::TestWithParam<int> {};

TEST_P(NumberTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0) << n << " is not even";
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, NumberTest, testing::Values(2, 4, 6, 8));
```

This instantiates and runs the test `IsEven` once for each value (2, 4, 6, 8).

### Naming Value-Parameterized Tests

By default, test names include the index of the parameter. You can supply a function or functor to generate custom test name suffixes.

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedTests, NumberTest, testing::Values(2, 4, 6),
  [](const testing::TestParamInfo<int>& info) {
    return "Num" + std::to_string(info.param);
  });
```

The generated tests will be named `NamedTests/NumberTest.IsEven/Num2`, etc.

### Abstract Value-Parameterized Tests

You can define tests in headers (as abstract tests) and instantiate them later in different compilation units. Use this pattern to define conformance tests for interfaces and allow implementers to instantiate them.

### Handling Uninstantiated Parameterized Tests

If a test suite defines `TEST_P` tests but never calls `INSTANTIATE_TEST_SUITE_P`, GoogleTest reports a failure to encourage you to instantiate or explicitly allow uninstantiated suites via `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);`.

---

## Typed Tests

Typed tests allow you to run the **same test logic** over a set of **types** rather than values. This helps verify that different implementations or types satisfy a contract.

### When to Use

- You have multiple types conforming to the same concept.
- You want to apply the same tests to different class or fundamental types.

### Defining Typed Tests

1. **Define a Fixture Class Template**

   Derive from `testing::Test`, parameterized by a type `T`.

   ```cpp
   template <typename T>
   class MyTypedTest : public testing::Test {
    public:
     T value_{};
     // Additional setup shared by tests
   };
   ```

2. **Associate a List of Types**

   Supply the type list with the `TYPED_TEST_SUITE` macro.

   ```cpp
   using MyTypes = ::testing::Types<int, double, char>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Write Typed Tests Using `TYPED_TEST` Macro**

   Use the special identifier `TypeParam` in the test body to refer to the current type.

   ```cpp
   TYPED_TEST(MyTypedTest, DefaultConstructedIsZero) {
     TypeParam value{};
     EXPECT_EQ(value, this->value_);
   }
   ```

### Example: Typed Test

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 protected:
  std::vector<T> values_;
};

using TestTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(ContainerTest, TestTypes);

TYPED_TEST(ContainerTest, CanAddElement) {
  this->values_.push_back(TypeParam());
  EXPECT_EQ(this->values_.size(), 1);
}
```

### Typed Test with Custom Names

You can customize the test name suffixes by providing a `NameGenerator` class with a static template `GetName(int)` method to the `TYPED_TEST_SUITE` macro as a third parameter.

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, TypeNames);
```

### Type-Parameterized Tests

Similar to typed tests but allow you to define test templates that can be instantiated multiple times with different type lists, often in different translation units. They provide more flexibility useful when types to test are not known up-front.

### Defining Type-Parameterized Tests

1. Define a fixture template.
2. Use `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` to declare tests.
3. Register with `REGISTER_TYPED_TEST_SUITE_P`.
4. Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Summary Table

| Feature                     | Description                                    | Macros                                      |
|-----------------------------|----------------------------------------------|---------------------------------------------|
| Value-Parameterized Tests   | Run tests with different parameter values     | `TEST_P`, `INSTANTIATE_TEST_SUITE_P`        |
| Typed Tests                 | Run tests with different types in a list      | `TYPED_TEST_SUITE`, `TYPED_TEST`            |
| Type-Parameterized Tests    | Define type templates instantiated multiple times | `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, `INSTANTIATE_TYPED_TEST_SUITE_P` |

---

## Best Practices and Tips

- Use value-parameterized tests when verifying the same logic against different data inputs.
- Use typed tests to verify different types comply with the same behavioral contract.
- Avoid over-complicating parameter generatorsâ€”simple explicit values improve readability.
- Use custom name generators for clarity in test outputs.
- Ensure that each parameterized test suite is instantiated to avoid no-test-run errors.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if a suite might be defined but not instantiated in some builds.

---

## Troubleshooting

- **Tests not running?** Confirm that all `TEST_P` suites are instantiated via `INSTANTIATE_TEST_SUITE_P`.
- **Duplicate test names?** Check your parameter name generator for uniqueness and valid characters.
- **Unexpected failures in parameterized tests?** Print or log the parameter value using `GetParam()` or `TypeParam` to identify problematic cases.

---

## Additional Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Testing Reference: TEST_P, INSTANTIATE_TEST_SUITE_P, TYPED_TEST_SUITE, TYPED_TEST](../reference/testing.md)
- [GoogleTest Primer](../primer.md) - Introduction and basics
- [Mocking Workflows](../guides/effective-testing-techniques/mocking-workflows.md) - Combine with parameterized tests

---

This page focuses exclusively on test parametrization techniques, essential for expanding test coverage efficiently in your GoogleTest-based test suites.



