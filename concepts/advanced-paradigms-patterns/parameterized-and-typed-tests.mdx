---
title: "Parameterized and Typed Testing"
description: "Uncover the mechanics behind value-parameterized and type-parameterized tests. Understand the workflows for running the same tests with multiple inputs or types, along with the benefits these paradigms bring to code coverage and code reuse."
---

# Parameterized and Typed Testing

GoogleTest expands your testing capabilities by allowing you to write parameterized and typed tests. These paradigms enable running the same tests multiple times with different inputs or across various types, dramatically improving code coverage and test reuse without increasing maintenance overhead.

---

## Understanding Value-Parameterized Tests

### What Are Value-Parameterized Tests?

Value-parameterized tests let you run the same test logic repeatedly using different input values, without duplicating test code. This is ideal for testing functions or classes under various conditions influenced by data.

### How to Write Value-Parameterized Tests

1. **Define a Parameterized Test Fixture**
   - Create a test fixture class that inherits from `testing::TestWithParam<T>`, where `T` is the type of your parameter.

   ```cpp
   class FooTest : public ::testing::TestWithParam<const char*> {
     // Fixture code here
   };
   ```

2. **Write Parameterized Test Cases Using `TEST_P`**

   Use the `TEST_P` macro to define test cases that access parameters via `GetParam()`:

   ```cpp
   TEST_P(FooTest, DoesBlah) {
     EXPECT_TRUE(DoSomething(GetParam()));
   }
   ```

3. **Instantiate Tests with Parameter Generators**

   Use `INSTANTIATE_TEST_SUITE_P` to specify the actual parameter values or value generators:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(MyInstantiation, FooTest, testing::Values("meeny", "miny", "moe"));

   const char* pets[] = {"cat", "dog"};
   INSTANTIATE_TEST_SUITE_P(Pets, FooTest, testing::ValuesIn(pets));
   ```

### Parameter Generators

GoogleTest provides built-in generators to create sequences of parameters:

| Generator                               | Description                                                                                           |
|---------------------------------------|---------------------------------------------------------------------------------------------------|
| `Range(begin, end [, step])`           | Produces a sequence from `begin` (inclusive) to `end` (exclusive), stepping by `step` (default 1). |
| `Values(v1, v2, ..., vN)`              | Produces the explicit values `v1, v2, ..., vN`.                                                     |
| `ValuesIn(container)` or `ValuesIn(begin,end)` | Uses the elements from a container or iterator range as parameters.                                   |
| `Bool()`                               | Generates boolean sequence `{false, true}`.                                                        |
| `Combine(g1, g2, ..., gN)`             | Creates all combinations (Cartesian product) of values from N generators.                          |

### Customizing Parameter Names

To improve test output readability, you can provide a name generator function or functor that produces custom suffixes for each test instance:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values("a", "b"),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param_" + std::to_string(info.index);
    });
```

### Use Cases and Best Practices

- Validate code behavior over ranges of inputs or flag combinations.
- Test multiple data-driven scenarios in one test suite without boilerplate.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);` if tests are defined but instantiations are not.

### Common Pitfalls

- Always instantiate tests with `INSTANTIATE_TEST_SUITE_P`, or tests will not run and a failure may be generated.
- Do not access parameters outside of `TEST_P`; always use `GetParam()` inside the test body.

---

## Understanding Typed Tests

### What Are Typed Tests?

Typed tests allow you to run the same test logic over multiple C++ types you explicitly specify. Unlike value-parameterized tests, these are type-driven, helping verify that different implementations or types conform to expected behaviors.

### How to Write Typed Tests

1. **Define a Fixture Class Template**

Parameterize a fixture class template by a type. Derive from `testing::Test`:

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
   // Shared code and typedefs
   using List = std::list<T>;
   static T shared_;
   T value_;
};
```

2. **Associate a List of Types**

Create a type list using `::testing::Types<>`. Use `TYPED_TEST_SUITE` to associate it:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

3. **Write Typed Tests with `TYPED_TEST`**

Define tests that use the special type parameter `TypeParam`:

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  // ...
}

TYPED_TEST(FooTest, HasPropertyA) { ... }
```

### Custom Test Suite Names

You can supply a custom name generator class to format test suite names:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
    return "unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### Use Cases and Best Practices

- Use typed tests to verify interface compliance across multiple types.
- Group common logic once, avoiding duplication.
- Use `this->` to refer to inherited members inside typed tests due to C++ name lookup rules.

### Common Pitfalls

- You must define the type list before `TYPED_TEST_SUITE`.
- Always use the `typename TestFixture::` prefix for dependent types.

---

## Understanding Type-Parameterized Tests

Type-parameterized tests are like typed tests but more flexible. You define tests abstractly without committing to types upfront and instantiate with type lists later. This is perfect for reusable test patterns and libraries.

### Steps to Use Type-Parameterized Tests

1. **Define a Fixture Class Template**

As before, define a template fixture class derived from `testing::Test`.

2. **Declare a Type-Parameterized Test Suite**

Use `TYPED_TEST_SUITE_P` to declare your fixture as type-parameterized:

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. **Write Type-Parameterized Tests with `TYPED_TEST_P`**

Define tests without tying to specific types:

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  // ...
}

TYPED_TEST_P(FooTest, HasPropertyA) { ... }
```

4. **Register the Test Suite and Test Names**

Register the patterns before instantiating:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

5. **Instantiate the Tests with Types**

Specify the types to instantiate the tests with:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```

### Use Cases

- Define reusable suite templates for interface or concept conformance tests.
- Instantiate tests multiple times with different type lists across translation units.

### Best Practices

- Keep `TYPED_TEST_P` test bodies minimal and type-independent.
- Use `REGISTER_TYPED_TEST_SUITE_P` to clearly specify which tests are part of the suite.
- When instantiating, choose unique prefixes to distinguish test results.

### Common Pitfalls

- Forgetting to `REGISTER_TYPED_TEST_SUITE_P` before instantiation
- Defining multiple suites with conflicting test names in one translation unit

---

## Test Naming Conventions and Execution

- **Value-Parameterized Tests**: Instantiated tests are named as `InstantiationName/TestSuite.TestName/i` where `i` is the index of the parameter in the generator.
- **Typed Tests and Type-Parameterized Tests**: Test suite names are based on fixture names, optionally suffixed by type names if custom name generators are used.

## Practical Tips

- Always instantiate your parameterized or typed tests in your test binaries after all tests are defined.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you have declared parameterized tests but do not instantiate them intentionally.
- Use static shared state carefully in typed tests due to multiple instantiations.
- Employ custom name generators to make test outputs more readable.

## Typical User Flow Example for Value-Parameterized Tests

```cpp
// Define a fixture.
class MyTest : public ::testing::TestWithParam<int> {};

// Define tests using the fixture.
TEST_P(MyTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

// Instantiate the fixture with parameters.
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyTest, testing::Values(2, 4, 6, 8));
```

When running, the test `EvenNumbers/MyTest.IsEven/0` tests `2`, `.../1` tests `4`, and so on.

## Typical User Flow Example for Typed Tests

```cpp
// Define template fixture.
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  static int shared_;
  T value_;
};

// Provide shared data.
template <typename T>
int MyTypedTest<T>::shared_ = 42;

// Associate types.
using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

// Write typed tests.
TYPED_TEST(MyTypedTest, HasSharedValue) {
  EXPECT_EQ(TestFixture::shared_, 42);
}

TYPED_TEST(MyTypedTest, ValueIsDefault) {
  TypeParam v = this->value_;
  EXPECT_EQ(v, 0);
}
```

## Typical User Flow Example for Type-Parameterized Tests

```cpp
// Define template fixture.
template <typename T>
class MyPatternTest : public testing::Test {};

// Declare type-parameterized test suite.
TYPED_TEST_SUITE_P(MyPatternTest);

// Define pattern tests.
TYPED_TEST_P(MyPatternTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Silence unused warning
}

// Register tests.
REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, IsDefaultConstructible);

// Instantiate test suite with types.
using Types = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyPatternTest, Types);
```

---

## Troubleshooting

- **Tests Not Running?** Ensure you've instantiated your parameterized or typed tests with the appropriate macros.
- **Naming Collisions?** Use unique instantiation prefixes and custom name generators.
- **Compiler Errors in Typed Tests?** Make sure to use `typename` for dependent types and access member variables with `this->`.
- **Test Skips Due to Missing Instantiation?** Call `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` for test suites you want to suppress errors for uninstantiated tests.

---

## Diagram: Parameterized and Typed Testing Workflow

```mermaid
flowchart TD
  A[Test Fixture Definition] --> B{Test Type}
  B -->|Value-Parameterized| C[Define Fixture inheriting TestWithParam]
  C --> D[Write TEST_P tests accessing GetParam()]
  D --> E[Instantiate with INSTANTIATE_TEST_SUITE_P]

  B -->|Typed| F[Define Fixture Template inheriting Test]
  F --> G[Define type list with ::testing::Types]
  G --> H[Bind with TYPED_TEST_SUITE]
  H --> I[Write TYPED_TEST cases using TypeParam]

  B -->|Type-Parameterized| J[Define Fixture Template inheriting Test]
  J --> K[Declare suite with TYPED_TEST_SUITE_P]
  K --> L[Define TYPED_TEST_P test cases]
  L --> M[Register tests with REGISTER_TYPED_TEST_SUITE_P]
  M --> N[Instantiate with INSTANTIATE_TYPED_TEST_SUITE_P]

  E --> O[Tests Run with each parameter]
  I --> O
  N --> O

  O --> P[Test Framework Executes Tests]
```

---

## Additional Resources

- [Value-Parameterized Tests Guide](/guides/parameterization-and-patterns/value-parameterized-tests)
- [Type-Parameterized Tests Guide](/guides/parameterization-and-patterns/type-parameterized-tests)
- [Testing Reference - Macros](../reference/testing.md#TEST_P)
- [Writing and Running Your First Test](/getting-started/first-test-setup/writing-running-first-test)
- [GoogleTest Primer](docs/primer.md)
- [Advanced GoogleTest Topics](docs/advanced.md)

---

Parameterizing your tests unlocks powerful and maintainable testing workflows that scale effortlessly. Typed and type-parameterized tests extend this capability to validate behaviors across types, ensuring your interfaces and implementations stay robust and reusable.

Leverage GoogleTest’s expressive macros and generators to focus on what matters most—validating your code’s correctness across many scenarios with minimal boilerplate.