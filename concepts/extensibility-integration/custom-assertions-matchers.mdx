---
title: "Custom Assertions and Matchers"
description: "Explore the mechanisms for defining your own assertions and matchers, allowing you to create highly tailored test logic for your project's specific needs. Understand the APIs and best practices for extending the assertion system."
---

# Custom Assertions and Matchers

Welcome to the guide on **Custom Assertions and Matchers** in GoogleTest/GoogleMock. This page explores how you can define your own assertions and matchers, tailoring test logic precisely to your project's unique needs. You will learn the key APIs, patterns, and best practices to extend the existing assertion system while keeping your tests expressive and maintainable.

---

## Why Custom Assertions and Matchers?

While GoogleTest provides a rich set of built-in assertions and matchers, real-world projects often require conditions and validations unique to their domain. Writing custom assertions and matchers allows you to:

- Express complex or domain-specific verification logic clearly
- Generate informative failure messages tailored to your types
- Reuse common validation throughout your tests
- Integrate deeply with mock behavior for argument verification

_By crafting tailored matchers, you transform your tests into readable, intent-focused narratives that pinpoint exactly what went wrong — saving debugging time and strengthening confidence._

---

## Getting Started with Custom Matchers

### The MATCHER Family of Macros

GoogleMock offers a convenient macro family to write custom matchers concisely without boilerplate:

```cpp
MATCHER(Name, "description") { /* return bool based on arg */ }
```

- `Name` is the matcher’s identifier, used later as `Name()`.
- Inside the statement block, `arg` refers to the value being matched.
- The `description` is a message printed on failure (can be empty for derived from the name).

**Example:** Check if a number is divisible by 7

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

// Usage:
EXPECT_CALL(mock_obj, Foo(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

If a value is not divisible by 7, the failure will print:

```
Value of: value
Expected: is divisible by 7
  Actual: 27
```

---

### Parameterized Matchers

When your matcher needs parameters for flexible matching logic, use:

```cpp
MATCHER_P(Name, param, "description") { /* logic with arg and param */ }
```

You can also define up to 10 parameters with `MATCHER_P2`, `MATCHER_P3`, etc.

**Example: Matching absolute values**

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}

EXPECT_THAT(x, HasAbsoluteValue(10));
```

If it fails, you see:

```
Expected: has absolute value 10
  Actual: -9
```

### Providing Descriptive Failure Messages

You can customize messages with:

- The `description` string parameter referring to matcher name, parameters, and boolean `negation`.
- Streaming additional failure details to `result_listener` inside the match code for richer error reports.

**Example:** Better feedback on divisibility failure

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;

  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

---

## Advanced: Defining Matcher Classes

When you need full control, define a matcher class implementing the matcher interface:

- Must declare:
  - `using is_gtest_matcher = void;` to identify as matcher
  - `bool MatchAndExplain(const T& value, std::ostream* listener) const`
  - `void DescribeTo(std::ostream* os) const`
  - `void DescribeNegationTo(std::ostream* os) const`

**Example: DivisibleBy7Matcher class**

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  explicit DivisibleBy7Matcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    int rem = n % divisor_;
    if (rem == 0) return true;
    if (os != nullptr) {
      *os << "the remainder is " << rem;
    }
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }
 private:
  const int divisor_;
};

inline testing::Matcher<int> DivisibleBy7(int n) {
  return testing::MakeMatcher(new DivisibleBy7Matcher(n));
}
```

---

## Matcher Composition and Utilities

### Combining Matchers

Matchers can be composed logically:

- `AllOf(m1, m2, ...)` - all must match
- `AnyOf(m1, m2, ...)` - any one must match
- `Not(m)` - logical negation

### Matching Container Contents

GoogleTest supports matchers such as:

- `ElementsAre(...)` to match container elements in order
- `UnorderedElementsAre(...)` to match elements ignoring order
- `Contains(...)` to detect an element

These support nested and parameterized matchers, enabling precise control.

### Inspecting Members or Properties

Matchers can target specific fields or properties:

- `Field(&Class::member, matcher)`
- `Property(&Class::getter_method, matcher)`

Example:
```cpp
EXPECT_THAT(foo_obj, Field(&Foo::number, Ge(5)));
```

### Matching Pointer Contents

Use `Pointee(matcher)` to assert on the object pointed to.

---

## Custom Assertions in GoogleTest

GoogleTest enables custom assertions to check complex boolean conditions with helpful failure messages.

You can write a function returning `::testing::AssertionResult` that returns `AssertionSuccess()` on pass and `AssertionFailure() << "message"` on fail.

**Example:**

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(value));
```

If the assertion fails, you get an insightful message showing the value and why it failed.

For more customized messages use predicate-formatter assertions with macros like `EXPECT_PRED_FORMAT2`.

---

## Best Practices & Common Pitfalls

- **Use `ON_CALL` for default mock behavior**, reserve `EXPECT_CALL` for when you want to verify calls.
- Avoid overspecifying expectations to keep tests maintainable.
- Write pure matchers without side effects; matchers may be called multiple times.
- Use descriptive messages in custom matchers/assertions to ease diagnosing failures.
- Suppress uninteresting call warnings with `NiceMock` or treat them as errors with `StrictMock`.
- When mocking overloaded functions, disambiguate overloads explicitly.

---

## Example Workflow: Creating and Using a Custom Matcher

<Steps>
<Step title="Define Your Matcher">
Use the `MATCHER` macro to quickly implement your custom logic.
</Step>
<Step title="Register and Use Your Matcher">
Call your matcher in `EXPECT_CALL` or `EXPECT_THAT` for assertive, readable tests.
</Step>
<Step title="Enhance Failure Messages">
Stream extra diagnostic details to `result_listener` inside your matcher.
</Step>
<Step title="Reuse and Compose">
Combine your matcher with others using `AllOf`, `AnyOf`, and container matchers.
</Step>
</Steps>

---

## Troubleshooting Custom Matchers

- **Matcher Not Called?** Ensure your expectation or assertion uses your matcher correctly.
- **Compilation Errors?** Check for proper matcher signature and macro usage.
- **Unexpected Failures?** Confirm your matcher is pure and consistent with the matched value's type.
- **Ambiguous Overloads?** Explicitly specify the overload or use helper functions (e.g., `Const()`).

---

## Additional Resources

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Practical recipes including custom matchers
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) — Full list of built-in and custom matcher guidance
- [Writing and Using Assertions](../../guides/core-testing-workflows/writing-assertions) — How to create assertions in GoogleTest
- [Using Matchers for Argument Verification](../../guides/mocking-best-practices/using-matchers) — How matchers integrate with mocks

---

## Summary

This page empowers you to extend GoogleTest and GoogleMock's assertion system effectively. From fast macro-based matcher creation to detailed matcher classes, it supports all levels of extensibility and composability. Use this power to create clear, informative, and robust tests that perfectly match your project's requirements.

---