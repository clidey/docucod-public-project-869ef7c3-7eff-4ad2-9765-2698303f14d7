---
title: "Customization and Framework Extension"
description: "Learn how to extend the testing framework, including defining custom matchers, actions, and assertion macros. This empowers advanced users to tailor GoogleTest and GoogleMock to unique scenarios and coding standards."
---

# Customization and Framework Extension

GoogleTest and GoogleMock provide rich customization points that empower advanced users to tailor the testing framework for unique scenarios and coding standards. This guide helps you extend the framework by defining custom matchers, actions, and assertion macros, enabling you to precisely specify test behavior and output.

---

## Customizing GoogleTest Behavior

GoogleTest accepts certain user-defined macros and hooks that allow you to override internal implementations to meet advanced or environment-specific requirements.

### Custom Macros in GoogleTest

Within your test environment or build configuration, you can define the following macros to inject custom behaviors:

- `GTEST_OS_STACK_TRACE_GETTER_`: Specifies a custom implementation class for obtaining OS stack traces.
- `GTEST_CUSTOM_TEMPDIR_FUNCTION_`: Overrides the default temporary directory function accessed via `testing::TempDir()`.

Additionally, for logging and threading support, GoogleTest allows overrides via macros defined in headers like `gtest-port.h`, including:

- Logging macros such as `GTEST_LOG_(severity)`, `GTEST_CHECK_(condition)`, plus user-provided functions like `LogToStderr()`.
- Threading feature toggles like `GTEST_HAS_NOTIFICATION_` and `GTEST_HAS_MUTEX_AND_THREAD_LOCAL_`, with the responsibility to provide necessary static mutex declarations and definitions.
- Export symbol annotations (`GTEST_API_`) for controlling API visibility.

> These customization points make it feasible to integrate GoogleTest into custom runtime environments or platforms with specialized requirements.

---

## Extending GoogleMock with Custom Matchers and Actions

The GoogleMock framework provides a powerful system to define custom matchers and actions, allowing you to enhance test expressiveness and adapt the framework to your domain-specific needs.

### Creating Custom Matchers

Matchers specify criteria that mock method arguments must satisfy. You can create custom matchers with:

#### The MATCHER Macros

- `MATCHER(name, description)`: Defines a parameterless matcher.
- `MATCHER_P(name, param, description)`: Defines a matcher parameterized by one value.
- `MATCHER_P2`, `MATCHER_P3`, … up to `MATCHER_P10` for multi-parameter matchers.

Inside these macros, you implement a `MatchAndExplain` function that returns a boolean, indicating whether the argument meets the condition. You have access to the matched `arg` and can stream diagnostic information to `result_listener` to enhance failure messages.

**Example:** Parameterless matcher to check if a number is even:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
```

Usage:

```cpp
EXPECT_CALL(mock_obj, Method(IsEven()));
```

**Example:** Parameterized matcher with custom description:

```cpp
MATCHER_P(InRange, range, absl::StrCat(negation ? "isn't" : "is", " in range ", range)) {
  return arg >= 0 && arg <= range;
}
```

Usage:

```cpp
EXPECT_THAT(value, InRange(100));
```

#### Writing Matcher Classes Directly

For advanced control or reusable polymorphic matchers, you can implement matcher classes with:

- A typedef `using is_gtest_matcher = void;`
- A templated `MatchAndExplain(const T& value, std::ostream* listener)` method.
- `DescribeTo(std::ostream*)` and `DescribeNegationTo(std::ostream*)` to customize failure messages.

This approach enables matchers that adapt to multiple argument types seamlessly.

### Creating Custom Actions

Actions specify what a mock function does when called. You can create custom actions by:

#### Using Lambdas or Functors

The simplest way to create a custom action is a callable object (lambdas, functors):

```cpp
EXPECT_CALL(mock, Foo(_))
    .WillOnce([](int x) { return x * 2; });
```

These must match the signature of the mocked function.

#### Using `ACTION()` and `ACTION_P()` Macros

Legacy macros let you define named actions similar to matchers:

```cpp
ACTION(IncrementArg) {
  return ++(*arg0);
}
```

You can define parameterized actions similarly with `ACTION_P`.

#### Implementing the `ActionInterface<F>`

For finest control, implement the interface:

```cpp
template <typename F> class ActionInterface {
 public:
  virtual ~ActionInterface();
  virtual Result Perform(const ArgumentTuple& args) = 0;
};
```

Where `F` is the signature of the mock method and `ArgumentTuple` is a tuple of arguments.

#### Writing Polymorphic Actions

When you want an action that can be used with multiple function signatures, define a polymorphic action class with a templated `Perform()` method and wrap it with `MakePolymorphicAction()`.

Example: Return second argument of any compatible function:

```cpp
class ReturnSecondArgAction {
 public:
  template <typename R, typename Tuple>
  R Perform(const Tuple& args) const { return std::get<1>(args); }
};

PolymorphicAction<ReturnSecondArgAction> ReturnSecondArg() {
  return MakePolymorphicAction(ReturnSecondArgAction());
}
```

### Working with Actions on Arguments

You can use helper actions like:

- `SetArgPointee<N>(value)`: Sets the pointee of the Nth mock function argument.
- `DoAll(...)`: Combines multiple actions to execute sequentially.
- `Invoke(...)`: Invokes a function, method, or callable as an action.
- `InvokeWithoutArgs(...)`: Invokes a zero-argument callable ignoring mock args.
- `WithArgs<...>(action)`: Selects specific mock arguments to pass to an action.

These facilitate complex behaviors such as side-effect injection or argument transformations.

---

## Changing Default Mock Behavior: NiceMock, NaggyMock, StrictMock

GoogleMock provides wrappers to control how strictly mock objects verify call expectations:

- **NiceMock<T>**: Suppresses warnings about uninteresting calls (calls with no expectation). Use this when uninteresting calls should be silently accepted.
- **NaggyMock<T>**: The default behavior, prints warnings for uninteresting calls.
- **StrictMock<T>**: Converts uninteresting calls into errors, failing tests on any unexpected call.

These wrappers inherit constructors of `T` and are usable wherever `T` is accepted.

**Caution:** These wrappers affect only *uninteresting calls*, not calls that violate existing expectations.

---

## Using Customization to Improve Test Workflows

Customizing and extending GoogleTest and GoogleMock empowers you to:

- Express domain-specific constraints precisely with custom matchers.
- Model complex mock behaviors with custom actions.
- Simplify test code readability by crafting reusable matchers and actions.
- Integrate GoogleTest/GoogleMock into unique build or runtime environments.

Modern C++ features such as lambdas and variadic templates make writing custom extensions concise and powerful.

---

## Practical Tips and Best Practices

- When defining custom matchers or actions, ensure they are functionally pure to avoid flaky tests.
- Use `SafeMatcherCast<T>(m)` to adapt matchers safely across compatible argument types.
- Use meaningful descriptions in matchers to generate helpful diagnostic messages.
- Prefer `ON_CALL()` to set default mock behaviors; use `EXPECT_CALL()` to specify and verify expected calls.
- Use `RetiresOnSaturation()` to control when expectations become inactive.
- If mocking methods with move-only types, prefer lambdas or callables for actions.
- Use `NiceMock` for less brittle tests during rapid development; apply `StrictMock` only when you want strict verification.

---

## Further Extensions

GoogleTest and GoogleMock's design allows further powerful customization:

- Providing your own implementations of logging, thread synchronization, or stack trace retrieval.
- Defining custom printers for new types to improve error message clarity.
- Implementing new cardinality classes to express call count constraints.

---

## References

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Recipes for custom matchers and actions.
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) — Beginner-friendly introduction to mocking.
- [Matchers Reference](/api-reference/core-apis/matchers) — Built-in and custom matcher capabilities.
- [Actions Reference](/api-reference/advanced-mocking-features/actions) — Available actions and how to extend them.
- [Mocking Reference](/reference/mocking) — Details on mock declarations, expectations, and calls.

---

## Summary

Customization and framework extension in GoogleTest and GoogleMock let you tailor the testing interface to your codebase's needs. By defining custom matchers and actions, setting default behaviors, and adjusting mock strictness, you gain fine control over test behavior and output, enabling robust, expressive, and maintainable tests.

---

## Example: Defining a Custom Matcher

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}

// Usage in test:
EXPECT_THAT(value, IsDivisibleBy7());
```

## Example: Defining a Custom Action

```cpp
class MultiplyByAction {
 public:
  explicit MultiplyByAction(int factor) : factor_(factor) {}

  template <typename R, typename Args>
  R Perform(const Args& args) const {
    return std::get<0>(args) * factor_;
  }

 private:
  int factor_;
};

// Wrapper factory
PolymorphicAction<MultiplyByAction> MultiplyBy(int factor) {
  return MakePolymorphicAction(MultiplyByAction(factor));
}

// Usage in test:
EXPECT_CALL(mock, Foo(_)).WillOnce(MultiplyBy(3));
```

---

For full explored examples and idiomatic usages, please refer to the official GoogleTest and GoogleMock cookbooks and cheat sheets.

---

<Source url="https://github.com/google/googletest" />
