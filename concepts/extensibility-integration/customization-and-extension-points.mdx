---
title: "Customization and Extension Points"
description: "Review the primary extension hooks provided by GoogleTest and GoogleMock, including custom assertion macros, matchers, actions, and platform porting layers. Learn best practices for adapting the frameworks to advanced or non-standard workflows."
---

# Customization and Extension Points

GoogleTest and GoogleMock provide several extension hooks and customization points that empower advanced users to adapt the framework to specialized or non-standard workflows. This guide explains the core concepts of these hooks, including custom assertion macros, matchers, actions, and platform porting layers. You'll also learn best practices for safely extending or modifying behavior while preserving the stability and maintainability of your tests.

---

## Overview of Extension Points

GoogleTest and GoogleMock embrace extensibility by exposing multiple levels where users can customize or extend functionality. These points allow you to tailor the testing and mocking experience beyond built-in capabilities.

- **Custom Assertion Macros:** Define your own assertion macros to encapsulate complex checks with descriptive failure messages.
- **Custom Matchers:** Create matchers that encapsulate reusable argument validation logic.
- **Custom Actions:** Implement actions to define custom behavior for mock methods beyond built-in return or side-effect actions.
- **Platform Porting Layers:** Adapt GoogleTest and GoogleMock to non-standard platforms by customizing synchronization, flag handling, and environment utilities.

Each of these extension points is thoughtfully designed to balance flexibility and ease of use without compromising test readability or framework reliability.

## Custom Assertion Macros

GoogleTest allows you to create your own assertion macros to simplify common verification patterns. These macros enable you to bundle complex logic and produce meaningful failure messages that integrate naturally with the framework's reporting.

**Key aspects:**

- Use the macro constructs `ASSERT_*` and `EXPECT_*` in your definitions.
- Provide clear, descriptive failure output that guides users toward fixing issues.
- Keep the macros focused on asserting specific logical properties relevant to your domain.

Example pattern to define a simple custom assertion could be:

```cpp
#define ASSERT_IS_DIVISIBLE_BY_7(value) \
  ASSERT_PRED_FORMAT1(IsDivisibleBy7Predicate, value)

::testing::AssertionResult IsDivisibleBy7Predicate(const char* expr, int val) {
  if (val % 7 == 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << expr << " with value " << val << " is not divisible by 7";
}
```

This creates an assertion users can invoke as `ASSERT_IS_DIVISIBLE_BY_7(x);` which will pass or fail with a clear message.

## Custom Matchers

Matchers are fundamental for expressing expectations about method arguments. Beyond the rich built-in library, you can define:

- **Simple custom matchers with `MATCHER()` macros** for unary predicates.
- **Parameterized matchers with `MATCHER_P*` macros** allowing encapsulation of complex conditions.
- **Full custom matcher classes** implementing `MatchAndExplain`, `DescribeTo`, and `DescribeNegationTo` methods.

This flexibility lets you represent domain-specific rules succinctly, enabling clearer and more maintainable tests.

**Example:**

```cpp
MATCHER(IsDivisibleBy7, "is divisible by 7") {
  return (arg % 7) == 0;
}

// Usage:
EXPECT_CALL(mock, SomeMethod(IsDivisibleBy7()));
```

**Best practices:**

- Ensure matchers are **pure functions** without side effects.
- Include informative failure explanations by using `result_listener` in your matcher bodies.
- When necessary, provide parameterized matchers to accommodate common variations.

## Custom Actions

Custom actions let you define what happens when mock methods are invoked and the built-in actions cannot express your intent. Actions can perform arbitrary logic, side effects, or control return values.

You can create custom actions by:

- Writing functors or lambdas compatible with the mock method's signature.
- Using the legacy `ACTION`, `ACTION_P`, or `ACTION_Pk` macros for quick definition without explicit templates.
- Implementing the `ActionInterface<F>` interface for monomorphic actions with precise control.
- Creating polymorphic actions with `MakePolymorphicAction()` enabling reuse across different mock function signatures.

**Example using a lambda custom action:**

```cpp
EXPECT_CALL(mock, Foo(_))
    .WillOnce([](int n) { return n * 2; });
```

**Legacy-style parameterized action:**

```cpp
ACTION_P(Add, n) {
  return arg0 + n;
}
EXPECT_CALL(mock, AddValue(_)).WillOnce(Add(5));
```

**Best practices:**

- Prefer lambdas or functors when you want simple, concise actions.
- Use polymorphic actions for maximum flexibility across different mocks.
- Avoid side effects in actions unless expressly intended; document the behavior clearly.

## Platform Porting Layer

GoogleTest and GoogleMock include a platform abstraction layer to ease portability across operating systems and environments.

The porting layer handles:

- **Threading and synchronization primitives:** Mutexes, condition variables.
- **Flag declarations and parsing:** To customize initialization and runtime behavior.
- **Environment utilities:** File system access, time, and other OS specific details.

Users targeting exotic platforms or embedded environments can customize these layers by:

- **Overriding macros or defining platform-specific implementations** of synchronization primitives.
- **Implementing or adjusting flag variables and handlers** to integrate with platform-specific command line or configuration systems.
- **Configuring environment interactions** to suit restricted or unusual execution contexts.

This extensibility enables GoogleTest to be adapted to a wide variety of platforms without modifying core framework logic.

## Best Practices for Customization

- **Isolate extensions:** Keep your custom matchers, actions, and assertions in dedicated namespaces or headers.
- **Leverage existing framework hooks:** Reuse `MATCHER()` macros, `ACTION_P` macros, and `ON_CALL` default actions.
- **Test extensions thoroughly:** Write unit tests to validate your matchers and actions behave correctly and deliver clear diagnostics.
- **Avoid over-complicating:** Use extensions to simplify the test code and improve expressiveness, never to add runtime complexity or obscure logic.

## Practical Workflow

1. **Identify the gap:** Confirm the need for a custom extension (matcher, action, or assertion).
2. **Implement incrementally:** Start with a simple matcher or action.
3. **Integrate into tests:** Replace repeated inline code with your reusable extension.
4. **Document usage clearly:** Provide examples and guidelines for fellow developers.
5. **Maintain compatibility:** Keep extensions compatible with framework updates and C++ standards.

## Troubleshooting Common Extension Issues

- **Unexpected test failures:** Verify your matchers/actions provide deterministic, side-effect free results.
- **Compilation errors with complex types:** Use type aliases or parentheses in `MOCK_METHOD` declarations to handle template commas.
- **Unclear error messages:** Improve descriptions in matchers and assertions.
- **Memory leaks or dangling pointers:** Ensure actions managing pointers respect ownership semantics.

## Reference to Related Concepts

This guide focuses on extensibility hooks rather than general mocking or assertion mechanics. For foundational knowledge, see:

- [gMock for Dummies](../gmock_for_dummies.md) for how mocks and expectations work.
- [Actions Reference](../reference/actions.md) for built-in and custom actions.
- [Matchers Reference](../api-reference/core-assertions-matchers/matchers-reference.md) for matcher types and composition.
- [Nice, Strict, and Naggy Mocks](../api-reference/mocking-framework/nice-strict-mocks.md) for controlling mock strictness behaviors.

## Summary

Customization and extension points empower you to tailor GoogleTest and GoogleMock to your project's specific needs, enabling cleaner, more expressive, and maintainable test code. By leveraging custom assertions, matchers, actions, and platform porting layers, you can handle advanced workflows and platforms while staying within the tested framework boundaries.

For a deeper dive, explore the gMock Cookbook, Mocking Reference, and Platform Portability documentation sections.
