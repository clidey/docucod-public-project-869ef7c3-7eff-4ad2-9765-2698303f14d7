---
title: "Custom Test Runners and Extending Main"
description: "Understand how GoogleTest's main entry point can be customized or replaced to fit into different build and automation environments. Explore patterns for integrating with CI/CD systems and embedded platforms."
---

# Custom Test Runners and Extending Main

GoogleTest provides a familiar and streamlined test runner entry point, but advanced users may want to customize or replace this entry point to better fit their build environment, integrate with continuous integration systems, or embed tests in unusual environments.

This guide explains the concepts behind GoogleTest's main test runner, describes patterns for extending or substituting it, and offers practical guidance on how to customize test launching behavior.

---

## Why Customize the Test Runner?

The GoogleTest framework supplies a `main()` function in its default test runner library (`gtest_main`) that automatically initializes and runs all tests defined in a program. This default is sufficient for most use cases. However, there are scenarios where customizing the main entry point is valuable or necessary, including:

- **Integration with CI/CD pipelines:** Custom test runners can collect additional metadata, alter test filtering, or invoke GoogleTest programmatically as part of larger automation workflows.
- **Embedding in other applications:** When tests must be embedded as part of another program's execution (for example, hardware controllers or embedded systems), the default command-line runner might be unsuitable.
- **Customized initialization and teardown:** If special setup or shutdown steps are needed beyond what test fixtures provide, embedding GoogleTest invocation inside a custom `main()` enables that control.
- **Custom command-line argument processing:** Applying custom parsing or augmentation of command line flags before passing control to GoogleTest.

---

## Overview of GoogleTest's Default Main Entry Point

The main canonical entry point is provided by the `::testing::InitGoogleTest(int* argc, char** argv)` function, which performs:

- Initialization of GoogleTest internal structures.
- Parsing command-line flags intended for GoogleTest (e.g., test filters).
- Setup of global test environment and handlers.

Following initialization, `RUN_ALL_TESTS()` is called to discover and execute all registered tests. The return value of `RUN_ALL_TESTS()` indicates the number of failures, enabling a process exit code to reflect test success or failure.

The typical simple main looks like this:

```cpp
#include <gtest/gtest.h>

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This is the implementation shipped in `gtest_main`.

---

## Customizing or Replacing the Test Runner

Users can provide their own `main()` functions instead of linking with `gtest_main`. This allows complete control over how tests are initialized and run. To do so:

1. **Link without `gtest_main`:** Link against `gtest` but not `gtest_main`.
2. **Implement `main()` yourself:** Use `InitGoogleTest()` for initialization and `RUN_ALL_TESTS()` to trigger test execution.

### Example: Custom Main For Special Setup

```cpp
#include <gtest/gtest.h>
#include <iostream>

int main(int argc, char** argv) {
  // Perform some custom initialization before GoogleTest
  std::cout << "Custom pre-test setup." << std::endl;

  ::testing::InitGoogleTest(&argc, argv);

  // Custom pre-run hook
  std::cout << "Beginning test run." << std::endl;

  const int result = RUN_ALL_TESTS();

  // Custom post-run hook
  std::cout << "All tests completed with code: " << result << std::endl;

  return result;
}
```

This pattern empowers users to add logging, resource management, or integrate externally without modifying GoogleTest internals.

### Using GoogleTest API Programmatically

GoogleTest also exposes programmatic interfaces for running individual tests, filtering, and querying test results, which can all be orchestrated within a custom test runner:

- `UnitTest::GetInstance()` provides access to the test controller.
- `TestEventListeners` allow hooking into the test lifecycle.
- `Run()` or `RunAllTests()` functions can be called explicitly.

This extensibility supports use cases like interactive test environments or embedding tests within GUI or daemon processes.

---

## Best Practices and Recommendations

- When possible, prefer linking with the default `gtest_main` unless you have a clear need for customization.
- Avoid changing `main()` inside test sources when you want to keep compatibility with standard build workflows or test runners.
- Use GoogleTest flags (`--gtest_filter`, `--gtest_repeat`, `--gtest_shuffle`, etc.) for flexible command-line control before resorting to custom main implementation.
- When integrating with CI/CD infrastructures, consider wrapping the test executable with scripts or launcher programs that handle environment setup and output processing, passing through control to the standard GoogleTest runner.
- For embedded or non-standard environments, supply a minimal `main()` that calls `InitGoogleTest` and `RUN_ALL_TESTS`, then add your environment setup code.

---

## Integrating with CI/CD Systems

To integrate GoogleTest runs into automated pipelines, consider the following integration points:

- **Custom test filter and environment setup:** Parse environment variables or config files in custom `main()` to set `--gtest_filter` programmatically.
- **Junit XML or other reports:** Use built-in flag `--gtest_output=xml`, or implement `TestEventListener` for customized reporting.
- **Parallel execution:** Some CI systems use sharding or parallel test executors; your custom runner can manage test partitions by adjusting filters.
- **Handling flaky tests:** Programmatically control retries or rerun logic in your custom runner.

---

## Embedded Platforms and Alternative Entry Points

If embedding GoogleTest in firmware or special platform environments:

- Implement your own `main()` or platform-specific entry point compatible with device boot or test start semantics.
- Ensure that argument passing works or adapt them accordingly, as some embedded platforms may lack command-line support.
- Use `InitGoogleTest()` and `RUN_ALL_TESTS()` as the execution core.
- Integrate GoogleTest's hooks in the platform's event loop or task scheduler.

---

## Troubleshooting Custom Test Runner Issues

- **Tests never run:** Verify your custom `main()` calls `RUN_ALL_TESTS()` after initialization.
- **No tests found:** Ensure test registration macros (`TEST()`, `TEST_F()`) are linked and visible.
- **Unexpected exit codes:** Return `RUN_ALL_TESTS()` result from your main to propagate success/failure.
- **Output not captured:** Confirm no output buffering or redirection issues when adding extra logging.

---

## Summary

Custom test runners provide powerful options to embed GoogleTest in diverse scenarios â€” from CI automation to embedded systems. The key is understanding and leveraging `InitGoogleTest` and `RUN_ALL_TESTS()` as the core interfaces with responsible layering of your custom logic around them.

---

## References

- `InitGoogleTest()` and `RUN_ALL_TESTS()` usage:
  [GoogleTest Primer](https://google.github.io/googletest/primer.html)
- For extending test lifecycle and event listeners, see:
  [GoogleTest Event Listeners](https://github.com/google/googletest/blob/main/docs/advanced.md#writing-a-new-event-listener)
- For integration with build systems, see:
  [Platforms and Build Systems](https://google.github.io/googletest-guides/integration-and-troubleshooting/platforms-and-build-systems.html)
- For embedding GoogleTest, see relevant sections in Platforms and Integration Guides.

<Source url="https://github.com/google/googletest" branch="main" paths='[{"path": "googletest/src/gtest_main.cc", "range": "1-40"}]' />