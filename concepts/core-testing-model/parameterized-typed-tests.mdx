---
title: "Parameterized and Typed Tests"
description: "Understand how GoogleTest supports parameterized and typed tests, allowing you to write reusable test logic that runs over multiple input values or data types to improve coverage and confidence."
---

# Parameterized and Typed Tests

GoogleTest enhances your testing capabilities by allowing you to write **parameterized** and **typed tests**. These test types let you write reusable test logic that automatically runs over multiple input values or data types, improving your test coverage and confidence without writing repetitive code.

---

## Overview

**Parameterized tests** run the same test logic multiple times with different input *values*.

**Typed tests** run the same test logic on multiple *types*.

This page explains how to create, configure, and use both types effectively to make your tests maintainable and scalable.

---

## Parameterized Tests

### What They Are

Parameterized tests enable executing a test multiple times with different input parameters. Instead of duplicating test code, you write the test once and supply different data sets to run it against.

### How to Write Parameterized Tests

1. **Define a test fixture that inherits from `::testing::TestWithParam<T>`**

   The template parameter `T` is the type of your test parameter values. For example, for integer parameters use `int`, for strings use `const char*` or `std::string`, etc.

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // Setup and teardown, plus shared test utilities, can go here
};
```

2. **Write tests using `TEST_P` instead of `TEST` or `TEST_F`**

Within a `TEST_P`, call `GetParam()` to access the current test parameter.

```cpp
TEST_P(MyParamTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

3. **Instantiate the test suite with a set of parameters using `INSTANTIATE_TEST_SUITE_P`**

  GoogleTest provides parameter generators such as:

  - `Values(v1, v2, ..., vN)`: specify explicit values
  - `ValuesIn(container)`: generate parameters from containers or arrays
  - `Range(begin, end [, step])`: generate a sequence from a range
  - `Bool()`: generate boolean values (false, true)
  - `Combine(g1, g2, ...)`: generate Cartesian products of multiple generators

```cpp
INSTANTIATE_TEST_SUITE_P(MyIntTests, MyParamTest, ::testing::Values(1, 2, 3));
```

Each parameter combination produces an individual test instance with an automatically generated name containing the index of the parameter.

### Customizing Parameter Names

You can supply your own naming function or functor for test parameter suffixes, controlling names in test reports and filtering.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNamedTests, MyParamTest, ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This makes tests like `CustomNamedTests/MyParamTest.Value1` visible and filterable.

### Inside Parameterized Tests

- Use `GetParam()` to get the current parameter value.
- Treat each invocation as a clean test; GoogleTest creates a fresh fixture instance per parameter.
- Use setup and teardown as usual in the fixture.

### Benefits

- Runs the same test logic over varied inputs without duplication.
- Simplifies maintenance when test logic changes.
- Enables comprehensive corner case coverage with minimal code.

### Sample Code

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

---

## Typed Tests

### What They Are

Typed tests allow you to run the same test code for multiple data types, useful when testing templates or classes that behave similarly but have different underlying types.

### How to Write Typed Tests

1. **Create a class template fixture deriving from `testing::Test`**

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
public:
  T value_;
};
```

2. **Define a list of types to test, using `testing::Types<...>`**

```cpp
using MyTypes = ::testing::Types<int, double, float>;
```

3. **Associate the type list with your test suite using `TYPED_TEST_SUITE`**

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. **Write individual tests using the `TYPED_TEST` macro**

Within these tests, use the special name `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam t{};
  (void)t;
  SUCCEED();
}
```

### Using Custom Type Names

You can supply a custom name generator class to generate human-readable suffixes based on each type, improving test output clarity:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Benefits

- Write one set of tests that run on any types you specify.
- Validate templates or generic classes thoroughly without duplication.
- Improve debugging with clearer typed test names (with a name generator).

---

## Type-Parameterized Tests (Advanced)

- These allow defining **abstract test patterns** as templates, *without* binding to specific types immediately.
- Test patterns are registered with `TYPED_TEST_SUITE_P`, test definitions with `TYPED_TEST_P`, then registered with `REGISTER_TYPED_TEST_SUITE_P`.
- Later, instantiate them multiple times in different translation units with specific type lists using `INSTANTIATE_TYPED_TEST_SUITE_P`.

This approach helps when writing interface/concept compliance tests applicable across multiple implementations.

---

## Summary of Important Macros and Functions

| Macro / Function                       | Description                                                       |
|-------------------------------------|-------------------------------------------------------------------|
| `TEST_P(Fixture, TestName)`          | Defines a single parameterized test case                          |
| `INSTANTIATE_TEST_SUITE_P(Name, Fixture, Generator)` | Instantiates parameterized tests with provided generator          |
| `TYPED_TEST_SUITE(Fixture, Types)`  | Defines a typed test suite with a list of types                   |
| `TYPED_TEST(Fixture, TestName)`     | Defines a single typed test case for each type in the suite      |
| `TYPED_TEST_SUITE_P(Fixture)`       | Defines a type-parameterized test suite (pattern)                |
| `TYPED_TEST_P(Fixture, TestName)`   | Defines a type-parameterized test (pattern)                      |
| `REGISTER_TYPED_TEST_SUITE_P(Fixture, ...)` | Registers type-parameterized test cases                            |
| `INSTANTIATE_TYPED_TEST_SUITE_P(Name, Fixture, Types)` | Instantiates a type-parameterized test suite                        |

---

## Best Practices and Troubleshooting Tips

- Always use unique instantiation prefixes with `INSTANTIATE_TEST_SUITE_P` to avoid name collisions.
- Use descriptive names for parameter instantiations for clarity.
- Write custom parameter name generators to generate valid, unique test names without spaces or special characters.
- Ensure test fixture classes are copyable and support necessary constructors.
- For typed tests, make sure that each type instantiation is valid for the test code.
- Remember that GoogleTest creates a fresh fixture instance per test execution; do not rely on state shared between parameter invocations.

---

## Real-World Scenario: Testing a Template Container

Imagine you are developing a templated container class `MyStack<T>`. You want to ensure the proper LIFO behavior for multiple types like `int`, `double`, and `std::string`. Instead of writing separate test classes, typed tests let you define one test class template and run the same tests across all types.

```cpp
template <typename T>
class MyStackTest : public ::testing::Test {
 protected:
  MyStack<T> stack;
};

using StackTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyStackTest, StackTypes);

TYPED_TEST(MyStackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack.empty());
}

TYPED_TEST(MyStackTest, CanPushAndPop) {
  this->stack.push(TypeParam{});
  EXPECT_FALSE(this->stack.empty());
  this->stack.pop();
  EXPECT_TRUE(this->stack.empty());
}
```

Running these typed tests ensures your container works correctly across the specified data types.

---

## Useful Links

- [Value-Parameterized Tests in GoogleTest Advanced Guide](../advanced.md#value-parameterized-tests)
- [Typed Tests in GoogleTest Advanced Guide](../advanced.md#typed-tests)
- [INSTANTIATE_TEST_SUITE_P Macro Details](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TYPED_TEST_SUITE and TYPED_TEST Macros](../reference/testing.md#TYPED_TEST_SUITE)
- [Custom Parameter Name Generation](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)

---

## Summary

Parameterized and typed tests in GoogleTest provide powerful ways to maximize test code reuse, improve test coverage, and express test intent clearly. Parameterized tests scale test runs across many input values, while typed tests iterate tests over multiple types, both enabling thorough verification with minimal code duplication.

This guide equips you with the knowledge and examples to implement these test styles confidently and effectively.
