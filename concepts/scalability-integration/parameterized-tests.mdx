---
title: "Parameterized and Type-Parameterized Tests"
description: "Uncover how parameterized and type-parameterized tests enable scalable test coverage by systematically varying inputs and data types. Learn the benefits for DRY (Don't Repeat Yourself) test code and coverage analysis."
---

# Parameterized and Type-Parameterized Tests

GoogleTest offers powerful techniques to scale your testing efforts by running test logic against multiple sets of inputs or types without duplicating test code. This documentation explains the concepts, benefits, and usage patterns of **value-parameterized tests**, **typed tests**, and **type-parameterized tests**, enabling you to maximize test coverage with minimal code duplication.

---

## Why Use Parameterized and Type-Parameterized Tests?

Imagine you have a function or class that should behave correctly over a range of inputs or data types. Writing separate tests for each variation becomes tedious and error-prone. Parameterized tests systematically vary test parameters, while typed tests vary the data type under test. By employing these techniques, you:

- **Write DRY test code**: Define the test logic once rather than repeating it.
- **Expand test coverage efficiently**: Automatically generate multiple test instances.
- **Simplify maintenance:** Changes to test logic propagate across all variations.

---

## Value-Parameterized Tests

### Concept

Value-parameterized tests allow you to run the same test logic with different input values (parameters). This is especially helpful when you want to validate behavior across various inputs without copying the test code.

### Defining Value-Parameterized Tests

1. **Create a fixture class** derived from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the type of the test parameter.

   For convenience, inherit from `testing::TestWithParam<T>`, which combines both.

   ```cpp
   class MyTest : public ::testing::TestWithParam<int> {
     // Optional: fixture setup/teardown
   };
   ```

2. **Define tests using the `TEST_P` macro**, where you can access the current parameter with `GetParam()`.

   ```cpp
   TEST_P(MyTest, HandlesVariousInputs) {
     int input = GetParam();
     EXPECT_TRUE(YourFunctionUnderTest(input));
   }
   ```

3. **Instantiate the test suite** with parameters using `INSTANTIATE_TEST_SUITE_P` and predefined parameter generator functions such as `Values()`, `Range()`, `Combine()`, or `Bool()`.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       MyParameters, MyTest, testing::Values(1, 2, 3, 5, 8));
   ```

### Parameter Generators

GoogleTest provides useful generators:

| Generator           | Description                                   |
|---------------------|-----------------------------------------------|
| `Values(v1, ..., vN)` | Explicit set of values                        |
| `Range(start, end [, step])` | Sequence from start up to (but not including) end, with optional step (default 1) |
| `ValuesIn(container)` | Values sourced from an array or container    |
| `Bool()`             | Boolean values (`false`, `true`)              |
| `Combine(g1, g2, ..., gN)` | Cartesian product of multiple generators, producing tuples |

### Customizing Test Names

You may provide a functor or lambda to generate meaningful test name suffixes based on the parameter values, improving test reports:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyTest, testing::Values(3, 5, 7),
    [](const testing::TestParamInfo<MyTest::ParamType>& info) {
      return "Input" + std::to_string(info.param);
    });
```

### Example

```cpp
class FibonacciTest : public ::testing::TestWithParam<int> {};

TEST_P(FibonacciTest, IsNonNegative) {
  int n = GetParam();
  EXPECT_GE(Fibonacci(n), 0);
}

INSTANTIATE_TEST_SUITE_P(
    FibonacciRange, FibonacciTest, testing::Range(0, 10));
```

### Notes and Best Practices

- The test fixture constructor must be public for use with `TEST_P`.
- Avoid using underscores in test suite or test names to prevent macro expansion issues.
- Parameters are evaluated *after* `InitGoogleTest()` is called, which allows dynamic parameter generation based on runtime information.
- By default, a value-parameterized test without instantiation causes a failing test; use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if skipping instantiation is intentional.

---

## Typed Tests

### Concept

Typed tests allow repetition of the same test code for different types. This is useful when you want to verify that multiple type implementations adhere to the same interface or behavior.

### Defining Typed Tests

1. **Define a test fixture template parameterized on a type:**

   ```cpp
   template <typename T>
   class MyTypedTest : public ::testing::Test {
    public:
     T value_;
   };
   ```

2. **Associate a list of types with the fixture using `TYPED_TEST_SUITE`:**

   ```cpp
   using MyTypes = ::testing::Types<int, float, double>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Write tests using `TYPED_TEST`, using `TypeParam` as the current type:**

   ```cpp
   TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
     TypeParam val = this->value_;
     (void)val;  // Silence unused warnings
     SUCCEED();
   }
   ```

### Example

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using Implementations = ::testing::Types<ArrayStack<int>, ListStack<int>>;
TYPED_TEST_SUITE(StackTest, Implementations);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.IsEmpty());
}
```

### Custom Naming

Optionally, provide a name generator class exposing a static templated function `GetName(int)` for type-specific suffixes.

---

## Type-Parameterized Tests

### Concept

Type-parameterized tests are like typed tests but allow defining abstract test patterns without binding to concrete types immediately. Types are specified and instantiated later, enabling greater flexibility and reuse across translation units.

### Defining Type-Parameterized Tests

1. **Define a type-parameterized fixture template:**

   ```cpp
   template <typename T>
   class MyTypeParamTest : public ::testing::Test { ... };
   ```

2. **Declare the suite with `TYPED_TEST_SUITE_P`:**

   ```cpp
   TYPED_TEST_SUITE_P(MyTypeParamTest);
   ```

3. **Define test cases with `TYPED_TEST_P`:**

   ```cpp
   TYPED_TEST_P(MyTypeParamTest, Test1) { ... }
   TYPED_TEST_P(MyTypeParamTest, Test2) { ... }
   ```

4. **Register test names:**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, Test1, Test2);
   ```

5. **Instantiate the tests in source files where concrete types are known:**

   ```cpp
   using MyTypes = ::testing::Types<int, float, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(My, MyTypeParamTest, MyTypes);
   ```

### Usage Highlights

- Type-parameterized tests support scenarios where the type list is unknown or extends dynamically.
- You can instantiate the same suite multiple times with different type lists.

---

## Workflow Summary

<Steps>
<Step title="Write Reusable Fixture">
Create a fixture class template (typed/type-parameterized) or specialized fixture (value-parameterized).
</Step>
<Step title="Define Tests">
Use `TEST_P` for value-parameterized; `TYPED_TEST` or `TYPED_TEST_P` for typed and type-parameterized.
</Step>
<Step title="Instantiate Tests">
Instantiate test suites with `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`.
</Step>
<Step title="Run Tests">
Run the tests with `RUN_ALL_TESTS()`, optionally filtering specific parameters/types.
</Step>
</Steps>

---

## Tips and Best Practices

- Use descriptive instantiation names to distinguish test groups.
- Avoid underscores in test suite/test names to prevent macro expansion issues.
- When testing multiple inputs and types, combine parameterized and typed tests carefully to keep tests readable.
- Leverage `Combine()` to test multiple parameters jointly.
- Use custom name generators to create readable and meaningful test output.
- Remember that each test instance uses a fresh fixture instance to maintain test isolation.
- Protect shared, expensive-to-build resources using static `SetUpTestSuite()` and `TearDownTestSuite()` when applicable.

---

## Troubleshooting

**Problem:** Tests defined with `TEST_P` but no instantiation leads to failing `GoogleTestVerification` test.

**Solution:** Either instantiate the test suite using `INSTANTIATE_TEST_SUITE_P`, or suppress with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if appropriate.

**Problem:** Compilation errors regarding fixture constructors in typed tests.

**Solution:** Ensure the fixture template has a public default constructor.

**Problem:** Undesired duplicated test names or invalid names.

**Solution:** Use custom name suffix generators that avoid underscores and invalid characters.

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [Macros for Parameterized Tests (TEST_P, INSTANTIATE_TEST_SUITE_P)](reference/testing.md#TEST_P)
- [Macros for Typed Tests (TYPED_TEST, TYPED_TEST_SUITE)](reference/testing.md#TYPED_TEST)

---

### Additional Resources

- Sample code demonstrating parameterized and typed tests: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc), [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)
- API Reference to parameterized test macros: [Testing Reference - Parameterized Tests](reference/testing.md#TEST_P)
- Advanced user guide: [GoogleTest Advanced Topics](docs/advanced.md)

---

By embracing parameterized and type-parameterized tests, you unlock scalable, maintainable, and robust test suites that keep your C++ code confident and regressions minimized.