---
title: "Value- and Type-Parameterized Tests"
description: "Explores how to leverage value- and type-parameterized tests for broad coverage across input sets and data types. Unpacks the macro-based approach, instantiation protocols, and practical patterns for scalable parameterized testing."
---

# Value- and Type-Parameterized Tests

Explore how to leverage value- and type-parameterized tests in GoogleTest for broad coverage across input sets and data types. This guide unpacks the macro-based approach, instantiation protocols, and practical patterns for scalable parameterized testing.

---

## Introduction to Parameterized Tests

Parameterized tests empower you to run the same test logic against multiple inputs or types, dramatically increasing coverage while minimizing code duplication. GoogleTest supports two main flavors:

- **Value-Parameterized Tests**: Test suites that run repeatedly with different runtime values.
- **Type-Parameterized Tests**: Test suites that run repeatedly with different compile-time types.

Both approaches use macros to organize tests in a way that feels natural, and test instantiation macros to generate test instances across your chosen parameter or type sets.

---

## Value-Parameterized Tests

Value-parameterized tests let you supply different parameter values to a test fixture at runtime, enabling data-driven testing patterns without manual test duplication.

### Writing Value-Parameterized Tests

1. **Define a Test Fixture Class**: Your fixture inherits from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Add your fixture members here
};
```

2. **Define Parameterized Tests**: Use `TEST_P` to write tests that have access to the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, HandlesMultipleValues) {
  EXPECT_GT(GetParam(), 0);  // Example assertion
}
```

3. **Instantiate the Test Suite**: Use `INSTANTIATE_TEST_SUITE_P` with a parameter generator (e.g., `Values`, `Range`, `Combine`, `Bool`) to supply the parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(MyValues, FooTest,
                         testing::Values(1, 2, 3));
```

#### Supported Parameter Generators

- `Values(v1, v2, ..., vN)`: Fixed list of values.
- `ValuesIn(container)`: Values from an STL container or array.
- `Range(start, end, [step])`: Sequence from start up to (but not including) end.
- `Bool()`: The two values `false` and `true`.
- `Combine(g1, g2, ..., gN)`: Cartesian product of multiple parameter generators, producing tuples.

#### Custom Test Name Suffixes

You can specify a function or functor in `INSTANTIATE_TEST_SUITE_P` that takes `testing::TestParamInfo<T>` and returns a unique, valid test name suffix. This improves the readability of test outputs and filtering.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

#### Notes & Best Practices

- The parameter type `T` must be copyable.
- Parameter generators are evaluated lazily, during `InitGoogleTest()`, so dynamic parameter computation is supported.
- Test names must consist only of alphanumeric characters or underscores; spaces and dashes are not allowed.
- Duplicate test name suffixes in instantiations cause a fatal error.
- `GetParam()` retrieves the test parameter within `TEST_P` bodies.

### Abstract Value-Parameterized Tests

Define parameterized tests in a header (`.h`) file and separate implementation in a `.cc` file. Consumers can then instantiate these tests with their own parameter values, enabling sharing of standard test suites without exposing test logic details.

### Example

```cpp
class MyParamTest : public testing::TestWithParam<std::string> {};

TEST_P(MyParamTest, IsNotEmpty) {
  EXPECT_FALSE(GetParam().empty());
}

INSTANTIATE_TEST_SUITE_P(BasicStrings, MyParamTest,
                         testing::Values("foo", "bar", "baz"));
```

---

## Type-Parameterized Tests

Type-parameterized tests execute the same test logic against different C++ types, allowing you to verify generic interfaces or templated code.

### Writing Typed Tests

1. **Define a Fixture Template**:

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_;
};
```

2. **Associate a Type List**:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

3. **Write Tests Using `TYPED_TEST`**:

Inside test bodies, use `TypeParam` to reference the current type.

```cpp
TYPED_TEST(FooTest, DoesSomething) {
  TypeParam value = this->value_;
  // Test logic using TypeParam
}
```

### Type-Parameterized Tests

Similar to typed tests, but allow test pattern definition without concrete type list. They are instantiated later with any suitable type list.

Workflow:

- Define fixture template.
- Declare test suite with `TYPED_TEST_SUITE_P`.
- Define type-parameterized test cases with `TYPED_TEST_P`.
- Register tests using `REGISTER_TYPED_TEST_SUITE_P` macro.
- Instantiate concrete suites with `INSTANTIATE_TYPED_TEST_SUITE_P`.

Example:

```cpp
template <typename T>
class FooTest : public testing::Test { /* ... */ };

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam value = 0;
  /* ... */
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah);

using MyTypes = testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

### Notes & Best Practices

- Use `typename TestFixture::` prefix to refer to member types within typed tests.
- When naming typed and type-parameterized tests, avoid underscores for compatibility.
- Type-parameterized tests can be instantiated multiple times across translation units.

---

## Practical Patterns & Usage Guidance

### Combining Parameters

Use `Combine()` to produce Cartesian products. For example, to test a function across many boolean feature flags:

```cpp
INSTANTIATE_TEST_SUITE_P(AllFlagCombos, MyFlagTest,
                          testing::Combine(testing::Bool(), testing::Bool()));
```

This creates tests for `(false, false)`, `(false, true)`, etc.

### Customizing Parameter Types

When parameter generators yield types different from your fixture's parameter type:

- Use `ConvertGenerator<T>(gen)` to cast generated parameter types.
- Or supply a conversion function:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInst,
    MyTestSuite,
    ConvertGenerator<MyParam>(
        Combine(Values(1, 2), Bool()),
        [](std::tuple<int, bool> t) { /* convert */ }));
```

### Avoiding Duplicate Test Names

Duplicated parameterized test names cause registration errors.
- Ensure uniqueness in name-generating functions.
- Parameter suffix names must contain only alphanumerics and underscores.

### Marking Tests Allowed to Be Uninstantiated

Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName);` if you define parameterized tests without instantiating them. This suppresses failure warnings.

---

## Troubleshooting Common Issues

| Problem                              | Solution                                                     |
|------------------------------------|--------------------------------------------------------------|
| Duplicate parameterized test names  | Use unique suffix naming functions or filter your names.    |
| Invalid test name characters         | Restrict suffixes to ASCII alphanumerics and underscores.    |
| Missing instantiation warnings       | Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.         |
| Dangling references in ConvertGenerator | Specify generated type explicitly and avoid string_view from temporary strings. |

---

## Summary

Value- and type-parameterized tests allow highly scalable testing across data values and types. They reduce boilerplate, improve coverage, and enable reusable test logic.

Use `TEST_P` with `INSTANTIATE_TEST_SUITE_P` for values and `TYPED_TEST` or `TYPED_TEST_P` with corresponding instantiation macros for types. Parameter generators like `Values`, `Range`, and `Combine` define the parameter spaces. Custom name generators improve test reporting clarity.

---

## References & Further Reading

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) - Full usage details.
- [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests) and (../advanced.md#type-parameterized-tests)
- [INSTANTIATE_TEST_SUITE_P API](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [Parameterized and Typed Tests API Reference](../api-reference/gtest-core-api/parameterized-and-typed-tests.md)
- [GoogleTest Primer](../primer.md) for foundational concepts.

---

## Source Examples

- `googletest/test/googletest-param-test-test.cc` demonstrates value-parameterized tests and their instantiation.
- `googletest/test/googletest-param-test2-test.cc` shows instantiation across translation units.
- `googletest/test/googletest-param-test-invalid-name2-test_.cc` highlights duplicate test name issues.

---

## Visual Overview

```mermaid
graph TD
  subgraph Value Parameterized Tests
    Fixture1["Test Fixture Class (TestWithParam<T>)"] --> TESTP1["TEST_P Macro Tests"]
    TESTP1 -->|INSTANTIATE_TEST_SUITE_P| GeneratedTests1["Generated Test Instances"]
    GeneratedTests1 --> Verification1["Use GetParam() to access value"]
  end

  subgraph Type Parameterized Tests
    FixtureTemplate["Test Fixture Template<T>"] --> TypedTest["TYPED_TEST and TYPED_TEST_P"]
    TypedTest --> TypedList["Type List (Types<...>) or Generated Instantiations"]
    TypedList --> GeneratedTests2["Generated Tests for Each Type"]
    GeneratedTests2 --> Verification2["Use TypeParam in Test Body"]
  end

  Value Parameterized Tests -.-> CustomNaming["Custom Name Generators"]
  Type Parameterized Tests -.-> CustomNaming

  CustomNaming --> TestFilter["Allows Meaningful Test Output and Filtering"]

  style Value Parameterized Tests fill:#e3f2fd,stroke:#1e88e5,stroke-width:2px
  style Type Parameterized Tests fill:#fce4ec,stroke:#c2185b,stroke-width:2px
```
```
