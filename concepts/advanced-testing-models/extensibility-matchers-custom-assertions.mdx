---
title: "Extensibility: Matchers & Custom Assertions"
description: "Dive into the extensibility mechanisms of GoogleTest—how to define custom assertions and matchers to fit your application’s logic. Discover GoogleTest’s matcher abstraction, allowing expressive and readable test conditions for complex objects and behaviors."
---

# Extensibility: Matchers & Custom Assertions

GoogleTest's power lies not only in its robust core features but also in its rich extensibility mechanisms. This page guides you through how to extend GoogleTest by writing custom matchers and assertions, which let you express intricate testing logic clearly and consistently — tailored precisely to your application's domain and needs.

---

## Understanding Matchers and Their Role

At the heart of GoogleTest's expressive assertions and mock expectations are **matchers**. A matcher is, essentially, a predicate that verifies if a given value meets a condition. Beyond simple equality checks, matchers enable conditions such as range inclusion, string prefix matching, pointer null checks, container contents validation, and more.

Matchers enhance readability and diagnostics, providing descriptive error messages when an expectation or assertion fails. You can seamlessly combine built-in matchers or define your own to match your domain-specific requirements.

---

## Writing Custom Matchers using the `MATCHER` Macros

GoogleTest offers a family of macros — `MATCHER`, `MATCHER_P`, `MATCHER_P2`, up to `MATCHER_P10` — for rapidly defining custom matchers:

- `MATCHER(name, description)`: Defines a matcher with no parameters.
- `MATCHER_P(name, param, description)`: Defines a matcher with one parameter.
- `MATCHER_P2(name, p1, p2, description)`: For two parameters, and so forth.

### How to Define a Basic Matcher

A matcher is defined via a macro where you implement the logic in the body, returning `true` if the argument satisfies the condition and `false` otherwise.

Example — define a matcher to check if a number is divisible by 7:

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

Usage example:

```cpp
EXPECT_CALL(mock_obj, Method(IsDivisibleBy7()));
EXPECT_THAT(my_value, IsDivisibleBy7());
```

If the matcher fails, GoogleTest prints a helpful message, automatically derived from the matcher name, e.g., "is divisible by 7".

### Adding Custom Failure Messages and Explanation

To improve diagnostics, provide a custom description string or write to the `result_listener` inside your matcher body for detailed failure messages.

Example with explanation:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

This enriches failure outputs with remainder information.

### Parameterized Custom Matchers

Parameterized matchers let you define matchers that take arguments.

Example — check if absolute value matches a parameter:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}
```

You can then write:

```cpp
EXPECT_THAT(Compute(), HasAbsoluteValue(10));
```

Your failure messages will include parameter values:

```
Expected: has absolute value 10
  Actual: -9
```

### Best Practices with MATCHER Macros

- Start simple, use the macro's automatic description when possible.
- Provide meaningful failure explanations for complex logic.
- Use `EXPECT_` statements inside bodies cautiously to add diagnostic info.
- Use the parameterized versions (`MATCHER_P`, `MATCHER_P2`, etc.) to capture context cleanly.

---

## Creating Custom Matcher Classes for Full Control

While the `MATCHER` macros are convenient, complex or widely reused matchers benefit from implementing the matcher interface directly. A matcher class defines:

- `MatchAndExplain(const T&, std::ostream*)`: Determines if the value matches and optionally explains.
- `DescribeTo(std::ostream*)`: Describes the matcher.
- `DescribeNegationTo(std::ostream*)`: Describes the negation.

### Example: Custom Matcher Class

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected_sum) : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /* listener */) const {
    return (foo.bar() + foo.baz()) == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  const int expected_sum_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return ::testing::MakeMatcher(new BarPlusBazEqMatcher(expected_sum));
}
```

Use it in tests:

```cpp
EXPECT_THAT(my_foo, BarPlusBazEq(5));
```

This gives you fine-grained control including how values are matched, described, and explained.

---

## Polymorphic Matchers

GoogleTest supports polymorphic matchers that can be used to match multiple types, adapting to the context automatically. Polymorphic matchers are ideal when your matcher logic applies uniformly across multiple compatible types.

Define polymorphic matchers by templating the `MatchAndExplain` method inside your matcher class.

Example snippet:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream* /* listener */) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

inline ::testing::PolymorphicMatcher<NotNullMatcher> NotNull() {
  return ::testing::MakePolymorphicMatcher(NotNullMatcher());
}
```

---

## Combining and Composing Matchers

Matchers can be combined using logical combinators such as:

- `AllOf(m1, m2, ...)`: Matches if all sub-matchers match.
- `AnyOf(m1, m2, ...)`: Matches if any sub-matcher matches.
- `Not(m)`: Matches if the matcher does not match.

This allows complex conditions to be composed clearly.

Example:

```cpp
EXPECT_THAT(value, AllOf(Ge(5), Ne(10)));  // value >= 5 and value != 10
```

---

## Matchers for Container and Tuple Types

GoogleTest includes specialized matchers to verify properties of containers and tuples, and you can extend or write your own for specialized container validation.

Common usages:

- `ElementsAre(...)`: Matches elements sequentially.
- `UnorderedElementsAre(...)`: Matches elements regardless of order.
- `Pair(m1, m2)`: Matches pairs with first and second fields.
- `Field(&Class::member, matcher)`: Validates a specific member field.
- `Property(&Class::method, matcher)`: Validates a property method's return value.

Use these to write expressive assertions verifying complex object structures.

---

## Safely Casting Matchers With `SafeMatcherCast<T>(m)`

GoogleTest enforces type safety when using matchers. Sometimes, you may want to cast a matcher from one type to another compatible type (e.g., from `Matcher<long>` to `Matcher<int>`).

Use `SafeMatcherCast<T>(m)` for this purpose. It performs compile-time checks and ensures that type conversions are safe and non-lossy.

Example:

```cpp
Matcher<Base*> base_ptr_matcher = Eq(derived_ptr);
Matcher<Derived*> derived_ptr_matcher = SafeMatcherCast<Derived*>(base_ptr_matcher);
```

---

## Custom Assertions Using Matchers

GoogleTest's `EXPECT_THAT` and `ASSERT_THAT` macros integrate matchers into assertions, allowing you to leverage custom matchers seamlessly:

```cpp
EXPECT_THAT(value, YourCustomMatcher(arg));
```

If the matcher fails, you get detailed diagnostics based on your matcher’s `DescribeTo` and `MatchAndExplain` implementations.

---

## Tips and Best Practices

- **Always prefer matchers over raw predicates:** They provide richer diagnostics.
- **Use the `MATCHER` macros when your matcher logic is straightforward:** Less boilerplate, more concise.
- **Implement matcher classes for complex, reusable logic:** Better control and maintainability.
- **Keep matchers pure and side-effect free:** GoogleTest requires matchers to be functional.
- **Leverage polymorphic matchers to maximize flexibility:** Especially when being used in generic code.
- **Combine matchers to articulate complex conditions clearly:** This improves test readability.
- **Provide descriptive failure messages:** Use `result_listener` or override description methods.

---

## Troubleshooting Common Issues

- **Matcher evaluations without explanation:** If your matcher does not provide good explanations, consider streaming more details to the `result_listener`.
- **Compilation errors in complex matchers:** Ensure type parameters and `SafeMatcherCast` usage are correct.
- **Ambiguous overloads:** Use explicit matcher casts or simpler matcher interfaces.

---

## Related Documentation

- [gMock Cookbook: Writing New Matchers Quickly](https://google.github.io/googletest/gmock_cook_book.html#new-matchers) — Practical recipes.
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) — Comprehensive list of built-in matchers.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — For usage of matchers in mocks.
- [Assertions Reference](https://google.github.io/googletest/reference/assertions.html#expect_that) — Using `EXPECT_THAT` with matchers.

---

By mastering GoogleTest’s matcher abstraction and custom assertion mechanisms, you create tests that are not only robust and maintainable but also clearly communicate intent and behavior, unlocking the full power of expressive, readable, and precise test specifications.