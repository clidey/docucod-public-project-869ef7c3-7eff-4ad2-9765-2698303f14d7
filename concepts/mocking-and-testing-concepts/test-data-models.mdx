---
title: "Test Data Models: Parameterized and Typed Tests"
description: "Explore how GoogleTest enables both data-driven and type-driven testing paradigms, including value- and type-parameterized tests for comprehensive coverage with minimal duplication."
---

# Test Data Models: Parameterized and Typed Tests

GoogleTest empowers you to write scalable and maintainable tests by embracing *parameterized* and *typed* test data models. These approaches drastically reduce duplication by enabling the same test logic to run with multiple inputs or types, ensuring comprehensive coverage with minimal maintenance.

---

## Overview

In many testing scenarios, you want to validate your code against a range of inputs or against multiple implementations. Writing individual test cases for each input or type quickly becomes tedious and error-prone.

GoogleTest introduces two powerful paradigms to help:

- **Value-Parameterized Tests:** Execute the same test logic with different input values.
- **Type-Parameterized Tests (Typed Tests):** Run tests against different types or implementations, perfect for interface conformance or template classes.

Both models promote code reuse, boost test coverage, and improve expressiveness.

---

## Value-Parameterized Tests

Value-Parameterized Tests let you define tests where the test data varies as values, such as integers, strings, or structs.

### Concept

Instead of writing many test cases, define a test logic *once*, and instantiate it with many values.

### Workflow

1. Define a parameterized test fixture class, deriving from `::testing::TestWithParam<T>`, where `T` is the type of your parameter.
2. Use the `TEST_P` macro to write your test cases, accessing parameters via `GetParam()`.
3. Instantiate the test suite with values using `INSTANTIATE_TEST_SUITE_P`.

### Example

```cpp
#include <gtest/gtest.h>

// Step 1: Define parameterized test fixture
class IsEvenTest : public ::testing::TestWithParam<int> {
};

// Step 2: Write test using TEST_P
TEST_P(IsEvenTest, HandlesEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

// Step 3: Instantiate with test values
INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

Here, the single test logic `HandlesEvenNumbers` runs four times, with each value in the list.

### Advanced Instantiation

- Use `::testing::ValuesIn(container)` to generate tests from any iterable container.
- Provide a custom function to generate test names for clearer output using the third argument of `INSTANTIATE_TEST_SUITE_P`.

### Best Practices

- Keep the parameter type simple and easily described for readable failure messages.
- Use meaningful names in instantiation to clarify test outputs.

---

## Type-Parameterized Tests (Typed Tests)

Typed Tests target scenarios where you want to test the same behavior across multiple types or implementations that conform to an interface.

### Concept

Define your test logic as a template class, then run it with various type parameters to verify type-specific or implementation-specific behavior.

### Workflow

1. Define a template test fixture class derived from `::testing::Test`.
2. Use the `TYPED_TEST_CASE` (deprecated) or preferably `TYPED_TEST_SUITE` macro to associate the fixture with a list of types.
3. Write test cases with `TYPED_TEST`, referring to `TypeParam` to represent the current type.

### Example

```cpp
#include <gtest/gtest.h>

template <typename T>
class StackTest : public ::testing::Test {
 protected:
  T stack_;
};

using StackTypes = ::testing::Types<std::stack<int>, std::stack<double>>;

TYPED_TEST_SUITE(StackTest, StackTypes);

TYPED_TEST(StackTest, IsInitiallyEmpty) {
  EXPECT_TRUE(this->stack_.empty());
}

TYPED_TEST(StackTest, CanPushAndPop) {
  this->stack_.push(TypeParam::value_type(5));
  EXPECT_FALSE(this->stack_.empty());
  this->stack_.pop();
  EXPECT_TRUE(this->stack_.empty());
}
```

This runs the `IsInitiallyEmpty` and `CanPushAndPop` tests against different stack types.

### When to Use

- Testing interface compliance across implementations.
- Verifying template classes for multiple type parameters.
- Scenario-driven testing by type.

### Notes

- Typed tests require careful design so tests can access type-specific members or typedefs.
- The test fixture's template parameter is available as `TypeParam` inside tests.

---

## Combining Typed and Value-Parameterized Tests

Sometimes your test needs vary by both type and value. GoogleTest supports this through *Type-Parameterized Parameterized Tests*.

- This advanced usage lets you combine both paradigms for complex scenarios.
- More details and examples can be found in the [GoogleTest Primer](primer.md) and the advanced testing guides.

---

## Benefits and Use Cases

* **Maintainability:** One source of truth for test logic.
* **Clarity:** Test code focused on behavior, not tedious repetitions.
* **Coverage:** Easy to add more types or values without duplicating code.

Real-world examples include:

- Verifying algorithms against different container types.
- Testing various numeric types or policies.
- Validating multiple implementations of an interface for contract adherence.

---

## Common Pitfalls and Troubleshooting

- Do not mix underscores in test or suite names; GoogleTest treats underscores specially.
- Typed tests must name the test fixture carefully to avoid compiler errors.
- When using value-parameterized tests, ensure parameter types are copyable and printable.
- Watch out for needing default constructors in typed tests to instantiate objects.

If you encounter issues, consult the:

- [GoogleTest FAQ on Typed vs Value Parameterized Tests](docs/faq.md#I-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-Should-I-use-typed-tests-or-value-parameterized-tests)
- [GoogleTest Primer](primer.md) for beginner-friendly examples.

---

## Summary

GoogleTest's parameterized and typed tests unlock a data-driven and type-driven testing paradigm that keeps your tests DRY (Don't Repeat Yourself), expressive, and scalable. Whether testing multiple inputs or crafting generic tests for different types, GoogleTest provides intuitive macros and test lifecycle support to ensure your coverage is robust and maintainable.

---

## Additional Resources

- Primer on [Parameterized Tests](primer.md#value-parameterized-tests)
- Guide to [Typed Tests and Type-Parameterized Tests](guides/advanced-testing/parameterized-and-type-parameterized-tests.md)
- FAQ section on [Typed vs Value-Parameterized Tests](docs/faq.md)
- Use [GoogleMock Cookbook](docs/gmock_cook_book.md) for mocking with parameterized tests

---