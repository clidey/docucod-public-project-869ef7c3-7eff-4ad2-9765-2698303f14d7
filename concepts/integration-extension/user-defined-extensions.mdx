---
title: "User-Defined Assertions and Matchers"
description: "Learn how to extend GoogleTest and GoogleMock by creating custom assertions and matchers. This is essential for adapting the framework to domain-specific requirements and ensuring expressive, domain-driven testing."
---

# User-Defined Assertions and Matchers

Extending GoogleTest and GoogleMock to define custom assertions and matchers is a critical skill for tailoring the testing framework to your unique domain and expressing test expectations clearly and succinctly. This guide walks you through the concepts, patterns, and practices for creating your own assertions and matchers that integrate smoothly with GoogleMock’s powerful mocking infrastructure.

---

## Why Create User-Defined Assertions and Matchers?

GoogleMock provides an extensive set of built-in matchers that cover a wide range of general-purpose comparisons and checks. However, your application or library likely involves domain-specific types and invariants that require specialized validations. Writing verbose inline checks or repeatedly combining primitive matchers can lead to cumbersome, brittle tests.

Custom matchers and assertions allow you to:

- **Express intent more clearly:** Give descriptive names and messages to complex checks.
- **Improve maintainability:** Encapsulate error-message logic and matching rules in one place.
- **Reuse logic:** Share your domain-specific predicates across tests and projects.

## Core Concepts

### Matchers
A **matcher** tests whether a value meets some condition. In GoogleMock, matchers are used to specify expected argument properties in `EXPECT_CALL` or `ON_CALL` statements.

Matchers can be:

- **Simple value matchers:** Check equality, range, or pattern.
- **Composed matchers:** Combine other matchers using logical operators like `AllOf()`, `AnyOf()`, or `Not()`.
- **Custom matchers:** Define new matchers to verify properties not covered by built-ins.

### Assertions
GoogleTest assertions (`EXPECT_*`, `ASSERT_*`) check conditions inside tests and provide clear failure messages. Custom assertions combine matchers with assertion macros like `EXPECT_THAT()` to provide domain-specific checks.

---

## Defining Custom Matchers

GoogleMock offers multiple ways to write your own matchers, ranging from simple macros to full-fledged classes. The goal is to give precise control over matching logic and failure message formatting.

### 1. Using Matcher Macros `MATCHER` and `MATCHER_P`

For most cases, `MATCHER` and parameterized `MATCHER_P` macros let you define simple and expressive matchers easily.

```cpp
#include <gmock/gmock.h>

// Simple matcher checking divisibility by 7
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

// Parameterized matcher checking absolute value
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}
```

#### Usage Examples

```cpp
EXPECT_CALL(mock_obj, Func(IsDivisibleBy7()));
EXPECT_THAT(value, HasAbsoluteValue(10));
```

#### Enhancing Error Messages

Inside the matcher body, you can write to `*result_listener` to provide extra context on failures.

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```


### 2. Defining Custom Matcher Classes

For more complex logic or reusable infrastructure, implement a matcher class yourself. Your class must provide:

- `bool MatchAndExplain(const T& value, std::ostream* listener) const` — tests the value and optionally writes explanations.
- `void DescribeTo(std::ostream* os) const` — prints the positive description.
- `void DescribeNegationTo(std::ostream* os) const` — prints the negative description.

Example of a matcher class:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;  // Marker for GoogleMock

  explicit BarPlusBazEqMatcher(int expected_sum) : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /*listener*/) const {
    return (foo.bar() + foo.baz()) == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  const int expected_sum_;
};

// Factory function for convenient usage
::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return ::testing::Matcher<const Foo&>(new ::testing::internal::Matchers::Impl<BarPlusBazEqMatcher>(BarPlusBazEqMatcher(expected_sum)));
}
```


### 3. Polymorphic Matchers

Your custom matcher class can be templated (or use a templated `MatchAndExplain` method) to support matching multiple argument types seamlessly, much like built-in polymorphic matchers such as `Eq()` and `NotNull()`.

Example:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const {
    return p != nullptr;
  }

  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

inline ::testing::PolymorphicMatcher<NotNullMatcher> NotNull() {
  return ::testing::MakePolymorphicMatcher(NotNullMatcher());
}
```

---

## Using Predicates as Matchers

If your matching logic can be expressed as a unary predicate function or functor (that returns something convertible to bool), wrap it with `Truly()`.

```cpp
bool IsEven(int n) { return (n % 2) == 0; }
EXPECT_CALL(mock_obj, Func(Truly(IsEven)));
```

This allows quick extension without writing full matcher classes.

---

## Composing Matchers

Use combinators like `AllOf()`, `AnyOf()`, and `Not()` to compose matchers logically.

```cpp
EXPECT_CALL(mock, Func(AllOf(Gt(5), Lt(10))));
EXPECT_CALL(mock, Func(Not(HasSubstr("bad"))));
```

You can also match multiple arguments as a group using the `.With()` clause with tuple matchers.

---

## Tips for Writing Effective Custom Matchers

- **Be pure:** Matchers must be deterministic and free of side-effects.
- **Write clear messages:** Use `DescribeTo()` and `DescribeNegationTo()` to provide easy-to-understand test failure summaries.
- **Reuse matchers:** Assign complex matchers to variables to improve readability.
- **Test your matcher:** Write dedicated tests to validate your matcher produces correct matches and failure messages.

---

## Creating Custom Assertions Using Matchers

To define user-friendly assertions, combine your custom matcher with GoogleTest’s assertion macros:

```cpp
#define EXPECT_FOO_EQ(val, expected) \
  EXPECT_THAT(val, FooEquals(expected))

// Usage
EXPECT_FOO_EQ(actualFoo, expectedFoo);
```

This approach integrates good diagnostics and failure messages while keeping test code clean.

---

## Troubleshooting Common Issues

- **Matcher not triggering:** Ensure your `MatchAndExplain()` returns correct bool and respects const correctness.
- **Poor error messages:** Implement `DescribeTo()` and stream details to the result listener for helpful diagnostics.
- **Compiling errors with templates:** Verify the matcher class template signatures and usage.


---

## Summary

User-defined assertions and matchers empower you to make your tests more expressive, maintainable, and aligned with your domain concepts. Whether employing simple macros or custom matcher classes, GoogleMock provides flexible APIs and conventions to extend its capability elegantly.

For comprehensive recipes and examples, consult the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers) and explore the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html).

---

## See Also

- [gMock Cookbook: Writing New Matchers](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers)
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [GoogleTest Assertions Reference](../core-testing-apis/assertions-expectations.md)


---

*This page is part of GoogleTest's Concepts Guide focused on customizing and extending the framework with user-defined assertions and matchers.*
