---
title: "Value and Type Parameterized Tests"
description: "Understand GoogleTestâ€™s support for value-parameterized and type-parameterized tests, empowering you to write flexible and reusable tests that automatically iterate over multiple data sets or types."
---

# Value and Type Parameterized Tests

GoogleTest empowers C++ developers to write flexible and reusable tests through **value-parameterized** and **type-parameterized** tests. These testing patterns allow a single test logic to be automatically executed multiple times with varying data sets or types, streamlining coverage and reducing duplication.

---

## 1. Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic repeatedly with different input values, enabling thorough data-driven testing without redundant code.

### How Value-Parameterized Tests Work

1. **Define a Test Fixture**: Create a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type. This class can hold shared test resources and helper functions.

2. **Write Tests with `TEST_P` Macro**: Define one or more parameterized tests in the fixture using the `TEST_P` macro. Within the test body, access the parameter using `GetParam()`.

3. **Instantiate Test Suites**: Use `INSTANTIATE_TEST_SUITE_P` to provide actual parameter values or ranges that GoogleTest will iterate over.

### Example: Simple String Parameter Test

```cpp
class FooTest : public testing::TestWithParam<std::string> {};

TEST_P(FooTest, WorksWithParam) {
  const std::string& param = GetParam();
  EXPECT_FALSE(param.empty());
}

INSTANTIATE_TEST_SUITE_P(
    StringVariants, FooTest,
    testing::Values("hello", "world", "parameterized"));
```

This example creates three tests running the same logic but with three string parameters.

### Parameter Generators

GoogleTest provides various built-in generators to specify test inputs:

| Generator           | Description                                                   |
|---------------------|---------------------------------------------------------------|
| `Values(v1, v2, ...)` | Explicitly enumerated parameter values                      |
| `ValuesIn(container)` | Parameters sourced from an array or container               |
| `Range(begin, end[, step])` | Generates values sequentially in a range (end excluded)     |
| `Bool()`            | Yields `false` and `true`                                     |
| `Combine(...)`      | Produces Cartesian product of multiple generators as tuples |

### Instantiation Details

- The prefix in `INSTANTIATE_TEST_SUITE_P(prefix, Fixture, generator)` uniquely names each instantiation batch.
- Test names reflect both the instantiation prefix and parameter index, e.g., `prefix/Fixture.TestName/0`.

### Customizing Parameter Test Names

To make parameterized test names readable and meaningful, provide a **name generator** functor or lambda as the last argument to `INSTANTIATE_TEST_SUITE_P`. It receives a `TestParamInfo<T>` and returns an ASCII alphanumeric test name suffix.

```cpp
INSTANTIATE_TEST_SUITE_P(MyInst, FooTest,
                         testing::Values("a", "b"),
                         [](const testing::TestParamInfo<std::string>& info) {
                           return info.param == "a" ? "Alpha" : "Beta";
                         });
```

### Abstracting Value-Parameterized Tests

You can define value-parameterized tests in headers or libraries and instantiate them elsewhere. This approach supports creating *abstract tests* reusable across projects or implementations.

---

## 2. Typed Tests

Typed tests allow you to write test logic once and repeat it across a known list of types, useful for verifying that multiple types conform to the same interface or behavior.

### How Typed Tests Work

1. **Define a Fixture Template**: Create a fixture class template parameterized by a type `T`, deriving from `testing::Test`.

2. **Associate Type List**: Define a type list using `testing::Types<...>` for the desired types.

3. **Declare Typed Test Suite**: Use `TYPED_TEST_SUITE(Fixture, Types)` to associate the types.

4. **Write Tests with `TYPED_TEST`**: Define tests referring to the type as `TypeParam` inside the fixture.

### Example: Typed Test for Containers

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container_;
};

using MyTypes = testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, MyTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}
```

GoogleTest will run this test twice: once for `std::vector<int>`, once for `std::list<int>`.

### Customizing Typed Test Names

You can provide a **name generator class** with a `template <typename T> static std::string GetName(int)` static method as a third argument to `TYPED_TEST_SUITE` for more descriptive type names.

---

## 3. Type-Parameterized Tests

Type-parameterized tests extend typed tests by allowing you to define reusable, *abstract* test patterns for types, with multiple instantiation points. This enables libraries or frameworks to offer generalized tests that client code can instantiate with their types.

### How Type-Parameterized Tests Work

1. **Define a Fixture Template**: Like typed tests, define a fixture template derived from `testing::Test`.

2. **Declare Pattern with `TYPED_TEST_SUITE_P`**: Specify that this fixture will be used for type-parameterized testing.

3. **Define Tests with `TYPED_TEST_P`**: Define tests inside this pattern suite.

4. **Register Tests with `REGISTER_TYPED_TEST_SUITE_P`**: Register test names used in the pattern.

5. **Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`**: Instantiate the pattern with concrete type lists.

### Example: Type-Parameterized Abstract Test

```cpp
template <typename T>
class MyAbstractTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyAbstractTest);

TYPED_TEST_P(MyAbstractTest, TestFeature) {
  TypeParam value{};
  EXPECT_EQ(value, value);
}

REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, TestFeature);

using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyAbstractTest, MyTypes);
```

### Notes on Type-Parameterized Tests

- You can instantiate the same pattern with different type lists in different translation units.
- This pattern supports scalable and maintainable generic interface testing.

---

## 4. Best Practices and Tips

- **Use `GetParam()` carefully**: Access parameters only within `TEST_P` bodies or fixtures.
- **Avoid underscored names**: Test suite and test names should not contain underscores.
- **Name parameterized tests meaningfully**: Use name generators for clarity in reports.
- **Register all type-parameterized tests**: Forgetting `REGISTER_TYPED_TEST_SUITE_P` causes tests not to run.
- **Mark uninstantiated parameterized tests explicitly**: Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress spurious failures when appropriate.

---

## 5. How GoogleTest Generates and Runs Parameterized Tests

GoogleTest dynamically generates individual test instances from your value or type parameter sets during initialization:

1. For each parameter or type, GoogleTest creates a unique test case with parameters bound.
2. Individual instances run isolated test bodies, reporting results clearly with parameter suffixes.
3. Tests respecting setup/teardown run independently, enabling clean state between parameter runs.

This automation enables concise, scalable coverage of complex inputs or type-sets.

---

## 6. Troubleshooting Common Issues

- **Tests do not run despite being defined**: Ensure that `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` is invoked; otherwise, tests are not instantiated.
- **Duplicate test names in parameterized tests**: Custom name generators must produce unique, valid test names.
- **Compiling errors with parameterized fixtures**: Verify that if you define `SetUpTestSuite()` or `TearDownTestSuite()`, they are declared `public` to comply with `TEST_P` requirements.
- **Mixing `TEST` and `TEST_F` or test fixture mismatches** cause runtime errors; maintain consistent fixture use within a test suite.

---

## 7. Summary

Value and type parameterized tests in GoogleTest offer powerful patterns to increase test coverage efficiently by automating repetitive test instantiations with different values or types. Understanding and applying these concepts helps build robust, maintainable C++ test suites adaptable to complex scenarios.

---

### Additional Resources

- [Value-Parameterized Tests (Advanced Guide)](../advanced.md#value-parameterized-tests)
- [Typed and Type-Parameterized Tests (Advanced Guide)](../advanced.md#typed-tests)
- [Test Macros and Fixtures (API Reference)](/api-reference/core-testing-api/test-macros-and-fixtures)
- [Testing Reference: Parameterized and Typed Tests](/api-reference/core-testing-api/parameterized-and-typed-tests)
- Sample tests in googletest repository: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) and [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)

---

<AccordionGroup title="Code Example: Value-Parameterized Test">
<Accordion title="Complete Example">
```cpp
// Define a parameterized test fixture.
class MyValueParamTest : public testing::TestWithParam<int> {};

// Write tests referring to GetParam().
TEST_P(MyValueParamTest, IsGreaterThanZero) {
  EXPECT_GT(GetParam(), 0);
}

// Instantiate tests with multiple values.
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, MyValueParamTest,
    testing::Values(1, 2, 3, 5, 8));
```
</Accordion>
</AccordionGroup>

<AccordionGroup title="Code Example: Typed Test">
<Accordion title="Complete Example">
```cpp
// Define a typed test fixture template.
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_ = T();
};

// Create a type list.
using TestTypes = testing::Types<int, double, bool>;

// Associate the types with the test suite.
TYPED_TEST_SUITE(MyTypedTest, TestTypes);

// Write typed tests using TypeParam.
TYPED_TEST(MyTypedTest, DefaultValueIsZero) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```
</Accordion>
</AccordionGroup>

<AccordionGroup title="Code Example: Type-Parameterized (Pattern) Test">
<Accordion title="Complete Example">
```cpp
// Define a type-parameterized fixture template.
template <typename T>
class MyAbstractTest : public testing::Test {};

// Declare the pattern.
TYPED_TEST_SUITE_P(MyAbstractTest);

// Define tests.
TYPED_TEST_P(MyAbstractTest, TypeSupportsDefaultConstructor) {
  TypeParam value{};
  (void)value;  // Silence unused warning.
}

// Register tests.
REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, TypeSupportsDefaultConstructor);

// Instantiate with concrete types.
using MyTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyAbstractTest, MyTypes);
```
</Accordion>
</AccordionGroup>

<Callout>
Note: Use the appropriate macro (`TEST_P`, `TYPED_TEST`, or `TYPED_TEST_P`) relevant for your parameterization style.
</Callout>
