---
title: "Mocking: Philosophy and Core Techniques"
description: "Discover the philosophy behind mocking in GoogleMock, including why and when to use mocks, how mock objects facilitate isolation, and the distinction between fake and real implementations in tests."
---

# Mocking: Philosophy and Core Techniques

## Understanding Mocking

Mocking plays a pivotal role in unit testing by enabling you to isolate the code under test from its dependencies. It allows you to verify not only the *state* produced by your code but also the *interactions* it has with other components. This is especially useful when real dependencies are impractical, unreliable, or slow in tests.

### Why Use Mocks?

Imagine you are building a graphics program that issues drawing commands to a system API. Testing it by rendering graphics and comparing images is expensive, brittle, and often platform-dependent. The better approach is to define an interface, such as a `Turtle` interface that abstracts drawing commands. You then provide:

- A **real implementation** for your production code.
- A **mock implementation** in tests that records and verifies the expected interactions.

This separation brings multiple benefits:

- Tests become *fast* since they don’t depend on actual rendering or hardware.
- Tests become *predictable* and *robust* against environmental differences (e.g., graphics cards).
- Tests become *expressive*, with expected interactions clearly stated in code.

## Core Concepts

### What Is a Mock Object?

- A mock object implements the same interface as a real object but is programmed with *expectations* about how it will be used.
  - Which methods will be called.
  - How many times.
  - With what arguments.
  - What results or side effects should occur.

Mocks help check the *interaction* between your code and its collaborators, as opposed to just the end state.

### Mocks vs Fakes

It’s important to distinguish mocks from fakes:

| Aspect         | Fake Object                                            | Mock Object                                             |
|----------------|--------------------------------------------------------|---------------------------------------------------------|
| Implementation | Working implementation, often simplified or in-memory  | Programmed with *expectations* and behavior specifications |
| Use            | Substitute for real object with some behavior          | Verification of interactions: method calls, parameters, call sequences |

An example fake might be an in-memory file system. The mock of the same file system interface records access and verifies correct usage.

## The Mocking Workflow

1. **Define the Interface and Mock Class**
    - Define a pure virtual interface representing your dependency.
    - Use GoogleMock’s `MOCK_METHOD()` macro to generate mock methods in a derived class.

2. **Create Mock Objects in Tests**
    - Instantiate mock objects.
    - Use `EXPECT_CALL()` to specify expected method calls and behaviors.

3. **Exercise the Code Under Test**
    - Inject or otherwise provide the mock to the code being tested.
    - Run functionality.

4. **Verify Expectations Automatically**
    - GoogleMock verifies at destruction that all expectations were met.
    - Failures occur immediately if expectations are violated.

### Example: Mocking a Turtle Interface

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual void GoTo(int x, int y) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};

TEST(PainterTest, DrawsCircle) {
  MockTurtle turtle;
  EXPECT_CALL(turtle, PenDown()).Times(::testing::AtLeast(1));

  Painter painter(&turtle);
  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));
}
```

With this, the test confirms that `PenDown()` is called at least once during the drawing of a circle.

## Setting Expectations with `EXPECT_CALL`

Expectations form the contract your test demands. They include:

- **Matchers:** Specify what argument values are expected.
- **Cardinalities:** Specify how often a method should be called.
- **Actions:** Specify what should happen when a method is invoked.
- **Ordering:** (optional) Specify the order of calls.

### Syntax Overview

```cpp
EXPECT_CALL(mock_object, Method(matchers...))
    .With(multi_argument_matcher)  // Optional
    .Times(cardinality)            // Optional
    .InSequence(sequences...)      // Optional
    .After(expectations...)        // Optional
    .WillOnce(action)              // Optional, repeatable
    .WillRepeatedly(action)        // Optional
    .RetiresOnSaturation();        // Optional
```

### Matchers: Argument Expectations

- Specify what argument values the method is expected to receive.
- Use `_` to indicate "match anything".
- Use built-in matchers like `Eq()`, `Ge()`, `NotNull()`, or compose your own.

```cpp
EXPECT_CALL(turtle, Forward(100));          // Exactly 100
EXPECT_CALL(turtle, GoTo(50, _));            // x == 50, y anything
EXPECT_CALL(turtle, Turn(::testing::Ge(90))); // Turn by at least 90 degrees
```

### Cardinalities: Call Counts

Control how many times the call is expected.

| Cardinality      | Meaning                           |
|------------------|---------------------------------|
| `AnyNumber()`     | Any number of times              |
| `AtLeast(n)`     | At least n times                 |
| `AtMost(n)`      | At most n times                  |
| `Between(m, n)`  | Between m and n times (inclusive)|
| `Exactly(n)` or n | Exactly n times                  |

For example:

```cpp
EXPECT_CALL(foo, Bar()).Times(Exactly(3));
EXPECT_CALL(foo, Baz(_)).Times(AtLeast(1));
```

If omitted, gMock infers the cardinality based on action clauses (`WillOnce`, `WillRepeatedly`).

### Actions: Define Behavior

Specify what the mock will do when called.

- `WillOnce(Return(value))` - specifies the response for one call.
- `WillRepeatedly(Return(value))` - response for all subsequent calls.
- Actions can be lambdas, functions, or built-in helpers.

```cpp
EXPECT_CALL(turtle, GetX())
    .WillOnce(Return(100))
    .WillOnce(Return(200))
    .WillRepeatedly(Return(300));
```

### Call Ordering

- Use `InSequence` to enforce strict sequential call order.

```cpp
{
  InSequence seq;
  EXPECT_CALL(foo, FirstCall());
  EXPECT_CALL(foo, SecondCall());
}
```

- Use `After()` and multiple `Sequence`s to specify partial ordering.

### Retiring Expectations

- `.RetiresOnSaturation()` indicates that expectation becomes inactive after it's been satisfied.

### Common Pitfalls

- Set expectations *before* exercising the mock.
- Avoid overly strict matchers which make tests fragile.
- Remember that newer expectations override older ones if applicable.

## Default Behaviors with `ON_CALL`

- `ON_CALL` sets what a mock method does when called but **does not set any expectation** on whether it must be called.
- Useful to specify default behavior for uninteresting calls.
- Syntax similar to `EXPECT_CALL`, but must end with a `.WillByDefault()` clause.

```cpp
ON_CALL(mock_object, Method(matchers...))
    .With(multi_argument_matcher)  // Optional
    .WillByDefault(action);         // Required
```

## Strictness Modes: NiceMock, NaggyMock, and StrictMock

GoogleMock provides wrappers to control the behavior regarding uninteresting calls:

- **NiceMock<T>**: Suppresses warnings on uninteresting calls. Recommended for most tests.
- **NaggyMock<T>**: Prints warnings for uninteresting calls. This is the current default.
- **StrictMock<T>**: Treats uninteresting calls as errors.

They are subclasses of your mock class and forward all method calls.

```cpp
NiceMock<MockFoo> nice_mock;
NaggyMock<MockFoo> naggy_mock;
StrictMock<MockFoo> strict_mock;
```

Be cautious with strictness; overly strict mocks can cause brittle tests.

## Summary

Effective use of mocking in GoogleMock unlocks powerful testing capabilities:

- Isolate units by replacing real dependencies with mocks.
- Define **precise expectations** on interactions with dependencies.
- Maintain **fast, robust, and maintainable** tests.
- Leverage default behaviors and strictness wrappers to tune test feedback.

By following the philosophy and techniques outlined, you design tests that verify the *contract* of your code, not its implementation details, enabling confidence and agility in development.

---

## Additional Resources

- [GoogleMock for Dummies](gmock_for_dummies.md): Beginner-friendly tutorial and concepts.
- [Mocking Reference](reference/mocking.md): Detailed API guidance.
- [gMock Cookbook](gmock_cook_book.md): Practical recipes and advanced patterns.
- [Strictness Modes](reference/mocking.md#StrictMock): Details on `NiceMock`, `NaggyMock`, and `StrictMock`.
