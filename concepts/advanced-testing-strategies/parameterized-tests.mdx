---
title: "Parameterized and Typed Tests"
description: "Master the use of value- and type-parameterized tests to cover a wide range of input spaces or data types efficiently. Understand the patterns for defining, instantiating, and customizing these test forms."
---

# Parameterized and Typed Tests

Master the use of value- and type-parameterized tests to cover a wide range of input spaces or data types efficiently. Understand the patterns for defining, instantiating, and customizing these test forms.

---

## Introduction

Parameterized and typed tests in GoogleTest enable you to write test code once and execute it multiple times with different inputs or types. This powerful technique eliminates repetitive code, improves test coverage by exercising various scenarios, and keeps your test suites concise and maintainable.

This guide will take you through the core concepts of value-parameterized tests and typed/type-parameterized testsâ€”explaining how to define, instantiate, and customize them effectively.

---

## Value-Parameterized Tests

Value-parameterized tests let you run the same test logic with different data values, each treated as a separate test instance.

### Defining a Value-Parameterized Test

1. **Create a Test Fixture Class**: Derive your fixture from `::testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // You can add helpers or shared setup here.
};
```

2. **Define Parameterized Tests**: Use `TEST_P` instead of `TEST` or `TEST_F`. Access the parameter inside the test body via the `GetParam()` method.

```cpp
TEST_P(MyValueTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

3. **Instantiate the Test Suite**: Use `INSTANTIATE_TEST_SUITE_P` to provide the parameter values using a generator such as `Values`, `Range`, or `Combine`.

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyValueTest, Values(2, 4, 6, 8));
```

This results in separate tests for each parameter, e.g., `EvenNumbers/MyValueTest.IsEven/0`, `.../1`, etc.

### Parameter Generators

GoogleTest provides versatile generators:

| Generator           | Description                                                                                          |
|---------------------|--------------------------------------------------------------------------------------------------|
| `Values(v1, ..., vN)`     | Generates the exact values supplied.                                                             |
| `Range(begin, end [, step])` | Generates values starting at `begin`, stepping by `step` (default 1), up to but excluding `end`. |
| `ValuesIn(container or iterators)` | Generates values from arrays, STL containers, or iterator ranges.                             |
| `Bool()`              | Generates the Boolean values `false` and `true`.                                                 |
| `Combine(g1, g2, ..., gN)` | Produces the Cartesian product (all combinations) of multiple parameter generators.               |

### Example: Using Multiple Parameter Generators

```cpp
class FlagTest : public ::testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(FlagTest, HandlesFlags) {
  int number;
  bool flag;
  std::tie(number, flag) = GetParam();
  // test logic here
}

INSTANTIATE_TEST_SUITE_P(
  AllCombinations,
  FlagTest,
  Combine(Range(0, 3), Bool())  // (0, false), (0, true), (1, false), etc.
);
```

### Customizing Test Names

By default, instantiations append indices to the test names (e.g., `/0`, `/1`). You can provide a custom naming function to generate more meaningful suffixes:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyValueTest, Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "ValueIs" + std::to_string(info.param);
    });
```

This helps produce test names like `CustomNames/MyValueTest.IsEven.ValueIs1`.

### When to Use Value-Parameterized Tests

- When you want to test the same behavior with varying data input values.
- When the parameter type is copyable.

---

## Typed Tests and Type-Parameterized Tests

Typed tests focus on running the same tests over different **types** rather than runtime values. This is invaluable when verifying parts of a generic library or interface.

### Typed Tests

These tests require that you know all types upfront.

1. **Define a Fixture Template**:

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T value_;
};
```

2. **Define Type List and Associate It**:

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, MyTypes);
```

3. **Define Typed Tests with `TYPED_TEST`**:

Inside the test body, `TypeParam` refers to the current type.

```cpp
TYPED_TEST(NumericTest, IsZeroInitially) {
  TypeParam value = this->value_;
  EXPECT_EQ(value, TypeParam());  // default constructs to zero
}
```

Each test is instantiated and run for all types in `MyTypes`.

### Type-Parameterized Tests (Type-Parameterized Test Suites)

These are abstract test suites where the test patterns are defined once and instantiated later across multiple translation units or with types unknown at test definition time.

1. **Declare Type-Parameterized Test Suite** with `TYPED_TEST_SUITE_P`.
2. **Define Tests with `TYPED_TEST_P`**.
3. **Register Tests with `REGISTER_TYPED_TEST_SUITE_P`**.
4. **Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`**, providing types to instantiate with.

Example:

```cpp
template <typename T>
class AbstractTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(AbstractTest);

TYPED_TEST_P(AbstractTest, Test1) {
  TypeParam val = TypeParam();
  // test logic
}

TYPED_TEST_P(AbstractTest, Test2) {
  // test logic
}

REGISTER_TYPED_TEST_SUITE_P(AbstractTest, Test1, Test2);

using MyTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, AbstractTest, MyTypes);
```

### When to Use Typed vs Type-Parameterized Tests

- Use **typed tests** when the types are known at test definition time and are fixed.
- Use **type-parameterized tests** to create reusable abstract test patterns instantiated with different types later, potentially in different translation units.

---

## Best Practices and Practical Tips

- **Choose parameter types wisely:** Ensure your parameter types are copyable and manageable across tests.
- **Use descriptive instantiation names:** Provide meaningful prefixes with `INSTANTIATE_*` macros to keep test reports understandable.
- **Leverage `Combine()` for exhaustive coverage:** Use for testing multiple parameters combinationally without manually listing all combinations.
- **Custom test names improve clarity:** Avoid default numeric suffixes when parameters or types are non-trivial.
- **Isolate side effects:** Each test instance runs independently with its own fixture object, ensuring no shared mutable state causes flakiness.
- **Watch for parameter evaluation timing:** Parameter values and generators are evaluated inside `InitGoogleTest()`, allowing for dynamic adjustments before running tests.

---

## Troubleshooting

<AccordionGroup title="Common Issues with Parameterized and Typed Tests">
<Accordion title="Tests Not Instantiating or Running">
Check that `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` macros are correctly used and linked in your build. Without instantiation, the tests won't be registered or executed.
</Accordion>
<Accordion title="Custom Test Names Not Displaying as Expected">
Ensure your custom name generator returns valid strings containing only alphanumeric characters and underscores. Invalid characters will cause the framework to fall back to numeric suffixes.
</Accordion>
<Accordion title="Parameters of Incompatible Types Causing Compilation Errors">
Use `ConvertGenerator` to convert the generated parameters to the required type explicitly when implicit conversion isn't possible.
</Accordion>
<Accordion title="Tests Skipping During Filtering or Sharding">
Verify your filter expressions and sharding configuration in your environment. Parameterized test names depend on instantiation prefixes, so filtering must match correctly.
</Accordion>
</AccordionGroup>

---

## Summary

Parameterized and typed tests empower you to cover broad testing scenarios across multiple values or types without duplicating code. By mastering `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST`, and `TYPED_TEST_P` patterns, you gain flexibility and scalability, ensuring robust test suites that are easier to maintain and extend.

---

## Further Reading and Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed and Type-Parameterized Tests](../advanced.md#typed-tests-and-type-parameterized-tests)
- [Test Macros and Test Suites](../api-reference/core-testing-apis/test-macros-suites.md)
- [Assertion Reference](../api-reference/core-testing-apis/assertions-results.md)
- [Mocking Introduction](../guides/mocking-patterns/introduction-to-mocking.md)
- [GoogleTest Primer](../docs/primer.md)

---

This page is part of the [Core Testing Workflows](../guides/core-workflows/parameterized-typed-tests.md) guide group and relates closely to [Test Discovery and Lifecycle](../concepts/core-testing-models/test-discovery-lifecycle.md) and [xUnit Architecture](../concepts/core-testing-models/xunit-architecture.md).
