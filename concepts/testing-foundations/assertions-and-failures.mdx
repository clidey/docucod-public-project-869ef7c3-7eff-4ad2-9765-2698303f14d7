---
title: "Assertions and Failure Handling"
description: "Understand how assertions form the backbone of GoogleTest, differentiating between fatal and non-fatal failures. Learn why GoogleTest's assertion philosophy emphasizes clear, actionable output and minimizes test flakiness. Distinguish between built-in and user-defined assertions at the core of test expressiveness."
---

# Assertions and Failure Handling in GoogleTest

In GoogleTest, assertions lie at the heart of writing effective and reliable tests. They are the fundamental checks that verify whether your code behaves correctly. This page explains how GoogleTest's assertion system works, emphasizing the distinction between fatal and non-fatal failures, the philosophy behind assertion design, and the role of both built-in and user-defined assertions in expressing test intent clearly.

---

## 1. The Backbone: Assertions in GoogleTest

GoogleTest provides a rich set of assertion macros that you use to confirm expected conditions in your tests. These assertions powerfully indicate success or failure by validating conditions related to expressions, equality, exceptions, regular expressions, and more.

Assertions are split mostly into two categories based on their impact when they fail:

- **Fatal Assertions (`ASSERT_*`)**: These abort the current function immediately upon failure, preventing further execution within the test. They ensure no subsequent test code runs once a critical failure occurs.

- **Non-Fatal Assertions (`EXPECT_*`)**: These report failures but allow the test to continue executing. This lets you check multiple conditions within a test, highlighting all issues rather than stopping at the first.

:::note
Fatal assertions can only be used in functions that return `void`. Attempting to use them in functions with other return types will result in confusing compiler errors. Use non-fatal assertions or refactor your code to comply. Additionally, fatal assertions cannot be used in constructors or destructors; consider placing such checks in `SetUp()` or `TearDown()` instead.
:::

---

## 2. Understanding Failures: Fatal vs Non-Fatal

The difference between fatal and non-fatal failures is crucial for controlling test flow and diagnosing problems:

- **Fatal Failure**:
  - Immediately aborts the current function, usually a test or helper method.
  - Prevents execution of any code following the failure.
  - Helps contain failures early so subsequent code (dependent on success) doesnâ€™t cause misleading crashes.

- **Non-Fatal Failure**:
  - Reports a failure but continues executing the rest of the test function.
  - Supports multiple condition checks in one test, improving test thoroughness.

### Why This Distinction Matters

By aborting a function but not the entire test program, GoogleTest avoids exceptions while giving tests a controlled way to stop once a critical problem emerges.

This separation helps you decide **when to fail fast to avoid crashes or undefined behavior** and **when to continue to gather more debugging information**.

---

## 3. GoogleTest's Assertion Philosophy

GoogleTest is designed with the user in mind, focusing on **clear, actionable output** and minimizing test flakiness.

### Key Principles:

- **Clear Output**: Failure messages always include the actual and expected values when possible. This drastically improves debuggability.

- **Minimal Flakiness**: By separating fatal and non-fatal assertions and carefully controlling failure propagation, GoogleTest helps prevent fragile tests that fail unpredictably.

- **Extensibility**: Beyond built-in assertions, users can craft custom assertions that provide detailed and meaningful messages tailored to their testing needs.

- **Fine-grained Control**: GoogleTest offers predicates and predicate-format assertions to improve error messages when validating complex conditions.

---

## 4. Built-in Assertions: Expressiveness at Your Fingertips

GoogleTest supplies macros to validate common scenarios, supporting a broad range of testing needs.

### Categories of Built-in Assertions:

- **Boolean Conditions**: `EXPECT_TRUE`, `ASSERT_FALSE`, etc.
- **Binary Comparisons**: `EXPECT_EQ`, `ASSERT_NE`, `EXPECT_LT`, and others for equality and ordering.
- **String Comparisons**: Handling C strings with `EXPECT_STREQ`, `EXPECT_STRCASEEQ`, etc.
- **Floating-Point Comparisons**: Specialized macros like `EXPECT_FLOAT_EQ`, `EXPECT_NEAR` for approximate equality.
- **Exception Handling**: `EXPECT_THROW`, `EXPECT_NO_THROW`, etc. (enabled only if exceptions are supported).
- **Predicate Assertions**: `EXPECT_PRED*` and `EXPECT_PRED_FORMAT*` to use boolean predicates or predicate-format functions that provide richer failure diagnostics.
- **Death Assertions**: For tests verifying that code causes processes to terminate under specific conditions.
- **Explicit Success and Failure**: `SUCCEED()`, `FAIL()`, and `ADD_FAILURE()` to manually indicate test outcomes.

Example of expressive assertion using `EXPECT_PRED_FORMAT2` and `testing::AssertionResult` for detailed failure messages:

```cpp
// Predicate function returning detailed failure message
::testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0)
    return ::testing::AssertionSuccess() << n << " is even";
  else
    return ::testing::AssertionFailure() << n << " is odd";
}

// Usage in a test
EXPECT_TRUE(IsEven(value));
```

This approach communicates precise cause of failure directly in test output.

---

## 5. User-Defined Assertions: Enhancing Test Clarity

GoogleTest encourages you to define your own assertions and matchers to express complex verification succinctly and readably.

### Techniques:

- **Predicate Assertions**: Use functions returning `bool` or `testing::AssertionResult` to embed custom logic with informative outputs.

- **Custom Matchers**: Define matchers that integrate seamlessly with `EXPECT_THAT` and `EXPECT_CALL`.

- **Streaming Messages**: Leverage the `<<` operator to append context-rich messages to assertion failures.

### Best Practices:

- Write predicates or matchers that produce detailed explanations of failures.
- Include values and reasoning in failure messages.
- Use `SCOPED_TRACE` to add contextual traces when assertions are in helper functions.

Example with `SCOPED_TRACE`:

```cpp
TEST(MyTest, HandlesMultipleCases) {
  for (int i = 0; i < 10; ++i) {
    SCOPED_TRACE("Iteration " + std::to_string(i));
    EXPECT_TRUE(IsProcessedCorrectly(i));
  }
}
```

This adds helpful file and line number info in failures inside loops or subroutines.

---

## 6. Managing Assertion Failures in Subroutines

Assertions within helper functions present special considerations due to GoogleTest's failure propagation model.

### Common Pitfall:

`ASSERT_*` and `FAIL()` **abort only the current function**, not the entire test. If a subroutine asserts fatally, control returns to the caller, which may continue executing and cause crashes or undefined behavior.

### Solutions:

- **Use HasFatalFailure()**: Test if a fatal failure happened in a called subroutine and handle it accordingly.

```cpp
Subroutine();
if (HasFatalFailure()) return;
// Safe to continue
```

- **Wrap Subroutines in EXPECT_NO_FATAL_FAILURE / ASSERT_NO_FATAL_FAILURE**: Guard calls to subroutines that may assert fatally.

```cpp
ASSERT_NO_FATAL_FAILURE(Subroutine());
```

- **Use Exceptions**: By installing a test event listener that throws on fatal failures, you propagate assertion failures as exceptions (advanced usage).

- **Avoid Fatal Assertions in non-void-returning functions**, or refactor those functions to return void to use fatal assertions safely.

---

## 7. Skipping Tests at Runtime

Sometimes test execution must be conditionally skipped due to unmet preconditions or runtime environment constraints.

GoogleTest provides the `GTEST_SKIP()` macro to skip a single test or all tests in a fixture cleanly.

```cpp
TEST(Foo, SkipExample) {
  if (!FeatureAvailable()) {
    GTEST_SKIP() << "Skipping because feature is unavailable.";
  }
  // Test code
}
```

Tests skipped with `GTEST_SKIP()` do not report failures.

---

## 8. Teaching GoogleTest How to Print Your Types

Useful failure messages depend on printable values. GoogleTest knows how to print standard types and many STL containers automatically.

If your type is not printed meaningfully, you can customize output:

- **Define `AbslStringify()` overload** in the same namespace for your type to provide formatted string output.

- **Define `PrintTo()` friend function**  to stream your type, used as a fallback or for testing-specific messages.

Example:

```cpp
namespace my_namespace {

class Point {
  int x, y;
  friend void PrintTo(const Point& p, std::ostream* os) {
    *os << '(' << p.x << ", " << p.y << ')';
  }
};

}
```

You can always use `::testing::PrintToString(value)` to get a string representation of a value.

---

## 9. Common Failure and Troubleshooting Patterns

GoogleTest failure messages contain rich information about:

- What was expected vs. actual
- The file and line number
- The failure type (fatal/non-fatal)
- User-provided messages

### Troubleshooting Tips:

- Check for missing or incorrect assertions.
- Use verbose output and `--gtest_break_on_failure` to facilitate debugging.
- Use `SCOPED_TRACE` to identify failures in helper functions or loops.
- For flakiness, try `--gtest_repeat=N` to reproduce intermittent failures.

### Propagating Failures Correctly

Remember to understand how fatal failures propagate. Subroutine assertions do not halt the entire test by default.

Use the strategies in section 6 to write robust test helpers.

---

## 10. Summary

GoogleTest's assertion and failure handling system:

- Provides a rich and expressive capability for verifying code correctness.
- Separates fatal and non-fatal failures to give fine-grained control over test execution.
- Encourages clear, informative failure messages with customizable output of values.
- Supports advanced features like predicate assertions, skipping tests, and user-defined assertions.
- Gives best practices for writing resilient tests and managing assertion flow, especially in helpers and subroutines.

Mastering assertions is essential to crafting effective tests that immediately report meaningful failures and minimize wasted debugging time.

---

## Related Documentation

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) for getting started with writing tests
- [Assertions API Reference](/api-reference/core-assertions-matchers/assertions-reference) for the full list of assertion macros
- [Matchers API Reference](/api-reference/core-assertions-matchers/matchers-reference) for detailed matcher usage
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for advanced mocking, including related assertion techniques
- [Advanced Topics](docs/advanced.md) in GoogleTest for deep dives into custom assertions, predicate assertions, and failure handling

---

## Practical Tips

- Use `EXPECT_*` assertions when it is valuable to check multiple conditions in one test.
- Use `ASSERT_*` assertions to fail fast on critical checks where continuing would cause crashes.
- When writing predicate assertions, prefer returning `AssertionResult` over raw `bool` to get richer failure output.
- Avoid fatal assertions in constructors or destructors.
- Use `SCOPED_TRACE` to add context to assertions inside helper functions and loops.
- Use `GTEST_SKIP()` to skip tests when runtime prerequisites are not met.


---

**Example: Detecting Even Numbers with Detailed Failure**

```cpp
// A predicate function returning AssertionResult for clear error messages.
testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0) {
    return testing::AssertionSuccess() << n << " is even";
  } else {
    return testing::AssertionFailure() << n << " is odd";
  }
}

TEST(NumberTest, EvenCheck) {
  EXPECT_TRUE(IsEven(5));  // Fails with detailed message: "5 is odd"
  EXPECT_TRUE(IsEven(6));  // Succeeds
}
```


---

This structured, user-focused approach to assertions and failure management empowers you to write tests that are not only robust and maintainable but also precision tools for debugging and verifying your code.