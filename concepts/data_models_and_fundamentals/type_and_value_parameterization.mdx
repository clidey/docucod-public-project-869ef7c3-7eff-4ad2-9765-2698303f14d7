---
title: "Type & Value Parameterization"
description: "Introduces value-parameterized and type-parameterized test models. Explains their purpose for combinatorial and generic testing, and how test instantiation is coordinated behind the scenes."
---

# Type & Value Parameterization

GoogleTest offers powerful mechanisms to write more flexible and concise tests through *type* and *value parameterization*. This page introduces these two forms of parameterized test models, explaining their purposes, how they enable combinatorial and generic testing, and how test instantiation is orchestrated behind the scenes.

---

## Why Parameterized Tests?

Imagine you want to verify the behavior of a function across a range of inputs or different types without duplicating test code. Parameterized tests allow you to write a test once and run it multiple times with different inputs or type variations, increasing coverage, reducing boilerplate, and keeping tests maintainable.

Two main models exist:

- **Value-Parameterized Tests:** Run the same test logic multiple times with various *values*.
- **Type-Parameterized Tests:** Run tests on multiple *types* to validate generic templates or polymorphic behavior.

---

## Value-Parameterized Tests

### Concept & Usage

Value-parameterized tests let you provide a sequence of values as test parameters. The same test logic executes once per value, each treated as a distinct test instance.

This is ideal when you want to verify how a function or class behaves with different inputs, such as:

- Testing a sorting function with various container sizes.
- Ensuring algorithms handle boundary values correctly.

### How to Define Value-Parameterized Tests

1. **Create a Test Fixture Derived from `::testing::TestWithParam<T>`**

   Your fixture inherits from `TestWithParam<T>`, where `T` is the type of the parameter.

   ```cpp
   class FooTest : public ::testing::TestWithParam<int> {
     // Setup and helper methods
   };
   ```

2. **Write Tests Using the `TEST_P` Macro**

   Inside each `TEST_P`, `GetParam()` returns the current test parameter value.

   ```cpp
   TEST_P(FooTest, HandlesValue) {
     int value = GetParam();
     // Use 'value' to perform assertions
     EXPECT_TRUE(IsValid(value));
   }
   ```

3. **Instantiate Tests with Parameter Generators Using `INSTANTIATE_TEST_SUITE_P`**

   You provide a name prefix, the test suite name, and a parameter generator to produce the test parameters.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       IntValues,
       FooTest,
       ::testing::Values(1, 2, 3));
   ```

The above instantiates `FooTest` with values `1`, `2`, and `3`. Each parameterized test will be named uniquely incorporating the prefix and parameter index.

### Parameter Generators

GoogleTest provides several built-in generators to produce parameter sequences:

| Generator               | Produces                                                                                  | Notes                                                               |
|------------------------|-------------------------------------------------------------------------------------------|---------------------------------------------------------------------|
| `Values(v1, v2, ..., vn)`| Series of specified values `{v1, v2, ..., vn}`                                             | Simple explicit values                                               |
| `ValuesIn(container)`   | Values taken from an array, container, or iterator range                                  | Good for collections or dynamic sets                                |
| `Range(start, end [, step])` | Sequence `{start, start+step, ..., < end}`                                                  | The sequence excludes the `end` value                               |
| `Bool()`               | Boolean values `{false, true}`                                                           | Useful for testing flags                                             |
| `Combine(g1, g2, ..., gN)` | Cartesian product of multiple parameter generators                                         | Useful for combinatorial tests across multiple parameters           |

#### Example: Combining Parameters

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedTest,
    MyTestFixture,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

This generates test cases for pairs: `(1, false)`, `(1, true)`, `(2, false)`, `(2, true)`.

### Behind the Scenes: Instantiation

When GoogleTest initializes (typically in `InitGoogleTest()`), generators are evaluated to produce the full list of parameterized test instances. All tests defined by `TEST_P` within the test suite are duplicated per parameter value, each assigned a unique identifier and name for filtering and reporting.

---

## Type-Parameterized Tests

### Concept & Usage

Type-parameterized tests verify that template or generic code functions correctly for multiple types, without writing a test for each type individually.

This model is critical for template-heavy C++ code that must behave consistently across types.

### How to Define Type-Parameterized Tests

1. **Define a Fixture Template with a `typedef` Named `TypeParam` or Use `::testing::Types<Ts...>`**

```cpp
template <typename T>
class MyTypeTest : public ::testing::Test {
  // Setup that can use `TypeParam`
};
```

2. **Use the `TYPED_TEST_SUITE` Macro to Associate the Fixture with Types**

```cpp
using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypeTest, MyTypes);
```

3. **Write Tests with the `TYPED_TEST` Macro**

Inside the test body, `TypeParam` refers to the current type.

```cpp
TYPED_TEST(MyTypeTest, DoesWork) {
  TypeParam value{}; // Default initialization
  EXPECT_TRUE(IsValid(value));
}
```

Tests will be instantiated for `int`, `double`, `std::string`.

### Customizing Type Names

GoogleTest uses the type names as part of test instance names. If the type names are long or complicated, you can define a custom name generator.

---

## Coordinating Instantiation

Both value- and type-parameterized tests rely on GoogleTest creating explicit test instances at runtime initialization. This allows:

- Delayed evaluation of parameters and types
- Dynamic control and filtering of tests via the command-line
- Clear naming and reporting of parameter variants

You can instantiate any number of times with different parameter sets or type lists, each distinguished by a unique prefix in their test names.

---

## Practical Tips & Best Practices

- Always define a descriptive prefix when instantiating tests to avoid name clashes.
- Leverage `Combine` carefully to avoid exploding the test count unintentionally.
- Use `GetParam()` clearly within tests for value-parameterized tests to emphasize dependency on parameters.
- When testing templates, start with a small selection of types then expand.
- Be mindful of test execution time; avoid mixing too many parameters without weighting importance.

---

## Example Summary for Value-Parameterized Tests

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Test fixture implementation
};

TEST_P(FooTest, HandlesVariousInts) {
  int param = GetParam();
  // Assertions using param
}

INSTANTIATE_TEST_SUITE_P(
    IntRange,
    FooTest,
    ::testing::Range(1, 5));  // tests with 1,2,3,4
```

## Example Summary for Type-Parameterized Tests

```cpp
template <typename T>
class MyTemplateTest : public ::testing::Test {
  // Setup that can refer to T
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTemplateTest, MyTypes);

TYPED_TEST(MyTemplateTest, DoesSomething) {
  TypeParam value = TypeParam();
  EXPECT_TRUE(IsValid(value));
}
```

---

## Related Documentation

- [Parameterized Tests Guide](/guides/core-workflows/parameterized-tests) for comprehensive examples and best practices.
- [Defining and Using Mocks](/api-reference/mocking-and-stubbing/defining-mocks) to combine with parameterized tests.
- [Actions & Custom Return Values](/api-reference/mocking-and-stubbing/actions-and-returns) to define behaviors in mocked parameterized tests.

---

Understanding type and value parameterization empowers C++ developers using GoogleTest to create concise, powerful, and maintainable tests that cover broad test spaces efficiently, fundamentally improving test robustness and developer productivity.
