---
title: "Parameterized and Typed Testing"
description: "Survey the conceptual underpinnings of parameterized and typed testing in GoogleTest. This page explains the patterns behind running the same logic over multiple data values or types, offering strategies for maximizing testing coverage with minimal code duplication."
---

# Parameterized and Typed Testing

GoogleTest provides a powerful conceptual framework for running the same test logic repeatedly over different data values or types without duplicating code. This capability, known as parameterized and typed testing, enables you to maximize testing coverage efficiently while keeping your tests clean and maintainable.

---

## Overview

Imagine you need to verify a function works correctly for multiple inputs or ensure several implementations of an interface satisfy the same contract. Writing separate tests for each input or type quickly becomes cumbersome and error-prone. GoogleTest solves this with two complementary concepts:

- **Parameterized Tests:** Allow the same test logic to be executed over multiple values, supplied as parameters.
- **Typed Tests and Type-Parameterized Tests:** Allow the same test logic to be executed over multiple types, verifying behavior across type variations.

Both reduce code duplication while providing clear, isolated results.

---

## Parameterized Testing: Running Tests Over Multiple Values

### What Are Parameterized Tests?

Parameterized tests let you write a test once and run it multiple times with different inputs. This approach is particularly useful for data-driven tests, such as validating input-output mappings or testing flag-dependent behaviors.

### Writing Parameterized Tests

1. **Define a Test Fixture:** Derive a fixture class from `::testing::TestWithParam<T>`, where `T` is the parameter type. You can implement setup, teardown, and any helper functions here.

    ```cpp
    class FooTest : public ::testing::TestWithParam<int> {
      // Usual fixture setup
    };
    ```

2. **Write Parameterized Test Cases:** Use the `TEST_P` macro (where `_P` stands for parameterized) instead of `TEST` or `TEST_F` to define test logic referencing the parameter via `GetParam()`.

    ```cpp
    TEST_P(FooTest, ProcessesParameter) {
      int param = GetParam();
      EXPECT_TRUE(Process(param));
    }
    ```

3. **Instantiate Test Suites:** Use `INSTANTIATE_TEST_SUITE_P` to provide a set of values to run the tests against. You can use GoogleTest-provided parameter generators such as `Values()`, `Range()`, `ValuesIn()`, `Bool()`, `Combine()`, and more.

    ```cpp
    INSTANTIATE_TEST_SUITE_P(
        SampleParams, FooTest,
        ::testing::Values(1, 2, 3, 42));
    ```

### Parameter Generators

These functions produce parameter sequences for test instantiation:

| Generator         | Description                                                                          |
|-------------------|--------------------------------------------------------------------------------------|
| `Range(start, end[, step])` | Produces a sequence of values starting from `start` up to but not including `end`, optionally stepping by `step` (defaults to 1). |
| `Values(v1, v2, ..., vN)`    | Yields a fixed set of values explicitly listed.                                  |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Yields values from an array, container, or iterator range.                   |
| `Bool()`                     | Produces the boolean sequence `{false, true}`.                                  |
| `Combine(g1, g2, ..., gN)`   | Creates a Cartesian product of n generators producing tuples of all value combinations. |
| `ConvertGenerator<T>(g)`     | Converts values from a generator to another type, allowing flexible parameter types. |

### Naming Parameterized Tests

 You can supply a custom name generator function or functor to `INSTANTIATE_TEST_SUITE_P` to produce readable and unique test names based on parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest, 
    ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

**Note:** Test names must be unique and only contain alphanumeric characters; underscores are discouraged.

### Best Practices and Tips

- Use parameterized tests to efficiently cover edge cases and validate different input domains.
- Supply custom parameter name generators to improve test readability and debugging.
- Organize parameters thoughtfully to avoid long, unwieldy test outputs.
- Remember that `INSTANTIATE_TEST_SUITE_P` must be called in global or namespace scope.

---

## Typed Tests: Running Tests Over Types

### What Are Typed Tests?

Typed tests let you write test logic once but run it over a fixed list of types. This is ideal when testing several implementations of the same interface or verifying that types conform to the same behavioral contract.

### How to Write Typed Tests

1. **Define a Fixture Template:** Declare a class template fixture parameterized on a type.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_ = T();
  // Additional setup or typedefs
};
```

2. **Associate a Type List:** Use `::testing::Types<T1, T2, ...>` to define the types to test.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write Typed Test Cases:** Use `TYPED_TEST` to write tests referencing the type parameter with `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam n = this->value_;
  EXPECT_TRUE(SomeCondition(n));
}
```

### Customizing Test Names

You can provide an optional type name generator class to add custom suffixes to the test suite names, making clear and readable test names.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "Char";
    if constexpr (std::is_same_v<T, int>) return "Int";
    return "Unknown";
  }
};
TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## Type-Parameterized Tests: Defining Tests Without Knowing Types Upfront

Sometimes you want to define abstract test patterns without knowing the types ahead of time. Type-parameterized tests let you define the test logic once and instantiate it with arbitrary type lists later, even multiple times, and in multiple translation units.

### Writing Type-Parameterized Tests

1. **Define a Fixture Template:** Same as typed tests.

2. **Declare the Type-Parameterized Test Suite:** Use `TYPED_TEST_SUITE_P` to declare a suite for type-parameterized tests.

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {};
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define Type-Parameterized Tests:** Use `TYPED_TEST_P` to write tests referencing `TypeParam`.

```cpp
TYPED_TEST_P(MyTypeParamTest, BehavesAsExpected) {
  TypeParam val{};
  EXPECT_TRUE(Check(val));
}
```

4. **Register Tests:** Register all defined tests names with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, BehavesAsExpected);
```

5. **Instantiate the Tests:** In source files where the types are known, instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using ImplTypes = ::testing::Types<int, float, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, ImplTypes);
```

### Advantages

- Enables writing reusable, interface-driven test suites.
- Allows multiple instantiations with different sets of types without redefining tests.
- Facilitates testing compliance of different implementations with the same behavioral specification.

---

## Common Pitfalls and Troubleshooting

- **Missing Instantiations:** If you define parameterized or typed tests but forget to instantiate them, tests will not run and GoogleTest may report errors or warnings.
- **Accessing Parameters:** In typed tests, use the special `TypeParam` to refer to the parameter type; in value-parameterized tests, use `GetParam()` to access the current test parameter.
- **Test Naming:** Avoid underscores (`_`) in test suite and test names, as they may cause conflicts or unexpected errors.
- **Public Access for SetUpTestSuite:** If your parameterized test fixture uses `SetUpTestSuite()` or `TearDownTestSuite()`, they must be declared public to work correctly with `TEST_P`.

---

## User Experience Flow

1. **Start by defining test fixture templates** depending on whether you want to parameterize by values or types.
2. **Write test cases that use either `GetParam()` (value) or `TypeParam` (type)** to refer to the parameter.
3. **Instantiate tests with concrete values or types** using the appropriate macros.
4. Run tests via your test suite binary as usual, noting that each instantiation produces distinct test results, identified by parameter or type.

---

## Practical Tips

- Use **parameterized tests** when your tests need to run across various data inputs.
- Use **typed tests** when you want to verify the behavior of multiple types under the same test logic, especially useful for generic programs.
- Use **type-parameterized tests** to build reusable test patterns abstracted from concrete types.
- Apply **custom test name generators** to improve test output readability, especially with complex parameter or type lists.
- Define **abstract test suites** with type-parameterized tests to validate concept conformance across different implementations.

---

## Helpful Examples

### Simple Parameterized Test Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, Computes) {
  int n = GetParam();
  EXPECT_GT(Factorial(n), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveNumbers, FactorialTest, Values(1, 2, 3, 8));
```

### Simple Typed Test Example

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_ = T();
};

using MyTypes = ::testing::Types<char, int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```

### Type-Parameterized Test Abstract Definition

```cpp
template <typename T>
class InterfaceComplianceTest : public ::testing::Test {
 public:
  void RunTest() { /* test logic */ }
};

TYPED_TEST_SUITE_P(InterfaceComplianceTest);
TYPED_TEST_P(InterfaceComplianceTest, SatisfiesProperty) {
  this->RunTest();
}
REGISTER_TYPED_TEST_SUITE_P(InterfaceComplianceTest, SatisfiesProperty);
```

### Type-Parameterized Test Instantiation

```cpp
using Implementations = ::testing::Types<MyImpl1, MyImpl2>;
INSTANTIATE_TYPED_TEST_SUITE_P(Impls, InterfaceComplianceTest, Implementations);
```

---

## See Also

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [TEST_P and INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md#TEST_P)
- [TYPED_TEST_SUITE and TYPED_TEST](docs/reference/testing.md#TYPED_TEST_SUITE)
- [TYPED_TEST_SUITE_P and TYPED_TEST_P](docs/reference/testing.md#TYPED_TEST_SUITE_P)

---

This page fits within the Concepts guide as a foundational explanation of testing patterns that empower users to scale their test coverage effectively and flexibly while preserving clarity and ease of maintenance.

---

## Related Documentation

- [Parameterized and Typed Tests Guide](guides/core-scenarios/parameterized-tests)
- [Parameterized and Typed Tests API Reference](api-reference/advanced-testing/parameterized-tests)
- [Value-Parameterized Tests in Advanced Topics](docs/advanced.md#value-parameterized-tests)
- [Typed Tests in Advanced Topics](docs/advanced.md#typed-tests)

---

## Troubleshooting

- If tests defined with `TEST_P` or `TYPED_TEST_P` do not appear to run, verify they are instantiated with `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` appropriately.
- Ensure no underscores (`_`) appear in test suite or test names to avoid naming conflicts.
- Check that test fixture classes have default constructors.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors when parameterized test suites are purposely left uninstantiated.

---