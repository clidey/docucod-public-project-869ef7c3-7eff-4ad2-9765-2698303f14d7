---
title: "Extensibility & Customization"
description: "Gain insight into GoogleTest’s and GoogleMock’s extensibility surfaces: learn how users can define custom assertions, matchers, actions, and test listeners. Explore the strategies for integrating your own logic within the framework’s event model and extension points."
---

# Extensibility & Customization

GoogleTest and GoogleMock offer powerful extensibility mechanisms, enabling you to adapt and augment the framework to your specific testing needs. This guide explores how to define custom assertions, matchers, and actions, and how to integrate user-defined logic within the framework’s test event system. By mastering these extensibility surfaces, you gain the flexibility required for advanced testing scenarios and complex domains.

---

## Custom Assertions

Custom assertions allow you to encapsulate common verification logic with rich, informative failure messages tailored to your domain.

### Defining Custom Assertions

A custom assertion is a function that returns a `::testing::AssertionResult`. The function should return `::testing::AssertionSuccess()` when the assertion passes, or `::testing::AssertionFailure()` with an explanatory message when it fails.

```cpp
::testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return ::testing::AssertionSuccess();
  } else {
    return ::testing::AssertionFailure() << n << " is not even.";
  }
}

TEST(CustomAssertionTest, Evenness) {
  EXPECT_TRUE(IsEven(4));       // Passes
  EXPECT_FALSE(IsEven(3));      // Fails with message "3 is not even."
}
```

### Using Custom Assertions

Use custom assertions where googletest’s built-in assertions are insufficient or to add domain-specific clarity. They integrate smoothly with `EXPECT_*` and `ASSERT_*` macros.

---

## Writing Custom Matchers

GoogleMock’s matcher framework lets you define predicates used in mock expectations and assertions, with detailed failure explanations.

### MATCHER Family of Macros

Easiest to use are the `MATCHER` and `MATCHER_P` macros to define simple and parameterized matchers.

```cpp
MATCHER(IsDivisibleBy, "", ) {
  return (arg % arg2) == 0;
}

TEST(CustomMatcherTest, Divisible) {
  EXPECT_THAT(10, IsDivisibleBy(5));  // Passes
  EXPECT_THAT(10, IsDivisibleBy(3));  // Fails
}
```

### Defining Matcher Classes

For advanced matchers, implement the matcher interface yourself:

- `MatchAndExplain(value, std::ostream*)`: Returns whether the value matches and optionally writes an explanation.
- `DescribeTo(std::ostream*)`: Describes what the matcher expects.
- `DescribeNegationTo(std::ostream*)`: Describes what it means to *not* match.

Example outline:

```cpp
class EvenMatcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % 2 == 0) return true;
    if (os) *os << "which is odd";
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is even";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is odd";
  }
};

::testing::Matcher<int> IsEven() {
  return ::testing::MakeMatcher(new ::testing::internal::MatcherInterfaceImpl<
      int, EvenMatcher>(EvenMatcher()));
}
```

### Polymorphic Matchers

You can write matchers that work for multiple types by templating `MatchAndExplain`.

### Best Practices

- Matchers must be pure functions without side-effects.
- Provide clear descriptions to support readable failure messages.
- Reuse matcher instances for efficiency.

---

## Defining Custom Actions

Actions specify what a mock method does when invoked. You can write your own actions for complex behaviors.

### Using Lambdas and Functors

The simplest way to define a custom action is to supply a lambda or functor with a call operator matching the mock method signature.

```cpp
class MultiplyBy {
 public:
  MultiplyBy(int factor) : factor_(factor) {}
  int operator()(int x) const { return x * factor_; }
 private:
  int factor_;
};

EXPECT_CALL(mock, Compute(_))
    .WillOnce(MultiplyBy(7));
```

### Action Interface

Advanced actions implement `::testing::ActionInterface<F>` where `F` is the mock method type. The key method is:

```cpp
template <typename Result, typename ArgumentTuple>
Result Perform(const ArgumentTuple& args);
```

This method executes the action given the function arguments.

### Polymorphic Actions

If your action works across multiple function signatures, wrap it via `MakePolymorphicAction`.

### Predefined Action Macros

Legacy macros like `ACTION` and `ACTION_P` exist but are discouraged in favor of lambdas or classes.

---

## Integrating Custom Logic with Test Events

Beyond assertions, GoogleTest exposes a *test event listener* interface allowing you to plug in custom logic during test execution.

### Test Event Listeners

You can subclass `::testing::TestEventListener` and override hooks such as:

- `OnTestStart`
- `OnTestPartResult`
- `OnTestEnd`
- `OnTestProgramStart`
- `OnTestProgramEnd`

Example:

```cpp
class MyListener : public ::testing::EmptyTestEventListener {
 public:
  void OnTestStart(const ::testing::TestInfo& test_info) override {
    std::cout << "Starting test: " << test_info.name() << std::endl;
  }
};

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  ::testing::TestEventListeners& listeners = ::testing::UnitTest::GetInstance()->listeners();
  listeners.Append(new MyListener);
  return RUN_ALL_TESTS();
}
```

This enables custom reporting, metrics collection, or integration with external tools.

### Modifying Default Listeners

You can also replace or wrap default listeners for richer output or integration.

---

## Summary

Extending GoogleTest and GoogleMock unlocks expressive power that fits your testing domain. Mastering custom assertions, matchers, and actions makes tests more readable and maintainable while allowing fine control. The test event listener mechanism lets you embed bespoke logic into the test lifecycle.

Start by crafting simple custom assertions or lambdas for actions, then explore matcher classes and event listeners for advanced scenarios.


---

## Additional Resources

- [Custom Assertions & Matchers Guide](/guides/advanced-usage-integration/custom-assertions-matchers)
- [gMock Cookbook - Custom Matchers & Actions](docs/gmock_cook_book.md)
- [Mocking Reference - EXPECT_CALL, ON_CALL](docs/reference/mocking.md)
- [Test Event Listeners API](https://github.com/google/googletest/blob/main/googletest/include/gtest/gtest.h#L502)

---

## Troubleshooting & Best Practices

- Ensure custom matchers and actions have no side-effects to avoid flaky tests.
- Use `MATCHER` macros for readable, concise definitions.
- When making polymorphic matchers or actions, template carefully to keep compatibility.
- Test custom components thoroughly in isolation.

---

## Example: Custom Matcher with Action

```cpp
MATCHER_P(IsNear, target, "Checks if value is near target") {
  return std::abs(arg - target) <= 0.001;
}

class AddOffset {
 public:
  AddOffset(int offset) : offset_(offset) {}
  int operator()(int x) const { return x + offset_; }
 private:
  int offset_;
};

TEST(MyMockTest, UsesCustomMatcherAndAction) {
  MockFoo mock;
  EXPECT_CALL(mock, GetValue())
      .WillOnce(AddOffset(5));
  EXPECT_CALL(mock, SetValue(IsNear(10)));

  int val = mock.GetValue();       // val == 5
  mock.SetValue(10.0001);          // Passes
  mock.SetValue(9.9999);           // Passes
  mock.SetValue(9.5);              // Fails
}
```
