---
title: "Using and Extending Matchers"
description: "Explore the matcher subsystem enabling expressive checks in assertions and mock expectations. Learn about built-in matchers, writing custom matchers, and advanced capabilities for composing and extending matcher logic."
---

# Using and Extending Matchers

GoogleTest’s matcher subsystem empowers you to write expressive, readable checks in both assertions (`EXPECT_THAT`) and mock function expectations (`EXPECT_CALL`). This page explores how to use built-in matchers effectively, write custom matchers, and leverage advanced matcher composition and extension techniques.

---

## Introduction to Matchers

Matchers describe the expected properties of values or function arguments. They can be:

- **Simple value matchers:** like `Eq(value)` to test equality.
- **Combinational matchers:** combine multiple checks with `AllOf()`, `AnyOf()`, or negate conditions with `Not()`.
- **Container matchers:** for verifying collections like `ElementsAre()`, `Contains()`, or `Each()`.
- **Pointer and field matchers:** like `Pointee(matcher)`, `Field(&Class::member, matcher)`, or `Property(&Class::getter, matcher)`.
- **Custom matchers:** users can define their own matchers using macros or classes.

Matchers produce detailed, human-friendly failure messages, explaining not only what was expected but also why the match failed or succeeded.

---

## Using Built-In Matchers

### Simple Matchers

Examples:

```cpp
EXPECT_THAT(value, Eq(5));           // value equals 5
EXPECT_THAT(ptr, NotNull());          // ptr is not NULL
EXPECT_THAT(str, StartsWith("Hello"));  // string starts with "Hello"
```

Matchers are polymorphic and work for compatible types without explicit casts.

### Combinational Matchers

Combine matchers to express compound conditions:

```cpp
EXPECT_THAT(num, AllOf(Ge(1), Le(10)));  // num is between 1 and 10 inclusive
EXPECT_THAT(text, AnyOf(HasSubstr("foo"), HasSubstr("bar"))); // contains "foo" or "bar"
EXPECT_THAT(x, Not(Eq(0)));              // x is not zero
```

### Container Matchers

Verify elements and structure of containers:

```cpp
EXPECT_THAT(vec, ElementsAre(1, Lt(0), _, 5));  // vec has 4 elements matching these conditions in order
EXPECT_THAT(set, UnorderedElementsAre(2, 1, 3));  // set contains 1, 2, and 3 in any order
EXPECT_THAT(map, Contains(Key(5)));                 // map has some key equal to 5
EXPECT_THAT(vec, Each(Gt(0)));                      // all elements in vec are greater than 0
```

---

## Writing Custom Matchers

When existing matchers don’t suffice, GoogleTest lets you quickly write your own.

### Quick way: MATCHER Macros

Use the `MATCHER` family of macros to concisely define new matchers.

Basic syntax:

```cpp
MATCHER(Name, description) {
  // 'arg' is the value to match; must return bool.
  return /* true if arg matches, false otherwise */;
}
```

Example:

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }
```

Use:

```cpp
EXPECT_THAT(value, IsEven());
EXPECT_CALL(mock_obj, Method(IsEven()));
```

By leaving `description` empty, a description is generated automatically from the matcher name. You can provide a custom description string or one that varies depending on `negation`.

### Parameterized Matchers

For matchers that take arguments, use `MATCHER_P` and variants (`MATCHER_P2`, ..., `MATCHER_P10`):

```cpp
MATCHER_P(HasAbsValue, val, "") {
  return abs(arg) == val;
}
```

Example:

```cpp
EXPECT_THAT(x, HasAbsValue(10));
```

The description can reference `val` and `negation` for sensible error messages.

### Advanced Custom Matchers

For more control:

- Implement the matcher interface class directly by defining `MatchAndExplain()`, `DescribeTo()`, and `DescribeNegationTo()` methods.
- Use `MakeMatcher()` or `MakePolymorphicMatcher()` to create matcher instances.

Example:

```cpp
class DivisibleByMatcher {
 public:
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  template <typename T>
  bool MatchAndExplain(const T& value, std::ostream* listener) const {
    bool matched = (value % divisor_) == 0;
    if (!matched && listener) {
      *listener << "which is " << (value % divisor_) << " modulo " << divisor_;
    }
    return matched;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }
  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }

 private:
  const int divisor_;
};

inline testing::Matcher<int> IsDivisibleBy(int divisor) {
  return testing::MakePolymorphicMatcher(DivisibleByMatcher(divisor));
}
```

---

## Matcher Composition and Extension

GoogleTest matchers are composable and can be cast to compatible types with `SafeMatcherCast<T>(matcher)`.

### Logical Combinators

- `AllOf(m1, m2, ...)`: All sub-matchers must match.
- `AnyOf(m1, m2, ...)`: Any one sub-matcher matches.
- `Not(m)`: Negates matcher `m`.

### Container-Based Compositions

- `ElementsAre(...)` and `UnorderedElementsAre(...)` allow matching containers with specific element expectations.
- `Contains(matcher)` verifies presence of at least one matching element.

### Tuple and Pair Matchers

- Use `Pair(matcher_for_first, matcher_for_second)` to match pairs.
- Use `FieldsAre(m1, m2, ...)` to match tuple-like structures or structs with multiple fields.

### Pointer and Reference Matchers

- `Pointee(m)`: Matches a pointer whose pointee matches `m`. Null pointers always fail.
- `Field(&Class::member, m)`: Matches an object whose member field matches `m`.
- `Property(&Class::getter, m)`: Matches an object whose getter method returns a value matching `m`.

### Helpers for Optional and Variant Types

- `Optional(m)`: Matches an optional-like type with its engaged value matching `m`.
- `VariantWith<T>(m)`: Matches a `std::variant` holding a value of type `T` matching the inner matcher.

---

## Practical Tips and Best Practices

- **Use polymorphic matchers:** Most built-in matchers are polymorphic; just use them naturally without worrying about explicit template parameters.
- **Combine matchers to express intent:** Prefer `AllOf` and `AnyOf` over complex single matchers for clarity.
- **Use container matchers for STL containers:** `ElementsAre` is ideal for ordered containers; use `UnorderedElementsAre` for unordered containers.
- **Use `SafeMatcherCast` to resolve type mismatches:** When matching arguments with slightly different types, this function safely converts matchers, preventing compilation errors.
- **Define custom matchers for repeated checks:** Reuse your complex checks by encapsulating them into custom matchers, improving test readability.
- **Leverage descriptions for diagnostics:** Provide custom descriptions or stream additional explanation to improve failure messages.
- **Avoid side effects in matchers:** Matchers must be pure predicates without side effects, as their evaluation might occur multiple times or be omitted depending on test verbosity.

---

## Examples

### Defining and Using a Custom Matcher

```cpp
MATCHER(IsNegative, "") {
  return arg < 0;
}

EXPECT_THAT(value, IsNegative());
```

### Parameterized Matcher with Description

```cpp
MATCHER_P(InClosedRange, low, "") {
  return arg >= low.first && arg <= low.second;
}

EXPECT_THAT(5, InClosedRange(std::make_pair(1, 10)));
```

### Using Container Matchers

```cpp
EXPECT_THAT(vec, ElementsAre(1, 2, 3));
EXPECT_THAT(set, UnorderedElementsAre(3, 1, 2));
```

### Matching Members of Objects

```cpp
EXPECT_THAT(foo, Field(&Foo::bar, Eq(10)));
EXPECT_THAT(foo, Property(&Foo::GetName, StartsWith("John")));
```

### Matching Pointer Arguments

```cpp
EXPECT_CALL(mock, Process(Pointee(Eq(5))));
```

---

## Troubleshooting Common Issues

- **Compilation errors matching arguments with different types:** Use `SafeMatcherCast<T>()` to explicitly convert matchers to the expected argument type.
- **Unexpected match failures producing uninformative messages:** Improve your matcher’s `MatchAndExplain()` to stream helpful messages to the result listener.
- **Overly restrictive tests due to unintentional matchers:** Use `Not()` and combinators to better express intent.
- **Null pointer dereference in `Pointee` or `Field`:** Remember these fail on `nullptr`; if nullable pointers are expected use `AnyOf(IsNull(), Pointee(...))`.

---

## Related Topics

- [Writing Clear and Effective Assertions](../guides/integration-and-best-practices/writing-effective-assertions)
- [Parameterized and Type-Parameterized Tests](../api-reference/core-testing-api/parameterized-and-type-parameterized-tests)
- [Mocking C++ Objects with GoogleMock](../guides/advanced-testing-strategies/mocking-with-googlemock)
- [Assertions and Failure Modes](../concepts/data-models-assertions/assertions-and-failures)
- [Matchers Reference](../api-reference/matchers-and-mocking/matchers-reference)

---

## Additional Resources

- [gMock Cookbook - Custom Matchers](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers)
- [Matchers Reference](../api-reference/matchers-and-mocking/matchers-reference)
- [EXPECT_THAT assertion](../api-reference/core-testing-api/assertions.md#EXPECT_THAT)

---

For a comprehensive understanding, users are encouraged to progressively explore matcher basics, custom matcher creation, and advanced matcher composition.


<AccordionGroup title="Custom Matcher Example">
<Accordion title="Basic MATCHER macro">
```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

EXPECT_THAT(value, IsEven());
EXPECT_CALL(mock, Func(IsEven()));
```
Defines an `IsEven` matcher usable wherever a matcher is expected.
</Accordion><Accordion title="Parameterized Matcher">
```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  if ((arg % divisor) == 0) return true;
  *result_listener << "with remainder " << (arg % divisor);
  return false;
}

EXPECT_THAT(x, IsDivisibleBy(3));
```
Allows passing parameters with descriptive failure messages.
</Accordion><Accordion title="Polymorphic Matcher Class">
```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const {
    return p != nullptr;
  }

  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

inline testing::PolymorphicMatcher<NotNullMatcher> NotNull() {
  return testing::MakePolymorphicMatcher(NotNullMatcher());
}
```
Defines a polymorphic matcher class usable with pointers of any type.
</Accordion></AccordionGroup>

<Check>
Matchers support detailed failure messages and composability, enabling precise and readable testing.
</Check>
