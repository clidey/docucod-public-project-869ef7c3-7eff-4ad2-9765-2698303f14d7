---
title: "Parameterized and Type-Parameterized Tests"
description: "Discover how to define and leverage parameterized and type-parameterized tests to cover a broad set of inputs and scenarios with minimal code duplication. Review the mechanisms for test data generation, instantiation, and test suite organization."
---

# Parameterized and Type-Parameterized Tests

GoogleTest provides powerful mechanisms to define tests that run repeatedly with varying data or types, allowing you to cover a broad range of scenarios efficiently with minimal code duplication. This guide explains how to define and use **value-parameterized tests** and **type-parameterized tests**, including test data generation, instantiation, and organization.

---

## Value-Parameterized Tests

Value-parameterized tests allow running the same test logic multiple times, each time with different input values. This is ideal when you want to verify that a function behaves correctly under multiple parameter settings without manually writing separate tests for each.

### Defining Value-Parameterized Tests

1. Define a test fixture class that inherits from `testing::TestWithParam<T>`, where `T` is the type of the parameters you want to test with. This fixture provides access to the current test parameter via the `GetParam()` method.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // You can put setup code or helpers here.
};
```

2. Use the `TEST_P` macro (the "P" stands for "parameterized") to define individual test functions under this fixture. Inside the test, call `GetParam()` to obtain the current parameter value.

```cpp
TEST_P(FooTest, DoesBlah) {
  int param = GetParam();
  EXPECT_TRUE(SomeFunction(param));
}

TEST_P(FooTest, HasPropertyBlah) {
  EXPECT_GT(GetParam(), 0);
}
```

### Instantiating Parameterized Tests

You instantiate value-parameterized tests using the `INSTANTIATE_TEST_SUITE_P` macro, which takes:

- A unique prefix name identifying this instantiation.
- The name of the test suite (fixture) class.
- A parameter generator that produces the sequence of parameter values to test.
- (Optional) a custom test name generator for readable test output.

Example instantiations:

```cpp
// Using predefined parameters
INSTANTIATE_TEST_SUITE_P(ExampleValues, FooTest, testing::Values(1, 2, 3));

// Using a container
const int kInts[] = {10, 20};
INSTANTIATE_TEST_SUITE_P(ArrayValues, FooTest, testing::ValuesIn(kInts));

// Using a range
INSTANTIATE_TEST_SUITE_P(RangeValues, FooTest, testing::Range(5, 10, 2));

// Using Boolean parameters
INSTANTIATE_TEST_SUITE_P(BoolValues, FooTest, testing::Bool());

// Combining multiple generators
INSTANTIATE_TEST_SUITE_P(
  CombinedValues, FooTest,
  testing::Combine(testing::Values(1, 2), testing::Bool()));
```

The instantiated tests will have names like `ExampleValues/FooTest.DoesBlah/0`, with the index denoting the parameter position.

### Parameter Generators Overview

| Generator Function   | Description                                                                                |
|---------------------|--------------------------------------------------------------------------------------------|
| `Values(v1, ..., vN)` | Generates tests with the specified discrete values.                                       |
| `ValuesIn(container)` | Generates tests from contents of an array, STL container, or iterator range.              |
| `Range(start, end[, step])` | Generates sequential values from start up to (but not including) end, with optional step size. |
| `Bool()`             | Generates test parameters `false` and `true`.                                            |
| `Combine(g1, ..., gN)` | Produces the Cartesian product of multiple generators, yielding tuples of parameter values. |
| `ConvertGenerator<T>(gen)` | Wraps another generator to convert values to a custom type or via a converter function. |

### Best Practices and Tips

- If your test logic needs multiple parameters, use `Combine()` to generate tuples.
- Provide a **custom name generator** if parameter values are complex to improve test suite readability.
- Remember generators are evaluated during test initialization, enabling dynamic parameter specification.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you define parameterized tests but do not want to instantiate them immediately.

### Common Pitfalls

- Ensure your test fixture correctly inherits from `TestWithParam<T>` to access `GetParam()`.
- Be aware that parameter generators are *not* evaluated at the macro call site but during `InitGoogleTest()`.
- When using `ConvertGenerator`, specify types carefully to avoid dangling references, especially when using lambdas.

---

## Typed Tests

Typed tests help you run the same set of test code over different **types**, useful when you want to ensure your template or generic code behaves consistently across multiple type instantiations.

### Defining Typed Tests

1. Define a test fixture class template parameterized by a type `T`, deriving from `testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  // Define type-specific helpers or members.
  using ListType = std::list<T>;
  static T shared_value;
  T value_;
};

template <typename T>
T MyTypedTest<T>::shared_value = T();
```

2. Specify the list of types you want to test with using the `Types` template alias and associate that list with the test suite using `TYPED_TEST_SUITE` macro:

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write test cases using `TYPED_TEST` macro. Inside the test case, the type parameter is accessible via the name `TypeParam`, and you may need `typename TestFixture::` to refer to dependent names.

```cpp
TYPED_TEST(MyTypedTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_value;
  typename TestFixture::ListType values;
  values.push_back(n);
  EXPECT_TRUE(!values.empty());
}

TYPED_TEST(MyTypedTest, HasPropertyA) {
  // Additional test logic here
}
```

### When to Use Typed Tests

- Testing templated classes or functions with various types.
- Verifying interface conformance across multiple implementations.
- Avoid duplicating identical test logic for different type instantiations.

### Type Names Customization

You can provide a custom name generator class to define human-readable names for types in test output:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
    return "UnknownType";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Notes

- Each `TYPED_TEST` defines a test per type in the type list.
- The test fixture object is created anew for each typed test.

---

## Type-Parameterized Tests

Type-parameterized tests allow defining generic test logic without specifying the types upfront. Later, you register your tests and instantiate them with specific types as needed, possibly multiple times in different parts of the program.

### Defining Type-Parameterized Tests

1. Create a fixture class template derived from `testing::Test`, similar to typed tests.

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // Define fixture members and helpers
};
```

2. Declare the test suite as type-parameterized using `TYPED_TEST_SUITE_P`.

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. Define tests using `TYPED_TEST_P` macro.

```cpp
TYPED_TEST_P(MyTypeParamTest, DoesBlah) {
  TypeParam value{};
  // Your test code using TypeParam
}

TYPED_TEST_P(MyTypeParamTest, HasPropertyA) {
  // Additional test code
}
```

4. Register tests with `REGISTER_TYPED_TEST_SUITE_P` by listing the test names.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesBlah, HasPropertyA);
```

5. Instantiate the test pattern with a list of types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```

### Use Cases

- Building libraries that define generic test logic which client code instantiates.
- Testing interface or concept conformance where types are determined later.
- Avoid hardcoding the type list when it might change or be large.

### Notes

- You can instantiate the same test pattern multiple times with different type lists.
- The instantiation prefix distinguishes different test runs in output.

---

## Summary of Macros

| Macro                         | Purpose                                               |
|-------------------------------|-----------------------------------------------------|
| `TEST_P(TestFixture, TestName)`  | Defines a value-parameterized test.                   |
| `INSTANTIATE_TEST_SUITE_P(Prefix, TestFixture, param_gen)` | Instantiates a value-parameterized test with parameters. |
| `TYPED_TEST_SUITE(TestFixture, Types [, NameGenerator])` | Defines typed tests over a list of types.              |
| `TYPED_TEST(TestFixture, TestName)` | Defines individual typed tests.                       |
| `TYPED_TEST_SUITE_P(TestFixture)` | Declares a type-parameterized test suite.             |
| `TYPED_TEST_P(TestFixture, TestName)` | Defines individual type-parameterized tests.          |
| `REGISTER_TYPED_TEST_SUITE_P(TestFixture, test_names...)` | Registers type-parameterized tests.                    |
| `INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestFixture, Types)` | Instantiates a type-parameterized test suite.          |

---

## Troubleshooting and Common Issues

- **No Test Runs**: Ensure you have instantiated all parameterized tests; otherwise, they will silently not run.
- **Incorrect Parameter Access**: Use `GetParam()` in `TEST_P` fixtures and `TypeParam` in typed tests.
- **Name Collisions**: Use unique prefixes when instantiating parameterized tests multiple times.
- **Dangling References**: Avoid returning references to temporary parameter objects in converters.

---

## Practical Example

```cpp
// 1. Define fixture with parameter type.
class MyParamTest : public testing::TestWithParam<int> {};

// 2. Define parameterized tests.
TEST_P(MyParamTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

TEST_P(MyParamTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

// 3. Instantiate tests with a list of integers.
INSTANTIATE_TEST_SUITE_P(IntegerTests, MyParamTest, testing::Values(2, 4, 6));

// 4. Typed tests example

template <typename T>
class MyTypedTest : public testing::Test {
 public:
  static T shared_value;
};

template <typename T>
T MyTypedTest<T>::shared_value = T();

using TestTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, TestTypes);

TYPED_TEST(MyTypedTest, SharedValueIsDefaultConstructed) {
  EXPECT_EQ(TestFixture::shared_value, TypeParam());
}
```

This setup allows robust, reusable testing across diverse inputs and types, increasing coverage and decreasing maintenance burden.

---

## References and Further Reading

- [GoogleTest Primer](docs/primer.md#value-parameterized-tests) — Basic concepts and getting started
- [Advanced GoogleTest Topics](docs/advanced.md#value-parameterized-tests) — Detailed usage and best practices
- [Testing Reference: Parameterized and Typed Tests](api-reference/core-testing-api/parameterized-and-type-parameterized-tests.md)
- [Writing and Running Your First Tests Guide](guides/core-workflows/writing-first-tests.md)
- [Organizing Test Suites Guide](guides/core-workflows/organizing-test-suites.md)

---