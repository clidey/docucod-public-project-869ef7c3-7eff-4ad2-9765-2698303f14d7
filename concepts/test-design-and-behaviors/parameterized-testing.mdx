---
title: "Parameterized and Typed Test Concepts"
description: "Learn the concepts behind running tests across multiple inputs or types. Understand the value and patterns of value-parameterized and type-parameterized tests for C++ codebases that require flexible and comprehensive test coverage."
---

# Parameterized and Typed Test Concepts

GoogleTest provides powerful features to broaden your test coverage without duplicating code: parameterized tests that iterate over multiple input values and typed tests that run the same logic across different types. This guide explains the core concepts and workflows behind these testing patterns, empowering you to write flexible, scalable tests for C++ codebases that demand comprehensive validation.

---

## Introduction to Parameterized Tests

Imagine you have a function or class whose behavior depends on various inputs or configurations. Instead of writing nearly identical tests multiple times, parameterized tests let you define a test once but run it repeatedly with different parameters. This approach:

- Increases coverage by exploring multiple scenarios effortlessly.
- Reduces boilerplate and maintenance overhead.
- Provides organized, readable test output showing which parameter caused a failure.


### Value-Parameterized Tests

**Value-parameterized tests** enable you to execute the same test logic with a series of different parameter values. This technique is ideal when you want to test the behavior of your code across a range of inputs, feature flags, or configurations.

#### Key Workflow

1. **Define a test fixture class** that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type (any copyable C++ type).

2. **Write test cases using the `TEST_P` macro** with this fixture. Inside these tests, access the current parameter with `GetParam()`.

3. **Instantiate the test suite,** supplying a generator of parameter values using `INSTANTIATE_TEST_SUITE_P`.


#### Example

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Optional: Add fixture setup/teardown or utility methods here.
};

TEST_P(FooTest, HandlesDifferentInputs) {
  const char* param = GetParam();
  EXPECT_TRUE(HandleInput(param));
}

// Instantiate with a list of string literals
INSTANTIATE_TEST_SUITE_P(MyParameterInstantiation, FooTest,
                         testing::Values("meeny", "miny", "moe"));
```

Each parameter value runs the test separately, producing results like:

- MyParameterInstantiation/FooTest.HandlesDifferentInputs/0 ('meeny')
- MyParameterInstantiation/FooTest.HandlesDifferentInputs/1 ('miny')
- MyParameterInstantiation/FooTest.HandlesDifferentInputs/2 ('moe')

You can also use a variety of generators for parameters:

| Generator          | Description                                                            |
| ------------------ | ---------------------------------------------------------------------- |
| `Range(start,end)` | Generates sequence from start (inclusive) to end (exclusive)          |
| `Values(v1, ...)`  | Explicit parameter list                                                |
| `ValuesIn(container)` | Parameters from a container or iterator range                        |
| `Bool()`           | Boolean values `{false, true}`                                         |
| `Combine(g1, g2)`  | Cartesian product of multiple generators (tuples of parameters)       |

---

## Using Value Generators

GoogleTest provides helper functions in the `testing` namespace to create parameter generators easily:

- `Range(start, end [, step])`: Generates ordered sequences, e.g., `Range(0, 5)` yields 0,1,2,3,4.
- `Values(...)`: Pass explicit parameter values directly.
- `ValuesIn(container)`: Use ranges or STL containers as parameter sources.
- `Bool()`: Generates `{false, true}`.
- `Combine(g1, g2, ...)`: Combines multiple generators producing tuples covering all combinations.

You can customize parameter types or convert generated tuples to user-defined structs using `ConvertGenerator`.

### Combining Parameters

For tests that need multiple parameters simultaneously, `Combine` creates tuples representing all possible combinations from multiple generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedTest, MultiParamTest,
    testing::Combine(
        testing::Values("cat", "dog"),
        testing::Values(Color::BLACK, Color::WHITE)));
```

This results in four test instances with parameters `("cat", BLACK)`, `("cat", WHITE)`, `("dog", BLACK)`, and `("dog", WHITE)`.

---

## Typed Tests

When you want to run the exact same tests over different C++ types, use *typed tests*. This avoids duplicating test definitions for each type variant and validates template correctness or different implementations efficiently.

### Typed Tests vs. Type-Parameterized Tests

- **Typed Tests:** You write tests bound to a fixed list of types known at compile time.
- **Type-Parameterized Tests:** You define a generic abstract test pattern that can be instantiated multiple times with arbitrary type lists elsewhere.

Both share the same core concepts but differ in flexibility and instantiation patterns.

### How to Use Typed Tests

1. Define a **test fixture class template** parameterized by a type `T`, inheriting from `testing::Test`.

2. Associate a **type list** to the test fixture using `TYPED_TEST_SUITE`.

3. Define typed tests with `TYPED_TEST`, referencing special identifiers:
   - `TypeParam` — the current test's type parameter.
   - `TestFixture` — the test fixture class template instantiated with `TypeParam`.

4. Run tests: GoogleTest will expand and run one instance of each typed test for every specified type.

### Example

```cpp
// Test fixture template
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
};

// List of types to test
using MyTypes = ::testing::Types<int, double, std::string>;

// Register the fixture and the types
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

// Define typed tests
TYPED_TEST(MyTypedTest, IsDefaultConstructed) {
  TypeParam default_value{};
  EXPECT_EQ(this->value_, default_value);
}

TYPED_TEST(MyTypedTest, CanAssignValue) {
  TypeParam val = TypeParam{};  // Example assignment
  this->value_ = val;
  EXPECT_EQ(this->value_, val);
}
```

This runs all tests once for each type in `MyTypes`.

---

## Type-Parameterized Tests

Type-parameterized tests are like typed tests but give more flexibility by allowing the tests to be defined without a concrete list of types upfront — instead, tests are registered and instantiated separately.

Workflow:

1. Define the test fixture class template.
2. Declare a type-parameterized test suite with `TYPED_TEST_SUITE_P`.
3. Define tests with `TYPED_TEST_P`.
4. Register the names of the test cases using `REGISTER_TYPED_TEST_SUITE_P`.
5. Instantiate the test suite with types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

This pattern supports sharing abstract tests for interfaces or concepts, allowing multiple independent instantiations per implementation.

---

## Naming Parameterized Tests

By default, the test name suffix related to parameters is an index or the string representation of the parameter. For better readability and debugging:

- Use the built-in name generator `PrintToStringParamName`.
- Provide a custom generator function or functor to create descriptive, unique, and valid parameter names that only contain ASCII alphanumeric characters and underscores.

Example of custom name generator:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyName, FooTest,
    testing::Values(1, 2),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Value" + std::to_string(info.index);
    });
```


---

## Practical Tips & Best Practices

- Choose the parameter type carefully — it should be copyable and should represent a meaningful test input.
- Always instantiate the test suite with `INSTANTIATE_TEST_SUITE_P`; leaving a `TEST_P` uninstantiated results in a failing test suite by default.
- If you intentionally have uninstantiated parameterized test cases (e.g., abstract tests), suppress warnings using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Use `Combine` carefully to avoid combinatorial explosion when combining multiple parameter sets.
- Keep parameter names unique and valid to avoid conflicts in test filtering and reporting.
- Prefer value-parameterized tests when varying inputs, use typed or type-parameterized tests when varying types.

---

## Troubleshooting Common Issues

- **Tests not running:** Check that you called `INSTANTIATE_TEST_SUITE_P` with the correct test suite name.
- **Name collisions or invalid characters:** Ensure your custom name generator produces unique, underscore-separated alphanumeric strings.
- **Parameter lifetime issues:** If your test parameter is a pointer or complex object, manage its lifetime carefully or use value semantics.
- **Compilation errors with typed tests:** Confirm that your test fixture template and type list are well-formed and included properly.

---

## Summary Diagram: Test Instantiation Flow

```mermaid
flowchart TD
  A[Define Test Fixture
(TestWithParam<T> or Test<T>)] --> B[Write Parameterized Tests
(TEST_P or TYPED_TEST)]
  B --> C[Define Parameter Generator
(e.g., Values, Range, Combine)]
  C --> D[Instantiate Test Suite
(INSTANTIATE_TEST_SUITE_P or INSTANTIATE_TYPED_TEST_SUITE_P)]
  D --> E[Test Framework Generates
Test Instances for Each Parameter]
  E --> F[Run Tests with
Parameters or Types]
```

---

## Additional Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) — for concrete example and detailed workflows.
- [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests) — for deeper dives on type-based testing.
- [Testing Reference - `TEST_P` and `INSTANTIATE_TEST_SUITE_P`](../reference/testing.md#TEST_P) — precise API definitions.
- [GoogleTest Primer](../primer.md) — strong foundational overview of testing with GoogleTest.
- [Sample7 and Sample8](https://github.com/google/googletest/tree/main/googletest/samples) — fully worked-out sample code demonstrating parameterized tests.

---

This concepts guide equips you to leverage GoogleTest's parameterized and typed tests effectively, increasing your C++ test coverage and maintainability while minimizing redundant code. As next steps, explore the detailed guides and sample tests to practice writing and instantiating your own parameterized and typed tests.


---

*End of Concept Guide*