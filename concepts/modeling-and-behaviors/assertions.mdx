---
title: "Assertions and Test Validation"
description: "Explore the rich assertion model that drives test validation in GoogleTest. Learn the difference between fatal and non-fatal failures, how to create user-defined assertions, and best practices for meaningful test diagnostics."
---

# Assertions and Test Validation

GoogleTest provides a rich and flexible assertion framework that allows you to validate your code behavior effectively during tests. This page explores the core assertion mechanisms, the distinction between fatal and non-fatal failures, how to build user-defined assertions, and best practices for achieving clear, actionable diagnostics.

---

## Understanding Assertions in GoogleTest

Assertions are the fundamental building blocks used to verify conditions in your tests. When an assertion fails, it indicates a deviation from the expected behavior and reports a failure accordingly.

### Fatal vs Non-fatal Failures

- **Fatal failures** terminate the current test function immediately.
- **Non-fatal failures** report the failure but allow test execution to continue.

GoogleTest distinguishes these via *ASSERT_* macros (fatal) and *EXPECT_* macros (non-fatal).

**Use cases:**
- Use `ASSERT_*` when subsequent test logic depends on the assertion's success (e.g., verifying pointers are not null before dereferencing).
- Use `EXPECT_*` when you want to log a failure but continue executing to collect more test data.

### Basic Assertion Macros

GoogleTest provides a comprehensive set of macros for asserts, including:

| Assertion Type       | Macro Examples            | Description                              |
|---------------------|--------------------------|------------------------------------------|
| Explicit Success/Failure | `SUCCEED()`, `FAIL()`       | Generate success or abort test execution |
| Boolean Checks       | `EXPECT_TRUE(condition)`, `ASSERT_FALSE(condition)` | Verify boolean conditions |
| Equality/Comparison  | `EXPECT_EQ(val1, val2)`, `ASSERT_LT(val1, val2)` | Binary comparison assertions |
| String Comparison    | `EXPECT_STREQ(str1, str2)` | Compare C strings by content |
| Floating-Point       | `EXPECT_FLOAT_EQ(val1, val2)`, `EXPECT_NEAR(val1,val2,epsilon)` | Compare floating points with epsilon or ULP-based tolerance |
| Exception Assertions| `EXPECT_THROW()`, `EXPECT_NO_THROW()` | Verify exceptions in code blocks |

### Streaming Custom Failure Messages

All assertions support streaming custom diagnostic messages via the `<<` operator to clarify failure contexts:

```cpp
EXPECT_TRUE(x > 0) << "x must be positive but is " << x;
```

This helps communicate the root cause more effectively when assertions fail.

## Using Matchers with `EXPECT_THAT`

GoogleTest supports expressive and extensible assertions with matchers for verifying that values meet complex criteria.

### Overview

- `EXPECT_THAT(value, matcher)` verifies that `value` satisfies `matcher`.
- Matchers can represent complex predicates and produce human-readable failure messages.

### Example

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(name, StartsWith("John"));
EXPECT_THAT(input, MatchesRegex("Line \\d+"));
EXPECT_THAT(number, AllOf(Gt(5), Lt(10)));
```

The failure messages from matchers clearly describe expectations and actual values, improving test readability and debuggability.

## Explicit Success and Failure

- `SUCCEED()` can be used to note a successful check explicitly (mostly for documentation).
- `FAIL()` generates a fatal failure and is useful to mark unreachable code or unexpected conditions.
- `ADD_FAILURE()` and `ADD_FAILURE_AT()` generate non-fatal failures, allowing tests to continue while logging errors.

## Boolean Condition Assertions

These assertions verify boolean expressions, providing clear, natural checks in tests.

| Macro         | Checks                                          |
|---------------|------------------------------------------------|
| `EXPECT_TRUE` | Expression is `true`                            |
| `ASSERT_TRUE` | (Fatal) Expression is `true`                    |
| `EXPECT_FALSE`| Expression is `false`                           |
| `ASSERT_FALSE`| (Fatal) Expression is `false`                   |

Example:

```cpp
EXPECT_TRUE(IsConnected()) << "Connection failed.";
```

## Binary Comparison Assertions

Assertions comparing two values with their respective comparators:

| Macro          | Meaning                             |
|----------------|-----------------------------------|
| `EXPECT_EQ`    | Equality (`==`)                    |
| `EXPECT_NE`    | Inequality (`!=`)                  |
| `EXPECT_LT`    | Less than (`<`)                    |
| `EXPECT_LE`    | Less or equal (`<=`)               |
| `EXPECT_GT`    | Greater than (`>`)                 |
| `EXPECT_GE`    | Greater or equal (`>=`)            |

**Note:**
- Pointer comparisons use pointer equality, so for C strings use string-specific macros like `EXPECT_STREQ`.

Example:

```cpp
EXPECT_EQ(result, expected) << "Mismatched result";
```

## String Comparison Assertions

C strings need explicit content comparisons, as pointer comparison would only check addresses.

| Macro            | Usage                                           |
|------------------|------------------------------------------------|
| `EXPECT_STREQ`   | Strings have the same contents                  |
| `EXPECT_STRNE`   | Strings are not equal                            |
| `EXPECT_STRCASEEQ`| Case-insensitive equality                       |
| `EXPECT_STRCASENE`| Case-insensitive inequality                     |

Example:

```cpp
EXPECT_STREQ(message.c_str(), "Success") << "Unexpected message";
```

## Floating-Point Comparisons

Due to representation and rounding, use specialized assertions:

- `EXPECT_FLOAT_EQ` and `ASSERT_FLOAT_EQ` compare `float`s allowing 4 ULP tolerance.
- `EXPECT_DOUBLE_EQ` and `ASSERT_DOUBLE_EQ` compare `double`s similarly.
- `EXPECT_NEAR(val1, val2, abs_error)` checks if absolute difference is within bounds.

Example:

```cpp
EXPECT_NEAR(output, expected, 1e-5) << "Output not within tolerance";
```

## Exception Assertions

GoogleTest can verify that code throws (or does not throw) expected exceptions.

| Macro             | Usage                              |
|-------------------|----------------------------------|
| `EXPECT_THROW`    | Code throws a specific exception  |
| `EXPECT_ANY_THROW`| Code throws any exception          |
| `EXPECT_NO_THROW` | Code does not throw                |

Example:

```cpp
EXPECT_THROW(FunctionThatThrows(), std::runtime_error);
```

You can wrap compound statements in braces:

```cpp
EXPECT_NO_THROW({
  Initialize();
  ProcessData();
});
```

## Predicate Assertions

Offer flexible predicates with detailed failure diagnostics.

- `EXPECT_PRED*` and `ASSERT_PRED*` verify predicates with 1 to 5 arguments.
- `EXPECT_PRED_FORMAT*` variants allow custom failure messages.

Example:

```cpp
bool IsWithinRange(int x) { return x >= 0 && x <= 10; }
EXPECT_PRED1(IsWithinRange, value);
```

When predicates fail, GoogleTest prints the argument values to aid debugging.

## Death Assertions

Specialized assertions verify that code causes process termination.

- `EXPECT_DEATH` and related variants run code in a subprocess and check for expected exit status and error messages.

Example:

```cpp
EXPECT_DEATH(FunctionThatCrashes(), "Error message regex");
```

Death tests require platform support and have detailed usage notes in [GoogleTest Advanced Guide](../advanced.md#death-tests).

## Writing Custom Assertions

GoogleTest enables users to create custom assertions for test-specific logic.

- Return a `testing::AssertionResult` indicating success or failure.
- Provide detailed descriptions for failure messages.

Example:

```cpp
#include <gtest/gtest.h>

using ::testing::AssertionResult;

AssertionResult IsEven(int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << n << " is not even";
}

TEST(NumberTest, EvenCheck) {
  int num = 3;
  EXPECT_PRED_FORMAT1(IsEven, num);
}
```

## Best Practices for Assertions

- Use the appropriate macro (`EXPECT_` or `ASSERT_`) depending on test flow needs.
- Write clear and precise custom failure messages.
- Prefer matchers and `EXPECT_THAT` for expressive and readable assertions.
- Avoid over-specifying; assert only necessary aspects to reduce test brittleness.
- Use `--gtest_stack_trace_depth` to limit stack trace noise if needed.

## Summary

GoogleTest's assertion model offers the flexibility to write expressive, maintainable, and robust tests. By leveraging fatal and non-fatal failures, rich matchers, and support for user-defined predicates and assertions, you can create tests that provide clear feedback and improve debugging efficiency.

---

## See Also

- [Matchers Reference](reference/matchers.md) — Explore the vast array of built-in and custom matchers.
- [Mocking Reference](reference/mocking.md) — How assertions fit into mocking and test validation.
- [Rich Assertions Guide](guides/core-workflows/rich-assertions.md) — Detailed guide on assertion usage and diagnostics.
- [GoogleTest Primer](overview/product-intro-and-value/what-is-googletest.md) — Foundations of the testing framework.

---

## Practical Tips

- For comparing floating-point values, always prefer floating-point specific assertions over `EXPECT_EQ`.
- When comparing C strings, prefer `EXPECT_STREQ` over `EXPECT_EQ` to avoid pointer comparison pitfalls.
- Use `EXPECT_THAT` with matchers to write assertions that read like natural language and deliver better diagnostic messages.
- Include custom failure messages to provide additional context.
- Run tests with `--gtest_break_on_failure` for immediate debugging on failures.

---

This foundation empowers you to write tests that validate your code with precision and clarity, accelerating your development and maintaining confidence in correctness.
