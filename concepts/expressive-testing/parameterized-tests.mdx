---
title: "Parameterized and Typed Tests"
description: "Examines how GoogleTest generalizes tests over multiple data sets and types, making your testing more comprehensive. Details value- and type-parameterization mechanisms, naming/categorization, and typical usage patterns."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write more comprehensive and reusable tests by allowing the generalization of test logic over multiple data sets and types. This documentation focuses on **parameterized and typed tests**, detailing how to apply value-parameterization and type-parameterization to make your testing scalable, expressive, and maintainable.

---

## Why Parameterized and Typed Tests?

Imagine you want to test the same functionality with multiple input values or for different data types without duplicating test code. Writing separate tests for each data variation leads to bloated test code and maintenance burdens. GoogleTest's parameterized and typed tests solve this elegantly by enabling the reuse of test logic across varied parameters or types.

This approach:

- Eliminates redundant test code.
- Increases test coverage by systematically running tests against diverse inputs.
- Enhances clarity by grouping related test variations logically.

---

## Value-Parameterized Tests

### Concept
Value-parameterized tests allow a test fixture to receive different input values, automating repeated test execution across those values.

### Define a Parameterized Fixture

You start by defining a test fixture class derived from `::testing::TestWithParam<T>` where `T` is the type of your input parameter:

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Optional: usual fixture setup here
};
```

This fixture class can access the current test's parameter via the `GetParam()` method.

### Writing Tests with `TEST_P`

Use the macro `TEST_P` (the 'P' stands for parameterized) to define test patterns that use the input parameter:

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}

TEST_P(FooTest, HasBlahBlah) {
  // Another test using GetParam()
}
```

### Instantiating Tests with Parameter Sets

To run the parameterized tests over specific values, use `INSTANTIATE_TEST_SUITE_P` with a **parameter generator** that produces the input values:

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName,
                         FooTest,
                         ::testing::Values("meeny", "miny", "moe"));
```

This runs the tests defined in `FooTest` with the parameters "meeny", "miny", and "moe".

GoogleTest appends the instantiation name as a prefix in test output and filters, distinguishing different parameter sets. For example:

```
InstantiationName/FooTest.DoesBlah/0  // for "meeny"
InstantiationName/FooTest.DoesBlah/1  // for "miny"
```

You can also instantiate with other generators, including:

- `ValuesIn(container)` — iterates values from a container or array
- `Range(start, end [, step])` — generates a sequence of values
- `Bool()` — generates a bool sequence {false, true}
- `Combine(g1, g2, ..., gN)` — Cartesian product of multiple generators

### Example

```cpp
class NumberTest : public ::testing::TestWithParam<int> {};

TEST_P(NumberTest, IsEven) {
  EXPECT_EQ(0, GetParam() % 2);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, NumberTest, ::testing::Values(2, 4, 6));
```

### Custom Parameter Name Generation

You can provide a function or functor to `INSTANTIATE_TEST_SUITE_P` that generates readable test name suffixes based on parameters for better filtering and readability:

```cpp
INSTANTIATE_TEST_SUITE_P(
  MyTests, MyTestSuite, ::testing::Values(1, 2, 3),
  [](const ::testing::TestParamInfo<int>& info) {
    return "Param" + std::to_string(info.param);
  });
```

---

## Typed Tests

### Concept
Typed tests define a test fixture class template parameterized by a type, allowing the same test logic to run with different types. Useful for verifying conformance of multiple implementations or type behaviors.

### Define a Typed Test Fixture

Create a fixture class template:

```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
  // Fixture members
};
```

### Associate Types with the Test Suite

Specify which types the test will run with using the `Types<>` template and `TYPED_TEST_SUITE` macro:

```cpp
using MyTypes = ::testing::Types<char, int, double>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

### Writing Typed Tests with `TYPED_TEST`

Define typed tests referencing the special name `TypeParam` as the current type:

```cpp
TYPED_TEST(FooTest, HandlesDefault) {
  TypeParam value = TypeParam();
  EXPECT_TRUE(SomeCondition(value));
}

TYPED_TEST(FooTest, DoesAction) {
  // Use this-> or TestFixture:: to access fixture members if needed
}
```

### Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 protected:
  T value_{};
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, IsZeroInitially) {
  EXPECT_EQ(this->value_, TypeParam(0));
}
```

---

## Type-Parameterized (Type-Parameterized Suite) Tests

Type-parameterized tests allow you to define abstract test patterns without knowing the type list in advance and instantiate them with different type lists later.

1. Define a fixture template

```cpp
template <typename T>
class FooTest : public ::testing::Test {
  // ...
};
```

2. Declare a type-parameterized test suite

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. Define tests with `TYPED_TEST_P`

```cpp
TYPED_TEST_P(FooTest, DoesStuff) {
  TypeParam val{};
  // test body
}
```

4. Register test names

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesStuff);
```

5. Instantiate with types and a unique prefix

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```

---

## Parameter Generators

GoogleTest provides useful generators for value-parameterized tests:

| Generator       | Description                                                                                              |
| --------------- | -------------------------------------------------------------------------------------------------------- |
| `Range(start, end [, step])` | Yields values from `start` to just before `end`, stepping by `step` (default 1).  |
| `Values(v1, ... )`            | Yields the given values explicitly.                                                                |
| `ValuesIn(container)`         | Yields values from a container or iterator range.                                                   |
| `Bool()`                     | Yields `false` and `true`.                                                                           |
| `Combine(g1, g2, ..., gN)`    | Yields the Cartesian product as tuples from multiple generators `g1`, `g2`, ..., `gN`.               |
| `ConvertGenerator<T>(gen)`    | Casts values from an underlying generator `gen` to another type `T`; useful with custom conversion functions.

---

## Best Practices & Tips

- Prefer `TEST_P` and value-parameterized tests when the variations are data values.
- Use typed tests for verifying behavior across types, e.g., different implementations or fundamental types.
- Provide meaningful test names using the custom name generator argument of `INSTANTIATE_TEST_SUITE_P` to improve result readability.
- When working with complex parameter combinations, use `Combine` to generate all tuples.
- Always instantiate your parameterized tests with `INSTANTIATE_TEST_SUITE_P` to avoid silent failures.
- Remember that a fresh test fixture object is created per test invocation, preserving test isolation.

---

## Common Pitfalls and Troubleshooting

- **No test run warning:** If you define value-parameterized tests but forget to call `INSTANTIATE_TEST_SUITE_P`, GoogleTest will report failures because the test suite has no instantiation.
- **Parameter lifetime:** If your parameter type involves pointers or references, be responsible for managing their lifetime correctly.
- **Test names must be valid:** Custom parameter naming functions must generate unique, non-empty strings containing only ASCII alphanumeric characters or underscore (`_`). Avoid underscores for compatibility.
- **Type compatibility:** For typed tests, the test fixture must be prepared to work correctly with the specified types.

---

## Summary
Value-parameterized and typed tests are powerful techniques to automate and extend your test coverage by reusing the same test logic over different inputs or types. By mastering these, you'll write clearer, more maintainable, and higher-coverage tests.

---

## Reference Links

- [GoogleTest Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [GoogleTest Typed Tests](../advanced.md#typed-tests)
- [Testing Reference - TEST_P and INSTANTIATE_TEST_SUITE_P](../reference/testing.md#TEST_P)
- [Testing Reference - Typed Tests](../reference/testing.md#TYPED_TEST)

---

## Example Code Snippet: Value-Parameterized Test

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEven) {
  EXPECT_EQ(0, GetParam() % 2);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```


## Example Code Snippet: Typed Test

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using TypesToTest = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, TypesToTest);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.IsEmpty());
}

TYPED_TEST(StackTest, CanPushAndPop) {
  this->stack_.Push(TypeParam());
  EXPECT_FALSE(this->stack_.IsEmpty());
}
```
