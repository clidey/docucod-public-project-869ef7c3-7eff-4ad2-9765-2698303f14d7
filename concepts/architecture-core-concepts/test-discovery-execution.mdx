---
title: "Test Discovery and Execution Model"
description: "Describes how GoogleTest discovers tests automatically, organizes them into suites, manages test lifecycle, and runs assertions. Covers how tests are isolated, which mechanisms ensure reproducibility, and the high-level entry and registration flow."
---

# Test Discovery and Execution Model

GoogleTest streamlines your testing workflow by **automatically discovering test cases and tests** in your codebase, organizing them into suites, managing their lifecycle, and running them with reliable assertion checks. This model ensures tests are isolated, repeatable, and informative, supporting your goal of writing fast, robust, and maintainable tests.

---

## Automatic Test Discovery

GoogleTest automatically detects tests during runtime initialization, so you **do not need to manually register or list your tests**.

- When you write tests using the `TEST()`, `TEST_F()`, or `TEST_P()` macros, GoogleTest registers them behind the scenes.
- Each test is assigned a fully qualified name consisting of a test suite name and a test name.

This discovery mechanism lets you focus on writing the test logic without extra boilerplate.

**Example:**

```cpp
TEST(MathUtils, FactorialOfZero) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(MathUtils, FactorialOfPositive) {
  EXPECT_EQ(Factorial(3), 6);
}
```

Both tests belong to the `MathUtils` test suite and will be discovered and executed automatically.

---

## Test Organization: Test Suites and Test Cases

GoogleTest organizes tests into **test suites** which group related tests logically, reflecting your code’s structure.

- A **test suite** corresponds to a collection of related tests, typically aligned with a class or feature.
- Each test inside a suite verifies a specific aspect or behavior.

This structure supports *readability*, *maintainability*, and allows fine-grained test execution.

### Test Suites and Fixtures

- When tests share a common fixture (shared objects or setup/teardown steps), you use the `TEST_F()` macro with a fixture class derived from `testing::Test`.
- This enables you to reuse test data configuration and resource management across tests.

```cpp
class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    queue_.Enqueue(1);
  }

  Queue<int> queue_;
};

TEST_F(QueueTest, IsNotEmpty) {
  EXPECT_NE(queue_.size(), 0);
}

TEST_F(QueueTest, AllowsDequeue) {
  auto element = queue_.Dequeue();
  ASSERT_NE(element, nullptr);
  EXPECT_EQ(*element, 1);
}
```

---

## Test Lifecycle Management

Each test's lifecycle involves the following phases, managed by GoogleTest:

1. **Test Fixture Creation**: A fresh instance of the test fixture class is created per test to ensure isolation.
2. **SetUp()**: Code to prepare the test environment is run.
3. **Test Execution**: The actual test body runs, invoking assertions.
4. **TearDown()**: Cleanup code runs after the test completes.
5. **Fixture Destruction**: The test fixture object is deleted.

This per-test instance model guarantees **tests do not interfere with each other**, supporting repeatability and predictable outcomes.

---

## Assertion Execution and Reporting

- Assertions inside tests check expected outcomes.
- GoogleTest provides **fatal assertions** (e.g., `ASSERT_*`) that abort the current test function on failure and **non-fatal assertions** (e.g., `EXPECT_*`) that allow the test to continue.
- During test execution, GoogleTest tracks assertion results, recording success, nonfatal failures, and fatal failures.

If a test fails or crashes, it's marked as failed, and detailed diagnostic messages include file, line number, and failure reason.

---

## Running Tests: The Execution Flow

Your `main()` function typically calls:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- `InitGoogleTest` parses command-line flags to customize test execution.
- `RUN_ALL_TESTS` runs all discovered tests and returns `0` if all succeed, else `1`.

This design lets you execute the entire test suite or filter tests based on names or other criteria.

---

## Isolation and Reproducibility

GoogleTest ensures every test:

- Runs in isolation with a fresh fixture.
- Does not depend on prior tests.
- Can be run individually for faster debugging.

This isolation eliminates flakiness caused by shared states and supports parallel test execution.

---

## Summary Diagram of Test Discovery and Execution

```mermaid
flowchart TD
  A[Program Start] --> B[InitGoogleTest]
  B --> C{Test Registry}
  C -->|Register TEST()/TEST_F()| D[Test Suites]
  D --> E[Select Tests to Run]
  E --> F[Test Fixture Creation]
  F --> G[SetUp()]
  G --> H[Test Body with Assertions]
  H --> I[TearDown()]
  I --> J[Fixture Destruction]
  J --> K{More Tests?}
  K -->|Yes| F
  K -->|No| L[Test Summary Reporting]
  L --> M[Return Exit Code]
```

---

## Practical Tips and Best Practices

- Use **unique, meaningful test suite and test names** to organize tests clearly.
- Leverage **test fixtures** (`TEST_F`) when tests share common setup.
- Prefer **non-fatal assertions (`EXPECT_*`)** for checks where continuing the test makes sense.
- Always call `testing::InitGoogleTest` before `RUN_ALL_TESTS` in your `main()`.
- Run tests frequently in isolation to catch regressions early.

---

## Troubleshooting Common Scenarios

### Test Not Discovered

- Validate that your test functions use `TEST()`, `TEST_F()`, or `TEST_P()` macros.
- Make sure your `main()` calls `InitGoogleTest` and `RUN_ALL_TESTS`.
- Check for typos in test or suite names.

### Tests Fail or Crash Unexpectedly

- Use detailed error messages to isolate failing assertions.
- Run failing tests in isolation using filters (`--gtest_filter=TestSuite.TestName`).
- Ensure proper setup and teardown in fixtures.

### Tests Affect Each Other

- Confirm each test uses fresh fixture instances.
- Avoid global or static state unless reset explicitly.

---

## Related Topics and Further Reading

- [GoogleTest Primer](../docs/primer.md) — A tutorial on writing your first tests.
- [Assertions and Result Handling](../api-reference/core-testing-apis/assertions.md) — Detailed assertion macros.
- [Mocking and GoogleMock Guides](../guides/getting-started-guides/mocking-basics.md) — For mocking dependencies.
- [Test Case and Suite Definition](../api-reference/core-testing-apis/test-basics.md) — Core test macros.
- [System Architecture Overview](../overview/architecture-concepts/system-architecture.md) — How GoogleTest fits inside your project.

---

## Code Example: Minimal Test Program

```cpp
#include <gtest/gtest.h>

// Simple factorial function to test
int Factorial(int n) {
  return (n <= 1) ? 1 : n * Factorial(n - 1);
}

TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(4), 24);
  EXPECT_EQ(Factorial(5), 120);
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This program automatically discovers the two tests in the `FactorialTest` suite, runs them, and reports their results.
