---
title: "Assertions and Failure Modes"
description: "Explores the types of assertions provided, differentiation between fatal/non-fatal failures, user-defined assertions, and how the system processes and reports errors. Details the extensibility of assertion mechanisms."
---

# Assertions and Failure Modes

GoogleTest provides a rich set of assertion macros that help you verify conditions in your C++ code. These assertions are the fundamental mechanism for reporting test results and errors during test execution. Understanding their types, behavior on failure, error reporting, and extensibility is critical to writing effective and maintainable tests.

---

## Types of Assertions

Assertions in GoogleTest fall into several key categories designed to meet different testing needs. Each assertion macro comes in a pair: an `EXPECT_` variant that generates *non-fatal* failures allowing test continuation, and an `ASSERT_` variant that generates *fatal* failures aborting the current function.

### Basic Assertion Categories

- **Explicit Success and Failure:** Assertions like `SUCCEED()`, `FAIL()`, and `ADD_FAILURE()` directly generate success or failure regardless of code conditions, useful for documenting control flow or signaling explicit failure.

- **Boolean Condition Assertions:** Macros such as `EXPECT_TRUE()`, `ASSERT_FALSE()`, verify Boolean expressions.

- **Binary Comparison Assertions:** These macros compare two values, e.g. `EXPECT_EQ(a, b)`, `ASSERT_GT(x, y)`. They display both the expressions and their evaluated values when failing.

- **String Comparisons:** Specialized macros like `EXPECT_STREQ()` and `EXPECT_STRNE()` compare C strings by value, with case-insensitive versions available.

- **Floating-Point Assertions:** Given the nature of floating-point precision, GoogleTest provides `EXPECT_FLOAT_EQ()`, `EXPECT_DOUBLE_EQ()`, and `EXPECT_NEAR()` to verify approximate equality.

- **Exception Assertions:** These verify whether code throws or does not throw exceptions, e.g. `EXPECT_THROW()`, `ASSERT_NO_THROW()`.

- **Predicate Assertions:** Allow complex predicates to be checked with detailed diagnostic messages, via macros like `EXPECT_PRED1()` and `ASSERT_PRED_FORMAT2()`.

- **Death Assertions:** For validating code that should cause the process to terminate, such as `EXPECT_DEATH()` and `ASSERT_EXIT()`.

### Explicit Success and Failure

These assertions allow you to forcibly mark a test or part of a test as passed or failed:

- `SUCCEED()`: Marks a success. It doesn’t automatically make the test pass if other failures exist but can mark a step clearly.
- `FAIL()`: Immediately generates a fatal failure, aborting the current `void` function.
- `ADD_FAILURE()`: Generates a non-fatal failure, allowing the test to continue executing.
- `ADD_FAILURE_AT(file, line)`: Like `ADD_FAILURE()` but records the failure at the specified file and line.

### Behavior Differences: Fatal vs Non-Fatal Failures

| Failure Type      | Generated By           | Effect on Test Execution          |
|-------------------|-----------------------|----------------------------------|
| Non-fatal failure | `EXPECT_`, `ADD_FAILURE()` | Test execution continues; failure recorded |
| Fatal failure     | `ASSERT_`, `FAIL()`    | Current function returns immediately; failure recorded and test aborted |

> **Key Understanding:** Fatal failures terminate the current function immediately but do **not** abort the entire test program or test suite. This means if you call a subroutine containing an `ASSERT_` that fails, the calling function continues unless you check for failure explicitly.

### Common Macros for Boolean and Comparison Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`
- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

### String-Specific Assertions

Special handling exists for C strings (`const char*`) and wide strings (`wchar_t*`), ensuring proper value comparison rather than pointer equality:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`: Checks both string contents are equal.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`: Checks string contents differ.
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`: Case-insensitive equality.
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`: Case-insensitive inequality.

### Floating-Point Comparisons

Assertions account for floating point precision problems:

- `EXPECT_FLOAT_EQ()` / `ASSERT_FLOAT_EQ()` checks approximate equality of floats to within 4 ULPs.
- `EXPECT_DOUBLE_EQ()` / `ASSERT_DOUBLE_EQ()` checks approximate equality for doubles.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(...)` verify values within an absolute error bound.

These assertions provide clear failure messages indicating the values and the limits exceeded.

### Exception Assertions

Use these to verify exception behavior:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(...)` expects statement throws exception_type.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(...)` expects no exception thrown.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(...)` expects any exception thrown.

### Predicate Assertions

Help in expressing complex conditions with informative messages:

- `EXPECT_PREDn(pred, val1, ..., valn)` / `ASSERT_PREDn(...)` where pred returns bool.
- `EXPECT_PRED_FORMATn(pred_formatter, val1, ..., valn)` where pred_formatter returns a richer `AssertionResult` to customize failure message.

These help diagnose which components of the predicate fail and provide detailed output.

### Death Assertions

Verify that a statement leads to process termination:

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH(...)` run statement in a child process and check termination plus output matches regex.
- `EXPECT_EXIT(statement, predicate, matcher)` verifies exit status satisfies predicate and output matches regex.

These death tests help validate precondition checks and critical failure paths.

---

## Failure and Error Reporting

### Test Part Results

An assertion or explicit failure generates a **TestPartResult** object representing:

- The type of result (success, non-fatal failure, fatal failure, skip)
- The file and line where the failure occurred
- A detailed message with summary and additional context

The GoogleTest framework manages these results centrally, associating them with their tests.

### Fatal vs Non-Fatal Failures Explained

- **Non-Fatal failures** record the problem but allow the test to continue. Useful for verifying multiple conditions in one test.
- **Fatal failures** halt the current function immediately, preventing further execution inside that scope.

Users must design tests considering the impacts of these behaviors.

### Managing Fatal Failure Propagation

Fatal failures (`ASSERT_*`, `FAIL()`) end the current function early but do **not** propagate like exceptions across the call stack. This can lead to subtle errors if callers assume no further test code runs. Three strategies mitigate this:

1. **Check explicitly for failure:** Use `testing::Test::HasFatalFailure()` to detect if a fatal failure happened and return early.

    ```cpp
    Subroutine();
    if (testing::Test::HasFatalFailure()) return;
    ```

2. **Use the `ASSERT_NO_FATAL_FAILURE()` macro:** Wrap calls to subroutines expected not to have fatal failures.

    ```cpp
    ASSERT_NO_FATAL_FAILURE(Subroutine());
    ```

3. **Throwing Listener:** Attach a listener that throws exceptions on fatal failure so that control flow can be caught with standard exception handling techniques (more advanced and requires exceptions to be enabled).

### Scoped Trace for Enhanced Failure Context

Failures inside subroutines can be ambiguous about where they actually happened. GoogleTest provides

- `SCOPED_TRACE(message)`: Adds a trace point which appends file, line, and user message information to failure messages in the current lexical scope.

- `ScopedTrace(file, line, message)`: A more explicit variant letting you specify file and line directly, useful for writing test helpers.

Example:
```cpp
void Sub1(int n) {
  EXPECT_EQ(Bar(n), 1);
  EXPECT_EQ(Bar(n + 1), 2);
}

TEST(FooTest, Bar) {
  SCOPED_TRACE("n=1");
  Sub1(1); // Failures here include "n=1" in the message
  Sub1(9); // No trace
}
```

Nested and concurrent traces are supported, and they provide richer diagnostic information to pinpoint failures.

### Logging Additional Information

Tests can record arbitrary key-value properties using `RecordProperty(key, value)`. These are logged in XML or JSON test reports, helping track custom metadata like performance metrics, configuration info, or environment details.

> **Note:**
> - Properties are recorded as strings.
> - Certain keys (`name`, `status`, `time`, etc.) are reserved by GoogleTest and cannot be used for properties.
> - Properties can be recorded during test execution or in setup/teardown phases.

### Handling Disabled and Skipped Tests

- Tests prefixed with `DISABLED_` are compiled but skipped during normal runs.
- Use the flag `--gtest_also_run_disabled_tests` to include these.
- `GTEST_SKIP()` allows skipping tests dynamically at runtime with an optional message.

### Test Naming and Fixture Consistency Checks

GoogleTest enforces that all tests within the same test suite use the same test fixture class. Mixing `TEST()` and `TEST_F()` or multiple fixtures with the same suite name produces clear runtime failures, helping avoid confusing ambiguous test results.

---

## Extensibility of Assertions and Handling Failures

### Custom Assertion Messages

All assertion macros support streaming additional information using `<<` to provide detailed failure context.

Example:
```cpp
EXPECT_TRUE(condition) << "Additional info: variable x=" << x;
```

This flexibility lets users annotate failures with explanation, variable states, or debug information improving failed test diagnosis.

### Predicate-Format Assertions

If your predicate evaluation involves objects that are hard to stream or you want custom messages, implement a predicate formatter returning `testing::AssertionResult`.

Example:
```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

EXPECT_PRED_FORMAT1(IsEven, value);
```

GoogleTest will print detailed output including the streamed message on failure.

### Fate of Assertions in Helper Functions

- Fatal assertions abort only the current function, not the full test.
- Use `SCOPED_TRACE` or fatal failure detection to propagate failure intent.
- Avoid using fatal assertions in constructors or destructors, as they don’t behave as expected. Instead use `SetUp()` and `TearDown()`.

### Recording Properties during Setup/Teardown

GoogleTest attributes recorded properties set during the test suite setup or tear-down to the respective test suite XML element, making it easy to log global metrics or configuration details for groups of tests.

### Event Listeners and Reporters

GoogleTest allows extension via event listeners to capture and process test events like assertion failures, test start/stop, and program end. Advanced users use this to build custom reporting, visualization tools, or integrate with other systems.


---

## Troubleshooting Common Assertion Scenarios

### Failing a Test but Continuing

Use `EXPECT_*` macros or `ADD_FAILURE()` to register failures without aborting the test early.

### Aborting a Test on Failure

Use `ASSERT_*` macros or `FAIL()` to abort the current function immediately, useful when subsequent code depends on success.

### Catching Failures from Called Functions

GoogleTest doesn't throw exceptions on failure by default, so use `ASSERT_NO_FATAL_FAILURE(statement)` or check `HasFatalFailure()` after subroutine calls.

### Handling Assertions Outside Test Functions

Assertions can be used outside `TEST()` bodies, but fatal assertions (`ASSERT_*`, `FAIL()`) require void return type functions.

### Avoid Inconsistent Test Fixtures

If you get runtime errors about mixed fixtures in one suite, check your usage of `TEST`, `TEST_F`, and fixture classes to ensure consistency.

### Seeing Exact File and Line in Failure

Use `ADD_FAILURE_AT(file, line)` and `FAIL_AT(file, line)` to associate failure with specific locations.

---

## Examples

### Using `EXPECT_EQ` with a Custom Failure Message

```cpp
TEST(MyTest, ChecksValue) {
  int x = ComputeValue();
  EXPECT_EQ(5, x) << "Unexpected value computed in ComputeValue()";
}
```

### Using `ASSERT_NO_FATAL_FAILURE` to Check Subroutines

```cpp
void Helper() {
  ASSERT_EQ(1, Compute(2));
}

TEST(MyTest, DoesSomething) {
  ASSERT_NO_FATAL_FAILURE(Helper());
  // Continue only if Helper() succeeded
}
```

### Propagating Failure Using `HasFatalFailure()`

```cpp
void Process() {
  EXPECT_TRUE(ServerReady());
}

TEST(MyTest, ComplexScenario) {
  Process();
  if (testing::Test::HasFatalFailure()) return;
  // Safe to continue
}
```

### Scoped Trace Usage

```cpp
void ComplexSubroutine(int n) {
  SCOPED_TRACE(testing::Message() << "n=" << n);
  EXPECT_EQ(1, Foo(n));
  ASSERT_EQ(2, Bar(n));
}

TEST(MyTest, UsesSubroutine) {
  for (int i = 0; i < 5; ++i) {
    ComplexSubroutine(i);
  }
}
```

---

For more details on assertions, see the [Assertions Reference](https://github.com/google/googletest/blob/main/docs/reference/assertions.md), and for advanced assertion usage consult the [Advanced Topics](https://github.com/google/googletest/blob/main/docs/advanced.md#using-assertions-in-subroutines) and [Assertion Placement](https://github.com/google/googletest/blob/main/docs/advanced.md#assertion-placement) guides.


---

<AccordionGroup title="Additional Resources">
<Accordion title="Assertion Macros Overview">
[Assertions Reference](https://github.com/google/googletest/blob/main/docs/reference/assertions.md) provides a comprehensive list of all assertion macros.
</Accordion>
<Accordion title="Failure Propagation and Handling">
See [Advanced GoogleTest Topics](https://github.com/google/googletest/blob/main/docs/advanced.md#propagating-fatal-failures) for guidance on correctly propagating fatal failures.
</Accordion>
<Accordion title="Event Listener API">
For extending the test event reporting, see [Extending GoogleTest by Handling Test Events](https://github.com/google/googletest/blob/main/docs/advanced.md#extending-googletest-by-handling-test-events).
</Accordion>
<Accordion title="Common Testing Pitfalls">
The [GoogleTest FAQ](https://github.com/google/googletest/blob/main/docs/faq.md#my-compiler-complains-void-value-not-ignored-as-it-ought-to-be) addresses common assertion misuse and error messages.
</Accordion>
</AccordionGroup>
