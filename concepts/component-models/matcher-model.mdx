---
title: "Matchers: Expressive Validation"
description: "Learn about the matcher model, enabling expressive validation of arguments and results in both assertions and mock expectations. Understand how built-in and custom matchers empower readable and maintainable tests."
---

# Matchers: Expressive Validation

Matchers lie at the heart of GoogleTest and GoogleMock's power, providing a rich and expressive model to validate *arguments* and *results* in your tests. This guide dives into the matcher model, explaining how built-in and custom matchers enable readable, maintainable, and robust tests through flexible argument validation in both assertions and mock expectations.

---

## What Are Matchers?

A **matcher** is a predicate-like object that tests whether a single value satisfies certain conditions you define. They are used everywhere in GoogleTest and GoogleMock to:

- Validate arguments passed to mock functions (`EXPECT_CALL` and `ON_CALL`).
- Assert properties of values within `EXPECT_THAT` and `ASSERT_THAT` macros.

Matchers take a value and return a boolean indicating success or failure, and crucially, they can describe themselves and explain why a match succeeded or failed. This helps GoogleTest generate detailed and informative failure messages that pinpoint precisely what went wrong.

### Why Use Matchers?

Imagine you want to check that a mock method is called with an integer argument equal to 5. You could write:

```cpp
EXPECT_CALL(mock, Foo(5));
```

This is equivalent to using `Eq(5)` matcher, where `Eq` stands for "equals". However, if you want to loosen or tighten the constraints — say allow any argument, or test that the argument is greater than 10, or matches a complex property — you use matchers. They make your expectations both expressive and maintainable.

---

## Using Built-in Matchers

GoogleMock ships with an extensive set of built-in matchers, enabling you to match arguments with fine-grained precision.

### Wildcard Matchers

- `_` — Matches any value of the correct type, useful when you don't care about certain arguments.
- `A<type>()` / `An<type>()` — Match any value of a specified type.

### Generic Comparison Matchers

Simple relational matchers for numbers, enums, pointers, and any type supporting comparison:

| Matcher        | Meaning                   |
|:--------------|:--------------------------|
| `Eq(value)`   | Equal to `value` (`==`)    |
| `Ne(value)`   | Not equal to `value` (`!=`)|
| `Ge(value)`   | Greater or equal (`>=`)    |
| `Gt(value)`   | Greater than (`>`)         |
| `Le(value)`   | Less or equal (`<=`)       |
| `Lt(value)`   | Less than (`<`)            |
| `IsNull()`    | Is a null pointer          |
| `NotNull()`   | Is a non-null pointer      |

They can be used directly in expectation matchers or assertions:

```cpp
EXPECT_CALL(mock, Foo(Ge(10)));  // Argument must be >= 10
EXPECT_THAT(result, Lt(100));      // Assert result < 100
```

### String Matchers

GoogleMock supports a variety of string-related matchers (both narrow and wide strings) to test substrings, prefixes, suffixes, case-insensitive comparison, and regular expressions:

- `StrEq(string)` / `StrNe(string)` — String equality / inequality.
- `StrCaseEq(string)` / `StrCaseNe(string)` — Case-insensitive equality / inequality.
- `HasSubstr(substring)` — Contains the substring.
- `StartsWith(prefix)` — Begins with the prefix.
- `EndsWith(suffix)` — Ends with the suffix.
- `MatchesRegex(regex_pattern)` — Matches the entire regex.
- `ContainsRegex(regex_pattern)` — Contains a match of the regex.
- `WhenBase64Unescaped(matcher)` — Matches base64-encoded strings whose unescaped form matches the matcher.

Example:

```cpp
EXPECT_THAT(name, StartsWith("Mr."));
EXPECT_THAT(message, ContainsRegex("error.*critical"));
```

### Boolean and Pointer Matchers

- `IsTrue()` / `IsFalse()` — Evaluates the Boolean value of the argument.
- `IsNan()` — Detects `NaN` floating-point values.
- `Optional(matcher)` — Matches an optional that contains a value matching the given matcher.
- `VariantWith<T>(matcher)` — Matches a variant holding alternative type `T` with a corresponding value matcher.
- `Ref(variable)` — Matches a reference to a specific variable.

### Container Matchers

Flexible matchers exist for standard containers to check sizes, contents, and element-wise properties:

| Matcher                     | Description                           |
|:----------------------------|:------------------------------------|
| `SizeIs(matcher)`           | Container size matches `matcher`    |
| `BeginEndDistanceIs(matcher)` | Distance between `begin()` and `end()` matches `matcher` (for containers without size).
| `ContainerEq(container)`    | Container exactly equals the given container (with detailed failure info).
| `Contains(element_matcher)` | Container contains at least one element matching `element_matcher`.
| `Contains(element).Times(n)`| Container contains `n` elements matching `element`.
| `Each(element_matcher)`     | All elements match `element_matcher`.
| `ElementsAre(m0, ..., mn)`  | Container has exactly `n+1` elements matching each matcher in order.
| `UnorderedElementsAre(m0, ..., mn)` | Like `ElementsAre` but order does not matter.
| `ElementsAreArray`          | Like `ElementsAre` but takes array or container of matchers or values.
| `UnorderedElementsAreArray` | Like `UnorderedElementsAre` but array or container.
| `Pointwise(m, container)`  | Elements match pairwise using 2-tuple matcher `m`.
| `UnorderedPointwise(m, container)` | Like `Pointwise` ignoring order.
| `WhenSorted(m)`             | Container matches `m` after sorting (with `<`).
| `WhenSortedBy(comparator, m)` | Container matches `m` after sorting with `comparator`.

Example:

```cpp
EXPECT_CALL(mock, Process(VectorThat))(ElementsAre(1, 2, 3));
EXPECT_THAT(my_map, Contains(Key(Ge(5))));
```

### Member Matchers

To evaluate particular fields or properties inside objects passed as arguments:

- `Field(&Class::field, matcher)` — Matches an object whose `field` matches `matcher`.
- `Property(&Class::property, matcher)` — Matches an object whose no-arg const `property()` method matches `matcher`.
- `Key(matcher)` — Matches the `first` element of a `std::pair`.
- `Pair(m1, m2)` — Matches both the `first` and `second` elements of a `std::pair`.
- `Pointee(matcher)` — Matches a pointer that points to a value matching `matcher`.
- `Pointer(matcher)` — Matches a pointer itself with a matcher.
- `Address(matcher)` — Matches the address of an object.
- `WhenDynamicCastTo<T>(matcher)` — Matches when dynamic_cast to `T` succeeds and matches inner matcher.

Example:

```cpp
EXPECT_CALL(mock, Process(Field(&Foo::count, Ge(10))));
EXPECT_THAT(p, Pair(Ge(0), HasSubstr("ok")));
EXPECT_THAT(p, Pointee(Ne(nullptr)));
```

### Multi-argument Matchers

Often you want to validate relationships *between* multiple arguments, not just each separately. The `.With()` clause in `EXPECT_CALL` accepts a matcher on the tuple of all arguments.

GoogleMock provides tuple matchers like:

- `Eq()`, `Ne()`, `Ge()`, `Gt()`, `Le()`, `Lt()` for pairs and tuples.
- `AllArgs(matcher)` — Matches all arguments with a matcher (a shorthand).
- `Args<N1, N2, ...>(matcher)` — Matches only selected arguments.

Example:

```cpp
EXPECT_CALL(mock, Foo(_, _))
    .With(Lt());  // First arg less than second arg
EXPECT_CALL(mock, Bar(_))
    .With(Args<0, 2>(AllOf(Ge(5), Ne(10))));
```

### Composite Matchers

Matchers can be composed logically:

- `AllOf(m1, m2, ...)` — Match if all matchers succeed.
- `AnyOf(m1, m2, ...)` — Match if any matcher succeeds.
- `Not(m)` — Negates matcher `m`.
- `Conditional(cond, m1, m2)` — Matches `m1` if `cond` is true, else `m2`.

Example:

```cpp
EXPECT_CALL(mock, Process(AllOf(Ge(0), Le(100))));
EXPECT_THAT(value, AnyOf(Eq(5), Gt(10)));
EXPECT_THAT(num, Not(Ne(42)));
```

---

## Defining Custom Matchers

If the built-in matchers are insufficient for your scenario, you can write your own with the powerful `MATCHER`, `MATCHER_P`, `MATCHER_P2`, ... macros or implement matcher classes manually.

### Using the `MATCHER` Macros

The `MATCHER(name, description)` macro defines a matcher named `name()` with the given description string. Inside its body, you have access to:

- `arg` — The value being matched.
- `arg_type` — The type of `arg`.
- `result_listener` — An optional stream to explain match details.

Example:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

EXPECT_CALL(mock, Bar(IsEven()));
EXPECT_THAT(value, Not(IsEven()));
```

The description string can use the `negation` boolean to customize messages for positive/negative matches.

### Parameterized Matchers

Use `MATCHER_P(name, param, description)` or `MATCHER_Pn` variants for matchers with parameters:

```cpp
MATCHER_P(HasAbsoluteValue, val, "") {
  return abs(arg) == val;
}

EXPECT_THAT(x, HasAbsoluteValue(10));
```

Description strings should incorporate matcher parameters for readable error output.

### Implementing Matcher Classes Manually

For advanced control and reusability, implement a matcher class with:

- `bool MatchAndExplain(const T& value, std::ostream* listener) const;`
- `void DescribeTo(std::ostream* os) const;`
- `void DescribeNegationTo(std::ostream* os) const;`

Then provide a factory function returning `Matcher<T>` wrapping your class.

Example:

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  explicit DivisibleBy7Matcher(int n) : divisor_(n) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os) *os << "the remainder is " << (n % divisor_);
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }

 private:
  const int divisor_;
};

Matcher<int> DivisibleBy7() {
  return DivisibleBy7Matcher(7);
}
```

This approach offers the cleanest descriptions and match explanation support.

---

## Practical Tips & Best Practices

- **Use `_` to ignore arguments:** Keeps tests focused and flexible.
- **Combine matchers for clarity:** Use `AllOf` and `AnyOf` rather than complex custom predicates.
- **Be mindful when matching containers:** Use `ElementsAre` for ordered checks and `UnorderedElementsAre` when order doesn't matter.
- **Use `Ref(variable)` carefully:** Matches against reference identity; useful for distinguishing specific instances.
- **Be explicit with overloaded methods:** Use `TypedEq` or explicit casting to resolve ambiguities.
- **Write pure, side-effect-free matchers:** gMock may call matchers multiple times or out of order.

---

## Troubleshooting Common Matcher Issues

### Unexpected Match Failure

- Check if the matcher correctly matches the argument type and value.
- Use `ExplainMatchResult()` to see why a match failed with more details.

### Ambiguous Overloaded Function

- Specify matcher parameter types explicitly using `TypedEq<type>(value)`.
- Use wrapper functions or simpler mock interfaces if possible.

### Uninteresting call warnings

- Use `NiceMock` to suppress warnings for calls without expectations.
- Consider defining catch-all expectations with `.Times(AnyNumber())`.

### Complex argument matching

- Use `Args<>` or `.With()` clauses for multi-argument relations.
- Write custom parameterized matchers or combinators.

### Trouble with Move-only types

- Use lambdas or callable objects to provide matching logic instead of `Return()` with move-only return types.

---

## Summary

You now have a powerful tool to express nuanced expectations on mock interactions and assertion validations. From simple equality checks to deep inspections of container contents and multi-argument relationships, matchers let you write robust and maintainable tests.

For even more advanced matchers and examples, explore Google's extensive built-in matchers, the `MATCHER` macro for custom definitions, and combine them with GoogleMock's mocking capabilities to achieve precise test verification.

---

## References & Related Documentation

- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [Using Matchers in GoogleMock Expectations](https://google.github.io/googletest/gmock_cook_book.html#UsingMatchers)
- [Defining Custom Matchers](https://google.github.io/googletest/reference/matchers.html#DefiningMatchers)
- [Writing Your First Test](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)

---

## Example Usage

```cpp
#include <gmock/gmock.h>
using ::testing::Ge;
using ::testing::_;

class MockFoo {
public:
  MOCK_METHOD(void, Process, (int x, const std::string& s), ());
};

TEST(FooTest, ValidatesArguments) {
  MockFoo mock;

  // Expect Process called with first arg >= 10, second arg any string.
  EXPECT_CALL(mock, Process(Ge(10), _));

  mock.Process(15, "hello");  // Succeeds.
  // mock.Process(5, "bye"); // Would fail.
}

// Custom matcher example
MATCHER(IsEven, "is an even number") {
  return (arg % 2) == 0;
}

TEST(FooTest, UsesCustomMatcher) {
  MockFoo mock;
  EXPECT_CALL(mock, Process(IsEven(), _));

  mock.Process(14, "world"); // Succeeds.
  // mock.Process(3, "fail"); // Fails.
}
```

---