---
title: "Parameterized Testing: Values and Types"
description: "Discover how GoogleTest supports value- and type-parameterized test suites, enabling broad coverage with concise test code. This page details the mechanism, benefits, and best practices for parameterized test design."
---

# Parameterized Testing: Values and Types

GoogleTest empowers you to create tests that run multiple times with varying inputs and conditions without duplicating your test code. This capability, called *parameterized testing*, comes in two main forms: value-parameterized tests and type-parameterized tests. This page focuses on the key concepts, practical guidance, and best practices to harness both value- and type-parameterized test suites effectively.

---

## Why Use Parameterized Tests?

Imagine writing a test that verifies a function's behavior on different input values or types. Without parameterized tests, you'd write many similar test cases manually. Parameterized tests simplify this by allowing you to define:

- **Value-Parameterized Tests**, which run the same test logic with different data values.
- **Type-Parameterized Tests**, which run the same test logic across different C++ types.

This approach enables broad test coverage, encourages clean code reuse, and reduces maintenance effort.

---

## Value-Parameterized Testing

Value-parameterized tests run the same test for multiple data inputs easily. This is ideal for data-driven scenarios where your code behavior depends on varying input values.

### Writing Value-Parameterized Tests

1. **Define a Test Fixture Class**

   Your fixture must inherit from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the parameter type you want to test.

   ```cpp
   class MyParamTest : public testing::TestWithParam<int> {
     // Test fixture members, setup/teardown, utilities...
   };
   ```

2. **Write Tests Using `TEST_P` Macro**

   Use `TEST_P` to declare tests that use your fixture. Call `GetParam()` inside the test body to retrieve the current parameter.

   ```cpp
   TEST_P(MyParamTest, HandlesEvenValues) {
     int value = GetParam();
     EXPECT_EQ(value % 2, 0);
   }
   ```

3. **Instantiate Tests with Parameter Generators**

   Use `INSTANTIATE_TEST_SUITE_P` to bind your value parameter set to the test suite. GoogleTest provides *parameter generators* for this purpose.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(EvenNumbers,
                            MyParamTest,
                            testing::Values(2, 4, 6, 8));
   ```

### Parameter Generators

GoogleTest provides several built-in functions to generate parameters:

| Generator                 | Description                                                   |
| ------------------------- | ------------------------------------------------------------- |
| `Range(begin, end [, step])` | Yields values starting from `begin` up to but not including `end`, stepping by `step` (default 1). |
| `Values(v1, v2, ..., vN)` | Yields a fixed list of specified values.                       |
| `ValuesIn(container)`     | Generates values from C-style arrays, STL containers, or iterator ranges. |
| `Bool()`                 | Generates boolean values `false` and `true`.                  |
| `Combine(g1, g2, ..., gN)` | Generates the Cartesian product of multiple generators as `std::tuple`s. |
| `ConvertGenerator<T>(g)` | Converts generated parameters via static cast or custom function to another type. |

### Examples

#### Range Generator

```cpp
INSTANTIATE_TEST_SUITE_P(ZeroToFive, MyParamTest, testing::Range(0, 5));
```

Creates tests with parameter values 0, 1, 2, 3, 4.

#### Values Generator

```cpp
INSTANTIATE_TEST_SUITE_P(SelectValues, MyParamTest, testing::Values(10, 20, 30));
```

Creates tests with parameters 10, 20, and 30.

#### Combine Generator (Multiple Parameters)

Use `test::Combine` to test all combinations of multiple parameter sets.

```cpp
using testing::Combine;
using testing::Values;

class MyMultiParamTest : public testing::TestWithParam<std::tuple<int, bool>> {};

INSTANTIATE_TEST_SUITE_P(Combinations, MyMultiParamTest,
                         Combine(Values(1, 2), Values(true, false))); 
```

This generates 4 test instances for pairs: `(1, true)`, `(1, false)`, `(2, true)`, `(2, false)`.

### Custom Test Names

You can specify a custom test name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P`. The supplied function takes a `TestParamInfo` object, which includes the parameter and its index, and returns a valid string name:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, MyParamTest, testing::Values(100, 200),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This will create test names like `NamedTests/MyParamTest.Value100`.

### Important Best Practices

- Your test parameter type `T` must be copyable.
- If your parameter type is a pointer, manage lifetimes carefully to avoid dangling references.
- Avoid using underscores and non-alphanumeric characters in generated test names.
- Always call `INSTANTIATE_TEST_SUITE_P` at namespace or global scope.
- Remember that parameters are evaluated after `InitGoogleTest()`, allowing initialization in `main()` before tests.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName);` if you define tests but don't instantiate them (typically in libraries).

---

## Type-Parameterized Testing

Type-parameterized tests allow you to run the same test logic across multiple C++ types. This enables verification of interface conformance or generic algorithms for different types without duplicating code.

### Writing Typed Tests

1. **Create a Test Fixture Template**

   Define your test fixture as a template class parameterized on a type and derive it from `testing::Test`.

   ```cpp
   template <typename T>
   class MyTypedTest : public testing::Test {
    public:
     T value_{};
   };
   ```

2. **Associate Types with the Test Suite**

   Use `testing::Types<T1, T2, ...>` to list types, then create a test suite using `TYPED_TEST_SUITE`.

   ```cpp
   using MyTypes = testing::Types<int, double, char>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Write Typed Tests Using `TYPED_TEST`**

   Define tests with `TYPED_TEST`. The type under test is accessible via `TypeParam` inside the test.

   ```cpp
   TYPED_TEST(MyTypedTest, IsDefaultInitialized) {
     TypeParam default_value{};
     EXPECT_EQ(this->value_, default_value);
   }
   ```

### Writing Type-Parameterized Tests (Abstract Tests)

Sometimes you want to define generic type tests once, then instantiate them in multiple translation units or libraries.

1. Define your fixture with `TYPED_TEST_SUITE_P`.
2. Write test patterns with `TYPED_TEST_P`.
3. Register the tests with `REGISTER_TYPED_TEST_SUITE_P`.
4. Instantiate with specific types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

Example:

```cpp
template <typename T>
class MyAbstractTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyAbstractTest);

TYPED_TEST_P(MyAbstractTest, TestCase1) {
  TypeParam val{};
  EXPECT_TRUE(true); // Replace with actual test logic
}

REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, TestCase1);

using MyTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyAbstractTest, MyTypes);
```

---

## Summary of Macros and Classes

| Macro / Class               | Purpose                                  |
|----------------------------|------------------------------------------|
| `TEST_P`                   | Define a value-parameterized test.      |
| `INSTANTIATE_TEST_SUITE_P` | Instantiate a value-parameterized test. |
| `TestWithParam<T>`          | Test fixture base for value-parameterized tests. |
| `TYPED_TEST_SUITE`          | Define types for typed tests.            |
| `TYPED_TEST`                | Define a typed test.                      |
| `TYPED_TEST_SUITE_P`        | Define abstract type-parameterized tests. |
| `TYPED_TEST_P`              | Define test patterns for type-parameterized tests. |
| `REGISTER_TYPED_TEST_SUITE_P` | Register type-parameterized tests.      |
| `INSTANTIATE_TYPED_TEST_SUITE_P` | Instantiate type-parameterized tests.    |

---

## Practical Tips

- When using `Combine()`, the generated sets can balloon in size rapidly. Use it judiciously.
- Custom conversions on parameters can be achieved with `ConvertGenerator<T>`, allowing flexible parameter and fixture types.
- If your test parameter type is complex or does not support streaming, consider writing a custom printer to aid readability in test output.
- Avoid underscores and special characters in test parameter names; GoogleTest requires names to be alphanumeric or underscores only.
- Use the built-in `testing::PrintToStringParamName` for basic parameter name generation; for complex needs, supply a custom naming function.

---

## Troubleshooting

- **No Tests Run or Instantiated:** Ensure that your `INSTANTIATE_TEST_SUITE_P` macro is called in global or namespace scope and that the parameter generators produce values.
- **Duplicate Test Names:** Custom test name generators must produce unique and valid names within an instantiation.
- **Dangling References in Parameters:** When using lambdas in `ConvertGenerator`, ensure that objects outlive the test execution.
- **Parameter Type Copyability:** All parameter types must be copyable unless explicitly managed by the user.

---

## Useful Links and Further Reading

- [Value-Parameterized Tests in Advanced Guide](../advanced.md#value-parameterized-tests)
- [Typed Tests and Type-Parameterized Tests in Advanced Guide](../advanced.md#typed-tests)
- [Parameterized Tests API Reference](../reference/testing.md#TEST_P)
- [Matchers for Custom Parameter Validation](../concepts/component-models/matcher-model.md)
- Example: [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)

---

Mastering parameterized tests unlocks powerful ways to increase your test coverage while keeping code maintainable and elegant. Use value-parameterized tests to cover data variations and type-parameterized tests to ensure your templates or interfaces behave correctly for all relevant types.
