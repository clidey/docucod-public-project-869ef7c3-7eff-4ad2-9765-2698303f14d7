---
title: "Parameterized & Typed Test Models"
description: "Understand the mechanisms behind parameterized and type-parameterized tests. Learn how test generators, instantiation, and type abstraction enable broad and scalable test coverage for diverse code scenarios."
---

# Parameterized & Typed Test Models

Understanding how GoogleTest enables broad and scalable test coverage through parameterized and typed testing models is crucial for writing flexible and maintainable tests. This guide explains the mechanisms behind these advanced testing constructs, focusing on value-parameterized tests, typed tests, and type-parameterized tests—equipping you to design test suites that adapt flexibly to varying input types and values.

---

## Value-Parameterized Tests

Value-parameterized tests allow the execution of the same test logic repeatedly with different input parameters. This approach reduces code repetition and improves test coverage across multiple input scenarios.

### Writing Value-Parameterized Tests

1. **Define a Test Fixture Class:**
   Create a test fixture derived from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the type of your parameter. For convenience, inherit from `testing::TestWithParam<T>`, which bundles both parent classes.

   ```cpp
   class FooTest : public testing::TestWithParam<const char*> {
     // Your fixture setup and utilities here.
   };
   ```

2. **Write Parameterized Tests:**
   Use the `TEST_P` macro to define tests inside the fixture, accessing the current test parameter via `GetParam()`.

   ```cpp
   TEST_P(FooTest, DoesSomething) {
     EXPECT_TRUE(SomeFunction(GetParam()));
   }
   ```

3. **Instantiate the Test Suite:**
   Use `INSTANTIATE_TEST_SUITE_P` to supply actual parameter values, specifying a name, the test suite, and a parameter generator.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       StringValues, FooTest,
       testing::Values("alpha", "beta", "gamma"));
   ```

   This creates three test instances `StringValues/FooTest.DoesSomething/0`, `/1`, and `/2` corresponding to each parameter.

### Parameter Generators

GoogleTest provides built-in generators to produce sequences of test parameters:

- `Range(start, end[, step])`: Generates values from start up to but not including end.
- `Values(v1, v2, ..., vN)`: Enumerates explicit values.
- `ValuesIn(container)`: Generates from iterable containers or arrays.
- `Bool()`: Generates `false` and `true`.
- `Combine(gen1, gen2, ..., genN)`: Produces Cartesian product (tuples) from multiple generators.

Example using combinations:

```cpp
INSTANTIATE_TEST_SUITE_P(
    ComboTests, FooTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

This generates tests for `(1, false)`, `(1, true)`, `(2, false)`, `(2, true)`.

### Custom Names for Parameters

By default, instantiated tests get names with indices (e.g., `/0`, `/1`). You may provide a custom name generator that accepts a `TestParamInfo<T>` and returns a string for each parameter suffix, enhancing readability.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams, FooTest,
    testing::Values(10, 20, 30),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Best Practices and Pitfalls

- **Define `SetUpTestSuite()`/`TearDownTestSuite()` as public** when using parameterized tests.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest)` to suppress errors for uninstantiated parameterized suites.
- Avoid assigning parameters that can't be copied or safely managed.
- Prefer `ValuesIn` over `Values` when handling containers.

---

## Typed Tests

Typed tests repeat the same test logic across a fixed list of types. You write tests once and verify the same behavior applies to all listed types.

### Creating Typed Tests

1. **Define a Fixture Template:**
   Write a class template derived from `testing::Test`.

   ```cpp
   template <typename T>
   class NumericTest : public testing::Test {
    public:
     T value_;
   };
   ```

2. **Associate Types:**
   Declare the type list using `::testing::Types`:

   ```cpp
   using MyTypes = ::testing::Types<int, double, float>;
   TYPED_TEST_SUITE(NumericTest, MyTypes);
   ```

3. **Write Typed Tests:**
   Use the `TYPED_TEST` macro. `TypeParam` refers to the current type.

   ```cpp
   TYPED_TEST(NumericTest, CanAddZero) {
     TypeParam zero = TypeParam();  // Default construct zero value
     EXPECT_EQ(zero + zero, zero);
   }
   ```

4. **Run the tests:**
   Compilation of the translation unit defines and instantiates tests for each type in `MyTypes`.

### Custom Type Names

You may supply a custom name generator class providing `template<typename T> static std::string GetName(int)`, allowing friendly and disambiguated suite names.

Example:

```cpp
class TypeNameHelper {
 public:
  template<typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(NumericTest, MyTypes, TypeNameHelper);
```

---

## Type-Parameterized Tests

Type-parameterized tests are a more flexible variant of typed tests. You declare abstract test patterns without binding them to specific types, and instantiate the patterns later in possibly multiple translation units with various type lists.

### Defining Type-Parameterized Tests

1. **Define a Fixture Template:**
   Like typed tests, define a class template derived from `testing::Test`.

2. **Declare a Type-Parameterized Test Suite:**
   Use `TYPED_TEST_SUITE_P` to indicate your fixture is for type-parameterized tests.

   ```cpp
   template <typename T>
   class AbstractTest : public testing::Test {};

   TYPED_TEST_SUITE_P(AbstractTest);
   ```

3. **Define Tests:**
   Use `TYPED_TEST_P` macro to declare test patterns.

   ```cpp
   TYPED_TEST_P(AbstractTest, WorksCorrectly) {
     TypeParam val{};
     EXPECT_EQ(val + val, val * 2);
   }
   ```

4. **Register Tests:**
   List all test pattern names with `REGISTER_TYPED_TEST_SUITE_P`.

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(AbstractTest, WorksCorrectly);
   ```

### Instantiating Type-Parameterized Tests

In a source or test file, instantiate the type-parameterized test suite:

```cpp
using TypesToTest = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, AbstractTest, TypesToTest);
```

You can instantiate multiple times with different type sets or prefixes to create modular, reusable test patterns.

---

## Key Benefits of Parameterized and Typed Tests

- **DRY Tests:** Write test logic once, avoid duplication.
- **Broad Coverage:** Easily cover multiple input values and types.
- **Modularity:** Decouple test logic definition and instantiation.
- **Clear Test Outputs:** Generated test names communicate parameter values or types clearly.
- **Extensibility:** Support for complex parameter combinations and custom naming.

---

## Troubleshooting and Tips

- Always ensure your test fixture's `SetUpTestSuite()` and `TearDownTestSuite()` methods are public when used with parameterized fixtures.
- If tests fail to instantiate, confirm matching `TEST_P` and `INSTANTIATE_TEST_SUITE_P` macro usage with the same fixture type.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings about parameterized tests without instantiations.
- Beware of dangling references when using `ConvertGenerator` with lambdas capturing temporary parameters.
- Use the GoogleTest reflection API to inspect generated tests and parameter names for validation.

---

## Additional Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [`TEST_P` Macro](../reference/testing.md#TEST_P)
- [`INSTANTIATE_TEST_SUITE_P` Macro](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [`TYPED_TEST_SUITE` and `TYPED_TEST`](../reference/testing.md#TYPED_TEST_SUITE)
- [`TYPED_TEST_SUITE_P` and `TYPED_TEST_P`](../reference/testing.md#TYPED_TEST_SUITE_P)

---

By mastering parameterized and typed testing models, you ensure your tests are flexible, scalable, and maintainable—empowering thorough validation of your C++ code across diverse scenarios with minimal duplication.

---