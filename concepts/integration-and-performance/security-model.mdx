---
title: "Security Model and Test Sandboxing"
description: "Understand the security considerations when running tests, including handling of death tests and sandboxing to avoid unintended side effects. Covers mechanisms for safe execution and handling of fatal errors or exceptions in test code."
---

# Security Model and Test Sandboxing

Understanding security considerations is crucial when running tests with GoogleTest, particularly when dealing with test failures that cause program termination, such as death tests, or when isolating tests to avoid side effects. This guide explores the mechanisms GoogleTest employs to ensure safe execution and containment of fatal errors or exceptions within test code.

---

## Safe Execution Environment

When running tests, especially those that may terminate the program or cause fatal errors, GoogleTest ensures that such events do not cause the entire test suite or process to crash unexpectedly. Instead, the framework isolates these conditions to provide controlled failure reporting and prevent interference with other tests.

### Death Tests and Test Sandboxing

Death tests in GoogleTest allow verification that specific code causes the program to exit or terminate under predefined conditions. To implement this securely and effectively, GoogleTest runs death tests in isolated environments:

- **Separate Processes:** Death tests execute in child processes separate from the main test runner process. This prevents crashes in death tests from terminating the entire test suite.
- **Signal Handling:** The test framework captures signals or exceptions that cause termination, allowing it to assess whether the expected failure happened.

By sandboxing death tests, GoogleTest avoids unintended side effects on other tests and enables clear failure diagnostics.

> **Example:** If you write a death test expecting an assertion failure, GoogleTest runs that test code in a sandboxed subprocess. If the assertion triggers as expected, the test passes; any other outcome fails gracefully.

<Tip>
Always write death tests to be deterministic and avoid side effects that might affect other tests or external resources.
</Tip>

## Uninteresting Calls and Strictness

GoogleMock extends this safety by managing uninteresting (unexpected but allowed) and unexpected mock calls with different strictness policies:

- **NaggyMock:** Prints warnings for uninteresting calls but allows them.
- **NiceMock:** Suppresses warnings for uninteresting calls.
- **StrictMock:** Treats uninteresting calls as test failures.

This allows test authors to control test assertiveness and balance error detection against noise.

## Handling Fatal Failures and Exceptions

GoogleTest carefully handles fatal failures in tests:

- **Fatal vs Non-Fatal Failures:** Fatal failures stop the current test execution immediately, but non-fatal ones allow the test to continue.
- **Exception Support:** When enabled, GoogleTest manages any exceptions thrown during tests, catching them and reporting failures rather than crashing.
- **Test Isolation:** By running tests that may cause fatal failures or exceptions separately, GoogleTest confines adverse effects and ensures overall test suite stability.

## Best Practices for Secure Testing

- **Use Death Tests Judiciously:** Design death tests that clearly specify the expected failure conditions to avoid false positives or false negatives.
- **Isolate Resources:** Avoid global state or external dependencies that could be corrupted by test termination.
- **Control Mock Strictness:** Use `NiceMock`, `NaggyMock`, or `StrictMock` according to the desired level of strictness for uninteresting calls.
- **Explicit Verification:** Use `Mock::VerifyAndClearExpectations()` to assert that mocks fulfill their expectations before test teardown.

<Info>
Sandboxes and isolated execution not only protect the test suite but also improve debugging and maintainability by offering readable, specific failure diagnostics.
</Info>

---

## Summary of Key Mechanisms

| Mechanism                   | Description                                                  |
|-----------------------------|--------------------------------------------------------------|
| Death Test Sandboxing       | Runs death tests in separate processes to isolate failures. |
| Uninteresting Call Policies | Provides adjustable warning/failure behavior for mocks.    |
| Exception and Fatal Failure Handling | Captures and isolates test errors to avoid crashing test runs. |
| Mock Verification Control   | Allows explicit verification and clearing of mock expectations. |

---

## Examples

### Writing a Death Test Safely

```cpp
#include <gtest/gtest.h>

TEST(MyDeathTest, TerminatesOnBadInput) {
  EXPECT_DEATH(
    {
      // Code that should terminate.
      TerminateIfBadInput(-1);
    },
    "Invalid input"
  );
}
```

GoogleTest runs this test in a dedicated subprocess so that the termination does not affect the test runner process.

### Controlling Mock Strictness

```cpp
#include <gmock/gmock.h>

using ::testing::NiceMock;
using ::testing::StrictMock;

class MockFoo {
 public:
  MOCK_METHOD(void, Bar, (), ());
};

TEST(MockTest, NiceMockSuppressesWarnings) {
  NiceMock<MockFoo> mock;
  mock.Bar();  // No warning despite no EXPECT_CALL
}

TEST(MockTest, StrictMockEnforcesCalls) {
  StrictMock<MockFoo> mock;
  // Will fail if Bar() is called without an EXPECT_CALL.
}
```

---

## Troubleshooting

### Common Issues

- **Test Crashes Entire Suite:** Ensure death tests are properly isolated, and avoid calling fatal-terminating code in normal tests.
- **Warnings on Uninteresting Calls:** Use `NiceMock` for quiet testing or define expectations explicitly.
- **Unexpected Exceptions:** Enable exception support in GoogleTest or catch exceptions within test code.

### Recommended Debugging Steps

1. Run tests with increased verbosity (`--gtest_verbose=info`).
2. Isolate problematic tests by running individually.
3. Use death tests only where necessary, carefully specifying expected termination conditions.

---

## Further Reading

- [Death Test API Reference](../api-reference/gtest-core-api/death-tests)
- [GoogleMock Strictness Levels](../concepts/advanced-mechanisms/mock-strictness)
- [Best Practices for Tests with Side Effects](../guides/core-testing-workflows/advanced-assertions-and-matchers)
- [Using Mock Verification Functions](../api-reference/gmock-api/mock-object-construction)

For a complete understanding of GoogleTest’s security and sandboxing mechanisms, refer to the Core Testing Workflows and Mocking architectures documentation.

---

## Diagram: Overview of Test Sandboxing and Mock Call Reactions

```mermaid
flowchart TD
  A[Test Runner] --> B{Test Type}
  B -->|Normal Test| C[Run Test in Main Process]
  B -->|Death Test| D[Run Test in Subprocess (Sandboxed)]

  subgraph Mock Call Handling
    C --> E[Mock Method Called]
    E --> F{Expectation Present?}
    F -->|Yes| G[Check Match & Actions]
    F -->|No| H[Uninteresting Call?]
    H -->|Yes| I{Mock Strictness}
    I -->|Nice| J[Allow Silently]
    I -->|Naggy| K[Warn User]
    I -->|Strict| L[Fail Test]
  end

  G --> M[Perform Action]
  J & K & L --> M
  M --> N[Test Continues or Ends]
```

This diagram highlights how tests categorized as death tests run in isolated subprocesses to avoid crashing the test runner, and how uninteresting mock calls are handled based on mock strictness settings.

---

This guide empowers you to write robust tests that handle security-sensitive scenarios gracefully by leveraging GoogleTest’s built-in sandboxing and strict mocking features.