---
title: "Assertions and Matchers"
description: "Explore the principles behind assertion APIs and matcher composition, including user-defined and built-in assertions. Understand matchers' role in improving test clarity and coverage, and how they enable expressive validation of complex C++ objects and behaviors."
---

# Assertions and Matchers

Explore the principles behind assertion APIs and matcher composition, including user-defined and built-in assertions. Understand matchers' role in improving test clarity and coverage, and how they enable expressive validation of complex C++ objects and behaviors.

---

## Introduction

Assertions and matchers form the core of test validation in GoogleTest, enabling precise and expressive checks of program behavior. Assertions verify conditions during tests and can report failures when expectations are not met. Matchers enhance the expressiveness of assertions by providing flexible criteria for comparing values beyond simple equality.

When combined, they empower you to write tests that clearly declare intent, provide rich failure diagnostics, and maintain robustness as your code evolves.

---

## Assertions Overview

Assertions are macros that cause a test to succeed or fail based on Boolean conditions or value comparisons.

- **Non-fatal Assertions (`EXPECT_`)**: Report errors but allow the test to continue.
- **Fatal Assertions (`ASSERT_`)**: Immediately abort the current test function upon failure.

### Common Assertion Types

- **Boolean Conditions**: `EXPECT_TRUE(condition)`, `EXPECT_FALSE(condition)`
- **Equality/Inequality**: `EXPECT_EQ(val1, val2)`, `EXPECT_NE(val1, val2)`
- **Comparison**: `EXPECT_LT`, `EXPECT_LE`, `EXPECT_GT`, `EXPECT_GE`
- **String Comparisons**: `EXPECT_STREQ`, `EXPECT_STRNE` for C strings, respecting content equality.
- **Floating-Point Comparisons**: `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, and `EXPECT_NEAR` for handling precision nuances.
- **Exception Assertions**: `EXPECT_THROW`, `EXPECT_NO_THROW`, and related macros.
- **Predicate Assertions**: `EXPECT_PRED` variants for custom predicate functions.

### Predicate Formatter Assertions

For complex predicates, `EXPECT_PRED_FORMAT*` macros allow more detailed failure messages, reporting both expression text and argument values.

### Example

```cpp
EXPECT_TRUE(IsPrime(7));  // Check boolean condition
EXPECT_EQ(result, expected_value);  // Check equality
EXPECT_STREQ(str1, str2);  // Compare C strings by content
EXPECT_FLOAT_EQ(calculate(), 3.14f);  // Floating-point comparison
```

---

## Matchers: Enabling Expressive Validations

Matchers describe criteria used in assertions to determine if a value meets the desired conditions. They are akin to predicates but also contain self-describing capabilities to generate clear failure messages.

Matchers support flexible, composable checks such as range tests, container content matching, member validations, and complex logical compositions.

### Advantages of Using Matchers

- **Readability**: Test code reads like English.
- **Maintainability**: Tolerate fine-grained changes without test brittleness.
- **Expressiveness**: Handle complex validation scenarios easily.
- **Detailed Diagnostics**: Provide informative messages explaining why a match failed.

### Using Matchers with Assertions

The `EXPECT_THAT(value, matcher)` macro integrates matchers into assertions for readable tests.

Example:

```cpp
using ::testing::StartsWith;
using ::testing::MatchesRegex;
EXPECT_THAT(my_string, StartsWith("Hello"));
EXPECT_THAT(value, MatchesRegex("\d+ units"));
```

### Common Built-in Matchers

- `Eq(val)`: Equal to `val`.
- `Ne(val)`: Not equal.
- `Lt(val)`, `Le(val)`, `Gt(val)`, `Ge(val)`: Comparison operations.
- `_`: Wildcard, matches anything.
- `Not(matcher)`: Negation.
- `AllOf(m1, m2, ...)`: Logical AND of matchers.
- `AnyOf(m1, m2, ...)`: Logical OR of matchers.
- `Pointee(matcher)`: Matches the dereferenced value of a pointer.
- `Field(&Class::member, matcher)`: Match a member variable.
- `Property(&Class::method, matcher)`: Match the result of a method call.
- Container Matchers: `ElementsAre`, `UnorderedElementsAre`, `Contains`, etc.

### Matcher Composition

Matchers can be combined to express conditions that span multiple fields or properties of an object.

Example:

```cpp
EXPECT_THAT(foo, AllOf(Field(&Foo::id, Eq(5)), Property(&Foo::name, StartsWith("John"))));
```

This asserts that `foo` has `id` equal to 5 and its `name()` starts with "John".

### Custom Matchers

For advanced cases, you can write your own matcher classes or use the `MATCHER` family of macros to define domain-specific validations with personalized failure messages.

Example:

```cpp
MATCHER(IsDivisibleBy7, "is divisible by 7") { return (arg % 7) == 0; }
EXPECT_THAT(value, IsDivisibleBy7());
```

### Parameterized Matchers

You can create matchers that receive parameters using `MATCHER_P`, `MATCHER_P2`, etc.

Example:

```cpp
MATCHER_P(IsInRange, range, "is in range") { return range.contains(arg); }
EXPECT_THAT(x, IsInRange(my_range));
```

---

## How Assertions and Matchers Work Together

- An assertion macro (`EXPECT_THAT`, `ASSERT_THAT`) takes a value and a matcher.
- The matcher tests the value for a match.
- If matching fails, a clear failure message explains the cause.

This model allows flexible testing of various conditions with concise syntax.

---

## Best Practices

- Use matchers to avoid rigid and brittle tests.
- When matching objects, validate only relevant members to focus your tests.
- Employ built-in matchers for common scenarios to reduce boilerplate.
- Write custom matchers for reusable complex checks and rich diagnostics.
- Prefer `EXPECT_` over `ASSERT_` when you want tests to continue despite failures.
- Use `EXPECT_THAT` for advanced, readable conditions instead of simple `EXPECT_EQ` when appropriate.

---

## Troubleshooting Common Situations

- **Matcher Misuse**: Ensure matchers are functionally pure without side effects.
- **Type Conflicts**: Use `SafeMatcherCast` or `MatcherCast` when matching types with implicit conversions.
- **Overloaded Functions**: Disambiguate overloaded mock methods with `Const()` or explicit matcher casts.
- **Uninformative Failures**: Write custom matchers with proper descriptions and `MatchAndExplain` support.

---

## Example: Combining Assertions and Matchers

```cpp
#include <gmock/gmock.h>
using ::testing::Eq;
using ::testing::_;
using ::testing::StartsWith;
using ::testing::ElementsAre;

class MyClass {
 public:
  virtual ~MyClass() = default;
  virtual std::string GetName() const = 0;
  virtual std::vector<int> GetNumbers() const = 0;
};

class MockMyClass : public MyClass {
 public:
  MOCK_METHOD(std::string, GetName, (), (const, override));
  MOCK_METHOD(std::vector<int>, GetNumbers, (), (const, override));
};

TEST(MyClassTest, ChecksNameAndNumbers) {
  MockMyClass mock;
  ON_CALL(mock, GetName()).WillByDefault(Return("Johnny"));
  ON_CALL(mock, GetNumbers()).WillByDefault(Return(std::vector<int>{1, 2, 3}));

  EXPECT_THAT(mock.GetName(), StartsWith("John"));
  EXPECT_THAT(mock.GetNumbers(), ElementsAre(1, 2, _));
}
```

---

## Further Learning and References

- See the [Assertions Reference](/api-reference/core-testing-api/assertions-api) for detailed assertion macros.
- The [Matchers API](/api-reference/core-testing-api/matchers-api) describes the built-in matchers and utilities.
- Google's [gMock Cookbook](docs/gmock_cook_book.md) and [Mocking Reference](docs/reference/mocking.md) offer practical mocking and matcher usage scenarios.
- For deeper exploration of matcher creation, see the custom matcher sections in the gMock Cookbook.

---

## Summary

Assertions and matchers empower rich, expressive, and precise verification of program behavior within GoogleTest. By combining macros that check conditions with flexible matchers, tests communicate clear intent and produce helpful failure diagnostics, thereby improving code quality and maintainability.

Mastering assertions and matchers is foundational for effective testing in C++ with GoogleTest and GoogleMock.
