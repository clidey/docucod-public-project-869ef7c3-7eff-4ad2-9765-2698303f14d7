---
title: "Value-Parameterized and Type-Parameterized Tests"
description: "Examine the conceptual approach to covering combinatorial input spaces using value- and type-parameterized tests. Learn how test instantiation, generators, and type lists work to provide exhaustive test coverage with minimal code duplication."
---

# Value-Parameterized and Type-Parameterized Tests

GoogleTest provides powerful mechanisms to scale your testing across many inputs and types without duplicating test logic: **value-parameterized tests** and **type-parameterized tests**. This guide elucidates these concepts, demonstrating how you can exhaustively cover combinatorial input spaces and various type implementations effectively and efficiently.

---

## Understanding the Need

Imagine testing a function that behaves differently based on an input parameter or a variety of data types. Writing repetitive tests for each case is tedious and error-prone. Parameterized tests automate this by allowing you to define a test once and run it multiple times with different parameters or types.

## Value-Parameterized Tests: Testing Across Input Values

### Concept
Value-parameterized tests let you run the same test logic multiple times, each with a different parameter value. This approach is ideal for data-driven testing, verifying correctness across diverse inputs without code duplication.

### Writing Value-Parameterized Tests

1. **Create a Fixture Class:**
   Derive your test fixture from `testing::TestWithParam<T>`, where `T` is the parameter type (any copyable type).

   ```cpp
   class FooTest : public ::testing::TestWithParam<const char*> {
     // Optional: Additional members and setup
   };
   ```

2. **Define Parameterized Tests with `TEST_P`:**
   Write tests using the `TEST_P` macro, accessing parameters with `GetParam()`.

   ```cpp
   TEST_P(FooTest, WorksForParam) {
     EXPECT_TRUE(foo.Blah(GetParam()));
   }
   ```

3. **Instantiate the Test Suite with Parameters:**
   Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with parameter sequences generated by GoogleTest's generators like `Values()`, `Range()`, or `Combine()`.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(MeenyMinyMoe,
                            FooTest,
                            testing::Values("meeny", "miny", "moe"));
   ```

### Parameter Generators

- **`Values(v1, v2, ... vN)`**: Explicit list of parameter values.
- **`ValuesIn(container or iterator range)`**: Generates parameters from a container or iterator range.
- **`Range(start, end[, step])`**: Generates a sequence of values from `start` to `end - 1`, with an optional `step`.
- **`Bool()`**: Generates `false` and `true`.
- **`Combine(g1, g2, ..., gN)`**: Produces Cartesian product of multiple parameter generators, creating tuples of combined parameters.

### Instantiation Naming

- The first argument in `INSTANTIATE_TEST_SUITE_P` is a unique prefix.
- Test instances generated are named as `<prefix>/<TestSuite>.<TestName>/<index>`.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(Pets, FooTest, testing::Values("cat", "dog"));
// Names generated:
// Pets/FooTest.WorksForParam/0 (for "cat")
// Pets/FooTest.WorksForParam/1 (for "dog")
```

### Advanced Usage

- **Abstract Tests:**
  Define parameterized tests in libraries without instantiation. Users instantiate them later, enabling reusable interface compliance tests.

- **Custom Parameter Names:**
  Provide a function or functor to generate friendly test name suffixes based on parameters.

  ```cpp
  INSTANTIATE_TEST_SUITE_P(
      Custom,
      FooTest,
      testing::Values(1, 2),
      [](const testing::TestParamInfo<int>& info) {
        return "Value_" + std::to_string(info.param);
      });
  ```

- **Suppressing Instantiation Warnings:**
  Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);` to allow test suites without instantiations.

---

## Typed Tests: Testing Across Types Known at Compile-Time

### Concept

Typed tests allow running the same test logic over a fixed set of types defined at compile-time. These tests verify that all types meet the same contract, ideal for testing multiple implementations of a conceptual interface.

### Writing Typed Tests

1. **Define a Fixture Class Template:**

   ```cpp
   template <typename T>
   class FooTest : public testing::Test {
    public:
     // Optional members
     T value_{};
   };
   ```

2. **Define the Type List:**

   ```cpp
   using MyTypes = ::testing::Types<char, int, unsigned int>;
   TYPED_TEST_SUITE(FooTest, MyTypes);
   ```

3. **Write Typed Tests Using `TYPED_TEST`:**
   Inside tests, `TypeParam` is the current type parameter.

   ```cpp
   TYPED_TEST(FooTest, DoesBlah) {
     TypeParam n = this->value_;
     EXPECT_TRUE(/* some check on n */);
   }
   ```

---

## Type-Parameterized Tests: Abstract Tests Over Types

### Concept

Type-parameterized tests are similar to typed tests but defer the choice of types until instantiation—allowing you to define the test pattern once and instantiate it with multiple type lists possibly in different translation units.

### Writing Type-Parameterized Tests

1. **Define a Fixture Class Template:**

   ```cpp
   template <typename T>
   class FooTest : public testing::Test {
     // ...
   };
   ```

2. **Declare the Type-Parameterized Test Suite:**

   ```cpp
   TYPED_TEST_SUITE_P(FooTest);
   ```

3. **Define Tests Using `TYPED_TEST_P`:**

   ```cpp
   TYPED_TEST_P(FooTest, DoesBlah) {
     TypeParam n = 0;
     // test logic
   }

   TYPED_TEST_P(FooTest, HasPropertyA) { ... }
   ```

4. **Register Test Names:**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
   ```

5. **Instantiate with Type Lists:**

   ```cpp
   using MyTypes = ::testing::Types<char, int, unsigned int>;
   INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
   ```

---

## Real-World Scenarios and Best Practices

- Use value-parameterized tests when verifying behavior for multiple input values or configurations.
- Use typed tests when verifying common behavior for multiple types known at compile time.
- Use type-parameterized tests to create flexible test libraries that can be instantiated with different sets of types.
- Always provide meaningful test parameters and avoid overly large Cartesian products that hurt test performance.
- Provide custom parameter name generators to make test output readable and debuggable.

---

## Code Example: Value-Parameterized Test Using Combine

```cpp
enum Color { BLACK, WHITE };

class AnimalTest
    : public testing::TestWithParam<std::tuple<const char*, Color>> {
};

TEST_P(AnimalTest, AnimalLooksNice) {
  auto [animal, color] = GetParam();
  EXPECT_TRUE(IsPretty(animal, color));
}

INSTANTIATE_TEST_SUITE_P(AnimalVariations, AnimalTest,
                         testing::Combine(testing::Values("cat", "dog"),
                                          testing::Values(BLACK, WHITE)));
```

This runs tests for all combinations of animals and colors.

---

## Code Example: Typed Test

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T value_{};
};

using NumericTypes = testing::Types<int, double, float>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, IsZeroInitially) {
  EXPECT_EQ(TypeParam(), this->value_);
}
```

This test runs `IsZeroInitially` for each numeric type.

---

## Troubleshooting Common Pitfalls

- **Failure to Instantiate:** Every `TEST_P` must have a corresponding `INSTANTIATE_TEST_SUITE_P`, or tests will not run, triggering errors. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if intentional.
- **Mismatched Fixture Types:** Tests in the same test suite must use the same fixture type.
- **Custom Parameter Names Must be Unique and Valid:** Names generated must contain only alphanumeric characters or underscores and must be unique across instantiations.
- **Parameter Types Must be Copyable:** Your parameter types need to be copyable and constructible as GoogleTest requires.

---

## Summary

Value-parameterized and type-parameterized tests are essential tools for writing scalable, maintainable, and robust test suites. They enable exhaustive coverage across different inputs and types, making your test code cleaner and your CI runs more powerful.

For efficient usage, balance thoroughness with realistic input sets and prefer meaningful, readable test names to ease debugging.

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [INSTANTIATE_TEST_SUITE_P](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TYPED_TEST_SUITE and TYPED_TEST](../reference/testing.md#TYPED_TEST_SUITE)
- [REGISTER_TYPED_TEST_SUITE_P and INSTANTIATE_TYPED_TEST_SUITE_P](../reference/testing.md#REGISTER_TYPED_TEST_SUITE_P)
- [Custom Parameter Name Generators](../advanced.md#specifying-names-for-value-parameterized-test-parameters)

---

## Links to Examples and Samples

- [Sample 7: Value-Parameterized Tests](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc)
- [Sample 8: Multiple Parameters](https://github.com/google/googletest/blob/main/googletest/samples/sample8_unittest.cc)
- [Sample 6: Typed Tests](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc)


## Pro Tip
If you’re new to parameterized testing, start by implementing simple value-parameterized tests using `Values()` or `Range()`. Once comfortable, explore combining parameters with `Combine()` and managing type-driven tests with `TYPED_TEST` and `REGISTER_TYPED_TEST_SUITE_P`. This progressive mastery ensures clearer, effective test strategy implementation.

---