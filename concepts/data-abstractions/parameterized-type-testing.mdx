---
title: "Parameterized and Typed Tests"
description: "Understand value-parameterized and type-parameterized tests, which allow the same test logic to run over a range of input values and types. Learn about the internal mechanisms that power this expressiveness and how to choose the right parameterization strategy."
---

# Parameterized and Typed Tests

GoogleTest offers powerful mechanisms for running the same test logic over multiple input values or types. This page explains *value-parameterized tests* and *typed tests* (including *type-parameterized tests*), empowering you to write concise, scalable, and maintainable tests that exercise broad input variations without redundancy.

---

## Introduction to Parameterized and Typed Tests

In typical unit testing, writing individual tests for many input values or types leads to bloated, repetitive test code. GoogleTest tackles this by providing:

- **Value-Parameterized Tests:** Run a test multiple times with different input *values*.
- **Typed Tests:** Run the same test logic over different C++ *types*.
- **Type-Parameterized Tests:** Like typed tests, but allow abstract test definitions instantiated with different type lists later, possibly multiple times.

These forms reduce duplication and improve test coverage by exercising code systematically.

---

## Value-Parameterized Tests

### What They Are

Value-parameterized tests enable you to *write a single test fixture* and *test pattern* that runs multiple times with distinct inputs. Use cases include:

- Testing different input values or data combinations.
- Testing parameter-dependent behavior.
- Running tests over multiple implementations via function pointers or factory patterns.

### How to Write Value-Parameterized Tests

1. **Define a Test Fixture**

   Create a class derived from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the type of the test parameter. Usually, derive from the convenience class `testing::TestWithParam<T>`.

   ```cpp
   class FooTest : public ::testing::TestWithParam<int> {
     // Optional members and setup/teardown
   };
   ```

2. **Define Test Patterns Using `TEST_P`**

   Use the `TEST_P` macro to write parameterized test cases within your fixture class.

   ```cpp
   TEST_P(FooTest, DoesBlah) {
     int param = GetParam();  // Access parameter
     EXPECT_TRUE(SomeFunction(param));
   }
   ```

3. **Instantiate the Test Suite with Parameters**

   Use `INSTANTIATE_TEST_SUITE_P` to generate tests by providing:
   - A unique instantiation name prefix.
   - The test suite (fixture) name.
   - A parameter generator (a sequence or set of values).

   GoogleTest provides built-in parameter generators:

   | Generator           | Description                                         |
   |---------------------|-----------------------------------------------------|
   | `Values(...)`       | Specify explicit values to test.                     |
   | `ValuesIn(container)` | Use values from arrays, vectors, or iterator ranges. |
   | `Range(start, end[, step])` | Generate values in a numeric range.               |
   | `Bool()`            | Generate `false` and `true`.                         |
   | `Combine(gen1, gen2, ...)` | Cartesian product of multiple generators.           |

   Example:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(PositiveValues, FooTest, testing::Values(1, 2, 3));
   ```

4. **Optional: Name Your Test Instances**

   You can provide a custom name generator function or use the built-in `testing::PrintToStringParamName` to generate friendly test names based on parameter values.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       NamedInstantiation, FooTest, testing::Values(1, 2, 3),
       testing::PrintToStringParamName());
   ```

### Advanced Usage

- **Combining Parameters:** Use `Combine()` to test combinations of multiple parameters packed as tuples.

- **Abstract Tests:** Define tests in one place and instantiate them with different parameter sets in different translation units to share test logic.

- **Suppress Warnings About Uninstantiated Tests:** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` macro to mark parameterized test fixtures which might not always be instantiated.

### Example

```cpp
class FactorialTest : public testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesCorrectFactorial) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ExpectedFactorialValue(n));
}

INSTANTIATE_TEST_SUITE_P(
    SmallNumbers, FactorialTest, testing::Values(0, 1, 2, 3, 4, 5));
```

This will run the `ComputesCorrectFactorial` test six times with `n` set to `0` through `5`.

---

## Typed Tests

Typed tests allow the same test logic to be executed for different C++ *types* rather than values. Use cases include testing template classes or functions over various type parameters.

### Typed Tests

Typed tests require listing the types *when writing tests*.

#### Writing Typed Tests

1. **Define a Fixture Class Template**

   ```cpp
   template <typename T>
   class MyTypedTest : public testing::Test {
   public:
     T value_{};
   };
   ```

2. **Associate a Type List**

   Use `testing::Types<...>` to provide a list of types, then register it with `TYPED_TEST_SUITE`.

   ```cpp
   using MyTypes = ::testing::Types<int, double, char>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Write Tests Using `TYPED_TEST`**

   Inside test bodies, use the special identifier `TypeParam` to refer to the type parameter.

   ```cpp
   TYPED_TEST(MyTypedTest, DefaultConstructedValueIsZero) {
     TypeParam val = this->value_;
     EXPECT_EQ(val, TypeParam{});
   }
   ```

The test suite will be run once for each type in the list.

### Type-Parameterized Tests

If you want to define tests without knowing the types upfront (for example, in header files) and instantiate them later, *type-parameterized tests* are the solution.

#### Writing Type-Parameterized Tests

1. **Define a Fixture Template**

   ```cpp
   template <typename T>
   class MyTypeParamTest : public testing::Test {
     // ...
   };
   ```

2. **Declare the Test Suite Patterns**

   ```cpp
   TYPED_TEST_SUITE_P(MyTypeParamTest);
   ```

3. **Write Tests Using `TYPED_TEST_P`**

   ```cpp
   TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
     TypeParam val{};
     EXPECT_TRUE(SomeOperation(val));
   }
   ```

4. **Register the Tests**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething);
   ```

5. **Instantiate the Pattern**

   Later (often in .cc files):

   ```cpp
   using MyTypes = ::testing::Types<int, float>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, MyTypeParamTest, MyTypes);
   ```

This approach allows writing reusable test logic that can be instantiated multiple times with different type sets, even across translation units.

---

## Choosing Value-Parameterized vs Typed Tests

### Guidelines

- Use **typed tests** if different implementations can be created the same way by type (e.g., default constructor).
- Use **value-parameterized tests** if constructing instances requires different code or parameters.
- Typed tests show the *type name* in test output on failure, aiding diagnosis.
- Value-parameterized tests show the *parameter index* or name; provide custom naming for usability.
- Typed tests require knowing the complete type list at test definition time.

### Example

Testing multiple class template instantiations:

```cpp
template <typename T>
class QueueTest : public testing::Test { ... };

using QueueTypes = ::testing::Types<std::queue<int>, MyQueue<int>>;
TYPED_TEST_SUITE(QueueTest, QueueTypes);

TYPED_TEST(QueueTest, IsEmptyInitially) {
  TypeParam queue;
  EXPECT_TRUE(queue.empty());
}
```

Alternatively, you might test different queues (or factory functions) via value-parameterized tests.

---

## Best Practices

- Avoid underscores (`_`) in test suite and test names to prevent naming conflicts.
- When using complex parameters, provide custom naming functions for better test identification.
- Remember that each parameterized test runs in a fresh fixture object.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if your test fixture might lack instantiations.
- Prefer `TEST_P` and `TYPED_TEST` macros for clarity and integration.

---

## Sample Code Snippets

### Value-Parameterized Test Example

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest,
                         testing::Values(2, 4, 6, 8));
```

### Typed Test Example

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, HasNonNegativeMax) {
  EXPECT_GE(std::numeric_limits<TypeParam>::max(), 0);
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyOnCreation) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyOnCreation);

using MyContainers = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImplementations, ContainerTest, MyContainers);
```

---

## Summary

Parameterized and typed tests provide elegant tools for running the same test logic across different inputs or types without duplicating code. Whether you need to check functionality over various values or across multiple type implementations, GoogleTestâ€™s mechanisms scale effortlessly.

Use value-parameterized tests when input variations dominate, and typed or type-parameterized tests when verifying template generics or interfaces implemented by different types.

---

## Further Reading and References

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests and Type-Parameterized Tests](../advanced.md#typed-tests)
- [INSTANTIATE_TEST_SUITE_P](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TEST_P Macro](../reference/testing.md#TEST_P)
- [TYPED_TEST and TYPED_TEST_SUITE](../reference/testing.md#TYPED_TEST)
- [GoogleTest FAQ on Typed vs Parameterized Tests](../docs/faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests)
- [Effective Mocking with GoogleMock](guides/advanced-features-and-patterns/effective-mocking.mdx) *(related for mocking across types)*

---

This page bridges fundamental user needs to apply parameterized and typed test patterns effectively, empowering cleaner code, comprehensive coverage, and improved test diagnostics.