---
title: "Value- and Type-Parameterized Testing Models"
description: "See how GoogleTest scales test coverage with value-parameterized and type-parameterized tests—enabling single test definitions to run across a range of values and types for thorough, automated validation."
---

# Value- and Type-Parameterized Testing Models

GoogleTest scales test coverage by enabling you to write tests that run over a range of values or types without duplicating test code. Value-parameterized and type-parameterized tests let you define a single test or test suite that is automatically instantiated multiple times with different input values or types, providing thorough and automated validation of your code across various scenarios.

---

## Value-Parameterized Tests

Value-parameterized tests are designed to run the same test logic with different parameter values, which helps you:

- Cover multiple input scenarios efficiently.
- Test behavior dependent on dynamic flags or configurations.
- Reuse test code without manually duplicating tests.

### How to Write Value-Parameterized Tests

1. **Define a Test Fixture:** Derive a fixture class from `testing::TestWithParam<T>`, where `T` is the type of the parameter. `T` can be any copyable type, including primitive types, complex objects, or tuples.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // Fixture code, setup, teardown, helpers...
};
```

2. **Define Parameterized Tests:** Use the `TEST_P` macro to define tests that will be parameterized. Inside the test body, access the current parameter value with `GetParam()`.

```cpp
TEST_P(MyValueTest, HandlesVariousValues) {
  int value = GetParam();
  EXPECT_TRUE(MyFunction(value));
}
```

3. **Instantiate Test Suites with Parameters:** Use `INSTANTIATE_TEST_SUITE_P` to create instances of the parameterized test suite with specific value sequences generated by one of GoogleTest’s builtin parameter generators such as `Values`, `Range`, `ValuesIn`, `Bool`, `Combine`, or `ConvertGenerator`.

```cpp
INSTANTIATE_TEST_SUITE_P(
  IntValuesSequence, MyValueTest, testing::Values(1, 5, 10));

// Or using a range:
INSTANTIATE_TEST_SUITE_P(
  ZeroToNSequence, MyValueTest, testing::Range(0, 5));
```

#### Common Parameter Generators

| Generator          | Description                                                   |
|--------------------|---------------------------------------------------------------|
| `Range(begin, end)` | Generates sequence `{begin, begin+1, ..., end-1}` (exclusive of end). Supports step value.
| `Values(...)`      | Generates sequence of explicitly listed values.
| `ValuesIn(container)` | Generates sequence from elements in a container or iterator range.
| `Bool()`           | Generates `{false, true}` for Boolean flag testing.
| `Combine(...)`     | Generates Cartesian product of multiple generators (as an std::tuple).
| `ConvertGenerator<T>(...)` | Casts or converts the generated sequence into type `T`.


### Customizing Test Names

The optional last argument of `INSTANTIATE_TEST_SUITE_P` lets you specify a function or functor to generate descriptive test names from parameters.

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedInstantiation, MyValueTest, testing::Values(1, 2, 3),
  [](const testing::TestParamInfo<int>& info) {
    return "Value" + std::to_string(info.param);
  });
```

Test names must be unique and contain only alphanumeric characters and underscores.

### Best Practices & Tips

- Place `INSTANTIATE_TEST_SUITE_P` calls at global or namespace scope, **not** inside functions.
- If you define `TEST_P` but never instantiate with `INSTANTIATE_TEST_SUITE_P`, GoogleTest will report a failure unless you suppress it with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Use `std::tuple` and `Combine` to test multiple varying parameters simultaneously.
- Access the parameter with `GetParam()` inside tests.

---

## Typed Tests

Typed tests allow you to run the same test logic on a fixed list of types. This is useful when you want to test an algorithm or data structure implementation across multiple types and ensure consistent behavior.

### How to Write Typed Tests

1. **Define a Test Fixture Template:** Create a template class derived from `testing::Test`, parameterized on a type.

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_ = T();
  using Container = std::vector<T>;
};
```

2. **Associate Type List:** Use `TYPED_TEST_SUITE` to bind a list of types to your test fixture.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write Typed Tests:** Use `TYPED_TEST` to define the test cases. Use the special identifier `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, DefaultConstructedValueIsZero) {
  TypeParam zero = TypeParam();
  EXPECT_EQ(zero, this->value_);
}
```

Each test will be compiled and run once per type in the list.

### Custom Type Naming

To produce customized names for the instantiated test suites, you can define a naming class with a static templated `GetName(int)` method and pass it as a third argument to `TYPED_TEST_SUITE`.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    if (std::is_same<T, char>::value) return "Char";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices & Tips

- Typed tests are **statically** bound to types you provide at compile time.
- Use `TypeParam` inside test bodies to refer to the type under test.
- `TYPED_TEST` replaces `TEST_F` for typed fixtures.

---

## Type-Parameterized Tests

Type-parameterized tests let you write abstract test logic and instantiate it with different lists of types later, even across translation units. This is ideal when you want to:

- Define interface-contract tests independently from the implementations.
- Allow multiple users or components to instantiate the same test pattern with types they provide.

### Writing Type-Parameterized Tests

1. **Define a Test Fixture Template:** Just like typed tests.

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {
  // ...
};
```

2. **Declare the Test Suite:** Use `TYPED_TEST_SUITE_P` to declare a type-parameterized test suite.

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define Tests:** Use `TYPED_TEST_P` macro instead of `TYPED_TEST`.

```cpp
TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
  TypeParam value = TypeParam();
  // Test logic
}

TYPED_TEST_P(MyTypeParamTest, HasProperty) {
  // ...
}
```

4. **Register Tests:** List all the test names using `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething, HasProperty);
```

5. **Instantiate Test Suites:** In one or more translation units, use `INSTANTIATE_TYPED_TEST_SUITE_P` to instantiate the test suite with a type list.

```cpp
using ImplTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, ImplTypes);
```

### Custom Naming and Multiple Instantiations

- Like typed tests, you can provide a custom naming class when instantiating to generate readable suite names.
- You can instantiate the same test suite multiple times with different type lists.
- Instantiations can be spread over multiple translation units enabling modular testing.

### Best Practices & Tips

- Unlike typed tests, here you do not need the full type list upfront and can define generic test patterns.
- Use `TypeParam` to refer to the current type inside tests.
- Ensure that tests are registered with `REGISTER_TYPED_TEST_SUITE_P` before instantiation.

---

## Summary of User Flow

- Define a test fixture tailored to the parameterization style you want: value-parameterized, typed, or type-parameterized.
- Write test cases using the appropriate macro (`TEST_P`, `TYPED_TEST`, or `TYPED_TEST_P`).
- Instantiate test suites with values or types to generate actual test instances.
- Optionally customize test names for clarity and filtering.

---

## Practical Examples

### Value-Parameterized Test Example

```cpp
class MathTest : public ::testing::TestWithParam<int> {};

TEST_P(MathTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(0, n % 2);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, MathTest, testing::Values(2, 4, 6, 8));
```

### Typed Test Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
 public:
  T container;
};

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, MyTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container.empty());
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class AlgorithmTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(AlgorithmTest);

TYPED_TEST_P(AlgorithmTest, RunsWithoutError) {
  TypeParam obj;
  EXPECT_NO_THROW(obj.Run());
}

REGISTER_TYPED_TEST_SUITE_P(AlgorithmTest, RunsWithoutError);

using ImplTypes = ::testing::Types<ImplementationA, ImplementationB>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, AlgorithmTest, ImplTypes);
```

---

## Troubleshooting & Common Pitfalls

- Forgetting to instantiate a `TEST_P` causes a silent failure; use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress alerts when intentional.
- Name collisions in parameterized test instantiations can cause failures; ensure uniqueness and valid characters in custom name generators.
- When using type-parameterized tests, all test patterns must be registered before instantiation.
- Avoid using fatal assertions in constructors; use `SetUp()` or `TearDown()` methods for assertion logic.

---

## Related Documentation

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for detailed walkthrough.
- [Typed Tests](../advanced.md#typed-tests) for fixed type lists.
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for reusable test patterns.
- [INSTANTIATE_TEST_SUITE_P](reference/testing.md#INSTANTIATE_TEST_SUITE_P) macro reference.
- [TYPED_TEST_SUITE](reference/testing.md#TYPED_TEST_SUITE) and [TYPED_TEST](reference/testing.md#TYPED_TEST) macros.
- [REGISTER_TYPED_TEST_SUITE_P](reference/testing.md#REGISTER_TYPED_TEST_SUITE_P) and [INSTANTIATE_TYPED_TEST_SUITE_P](reference/testing.md#INSTANTIATE_TYPED_TEST_SUITE_P).

---

For real-world best practices, refer to the `guides/practical-testing-patterns/parameterized-testing` and `api-reference/testing-framework/parameterized-and-typed-tests` in this documentation.


---

## Diagram: Test Model Overview

```mermaid
flowchart TD

  subgraph Value-Parameterized Tests
    VPTF[Test Fixture Class (inherits TestWithParam<T>)] --> TEST_P[TEST_P(TestFixture, TestName)]
    TEST_P --> INSTANTIATE[INSTANTIATE_TEST_SUITE_P(InstanceName, TestFixture, ParamGenerator)]
  end

  subgraph Typed Tests
    TTF[Test Fixture Template Class <T>] --> TYPED_TESTS[TYPED_TEST_SUITE(TestFixture, Types)]
    TYPED_TESTS --> TYPED_TESTS_DEF[TYPED_TEST(TestFixture, TestName)]
  end

  subgraph Type-Parameterized Tests
    TPTF[Test Fixture Template Class <T>] --> TYPED_P_DECLARE[TYPED_TEST_SUITE_P(TestFixture)]
    TYPED_P_DECLARE --> TYPED_TEST_P_DEF[TYPED_TEST_P(TestFixture, TestName)]
    TYPED_TEST_P_DEF --> REGISTER[REGISTER_TYPED_TEST_SUITE_P(TestFixture, TestName...)]
    REGISTER --> INSTANTIATE_TYPED[INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestFixture, Types)]
  end

```
