---
title: "Using GoogleMock: Basics"
description: "Introduce core mocking concepts with simple examples, showing how to define mock objects, set up expectations, and validate interactions in your tests. Lays the foundation for advanced mocking scenarios."
---

# Using GoogleMock: Basics

Welcome to your first step in mastering GoogleMock (gMock)—Google’s powerful C++ mocking framework. This guide introduces the essential concepts and workflows to help you define mock objects, set expectations on their behavior, and validate interactions in your tests. By following these instructions, you will gain the foundational skills to write tests that verify how your code interacts with dependencies, enabling robust, maintainable, and fast unit testing.

---

## 1. What Are Mock Objects?

Mock objects simulate components your code depends on, allowing you to test behavior without relying on real implementations. They let you specify:

- Which methods will be called
- With what arguments
- How many times
- In which order
- What those methods should return or do

This interaction-driven testing ensures your code communicates correctly with its collaborators.

### Why Use Mock Objects?
- Remove dependencies on slow or unavailable resources (e.g., databases, network)
- Control and simulate error conditions easily
- Verify that interactions happen as expected

---

## 2. Defining a Mock Class

To create a mock for an interface or abstract class:

1. Derive a class from the interface you want to mock.
2. Use the `MOCK_METHOD` macro to declare mock methods in the public section.
3. For each virtual method, replicate its signature inside `MOCK_METHOD`.
4. Add `(const, override)` qualifiers for const methods to ensure proper overriding.

### Example: Mocking a Simple Interface

Given an interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};
```

You can define your mock as:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

### Important Tips

- Always declare `MOCK_METHOD`s **public**, regardless of original access specifier.
- For methods with comma-containing types (e.g., `std::pair<int, int>`), use either:
  - Type aliases, or
  - Parentheses around the type (e.g., `(std::pair<int, int>)`).
- Add `override` in the macro for strong compiler checks.

---

## 3. Setting Expectations and Actions

After defining your mock class, you create mock objects in your tests and specify what you expect them to receive.

### Typical Workflow:

1. `EXPECT_CALL` — Define expected method calls with argument matchers and cardinalities.
2. Optional: Define method behaviors with `WillOnce` and/or `WillRepeatedly`.
3. Exercise the code under test.
4. Upon mock destruction (or manual verification), gMock asserts that all expectations were met.

### Syntax Overview

```cpp
EXPECT_CALL(mockObject, MethodName(arg_matchers))
    .Times(cardinality)
    .WillOnce(action)
    .WillRepeatedly(action);
```

- `arg_matchers`: Specify expected arguments; use `_` as wildcard.
- `Times()`: Specify number of allowed calls (default is 1).
- `WillOnce()`: Define action to perform once per matching call.
- `WillRepeatedly()`: Action for calls after `WillOnce()`s are used.

### Example:

```cpp
using ::testing::Return;
using ::testing::_;

TEST(PainterTest, DrawsCircle) {
  MockTurtle turtle;

  // Expect PenDown() to be called once or more.
  EXPECT_CALL(turtle, PenDown()).Times(::testing::AtLeast(1));

  // Expect Forward(100) to be called exactly once.
  EXPECT_CALL(turtle, Forward(100)).Times(1);

  // GetX() returns 50 when called.
  EXPECT_CALL(turtle, GetX()).WillOnce(Return(50));

  Painter painter(&turtle);
  painter.DrawCircle(0, 0, 10);
}
```

Once this test executes, if `PenDown()`, `Forward()`, or `GetX()` are called differently than expected, gMock will fail the test with detailed info.

---

## 4. Matchers: Specifying Argument Expectations

Matchers allow fine-grained control over the expected argument values in mock calls.

- `_` matches *any* value (wildcard).
- `Eq(val)` matches exactly `val`.
- `Ge(val)`, `Le(val)`, etc., match based on comparisons.

Example:

```cpp
EXPECT_CALL(turtle, Forward(Ge(50)))  // Expect Forward called with value >= 50.
    .Times(1);
```

You can combine matchers or write your own for complex conditions.

---

## 5. Ordering and Cardinality

### Controlling Call Order

By default, gMock does **not** enforce call order between different expectations.

To require calls occur in a specific order:

```cpp
using ::testing::InSequence;
{
  InSequence seq;
  EXPECT_CALL(mock, FirstMethod());
  EXPECT_CALL(mock, SecondMethod());
}
```

Now `FirstMethod()` must be called before `SecondMethod()`, or the test fails.

### Cardinalities

Specifies how many times a method is expected to run. Common choices:

- `Times(ExactCount)` — expect exact number of calls.
- `Times(AnyNumber())` — allow any number of calls.
- `Times(AtLeast(n))` — at least n calls.

Setting `Times(0)` explicitly forbids any calls.

---

## 6. Different Mock Strictness Modes

When using mock objects, you can control how gMock treats calls that do not match any expectation.

- **NaggyMock** (default): Prints warnings for uninteresting calls.
- **NiceMock**: Suppresses warnings for uninteresting calls.
- **StrictMock**: Treats uninteresting calls as test failures.

Usage:

```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_mock;
StrictMock<MockFoo> strict_mock;
```

Choose the strictness mode that matches your test goals. Recommendations:

- Use **NiceMock** for less noisy tests during development.
- Use **StrictMock** only when you want to strictly enforce all interactions.

---

## 7. Verifying and Resetting Mocks

- Verification happens automatically when a mock is destroyed.
- To verify manually:

```cpp
using ::testing::Mock;
Mock::VerifyAndClearExpectations(&mock_object);
```

- To reset both expectations and default actions:

```cpp
Mock::VerifyAndClear(&mock_object);
```

Do **not** set new expectations after calling verify-and-clear.

---

## 8. Troubleshooting Common Issues

- **Warning: Uninteresting call:** You called a method without expectations. Add `EXPECT_CALL` or use `NiceMock`.
- **Call order violation:** Use sequences (`InSequence`) to enforce order.
- **Too few/many calls:** Check `Times()` clauses; consider `RetiresOnSaturation()` for precise control.
- **Confusing matches with overloaded methods:** Specify argument types clearly or mock all overloads.

---

## 9. Summary of Key Macros and Functions

| Macro / Function     | Purpose                                          |
|---------------------|--------------------------------------------------|
| `MOCK_METHOD`        | Define a mock method in a mock class             |
| `EXPECT_CALL`        | Set expectations for a mock method call          |
| `ON_CALL`            | Define default behavior without setting expectation |
| `NiceMock<T>`        | Suppress warnings for uninteresting calls        |
| `NaggyMock<T>`       | Print warnings (default behavior)                 |
| `StrictMock<T>`      | Treat uninteresting calls as errors               |
| `Mock::VerifyAndClearExpectations` | Manually verify and clear expectations          |

---

## 10. Next Steps

- Explore advanced topics such as:
  - Custom matchers and actions
  - Delegating calls to real or fake objects
  - Using cardinalities for partial orders
  - Mocking tentacles like templates, move-only types, and overloaded methods
- Dive into the [gMock Cookbook](../guides/mocking-and-advanced-testing/setting-expectations-and-actions) for recipes and best practices.
- Consult the [Matchers Reference](../api-reference/assertions-and-matchers/core-matchers) to write expressive expectations.

---

By mastering these basics, you lay a solid foundation for advanced mocking scenarios, giving you confidence in writing robust and precise tests that ensure your code behaves correctly in complex systems.