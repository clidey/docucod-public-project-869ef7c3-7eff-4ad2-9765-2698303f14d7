---
title: "Core Concepts and Terminology"
description: "Master the foundational concepts behind GoogleTest: tests and test suites, assertions, fixtures, mocks, expectations, and parameterized tests. This page introduces the primary vocabulary and connects each term to its practical significance."
---

# Core Concepts and Terminology

## Introduction

Welcome to the foundational guide on the core concepts and terminology behind GoogleTest and GoogleMock. This page is designed to help you master the key vocabulary that underpins the framework, enabling you to write effective and maintainable tests. You'll learn what tests, test suites, assertions, fixtures, mocks, expectations, and parameterized tests are, and understand their practical significance in real testing scenarios.

By fully understanding these terms, you'll unlock the power to better specify, organize, and verify your tests, making your test suites robust and expressive.

---

## Understanding Tests and Test Suites

### What Is a Test?

A *test* is a small piece of code that verifies a specific behavior or functionality in your system. It exercises your code under certain controlled conditions and checks for expected outcomes. In GoogleTest, you write tests using `TEST()` or `TEST_F()` macros, where a test:

- Runs independently from other tests
- Contains assertions that confirm correctness
- Might setup specific preconditions

### What Is a Test Suite?

Tests are grouped into *test suites*—logical collections of related tests. Think of test suites as containers that enable organizing tests by features, components, or functionality. Grouping tests into suites facilitates better management, set-up reuse, and filtered test execution.

GoogleTest supports test suites through naming conventions in `TEST()` and is extended further via *test fixtures* using the `TEST_F()` macro.

---

## Assertions: Verifying Behaviors

*Assertions* are the core mechanism in your tests to check if the behavior of your code matches expectations.

GoogleTest supports two main types:

- **EXPECT_*** : Non-fatal assertions that report failure but allow the test to continue.
- **ASSERT_*** : Fatal assertions that abort the current test upon failure.

Example:

```cpp
EXPECT_EQ(result, expected_value);  // Test continues on failure
ASSERT_TRUE(pointer != nullptr);   // Test halts if null
```

Use assertions to verify equivalence, inequality, throws, or custom predicates, providing detailed feedback on test failures.

---

## Test Fixtures: Reusing Setup

When multiple tests need common setup or teardown steps, you use *test fixtures*. A test fixture is a class derived from `testing::Test` that provides:

- Reusable member variables
- Setup logic via `SetUp()`
- Cleanup logic via `TearDown()`

Example:

```cpp
class QueueTest : public testing::Test {
 protected:
  Queue<int> queue_;

  void SetUp() override {
    queue_.Enqueue(5);
  }
};

TEST_F(QueueTest, SizeIsOneInitially) {
  EXPECT_EQ(queue_.size(), 1);
}
```

Each test using `TEST_F()` gets a fresh instance of the fixture, ensuring isolation.

---

## Mocks: Simulating and Verifying Interactions

### What Is a Mock?

A *mock object* simulates a real object’s interface for testing purposes. Unlike fakes, mocks allow you to:

- Specify *expectations* about which methods will be called
- Define *behaviors* and responses to method calls
- Verify *interactions* such as call order, frequency, and arguments

Mocks are powerful for isolating your tests from dependencies and for testing interaction-based behavior.

### Creating Mocks

You define mock methods using the `MOCK_METHOD` macro inside a mock class that inherits from the interface you are mocking.

Example:

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
};
```

### Expectations: `EXPECT_CALL`

You use `EXPECT_CALL` to specify which calls you expect on a mock object, with what arguments, in what order, and how many times.

Basic syntax:

```cpp
EXPECT_CALL(mock_object, Method(matchers...))
    .Times(cardinality)
    .WillOnce(action)
    .WillRepeatedly(action);
```

Behaviors include what values to return or side effects to perform when the called methods are invoked.

### Default Behavior: `ON_CALL`

`ON_CALL` specifies default actions for methods when no explicit expectation matches. Unlike `EXPECT_CALL`, it doesn’t enforce that the method will be called.

Example:

```cpp
ON_CALL(mock_object, Method(_))
    .WillByDefault(Return(default_value));
```

### Importance of Matchers

*Matchers* define argument expectations for calls. You can specify exact matches or flexible conditions:

- Exact: `EXPECT_CALL(foo, Bar(5))`
- Wildcard: `EXPECT_CALL(foo, Bar(_))`
- Predicates: `EXPECT_CALL(foo, Bar(Ge(10)))`

Using matchers precisely helps avoid brittle or overly strict tests.

---

## Expectations, Cardinalities, and Sequences

### Cardinalities (`Times` Clause)

The `Times()` clause controls how many times an expected call should occur.

Common cardinalities:

| Cardinality  | Meaning                              |
| ------------| -----------------------------------|
| `Exactly(n)`| Called exactly `n` times             |
| `AtLeast(n)`| Called at least `n` times            |
| `AtMost(n)` | Called at most `n` times             |
| `AnyNumber()`| Called any number of times           |

If `Times` is omitted, gMock infers cardinality based on actions.

### Sequences and Ordering

You can specify call order using:

- `InSequence`: Enforces calls to occur strictly in the order declared.
- `After`: Specifies that one call occurs after another.

Example:

```cpp
{
  InSequence seq;
  EXPECT_CALL(mock, Foo());
  EXPECT_CALL(mock, Bar());
}
```

This means `Foo()` must be called before `Bar()`, otherwise the test fails.

### Expectation Retirement

By default, expectations remain active even after being satisfied. Use `.RetiresOnSaturation()` to retire an expectation once its call quota is reached, allowing others to match subsequent calls.

---

## Parameterized Tests and Typed Tests (Overview)

Parameterized and typed tests allow you to run the same test logic over multiple inputs or types, maximizing test coverage with minimal code duplication.

GoogleTest supports these advanced features - you define a test once, specify parameters or types, and GoogleTest runs the test for each.

While details are beyond this page, these allow convenient testing of algorithms or systems against various data without manually duplicating test code.

---

## Recap: Why These Concepts Matter

Understanding the above concepts enables you to:

- Write tests that are clear, maintainable, and expressive
- Verify not just results but how your code interacts with dependencies
- Structure tests for readability and robustness
- Avoid common pitfalls like brittle or over-constrained tests
- Utilize GoogleMock’s power to mock flexibly and debug efficiently

---

## Next Steps

Now that you know the foundational terminology, proceed to:

- [Key Features at a Glance](/gtest_overview/architecture_core_concepts/quick_feature_overview) to see the capabilities of GoogleTest and GoogleMock.
- [Effective Mocking Techniques](/guides/core-workflows/mocking-techniques) to deepen your practical skills in writing and managing mocks.
- [Matchers Reference](reference/core_assertions_matchers/matchers_reference) for a detailed list of argument matchers and their usage.

Explore these resources to build mastery progressively.

---

## Additional Resources

- [Mocking Reference](docs/reference/mocking.md): Detailed explanations and examples for mocking APIs.
- [gMock Cookbook](docs/gmock_cook_book.md): Practical recipes and patterns for using GoogleMock effectively.
- [GoogleTest Primer](docs/primer.md): A broad introduction to GoogleTest concepts, useful for new users.

Use these guides to deepen your understanding and advance your test development proficiency.

---

*This concludes the Core Concepts and Terminology overview. With these fundamentals, you are well equipped to read and write tests with GoogleTest and to utilize GoogleMock's powerful mocking framework.*
