---
title: "Assertion Models and Test Outcomes"
description: "Dive into GoogleTest's powerful assertion framework. Learn the difference between fatal and non-fatal assertions, how assertion results are constructed and aggregated, and the mechanisms for capturing test failures, skips, and successes."
---

# Assertion Models and Test Outcomes

GoogleTest’s assertion framework forms the foundation of its robust testing capabilities. It differentiates between the outcomes of assertions — success, non-fatal failure, fatal failure, and skip — and manages how they influence test execution and reporting.

---

## Understanding Assertion Outcomes

Assertions in GoogleTest serve to verify specific conditions within your tests. Each assertion yields one of the following outcomes:

- **Success**: The condition was met; the test continues as normal.
- **Non-Fatal Failure**: The condition failed, but execution continues within the current test function.
- **Fatal Failure**: The condition failed, and the current test function terminates immediately.
- **Skipped**: The test or assertion has been consciously skipped, typically via `GTEST_SKIP()`.

This outcome determines how GoogleTest manages control flow and records the test status.

### Fatal vs Non-Fatal Failures

- **Fatal Failures**
  - Generated via `ASSERT_*`, `FAIL()`, or similar macros.
  - Immediately abort the current test function.
  - Useful in conditions where proceeding after failure makes little sense (e.g., invalid inputs).

- **Non-Fatal Failures**
  - Generated via `EXPECT_*`, `ADD_FAILURE()`, etc.
  - Allow the current test to continue, reporting multiple failures for richer diagnostics.
  - Preferred when you want to capture all failures in a single test run.

> **Tip:** Use `EXPECT_*` macros to accumulate multiple assertion results in your tests. Switch to `ASSERT_*` when failure makes continuing unsafe or illogical.

### Skipped Tests and Assertions

The `GTEST_SKIP()` macro signals that a test or subtest should be skipped. Skipped parts do not count as failures or successes—they represent intentional avoidance due to unmet preconditions or unsupported configurations.

---

## The `TestPartResult` Object: Capturing Individual Assertions

At the core, GoogleTest models each assertion or explicit success/failure invocation as a `TestPartResult`. This object encapsulates the essential details of a test part outcome:

- **Type**: One of `kSuccess`, `kNonFatalFailure`, `kFatalFailure`, or `kSkip`.
- **Source File and Line Number**: The exact location where the assertion occurred.
- **Summary and Message**: A brief summary extracted from the full failure message, and the full message string.

This design allows users and test infrastructure to query the nature, location, and message related to each assertion.

### Class Overview of `TestPartResult`

```cpp
class TestPartResult {
 public:
  enum Type {
    kSuccess,
    kNonFatalFailure,
    kFatalFailure,
    kSkip
  };

  TestPartResult(Type type, const char* file_name, int line_number,
                 const char* message);

  Type type() const;
  const char* file_name() const;
  int line_number() const;
  const char* summary() const;
  const char* message() const;

  bool skipped() const;
  bool passed() const;
  bool nonfatally_failed() const;
  bool fatally_failed() const;
  bool failed() const;

 private:
  static std::string ExtractSummary(const char* message);
  ...
};
```

- Use `type()` to determine the assertion outcome.
- Use `failed()`, `passed()`, or `skipped()` convenience methods to quickly check the result.

> **Note:** Users should never inherit from `TestPartResult`; its destructor is not virtual.

---

## Aggregating Assertion Results with `TestPartResultArray`

A test function may have multiple assertions. GoogleTest collects these into a `TestPartResultArray` that holds a vector of `TestPartResult` objects.

This array:

- Allows inspection of all assertion results in the test.
- Supports appending new results as assertions execute.
- Can be queried for count and individual results.

```cpp
class TestPartResultArray {
 public:
  void Append(const TestPartResult& result);
  const TestPartResult& GetTestPartResult(int index) const;
  int size() const;

 private:
  std::vector<TestPartResult> array_;
};
```

---

## Reporting Assertion Results

GoogleTest employs a reporting interface for assertions:

```cpp
class TestPartResultReporterInterface {
 public:
  virtual ~TestPartResultReporterInterface() = default;
  virtual void ReportTestPartResult(const TestPartResult& result) = 0;
};
```

The framework's internal implementations use this interface to collect, dispatch, and log assertion results.

---

## User Workflow: How Assertion Outcomes Affect Tests

1. **Writing Assertions**
   - You write `ASSERT_*` or `EXPECT_*` macros in your test bodies.

2. **Execution and Flow Control**
   - When an assertion runs, GoogleTest creates a `TestPartResult` reflecting whether it passed, failed non-fatally, or fatally.
   - Non-fatal failures allow the test to continue; fatal failures abort the test body.
   - Skipped tests are reported via special `TestPartResult`s.

3. **Test Result Aggregation**
   - All `TestPartResult`s for the test are collected in the test’s `TestResult`.
   - The aggregated result determines if the test overall passed, failed, or skipped.

4. **Reporting and Output**
   - GoogleTest uses event listeners to emit detailed or summary information based on the collected `TestPartResult`s.

5. **Advanced Use Cases**
   - Users can query if there are fatal or non-fatal failures within custom code via static functions of the `Test` class (e.g., `Test::HasFatalFailure()`).

---

## Practical Tips and Best Practices

- **Choose assertions carefully:** Use `EXPECT_*` to collect multiple failures, use `ASSERT_*` when subsequent steps depend on a condition.
- **Check for failures in subroutines:** If your helper function may `ASSERT_*` fail, use `ASSERT_NO_FATAL_FAILURE()` macros or check `Test::HasFatalFailure()` afterwards to early-exit safely.
- **Add context with traces:** Use `SCOPED_TRACE()` to add precise contextual information about failures within subroutines or loops.
- **Use `GTEST_SKIP()` judiciously:** Skip tests only when necessary to avoid hiding bugs.
- **Log additional properties:** Use `Test::RecordProperty()` to attach metadata or diagnostic info to tests, fixtures, or environment setup.

---

## Troubleshooting Common Issues

- **Assertions not aborting as expected:** Remember `EXPECT_*` macros do not abort; use `ASSERT_*` if needed.
- **Fatal assertions in non-void functions:** You can only use fatal failure macros (like `ASSERT_*`) in `void`-returning functions. Use `EXPECT_*` or restructure code if needed.
- **Lost failure context in subroutines:** Use `SCOPED_TRACE()` to add contextual traces.
- **Skipped tests appear unexpectedly:** Check if `GTEST_SKIP()` was invoked or if filtering is skipping tests.

---

## Summary

GoogleTest's assertion model revolves around capturing individual assertion outcomes using `TestPartResult` objects that classify success, non-fatal failure, fatal failure, or skip. The test aggregates these results to define overall test statuses, which drive test flow control and reporting. Users interact primarily through assertion macros that manage flow and report detailed diagnostics, supported by APIs and helper macros to control assertion execution and enrich failure messages.

---

## See Also

- [GoogleTest Primer - Assertions](primer.md#assertions)
- [Assertions Reference](reference/assertions.md)
- [GoogleTest Primer - Simple Tests](primer.md#simple-tests)
- [Advanced GoogleTest Topics - More Assertions](advanced.md#more-assertions)
- [Test Fixtures, Environment, and Reporting](api-reference/core-testing-api/test-fixtures-reporting)
- [Catching Failures in Tests](advanced.md#catching-failures)
