---
title: "Parameterized and Typed Tests"
description: "Understand the models behind value-parameterized and type-parameterized tests: how test data is generated and injected, how test suites are instantiated across different parameters or types, and how this approach enables reusable test logic."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write versatile and reusable test logic with **parameterized and typed tests**. These testing models allow injecting different data values or types into test execution, enabling broad validation scopes with minimal code duplication.

This guide breaks down the essential models behind **value-parameterized** and **type-parameterized tests**, showing how data or types are generated, used to instantiate test suites, and how this model facilitates scalable, maintainable test design.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic across different input values or parameters without rewriting the test multiple times.

### The Concept

Imagine you need to verify a function with varying inputsâ€”testing each input individually means duplicating code. Instead, with value-parameterized tests, you write *one* test case that accepts a parameter which varies on each execution.

The core ideas are:

- A **test fixture** inherits from a special interface providing access to parameter values.
- The test logic references the current parameter using `GetParam()`.
- You **instantiate** the test suite with a sequence of parameters; GoogleTest runs one test per parameter value.

### How Test Data is Generated

GoogleTest uses **parameter generators** to supply input data sequences to value-parameterized tests. These generators produce a series of parameters which tests iterate over.

Common generators include:

- **`Values(...)`**: Explicit list of values.
- **`ValuesIn(container)`**: Values from STL containers or C arrays.
- **`Range(start, end [, step])`**: Numeric range generating values from start up to but not including end.
- **`Bool()`**: Only `false` and `true`, useful for flag-like parameters.
- **`Combine(g1, g2, ...)`**: Cartesian product of multiple generators, produces tuples of parameters covering all combinations.

### Fixtures and Test Patterns

Your fixture inherits from `::testing::TestWithParam<T>`, where `T` is your parameter type. You then define tests using the `TEST_P` macro. Inside the test, use `GetParam()` to access the current parameter.

Example:

```cpp
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveValues, FooTest,
    ::testing::Values(1, 2, 3, 10));
```

This will run `IsPositive` four times, once for each value.

### Test Instantiation and Names

`INSTANTIATE_TEST_SUITE_P` creates actual test instances from your test pattern and parameter generator.

- Each instance gets a unique name combining the instantiation name, test suite, test method, and an index or custom suffix based on the parameter.
- You can customize test names by supplying a name generator function.

Example with a custom name generator:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInst, FooTest, ::testing::Range(1, 4),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

This produces test suffixes like `Val1`, `Val2`, etc., resulting in clearer test names.

### Lifecycle and Isolation

For each parameter value, GoogleTest constructs a fresh fixture instance, calls `SetUp()`, runs the test body, then calls `TearDown()`. This ensures isolation between test runs.

### Advanced Usage and Abstract Tests

- You can **define tests in a library**, leaving instantiation to downstream code.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to mark tests that may have no instantiation.
- You may combine multiple parameters via `Combine()` for comprehensive multi-dimensional testing.
- `ConvertGenerator` helps convert generated tuples to user-defined parameter structs.

---

## Typed Tests and Type-Parameterized Tests

When the test logic is the same but you want to verify behavior across multiple *types*, typed tests come into play.

### Typed Tests

Typed tests let you run all tests in a suite against a fixed list of types known at compile time.

Key steps:

1. Define a **test fixture template** parameterized on a type.

2. Declare the list of types you want to test.

3. Use `TYPED_TEST_SUITE` macro to associate the fixture template with the list of types.

4. Define tests with `TYPED_TEST` macro using a special `TypeParam` placeholder to refer to each type.

Example:

```cpp
template <typename T>
class MyContainerTest : public testing::Test {
 public:
  T container;
};

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(MyContainerTest, MyTypes);

TYPED_TEST(MyContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container.empty());
}
```

### Type-Parameterized Tests

Similar to typed tests but allow defining the test logic *without* knowing the type list ahead of time:

- Define the test fixture template and tests using `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`.
- Register the tests using `REGISTER_TYPED_TEST_SUITE_P`.
- Later, instantiate the suite with any list of types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

This enables sharing of generic test suites that multiple clients can reuse with their own type sets.

Example:

```cpp
template <typename T>
class FooTest : public testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  // test logic
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```

---

## How Tests Get Generated and Run

Both value-parameterized and typed tests rely on GoogleTest's internal **test registration system**:

- Test definitions through macros create placeholders linked to test fixtures.
- Instantiation macros create multiple concrete test cases derived from these placeholders, each with a distinct parameter or type.
- At runtime, `RUN_ALL_TESTS()` discovers all registered concrete tests and executes them.

This means one master test pattern translates into many actual tests differing by parameter or type.

The system supports:

- Isolated fixture construction per invocation.
- Unique test names for clarity and filtering.
- Custom parameter naming through user-defined generators.

---

## Practical Tips & Best Practices

- **Use parameterized tests for broad input testing** to reduce code duplication.
- **Choose clear, concise test parameter names** for easier test filtering and reporting.
- **Prefer typed tests when behavior depends on type variations**, especially with template code.
- For complex type-parameterized tests you expect to reuse, **define abstract tests** and instantiate in clients.
- Beware of lifetime issues when using `ConvertGenerator` with lambdas referencing temporary objects.

---

## Summary

Parameterized and typed tests in GoogleTest allow for comprehensive, scalable testing across data and type variations. By defining generalized test logic once and instantiating it across parameters or types, your test suite stays concise and maintainable.

Use the built-in parameter generators and macros (`TEST_P`, `TYPED_TEST`, etc.) to unlock flexible test patterns that fit a wide range of testing needs.

---

## Additional Resources

- [Value-Parameterized Tests (Advanced Guide)](../guides/core_testing_patterns/parameterized_tests.md)
- [Typed and Type-Parameterized Tests (Advanced Guide)](../guides/core_testing_patterns/parameterized_tests.md#typed-and-type-parameterized-tests)
- [Testing Reference - Parameterized and Typed Tests](../api-reference/core-testing-api/parameterized-and-typed-tests.md)
- [Test Macros and Suite Framework](../api-reference/core-testing-api/test-macros-framework.md)
- [GoogleTest Primer](../overview/product-intro-and-value/what-is-googletest.md)

---

## Diagram: Parameterized Test Flow

```mermaid
flowchart TD
  A[Define Fixture Template with Param or Type]
  B[Define Tests Using TEST_P or TYPED_TEST]
  C[Create Parameter/Type Generator]
  D[Instantiate Test Suite (INSTANTIATE_TEST_SUITE_P or INSTANTIATE_TYPED_TEST_SUITE_P)]
  E[GoogleTest Expands Tests for Each Parameter or Type]
  F[RUN_ALL_TESTS Executes All Tests]
  G[Test Fixture Constructed per Test Instance]
  H[Test Body Executes with Current Param or Type]
  I[Test Result and Reporting]

  A --> B --> D
  C --> D
  D --> E --> F
  F --> G --> H --> I
```

---

## Troubleshooting

- **No tests run?** Check if you have instantiated your parameterized tests with `INSTANTIATE_TEST_SUITE_P`.
- **Duplicate test names?** Ensure unique instantiation prefixes and custom parameter naming if necessary.
- **Parameter names invalid?** Test names can only contain alphanumeric characters and underscores; verify your custom namer functions.
- **Dangling references in `ConvertGenerator`?** Avoid lambdas capturing temporary objects; use explicit string lifetimes.

Follow these guidelines to effectively harness the power of parameterized and typed tests in GoogleTest.

---

## Source Code

Browse the implementation of these features for deeper insight:

<Source url="https://github.com/google/googletest" path="googletest/include/gtest/gtest-param-test.h" range="1-220" branch="main" />
<Source url="https://github.com/google/googletest" path="googletest/include/gtest/gtest-typed-test.h" range="1-220" branch="main" />