---
title: "Assertion and Failure Handling"
description: "Learn about the assertion model, including fatal vs. non-fatal failures, user-defined assertions, and reporting. Understand how failures are captured, processed, and surfaced to developers, supporting both robust debugging and continuous integration."
---

# Assertion and Failure Handling

Understanding how GoogleTest handles assertions and failures is essential for writing reliable, maintainable tests. This guide walks you through the core concepts of assertion outcomes, the difference between fatal and non-fatal failures, user-defined assertion tools, and how GoogleTest captures and reports failures to support efficient debugging and integration workflows.

---

## 1. Assertion Model

### 1.1 Types of Assertions

GoogleTest assertions check conditions within your tests and yield one of three outcomes:

- **Success**: Condition is met; test continues normally.
- **Non-Fatal Failure**: Condition failed, but the test continues running, reporting the failure.
- **Fatal Failure**: Condition failed and the current function is immediately aborted. Note that this abort affects only the function containing the assertion, not the entire program.

The two commonly used forms are `EXPECT_*` (non-fatal) and `ASSERT_*` (fatal). Choose between them depending on whether the test can proceed meaningfully after a failure.

### 1.2 Effects of Failure Types

- **Non-Fatal Failures** allow the test to continue, enabling multiple failures to be detected in one test run.
- **Fatal Failures** guarantee early exit from the current test function, preventing further errors or crashes at the cost of halting that specific test’s execution.

> **Tip:** Use `ASSERT_*` when subsequent test code depends on the assertion passing. Use `EXPECT_*` otherwise.

### 1.3 Assertion Macros and Streaming

Assertions support streaming custom failure messages using the `<<` operator, which helps provide detailed context on failures.

```cpp
ASSERT_EQ(x.size(), y.size()) << "Vectors differ in length";
EXPECT_TRUE(is_valid) << "Value is invalid";
```

Any object that can be streamed to an `ostream` (including strings and `wchar_t*` converted to UTF-8) can be used in these messages.

---

## 2. User-Defined Assertions

### 2.1 Boolean Functions as Predicates

Use predicate assertions when you have a Boolean function or functor:

```cpp
bool IsPositive(int n) { return n > 0; }
EXPECT_PRED1(IsPositive, x);
```

If the predicate returns `false`, GoogleTest prints the values of the arguments that led to failure, offering better failure diagnostics than a simple `EXPECT_TRUE`.

### 2.2 Assertions Returning `AssertionResult`

To give richer failure information, write predicates that return `::testing::AssertionResult`:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  else return testing::AssertionFailure() << n << " is odd";
}
EXPECT_TRUE(IsEven(value));
```

This approach prints detailed messages on failure, showing why the predicate failed.

### 2.3 Predicate-Formatter Assertions for Custom Messages

Write predicate-formatters if default messages are unsatisfactory or some arguments are unprintable:

```cpp
testing::AssertionResult AssertPrime(const char* expr, int n) {
  if (IsPrime(n)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " with value " << n << " is not prime";
}
EXPECT_PRED_FORMAT1(AssertPrime, number);
```

This lets you tailor failure messages fully and is best for complex or non-printable test conditions.

---

## 3. Failure Reporting and Propagation

### 3.1 How Failures Are Captured

When an assertion fails, GoogleTest captures the failure details including:<br>- Failure type (fatal or non-fatal)<br>- File name and line number<br>- Failure summary and message<br><br>These are stored internally and later presented to the user in reports.

### 3.2 Run-Time Behavior on Fatal Failures

Fatal failures abort only the current function, not the entire test or program. This behavior helps in cleanup but requires awareness when writing helper functions:

```cpp
void Helper() {
  ASSERT_TRUE(Check());  // Aborts Helper() on failure, but test continues.
  ...
}

TEST(MyTest, Example) {
  Helper();
  // Executes even if Helper() aborted early.
}
```

### 3.3 Controlling Fatal Failure Propagation

- Use `ASSERT_NO_FATAL_FAILURE(statement);` to check if `statement` produces any fatal failures within the same thread and fail if so.
- To detect if a subroutine caused a fatal failure, you can check `testing::Test::HasFatalFailure()`.

These techniques simulate exceptions for aborting whole tests when fatal failures occur in helper functions.

### 3.4 Skipping Tests with `GTEST_SKIP()`

You can dynamically skip tests or entire test suites during runtime when preconditions aren’t met:

```cpp
TEST(MyTest, SkipExample) {
  if (!IsFeatureAvailable()) {
    GTEST_SKIP() << "Skipping because feature is unavailable";
  }
  // Rest of test...
}
```

This allows flexible, runtime control over test execution without failing the test.

---

## 4. Generating Test Execution Reports

GoogleTest aggregates information about test results:<br>- Counts of passed, failed, and skipped assertions<br>- Test execution time<br>- Failure summaries and messages<br>- Properties logged by the user (see next section)

This enables detailed XML and JSON reports for automated tools and CI systems.


## 5. Recording Additional Information with Custom Properties

### 5.1 Using `RecordProperty`

Tests can log custom key/value pairs during execution via `RecordProperty`:

```cpp
RecordProperty("MaxValue", std::to_string(max));
RecordProperty("BuildVersion", "v2.1.0");
```

- Properties logged between fixture `SetUpTestSuite()` and `TearDownTestSuite()` methods appear at the test suite level.
- Properties logged during individual tests appear at the test case level.
- Properties logged outside of tests appear at the global level.

### 5.2 Property Key Restrictions

Keys must be valid XML attribute names and must not conflict with reserved keys like `name`, `status`, `time`, `classname`, etc.

### 5.3 Benefits of Property Logging

These properties enhance automated analysis by attaching additional metadata to tests such as configuration parameters, external system states, or custom diagnostics.

---

## 6. Best Practices and Common Pitfalls

- Always ensure `ASSERT_*` and fatal failures are used only within void-returning functions to avoid compiler errors.
- Use `SCOPED_TRACE` to add contextual information during nested helper function calls for clearer failure diagnostics.
- When designing predicate assertions, prefer returning `AssertionResult` over bare `bool` for richer failure messaging.
- Remember that `ASSERT_*` failures abort only the current function; if you want to halt entire tests on failure from subfunctions, use `ASSERT_NO_FATAL_FAILURE` or check `HasFatalFailure()`.
- Use `GTEST_SKIP()` to skip tests cleanly when runtime conditions make running a test pointless or unsafe.
- Log meaningful properties with `RecordProperty` to provide additional context for failures or test conditions.

---

## 7. Example Usage

```cpp
class MyTestFixture : public testing::Test {
protected:
  void SetUp() override {
    if (!Database::IsAvailable()) {
      GTEST_SKIP() << "Skipping due to missing database";
    }
  }
};

bool IsPositive(int n) {
  return n > 0;
}

testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

TEST_F(MyTestFixture, ChecksValues) {
  int value = ComputeValue();
  EXPECT_PRED1(IsPositive, value);
  EXPECT_TRUE(IsEven(value)) << "Value must be even for this test.";

  ASSERT_NO_FATAL_FAILURE(CheckInvariant());

  RecordProperty("ComputedValue", std::to_string(value));
}
```

This example demonstrates skipping tests, predicate assertions, rich failure messages, and recording custom test properties.

---

## 8. Troubleshooting

### 8.1 Misusing Fatal Assertions

Calling `ASSERT_*` in non-void functions will cause confusing compiler errors. Always use `ASSERT_*` only in void-returning functions or use `EXPECT_*` for non-fatal checks.

### 8.2 Failing to Halt Test on Subfunction Failure

Remember `ASSERT_*` aborts only the current function; employ `ASSERT_NO_FATAL_FAILURE` or `HasFatalFailure()` in the test body to stop execution properly.

### 8.3 Improper Usage of `RecordProperty`

Ensure property keys are valid XML attribute names and avoid using reserved keys to prevent silent failures in property logging.

### 8.4 Skipping Tests Unexpectedly

Use `GTEST_SKIP()` intentionally and verify precondition checks; accidental skips usually indicate unmet runtime conditions.

---

## 9. Additional References

- [GoogleTest Primer – Assertions](../../guides/getting-started/essential-assertions)
- [Assertions Reference](../../api-reference/core-testing-apis/assertions)
- [Advanced GoogleTest Topics – Assertion Placement & Predicate Assertions](../../docs/advanced.md#assertion-placement)
- [Scoped Trace for Adding Context to Assertions](../../docs/advanced.md#adding-traces-to-assertions)
- [Recording Test Properties](../../docs/advanced.md#logging-additional-information)
- [Death Tests and Failure Modes](../../guides/advanced-testing-patterns/death-tests-failure-modes)
- [Writing and Organizing Tests](../../api-reference/core-testing-apis/writing-tests)

---