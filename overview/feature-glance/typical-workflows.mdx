---
title: "Common User Workflows"
description: "Provides a brief tour of the day-to-day user experience: writing a first test, running tests, and interpreting results. Includes reference to 'Getting Started' and directs users toward in-depth primers and sample code."
---

# Common User Workflows

Experience GoogleTest from a user's perspective with a walkthrough of the everyday workflows you'll rely on to write, run, and understand your tests. This page guides you through the essence of the user journey — crafting your first test, executing test suites, and interpreting the results — along with pointers to deepen your understanding and explore sample code.

---

## Your First Test: The Starting Point

Embarking on testing with GoogleTest begins with writing a single, simple test case. Imagine you just created a function in your C++ project, and you want to verify that it behaves correctly.

### Step 1: Include the Testing Framework

Start by including the GoogleTest headers in your test source file:

```cpp
#include <gtest/gtest.h>
```

### Step 2: Write the Test Case

Define a test using GoogleTest's `TEST` macro, which takes two parameters: the test suite name and the test name. For example:

```cpp
TEST(MyFirstTestSuite, HandlesBasicInput) {
  int expected = 42;
  int actual = MyFunction(40, 2);  // The function you want to test
  EXPECT_EQ(expected, actual);     // Assertion verifies the result
}
```

This test checks that `MyFunction` returns 42 when passed parameters 40 and 2. The `EXPECT_EQ` macro performs this assertion, and the test will fail if the actual result deviates.

### Outcome

If your test passes, congratulations! You've created a simple verification. If it fails, GoogleTest will output a detailed error message including the file and line number where the failure occurred.


## Running Tests: From Command Line to IDE

Once you have some tests written, you want to execute them and verify their outcomes rapidly.

### Executing Tests

Run your compiled test binary. GoogleTest detects and runs all tests automatically — no manual test registration needed:

```bash
./my_tests
```

By default, GoogleTest runs all tests and outputs a summary indicating which passed or failed.

### Interpreting Test Results

- Green or "PASSED" messages mean your tests behaved as expected.
- Red or "FAILED" messages highlight failed assertions or other errors.
- Each failure prints the source location, the expected and actual values, and optionally, stacks traces if enabled.

### Using Flags for More Insight

For deeper debugging:

- `--gtest_filter=TestSuiteName.TestName` runs a subset to focus on specific tests.
- `--gtest_catch_exceptions=0` disables exception catching to aid debugging.
- `--gmock_verbose=info` (when working with mocks) reveals detailed mock call information.

### IDE Integration Tips

Many IDEs and editors support running GoogleTest directly, often with clickable links from test failures taking you straight to the failing line of code.


## Interpreting Test Output

GoogleTest reports are designed for clarity:

- **Test suite and test name** clearly indicate which test the output corresponds to.
- **Failure messages** include the expression that failed and the values involved.
- Optional **stack traces** provide context on where failures occurred inside your code.

```text
[ RUN      ] MyFirstTestSuite.HandlesBasicInput
my_test.cc:12: Failure
Expected equality of these values:
  expected
    Which is: 42
  actual
    Which is: 43
[  FAILED  ] MyFirstTestSuite.HandlesBasicInput (0 ms)
```

This level of detail speeds up root cause analysis and test maintenance.


## Leveraging GoogleMock in Your Workflow

When dependencies or collaborators in your system are complex or slow, mocks come in to simplify and speed verification of interactions.

### Basic Workflow with Mocks

1. **Define your mock class** replacing interfaces or collaborators using `MOCK_METHOD` macros.
2. **Set expectations with `EXPECT_CALL`** to specify how mocks should be used.
3. **Exercise your code** under test by passing mocks.
4. **Observe mock verification** automatically when mocks are destroyed.

Example:

```cpp
#include <gmock/gmock.h>
using ::testing::Return;

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
};

TEST(DrawingTest, DrawsLineCorrectly) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown());
  EXPECT_CALL(turtle, Forward(100));

  Painter painter(&turtle);
  painter.DrawLine(100);
}
```

This test checks that `DrawLine()` results in calls to `PenDown()` and `Forward(100)`. If these calls aren’t made, GoogleMock will report errors.


## Quick Reference

| Workflow Stage          | Typical User Actions                                  |
|------------------------|------------------------------------------------------|
| Writing First Test      | Use `TEST` macro to create an assertion-based test. |
| Running Tests           | Execute test binary, use filtering flags to select tests. |
| Reading Results        | Analyze pass/fail output and error details.            |
| Using Mocks             | Define mocks using `MOCK_METHOD`, set expectations, verify interactions. |


## Next Steps and Resources

Step beyond this introductory workflow by exploring:

- [Writing and Running Your First Test](../getting-started/configuration-first-run/write-first-test)
- [Mocking Dependencies with GoogleMock](../guides/core-workflows/mocking-basics)
- [Feature Highlights](../overview/feature-glance/feature-highlights) for a deeper dive into capabilities
- [Sample Tests and Common Workflows](../getting-started/configuration-first-run/test-samples) offering practical examples

---

<Tip>
GoogleTest focuses on ease of use by automatically discovering tests for you, intuitive assertion macros, and clear reporting, empowering you to spend more time improving your code and less time wrestling with your test harness.
</Tip>

<Note>
While this page introduces the user experience at a high level, detailed guides on writing sophisticated tests, mocking techniques, and integration are available and highly recommended.
</Note>

---