---
title: "Feature Overview & Major Workflows"
description: "Take a guided tour of the core and advanced features: test discovery, assertions, grouping tests, parameterization (values and types), death tests, and mocking. See how these empower expressive, maintainable tests in modern C++ Development."
---

# Feature Overview & Major Workflows

Explore the essential and advanced features GoogleTest offers to write expressive, maintainable, and comprehensive C++ tests. This guided tour covers how GoogleTest handles automatic test discovery, a rich set of assertions, flexible test grouping, parameterized testing (both value and type), special death tests, and powerful mocking capabilities. Understanding these features empowers you to build robust testing suites that integrate seamlessly into modern C++ development workflows.

---

## Unlocking GoogleTest's Core Features

GoogleTest simplifies the testing process by automating repetitive tasks and giving you control over test scope and behavior to maximize test clarity and coverage.

### Automatic Test Discovery
GoogleTest automatically discovers tests simply through the use of its provided macros (`TEST()`, `TEST_F()`, `TEST_P()`, `TYPED_TEST()`, etc.) in your codebase. This means there is no manual registration required; all tests are collected and ready to run once you invoke `RUN_ALL_TESTS()`.

This not only saves time but also ensures consistency and reliability in test detection, even across multiple translation units or parameters.

### Rich Assertions for Verification
Assertions form the heart of your tests. GoogleTest presents an extensive collection, enabling you to verify conditions ranging from simple Boolean checks to advanced comparisons:

- Equality and relational checks (`EXPECT_EQ`, `ASSERT_LT`, etc.) that provide detailed diagnostics on failure.
- String comparisons that handle case sensitivity and null pointers.
- Floating-point assertions that consider precision and near-equality.
- Predicate assertions that can test complex user-defined conditions.

Writing assertions with `EXPECT_*` macros allows the test to continue after a failure to detect multiple issues at once, while the `ASSERT_*` variants halt execution to avoid invalid state usages.

### Logical Grouping with Test Suites and Fixtures
Tests are grouped into *test suites* (historically called test cases) by naming conventions, reflecting the structure of your code under test. When multiple tests require shared setup or state, *test fixtures* come into play. Defining fixtures with `TEST_F()` allows reuse of common objects and code, improving readability and maintainability.

### Parameterized Tests: Values and Types
Parameterized tests let you run the same test logic with different data or types, removing tedious duplication.

- **Value-Parameterized Tests (`TEST_P`)**: Run tests multiple times using different input values generated by factories like `Values()`, `Range()`, `ValuesIn()`, `Bool()`, `Combine()`, and the converter `ConvertGenerator()`. Instantiations are declared with `INSTANTIATE_TEST_SUITE_P`, enabling various parameter sequences and combinations.

  ```cpp
  // Define a fixture with an int parameter
  class FooTest : public ::testing::TestWithParam<int> {};

  // Parameterized test accessing the parameter
  TEST_P(FooTest, HandlesValues) {
    int val = GetParam();
    EXPECT_GT(val, 0);
  }

  // Instantiate tests with the Values generator
  INSTANTIATE_TEST_SUITE_P(
      PositiveValues, FooTest,
      ::testing::Values(1, 2, 3, 5));
  ```

- **Type-Parameterized Tests (`TYPED_TEST`)**: Run tests for different types by defining a fixture template parameterized on a type list. This is ideal for testing templates and generic code.

  ```cpp
  template <typename T>
  class MyContainerTest : public ::testing::Test {
   public:
    T container_;
  };

  using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
  TYPED_TEST_SUITE(MyContainerTest, MyTypes);

  TYPED_TEST(MyContainerTest, IsEmptyInitially) {
    EXPECT_TRUE(this->container_.empty());
  }
  ```

These mechanisms provide exhaustive coverage against a broad range of inputs and types without extra boilerplate.

### Death Tests: Testing Error Conditions
Death tests verify that your code properly terminates when encountering fatal errors (e.g., assertions, fatal failures).

They allow you to write tests expecting your program to abort or crash in specific ways, making your tests safer against edge cases and invalid states.

### Mocking: Simulating Interactions
GoogleTest integrates seamlessly with GoogleMock (though covered in separate guides), allowing you to create mock objects and specify expectations. This enables isolation of units of code by simulating dependencies, ensuring tests are both honest and focused.

---

## Feature Highlights at a Glance

### 1. Automatic Test Discovery
- Detects all tests defined with macros in your codebase
- Works across files, parameterized tests, and typed tests

### 2. Assertions
- Broad suite of assertion macros (`EXPECT_*`, `ASSERT_*`)
- Supports detailed diagnostics and custom messages

### 3. Test Suites & Fixtures
- Group tests logically by suite name or test fixture
- Share setup and teardown logic cleanly

### 4. Parameterized Tests
- Value-Parameterized: Generate input data sets with `Values()`, `Range()`, `Combine()`, etc.
- Type-Parameterized: Run tests across various data types
- Custom naming generators for parameterized tests

### 5. Death Tests
- Check that code triggers fatal failures when expected

### 6. Mocking Support
- Use with GoogleMock to create mock interfaces and control dependencies

---

## Real-World Workflow Examples

### Building Data-Driven Tests with Parameterization
Suppose you want to ensure your function works correctly for various input integers. Instead of multiple test cases, you could:

1. Define a value-parameterized test fixture inheriting from `TestWithParam<int>`.
2. Use `TEST_P` to define the test logic.
3. Instantiate the tests with a sequence of values using `Values(1, 2, 3)` or a range.

This approach reduces duplication, improves maintainability, and provides clear test reports with each parameter's outcome.

### Testing Template Classes with Type-Parameterized Tests
For a generic container implementation, validate behavior across different container types:

1. Define a templated fixture.
2. Use `TYPED_TEST_SUITE` to list container types.
3. Use `TYPED_TEST` to define common tests.

GoogleTest runs tests for each specified type, ensuring that your code behaves consistently across container choices.

### Expressing Complex Parameter Sets with Combine
Combine multiple parameter generators to test combinations of flags or inputs:

```cpp
INSTANTIATE_TEST_SUITE_P(
  CombinationTests, FooTest,
  ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

This automatically generates tests for all value pairs (1, false), (1, true), (2, false), (2, true).

---

## Best Practices & Tips

- Prefer `EXPECT_*` over `ASSERT_*` when possible, to reveal multiple failures at once.
- Parameterize tests to avoid duplicating similar logic differing only in data or types.
- Use custom name generators in parameterized tests to get clear, descriptive test names.
- Leverage fixtures' `SetUpTestSuite` and `TearDownTestSuite` for heavy setup shared by all tests in a suite.
- Use death tests sparingly and only when verifying fatal error conditions.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Troubleshooting Topics">
<Accordion title="Parameterized Tests Not Instantiating">
Ensure you have corresponding `INSTANTIATE_TEST_SUITE_P` calls for every `TEST_P` suite unless explicitly allowed with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
</Accordion>
<Accordion title="Test Names Not What I Expect">
Use custom parameter name generators or `PrintToStringParamName` to control how parameter values appear in test names.
</Accordion>
<Accordion title="Death Test Failures"
>
Make sure death tests run isolated and are supported on your platform. Verify that expected patterns for expected failures are correct.
</Accordion>
</AccordionGroup>

---

## Getting Started Preview

To start using these features, you should:

- Include `<gtest/gtest.h>` in your test source files.
- Write simple tests with `TEST()` and `TEST_F()`.
- Progress to value-parameterized tests with `TEST_P` and instantiate with `INSTANTIATE_TEST_SUITE_P` using generators like `Values()`, `Range()`, or `Combine()`.
- For templates and generic code, use typed tests with `TYPED_TEST_SUITE` and `TYPED_TEST`.
- Consult related pages for detailed guidance on writing your first tests, parameterization, and mocks.

Next steps:

- [Getting Started: Building with CMake and Bazel](/guides/core-workflows/getting-started-cmake-bazel)
- [Writing and Running Your First Tests](/guides/core-workflows/writing-first-tests)
- [Organizing Test Suites and Test Discovery](/guides/core-workflows/organizing-test-suites)

For advanced usage:

- [Parameterized and Type-Parameterized Tests](/guides/advanced-testing-strategies/parameterized-and-typed-tests)
- [Death Tests and Failure Handling](/guides/advanced-testing-strategies/death-and-failure-tests)
- [Mocking C++ Objects with GoogleMock](/guides/advanced-testing-strategies/mocking-with-googlemock)

---

## Diagram: Major Workflows Overview

```mermaid
flowchart TD
  A[Write Tests] --> B{Type of Test}
  B -->|Simple| C[Use TEST()]
  B -->|Fixture| D[Use TEST_F() with Test Fixture]
  B -->|Value-param| E[Define TEST_P & Use INSTANTIATE_TEST_SUITE_P]
  B -->|Type-param| F[Define TYPED_TEST_SUITE & TYPED_TEST]

  E --> G[Use Parameter Generators (Values, Range, Combine)]
  G --> H[Custom Name Generators Optional]

  D & C & F --> I[Run Tests via RUN_ALL_TESTS()]

  subgraph Specialized Tests
    J[Death Tests]
    K[Mocking with GoogleMock]
  end

  I --> L[Get Results, Debug Failures]

  style J fill:#f9f,stroke:#333,stroke-width:2px
  style K fill:#f9f,stroke:#333,stroke-width:2px
```

---

For complete details on each feature and how to apply them, please consult the dedicated guides and the API reference.

---