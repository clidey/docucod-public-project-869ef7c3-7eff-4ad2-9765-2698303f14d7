---
title: "Key Features at a Glance"
description: "Summarizes the most important features including xUnit-style testing, test discovery, expressive assertions, user-definable assertions, mocking, value- and type-parameterized tests, and robust test running options."
---

# Key Features at a Glance

Discover the fundamental capabilities that make GoogleTest a powerful and versatile C++ testing framework. Whether you're writing unit tests, integration tests, or advanced test scenarios, GoogleTest equips you with a rich set of features designed to streamline your test creation, execution, and maintenance.

---

## Comprehensive xUnit-Style Testing

GoogleTest builds on the proven xUnit architecture, allowing you to write independent, repeatable tests grouped logically into test suites. Each test runs in isolation with automatic setup and teardown support, helping you ensure consistent results and quick diagnosis of failures.

### Highlights:
- Define individual tests easily with the `TEST()` macro.
- Group related tests into test suites using consistent naming.
- Use test fixtures (`TEST_F()`) for shared setup to avoid duplication.

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

class QueueTest : public testing::Test {
 protected:
  Queue<int> queue_;
  void SetUp() override {
    queue_.Enqueue(1);
  }
};

TEST_F(QueueTest, DequeueWorks) {
  int* val = queue_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, 1);
  delete val;
}
```

## Automatic Test Discovery

Forget about manually listing tests. GoogleTest registers your tests automatically, so when you run `RUN_ALL_TESTS()`, every defined test in your linked modules executes without extra configuration.

- Supports tests across multiple source files.
- Enables selective test execution via filtering (`--gtest_filter`).
- Allows listing all tests (`--gtest_list_tests`) for inspection.

## Expressive and Customizable Assertions

GoogleTest provides an extensive collection of assertions to check conditions in your code and display informative diagnostics when failures happen.

- Fatal (`ASSERT_`) vs. non-fatal (`EXPECT_`) assertions offer control over test flow.
- Wide variety of assertions: equality, relational, string, floating-point comparisons, and more.
- Supports custom failure messages via stream operators.

```cpp
EXPECT_EQ(vector1.size(), vector2.size()) << "Vectors size mismatch";
for (size_t i = 0; i < vector1.size(); i++) {
  EXPECT_EQ(vector1[i], vector2[i]) << "Vectors differ at index " << i;
}
```

## User-Definable Assertions

Extend GoogleTest assertions for your custom data types or complex conditions.

- Define predicate functions returning `testing::AssertionResult` to improve failure messages.
- Use predicate-formatter assertions (`EXPECT_PRED_FORMAT`) for fine-tuned control over assertion output.

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess() << n << " is even";
  else return testing::AssertionFailure() << n << " is odd";
}

EXPECT_PRED_FORMAT1(IsEven, GetValue());
```

## Mocking Framework Integration (gMock)

Seamlessly integrate mocking capabilities to create and control mock objects for your dependencies.

- Declare mock classes with `MOCK_METHOD` macro.
- Define expectations on mock functions with `EXPECT_CALL`.
- Customize behavior with actions such as `Return()`, `Throw()`, or complex sequences.
- Control call counts and sequences for robust interaction testing.

```cpp
class MockFoo {
 public:
  MOCK_METHOD(int, Bar, (int), ());
};

MockFoo mock;
EXPECT_CALL(mock, Bar(42)).WillOnce(Return(1));
EXPECT_EQ(mock.Bar(42), 1);
```

## Value- and Type-Parameterized Tests

Run the same test logic over multiple sets of parameters or types, minimizing redundant code and ensuring broader coverage.

- Use `TEST_P` and `INSTANTIATE_TEST_SUITE_P` for value-parameterized tests.
- Use `TYPED_TEST_SUITE` and `TYPED_TEST` for typed tests.
- Support data-driven and interface-conformance testing scenarios.

```cpp
class MyParamTest : public testing::TestWithParam<int> {};

TEST_P(MyParamTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveValues, MyParamTest, testing::Values(1, 2, 3));

template <typename T>
class MyTypedTest : public testing::Test {};

using MyTypes = testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  SUCCEED();
}
```

## Flexible and Robust Test Running Options

Run your tests exactly as you need, with support for:

- Filtering tests with `--gtest_filter` to selectively run subsets.
- Repeating tests multiple times to catch flaky failures (`--gtest_repeat`).
- Shuffling test order to uncover hidden dependencies (`--gtest_shuffle`).
- Enforcing fail-fast behavior with `--gtest_fail_fast`.
- Skipping tests dynamically at runtime with `GTEST_SKIP()`.

## Practical Example: Quick Installation to Test Run

1. Write your tests using `TEST` and `EXPECT_*` macros.
2. Initialize GoogleTest in your `main()`:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

3. Build and run. Use command-line flags to discover or filter tests.

---

For more details, explore the in-depth guides and references linked throughout the documentation or visit [GoogleTest GitHub](https://github.com/google/googletest).


<AccordionGroup title="Common Pitfalls & Tips">
<Accordion title="Use ASSERT_ vs. EXPECT_ Properly">
Remember that `ASSERT_*` macros abort the current function on failure, preventing further checks, while `EXPECT_*` allow the test to continue. Use `ASSERT_*` for preconditions that invalidate the rest of the test.
</Accordion>
<Accordion title="Avoid Underscores in Test Names">
Test suite and test names should avoid underscores to prevent internal naming conflicts and potential compilation or runtime errors.
</Accordion>
<Accordion title="Manage Test Fixtures Carefully">
Make sure each test case has a default constructor. Be mindful about resource allocation to avoid leaks, using `SetUp()` and `TearDown()` appropriately.
</Accordion>
<Accordion title="Leverage Scoped Traces for Debugging">
Use `SCOPED_TRACE` to annotate failures occurring in helper functions, making failure reports easier to diagnose.
</Accordion>
</AccordionGroup>
