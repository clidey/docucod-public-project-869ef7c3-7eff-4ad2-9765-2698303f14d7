---
title: "Core Concepts and Terminology"
description: "Get up to speed on key terms and ideas: tests, test fixtures, test suites, assertions, parameterized tests, mocks, matchers, actions, and cardinalities. Understand the C++ idioms reflected in the framework’s design, with references to where these concepts are implemented."
---

# Core Concepts and Terminology

## Introduction

Understanding GoogleTest’s core concepts and terminology lays a solid foundation for writing effective tests and leveraging its full power. This page introduces key terms such as **tests**, **test fixtures**, **test suites**, **assertions**, **parameterized tests**, **mocks**, **matchers**, **actions**, and **cardinalities**. Additionally, you will get insight into the C++ idioms reflected in GoogleTest's design, with references to where these ideas are implemented.

These concepts form the vocabulary and structural principles that guide your journey through test development, helping you write tests that are clear, maintainable, and robust.

---

## Key Concepts and Terminology

### Tests

A **test** in GoogleTest is a function that verifies a particular behavior or outcome of your code. It is the atomic unit of verification and encapsulates an assertion or a group of assertions.

- Tests are defined using the `TEST(TestSuiteName, TestName)` macro.
- Each test runs independently and reports success or failure.

### Test Fixtures

Often tests share common setup and teardown logic. GoogleTest provides **test fixtures** to encapsulate this shared context:

- A fixture is a C++ class deriving from `::testing::Test`.
- It allows you to write `SetUp()` and `TearDown()` methods that run before and after each test in the fixture.
- Tests that use a fixture are written with `TEST_F(FixtureName, TestName)`.

Example:

```cpp
class MyTestFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // common init
  }

  void TearDown() override {
    // common cleanup
  }

  // Shared members used by tests
  int value_;
};

TEST_F(MyTestFixture, Test1) {
  EXPECT_EQ(value_, 0);
}
```

### Test Suites

A **test suite** is a grouping of related tests, defined by sharing the same first argument to `TEST` or `TEST_F`. It helps organize tests logically and manage test execution.

### Assertions

Assertions verify expectations inside tests. They come in two flavors:

- **Fatal assertions** (e.g., `ASSERT_EQ()`) abort the current test if they fail.
- **Non-fatal assertions** (e.g., `EXPECT_EQ()`) report a failure but allow the test to continue.

Assertions compare expected and actual values and provide informative messages on failure.

### Parameterized Tests

**Parameterized tests** let you run the same test logic with multiple inputs. This avoids duplication and improves test coverage.

- Use `TEST_P` and `INSTANTIATE_TEST_SUITE_P` macros.
- Parameters are passed to the test fixture.

Example:

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {};

TEST_P(MyParamTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyParamTest,
                         ::testing::Values(2, 4, 6, 8));
```

### Mocks

Mocks are objects that simulate the behavior of real objects in a controlled way.

- GoogleMock (gMock) is integrated with GoogleTest to provide a powerful mocking framework.
- A **mock class** implements an interface or base class to intercept method calls.
- You specify expectations on method calls and actions (what the mock should do).

Example of creating a simple mock:

```cpp
class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetValue() = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (override));
};
```

### Matchers

Matchers define argument conditions for mock method calls. They are predicates that test if arguments fulfill certain criteria.

Common matchers include `_` (wildcard, matches anything), `Eq(val)`, `Ge(val)`, `NotNull()`, and many more.

Example:

```cpp
EXPECT_CALL(mock_foo, GetValue())
    .WillOnce(Return(42));
EXPECT_CALL(mock_foo, DoSomething(Ge(5)));
```

### Actions

Actions specify what a mock method does when called:

- Return values (`Return(...)`)
- Invoking custom functions (`Invoke(...)`)
- Setting output arguments (`SetArgPointee<N>(value)`)
- Doing multiple things (`DoAll(...)`)

Example:

```cpp
EXPECT_CALL(mock_foo, GetValue())
    .WillOnce(Return(10))
    .WillRepeatedly(Return(20));
```

### Cardinalities

Cardinalities specify how many times you expect a mock method to be called:

- `Times(n)` - exactly n times
- `AtLeast(n)` - minimum n times
- `AtMost(n)` - maximum n times
- `AnyNumber()` - any number of times

Example:

```cpp
EXPECT_CALL(mock_foo, DoSomething())
    .Times(AtLeast(1));
```

---

## C++ Idioms Reflected in GoogleTest

GoogleTest and GoogleMock leverage modern C++ idioms to provide expressive and safe APIs.

- **Templates and Polymorphism:** Mocking is implemented via class templates that accept mock classes and enhance their behavior.
- **RAII (Resource Acquisition Is Initialization):** Test setups and teardowns use destructors and constructors to manage resources.
- **Move Semantics:** GoogleMock supports mocking methods that take or return move-only types (e.g., `std::unique_ptr`).
- **Variadic Templates:** Used to handle methods with arbitrary argument lists.

For example, `NiceMock<T>`, `NaggyMock<T>`, and `StrictMock<T>` are template wrappers that modify the behavior of mock objects regarding uninteresting calls.

See [googlemock/include/gmock/gmock-nice-strict.h](https://github.com/google/googletest/blob/main/googlemock/include/gmock/gmock-nice-strict.h) for their implementation.

---

## How These Concepts Fit Together

The core concepts combine to form workflows in your tests:

1. **Define mocks** for your dependencies using `MOCK_METHOD` macros.
2. **Set expectations** on mocks with matchers and cardinalities.
3. **Specify behavior** of mocked methods using actions.
4. **Write tests** to exercise your code using test fixtures and parameterized tests.
5. **Run tests** to check correctness and catch interaction errors.

By mastering these concepts, you build tests that not only validate code but also document its expected interactions and behaviors clearly.

---

## Practical Tips and Best Practices

- Always declare destructors **virtual** in base classes you mock to avoid undefined behavior and leaks.
- Prefer to use **test fixtures** for shared setup to avoid duplication and improve readability.
- Use **parameterized tests** to cover multiple inputs efficiently.
- Use **NiceMock** to suppress warnings for uninteresting calls during test development, but rely on strict or naggy mocks to catch unexpected interactions in final tests.
- Define only necessary expectations to avoid brittle tests; use `ON_CALL` for default behaviors.
- Use descriptive names for tests and expectations; it makes failure messages more actionable.

---

## Troubleshooting Common Issues

- If a mocked method calls the real implementation, verify it is declared `virtual`.
- Avoid ambiguities with overloaded methods by specifying matchers explicitly or using `Const()` wrapper.
- Remember `EXPECT_CALL` must be set **before** the mock method is invoked.
- If you receive warnings about 'uninteresting calls', consider whether you need to set expectations or use `NiceMock`.

---

## References and Further Reading

- [gMock Cheat Sheet](../docs/gmock_cheat_sheet.md) - Quick reference guide for mocks, matchers, actions, and cardinalities.
- [gMock Cookbook](../docs/gmock_cook_book.md) - Recipes for common mocking patterns and advanced usage.
- [gMock for Dummies](../docs/gmock_for_dummies.md) - Beginner’s guide to mocking.
- [Mocking Reference](../docs/reference/mocking.md) - Detailed API reference.
- [Controlling Mock Strictness](../api-reference/mocking-and-matcher-api/nice-naggy-strict-mock-api.md) - Learn about NiceMock, NaggyMock, and StrictMock wrapper types.

---