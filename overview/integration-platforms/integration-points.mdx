---
title: "Ecosystem Integrations"
description: "Describes how the framework can be integrated with popular build tools (CMake, Bazel), CI/CD systems, IDEs, and test runners. Mentions key configuration files and main program entry points for lifting tests into automated workflows."
---

# Ecosystem Integrations

Integrating GoogleTest and GoogleMock effectively into your development environment accelerates testing, automates workflows, and enhances productivity. This page details how the framework can be integrated with popular build tools, Continuous Integration/Continuous Deployment (CI/CD) systems, IDEs, and test runners — enabling seamless automation of your C++ testing pipeline.

---

## Why Integrate?

Imagine your C++ project managed by CMake or Bazel automatically running all tests upon every code commit, reporting results directly in your CI dashboard or your favorite IDE. With proper integration, GoogleTest and GoogleMock tests become vital, automated feedback loops that help detect regressions quickly, maintain code quality, and empower teams to move faster.

Whether you want to run tests locally inside your IDE or incorporate them into automated CI/CD pipelines, understanding and configuring integrations ensures you harness the full power and flexibility of the framework.

---

## Supported Build Tools

GoogleTest and GoogleMock integrate tightly with the most common C++ build tools. The two officially highlighted build tools are:

### CMake
- Configuration files (like `gmock_main.pc.in`) provide essential information for smooth linking with `gmock_main` which already includes a `main()` function for your test binaries.
- Typical usage involves linking against GoogleMock libraries via targets such as `gmock` and `gmock_main` to avoid writing your own `main()` function.
- Example snippet you could add in your `CMakeLists.txt`:

```cmake
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

target_link_libraries(your_test_target 
  ${GTEST_LIBRARIES} 
  gmock_main 
  pthread  # if needed
)
```

### Bazel
- Bazel users can declare dependencies on GoogleTest and GoogleMock targets provided by the framework’s Bazel packages.
- This allows tests to be built and discovered with Bazel’s native support for test rules.

---

## Continuous Integration / Continuous Deployment (CI/CD) Systems

### Automating Test Runs
- GoogleTest's `RUN_ALL_TESTS()` macro executes all registered tests and returns an exit code reflecting success or failure.
- This behavior is ideal for CI systems, which can detect test failures from the process’ exit status.

### Program Entry Points
- By linking with provided main entry point libraries like `gmock_main`, you avoid manually implementing the `main()` function.
- This entry point is optimized to initialize both GoogleTest and GoogleMock and execute all tests via `RUN_ALL_TESTS()`.
- For instance, the source file `gmock_main.cc` illustrates this standard main function:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleMock(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- For embedded or special platforms (ESP8266, Arduino), `setup()` and `loop()` functions exist instead, adapting initialization and test execution for those environments.

### Configuring Tests in CI
- Tests can be integrated into CI workflows by simply invoking the test binaries produced by your build system.
- Ensure test binaries respect exit codes so CI systems can correctly detect failures.
- Some CI systems can parse detailed test outputs if tests emit them in supported formats (XML/JUnit style), which GoogleTest supports via command-line flags.

---

## IDE Integration

Most modern IDEs supporting C++ can be configured to run GoogleTest-based tests:

- IDEs like CLion, Visual Studio, and others provide native or plugin-based support for discovery, running, and debugging GoogleTest tests.
- Integration benefits include test result visualization, breakpoint support within tests, and smooth navigation between test results and source code.
- Linking your tests against `gmock_main` or `gtest_main` ensures the executable has a ready entry point.
- The standard interface for launching tests via `RUN_ALL_TESTS()` means the IDE requires no special handling.

---

## Key Configuration Files and Entry Points

### Main Program Entry: `gmock_main.cc`
- Located in the GoogleMock source as a standard main definition.
- Initializes GoogleMock (and transitively GoogleTest).
- Runs `RUN_ALL_TESTS()` which executes all registered tests.

### Build Configuration Files
- In CMake: `gmock_main.pc.in` template defines installation parameters for pkg-config usage.
- These files specify locations for headers, libraries, and necessary flags for compiler and linker.

Linking against `gmock_main` is recommended when you want the framework-provided entry point. Alternatively, if your test has specific requirements (e.g. custom command-line flag handling or setup), you can define your own `main()` using `testing::InitGoogleMock()`.

---

## Best Practices for Integration

- **Leverage provided main functions:** Avoid writing your own unless necessary to simplify setup and ensure consistent test execution.
- **Automate test runs:** Always integrate test executables into CI pipelines.
- **Use native build tool support:** Utilize CMake or Bazel rules for test discovery and execution.
- **Configure your IDE:** Take advantage of built-in GoogleTest support for faster debugging and test management.
- **Monitor test exit codes:** CI and scripts must check test binary exit statuses to detect failures reliably.

---

## Troubleshooting Common Integration Issues

- **Tests not discovered or run:** Confirm test binaries link against `gmock_main` or include main implementation.
- **No tests run (exit code 0):** Ensure tests are registered properly; e.g., macros like `TEST()` or `TEST_F()` used correctly.
- **CI unable to detect failures:** Verify your test runner respects and returns exit codes from `RUN_ALL_TESTS()`.
- **Linker errors regarding `main`:** Possibly missing `gmock_main` target or conflicting multiple `main` definitions.

---

## Summary Diagram of Integration Points

```mermaid
flowchart TD
  A[Source Code with TESTS] -->|Build| B[Build System (CMake or Bazel)]
  B --> C[Test Executable with gmock_main linked]
  C --> D[Run Tests: RUN_ALL_TESTS() executes all tests]
  D -->|Success/Fail| E[CI/CD System]
  D -->|Success/Fail| F[IDE Test Runner]

  subgraph Build System
    B
    G[gmock_main.pc.in & Configurations]
    B --> G
  end

  subgraph Platforms
    C
    D
  end

  E -->|Reports Results| H[Developers/Team]
  F -->|Interactive Debug & View| H
```

---

For more detailed guidance on writing custom `main()` functions or advanced build setups, please consult the Getting Started and Platform Support documentation sections.

---

## Next Steps

- Visit [Getting Started](/overview/getting-started-intro/product-intro) to understand basic test writing and execution.
- Learn how to write and use mocks effectively in the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html).
- Explore platform and toolchain compatibility in [Platform Support](/overview/integration-platforms/platform-support).

---

# References

- `gmock_main.cc` source: provides the main test entry point implementation.
- `gmock_main.pc.in`: CMake install configuration template.
- [GoogleTest Primer](docs/primer.md): foundational testing concepts and usage.


<Callout>
**Tip:** When integrating into CI/CD, ensure your test environment can execute test binaries and interpret their exit codes properly to validate test success or failure automatically.
</Callout>

<Note>
Linking your test targets against `gmock_main` or `gtest_main` obviates the need to write or maintain your own `main()` function, reducing boilerplate and ensuring standardized test execution.
</Note>
