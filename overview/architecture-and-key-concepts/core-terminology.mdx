---
title: "Core Concepts and Terminology"
description: "Defines foundational terminology for new users: test cases, test suites, fixtures, assertions (fatal/non-fatal), matchers, parameterized tests, type-parameterized tests, death tests, and mock objects. Serves as an essential glossary for understanding subsequent documentation and code."
---

# Core Concepts and Terminology

Welcome to the foundational glossary of GoogleTest and GoogleMock. Before diving into writing or understanding tests, it's essential to grasp the core concepts and terminology that form the backbone of this powerful C++ testing framework.

This page defines critical terms such as test cases, test suites, fixtures, assertions, matchers, parameterized and typed tests, death tests, and mock objects. Think of it as your essential map to navigate subsequent guides, API references, and architecture discussions with confidence.

---

## Understanding Tests: Test Cases and Test Suites

### What Is a Test Case?

A test case is a programmatic unit of test logic that checks a specific aspect of your code. It encapsulates a scenario or behavior to verify. Each test case executes code, applies assertions to validate expected outcomes, and reports success or failure.

**Example:**

```cpp
TEST(MathTest, AdditionWorks) {
  EXPECT_EQ(2 + 2, 4);
}
```

Here, `MathTest` is the test case name, and `AdditionWorks` is the specific test within that case.

### What Is a Test Suite?

A test suite groups related test cases. It organizes tests logically, making it easier to manage and run groups of related tests together.

- In GoogleTest, a suite can be identified by test cases sharing a common prefix or fixture.
- Useful for running subsets of tests relevant to a component or module.

Consider suites as folders and test cases as files within them.

---

## Test Fixtures: Preparing the Test Environment

### What Are Fixtures?

Fixtures set up the environment for your tests. They allow you to share common setup and cleanup logic across multiple tests, keeping your tests clean and focused.

You define fixtures by subclassing `::testing::Test` and overriding `SetUp()` and `TearDown()` methods.

**Example:**

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  void SetUp() override {
    // Initialize database connection
  }

  void TearDown() override {
    // Close database connection
  }
};

TEST_F(DatabaseTest, QuerySucceeds) {
  // Test logic here
}
```

### Why Use Fixtures?

- Avoids duplication of setup/teardown code
- Ensures consistent environment across tests
- Reduces test maintenance overhead

---

## Assertions: Verifying Conditions in Tests

### What is an Assertion?

An assertion checks whether a condition holds true in your test. It is the primary way to verify that your code behaves as expected.

GoogleTest provides two types:

- **Fatal Assertions:** If they fail, the current test is immediately aborted.
  - Examples: `ASSERT_TRUE(condition)`, `ASSERT_EQ(value1, value2)`

- **Non-fatal Assertions:** If they fail, the test continues executing, but the failure is recorded.
  - Examples: `EXPECT_TRUE(condition)`, `EXPECT_EQ(value1, value2)`

Use fatal assertions when subsequent code depends on the success of earlier checks. Otherwise, prefer non-fatal assertions to gather more failure info in a single run.

### Practical Tips

- Use `EXPECT_*` for checks where continuing makes sense.
- Use `ASSERT_*` when failure means the test cannot proceed correctly.

---

## Matchers: Flexible Argument Validation

Matchers allow expressive, flexible conditions to verify function arguments. They act like predicates, enabling you not only to check exact values but also value properties.

### Common Matcher Patterns

- Exact value: `Eq(5)` matches if the argument equals 5.
- Wildcard: `_` matches any value.
- Relational: `Gt(10)`, `Le(20)` match greater-than and less-or-equal conditions.
- Composite: `AllOf(...)`, `AnyOf(...)` to combine multiple matchers.

**Example:**

```cpp
EXPECT_CALL(mock, Process(DataEq(expected_data)));  // Using a custom matcher
EXPECT_CALL(mock, Process(Ge(100)));                 // Argument >= 100
EXPECT_CALL(mock, SetValue(_));                       // Any value accepted
```

Matchers enable you to focus on *what matters* in your tests while ignoring noise.

---

## Parameterized and Type-Parameterized Tests

Parameterized and typed tests enable running the same test logic multiple times with different inputs or types, making tests concise and comprehensive.

### Parameterized Tests

Parameterized tests run once per value in a specified input set.

**Example:**

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ReturnsExpected) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ExpectedFactorial(n));
}

INSTANTIATE_TEST_SUITE_P(ValidCases, FactorialTest, ::testing::Values(0, 1, 5, 10));
```

### Type-Parameterized Tests

Allow running the same test logic on multiple types to verify type correctness.

**Example:**

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {};

TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsSigned) {
  EXPECT_TRUE(std::numeric_limits<TypeParam>::is_signed);
}
```

These mechanisms help detect issues early across various inputs and types without code duplication.

---

## Death Tests: Testing Program Failures Safely

Death tests verify that your code crashes, asserts, or exits in the expected manner under certain conditions.

They run the test code in a separate process and observe termination.

**Example:**

```cpp
EXPECT_DEATH(MyFunction(-1), "negative input not allowed");
```

Death tests help validate robustness and error handling, ensuring your program fails predictably.

---

## Mock Objects: Controlling and Verifying Collaborators

### What Are Mock Objects?

Mocks simulate behavior of real objects to isolate tests from dependencies. They allow specification of:

- Expected method calls and call order
- Arguments and argument properties
- Return values or side effects

Mocks verify the interaction between your code and its collaborators, increasing test precision.

### Creating Mock Classes

- Derive mock classes from interfaces or abstract classes.
- Use the `MOCK_METHOD` macro in the public section to define mock methods.

Example:

```cpp
class MockDatabase : public Database {
 public:
  MOCK_METHOD(bool, Connect, (const std::string& url), (override));
  MOCK_METHOD(int, Query, (const std::string& sql), (override));
};
```

### Expectations

Specify expectations on mocks using `EXPECT_CALL`, defining what methods are called, with which arguments, how many times, and what result.

Example:

```cpp
EXPECT_CALL(mock_db, Connect(_))
    .Times(1)
    .WillOnce(Return(true));
```

### Best Practices

- Use `ON_CALL` to specify default behavior without expectations.
- Prefer `NiceMock` or `StrictMock` wrappers to control warning and failure reporting for uninteresting calls.
- Remember mock expectations are "sticky"; use `.RetiresOnSaturation()` or sequences to handle repeated calls gracefully.

---

## Summary

Understanding these core concepts is essential to effectively write, read, and maintain tests using GoogleTest and GoogleMock. Mastery of test structuring, assertion types, matching strategies, parameterization, death testing, and mock design will empower you to create robust, maintainable, and precise C++ tests.

For a comprehensive grasp, explore related documentation under [Overview › Architecture & Core Concepts](../architecture-and-key-concepts/architecture-overview.md), [Guides › Core Testing Workflows](../../guides/core-testing-workflows/writing-basic-tests.md), and [Mocking Reference](../../reference/mocking.md).


---

<AccordionGroup title="Glossary & Additional Notes">
<Accordion title="Test Case vs Test Suite">
A **test case** refers to an individual test, while a **test suite** groups multiple test cases. GoogleTest often treats test case names as suite names.
</Accordion>
<Accordion title="Fatal vs Non-fatal Assertions">
Use `ASSERT_*` for fatal checks that stop test execution immediately, and `EXPECT_*` for non-fatal checks that allow tests to continue and report multiple failures.
</Accordion>
<Accordion title="Matchers Detailed">
Matchers provide ways to specify argument constraints for mock methods. They can be combined, parameterized, and customized for rich expressiveness.
</Accordion>
<Accordion title="How to Mock Virtual Functions">
Mock only virtual functions; non-virtual functions cannot be mocked directly. Use interfaces or dependency injection to enable mocking.
</Accordion>
<Accordion title="Using Sequences and RetiresOnSaturation">
To specify call order and avoid "upper bound violated" errors, use `InSequence` to arrange expectations or `.RetiresOnSaturation()` to deactivate saturated expectations immediately.
</Accordion>
<Accordion title="Difference Between ON_CALL and EXPECT_CALL">
`ON_CALL` sets default behavior without enforcing call expectations, while `EXPECT_CALL` sets behavior *and* enforces the expectation that the call occurs.
</Accordion>
</AccordionGroup>
