---
title: "Core Concepts & Terminology"
description: "Defines core domain terms such as test case, assertion, fixture, parameterized test, and death test. Illustrates each concept with concise descriptions, mapping them to the relevant source files and underscoring their practical importance."
---

# Core Concepts & Terminology

Understanding the essential terms behind GoogleTest and GoogleMock (gMock) empowers you to write more effective and maintainable tests. This page defines the core domain concepts such as **test case**, **assertion**, **fixture**, **parameterized test**, and **death test** in concise, approachable terms. Each concept is illustrated with practical significance and mapped to the relevant source files, guiding you on where to explore further.

---

## What Are Core Concepts in GoogleTest?

At its heart, GoogleTest helps you write C++ tests that verify the behavior of your code. It provides key abstractions that organize the tests and provide detailed feedback when things go wrong. Here's what you need to know:

- **Test Case**: A logical grouping of tests that share common setup or configuration. Each test case contains one or more test methods.

- **Test**: An individual unit test that exercises a specific piece of code, verifying expected outcomes using assertions.

- **Assertion**: A statement that verifies a particular condition is true or false. If an assertion fails, the test fails with detailed diagnostics.

- **Test Fixture**: A class that sets up the environment for tests within a test case, providing shared objects or state.

- **Parameterized Test**: A family of tests that run the same test logic with different input parameters, enabling data-driven testing.

- **Death Test**: A special test that verifies code behavior on fatal failures or crashes, ensuring your program fails as expected in extreme conditions.


Each concept corresponds within the source code to designated files and APIs, forming the building blocks of your test writing and execution.


## Why These Terms Matter

By internalizing these concepts, you can craft tests that are:

- **Well-organized**: Group related tests logically, avoiding duplication.
- **Expressive**: Use assertions meaningfully to pinpoint failures.
- **Efficient**: Leverage parameterized tests to maximize coverage with minimal code.
- **Robust**: Include death tests to validate your program's handling of catastrophic situations.

They form the vocabulary that bridges your intent and the framework's capabilities.


## Core Domain Term Definitions

### Test Case
A test case is a named collection of tests, typically representing a component or feature under test. Test cases can share setup and teardown logic through test fixtures.

**Example:**
```cpp
TEST(MathFunctions, HandlesZeroInput) {
  ASSERT_EQ(Factorial(0), 1);
}

TEST(MathFunctions, HandlesPositiveInput) {
  ASSERT_EQ(Factorial(5), 120);
}
```
Here, `MathFunctions` is the test case grouping individual tests.

### Test
A single executable unit verifying a specific piece of functionality. Each test runs independently.

### Assertion
Assertions confirm the outcome of the code under test. GoogleTest provides rich assertion macros:
- `EXPECT_`: Records failure but continues the test.
- `ASSERT_`: Fails immediately and aborts the test.

Example assertion:
```cpp
ASSERT_TRUE(IsPrime(7));
EXPECT_EQ(GetMax({1, 2, 3}), 3);
```

### Test Fixture
Test fixtures initialize and clean up shared test context, avoiding repetitive code. Declared as a C++ class inheriting `::testing::Test`.

```cpp
class VectorTest : public ::testing::Test {
 protected:
  std::vector<int> v;

  void SetUp() override {
    v = {1, 2, 3};
  }
};

TEST_F(VectorTest, SizeIsCorrect) {
  EXPECT_EQ(v.size(), 3);
}
```

The `VectorTest` fixture is reused across multiple tests.

### Parameterized Test
Enables running the same test logic over multiple inputs.

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, HandlesEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

Parameterized tests increase coverage without code duplication.

### Death Test
Death tests check that code crashes or exits under expected fatal scenarios.

```cpp
TEST(FooDeathTest, DiesOnNullptr) {
  EXPECT_DEATH(Foo(nullptr), "null pointer");
}
```

This verifies exact failure behavior, ensuring reliability in extreme cases.


## Mapping Concepts to Source Files

Each core concept is supported and implemented through specific components and source files:

| Concept            | Typical Source Files / Locations       | Notes                                                  |
|--------------------|--------------------------------------|--------------------------------------------------------|
| Test Case & Test   | `test/gtest.h`, `test/gtest.cc`       | Declaration macros like `TEST`, `TEST_F`                 |
| Assertions         | `assertions.h`, `assertions.cc`       | `ASSERT_*`, `EXPECT_*` macros and helper functions       |
| Test Fixtures      | `test/gtest.h`, `test/gtest.cc`       | `::testing::Test` class and overrides                    |
| Parameterized Tests| `test/gtest-param-test.h`              | Support classes like `TestWithParam<>`                    |
| Death Tests        | `test/gtest-death-test.h`              | Specialized mechanisms to spawn subprocesses and verify  |

Meanwhile, GoogleMock (gMock) extends these concepts to mocking C++ classes:

| Concept         | Typical Source Files                 | Notes                                                |
|-----------------|----------------------------------|------------------------------------------------------|
| Mock Classes    | `gmock/gmock.h`, `gmock/gmock-spec-builders.h` | Macros for mock method declarations `MOCK_METHOD`   |
| Setting Expectations | `gmock/gmock.h`, `gmock/gmock-spec-builders.h`  | `EXPECT_CALL`, modifiers like `.Times()`, `.WillOnce()` |
| Matchers        | `gmock/gmock-matchers.h`          | Argument matching for flexible checking                |
| Actions         | `gmock/gmock-actions.h`           | Control mock method behaviors                           |
| Strictness Levels| `gmock/gmock-nice-strict.h`       | `NiceMock`, `StrictMock`, `NaggyMock` wrappers         |


## Practical Importance of Understanding Core Concepts

Imagine you want to validate a sorting function. Knowing core concepts helps you:

1. Group related tests in a test case `SortingFunctions`.
2. Use a test fixture to reuse a dataset across tests.
3. Write assertions to verify sorted order.
4. Employ parameterized tests to run against various input sizes and types.
5. Write mocks to simulate dependencies for integration tests.

Without understanding these terms, you may miss critical capabilities or write brittle tests.


## Troubleshooting Common Pain Points

- **Confusing a test case with a test:** Remember a test case is a collection; tests are individual.
- **Skipping fixture setup:** Leads to repetitive initialization and potential errors.
- **Overriding expectations after calls:** Always declare expectations before exercising mocks.
- **Misusing `EXPECT_` vs `ASSERT_`:** Use `ASSERT_` when further test logic depends on validated conditions.


## Next Steps

With these definitions in mind, you can confidently proceed to:

- [Getting Started with GoogleTest](../guides/core-workflows/getting-started-gtest) to learn how to apply these concepts.
- [Writing and Structuring Effective Tests](../guides/core-workflows/writing-effective-tests) for practical techniques.
- [Mocking Objects with gMock](../reference/mocking.md) to leverage powerful mocking capabilities.


<Tip>
Understanding these core terms is foundational. They enable you to structure tests clearly, diagnose problems swiftly, and harness the full power of GoogleTest and GoogleMock.
</Tip>