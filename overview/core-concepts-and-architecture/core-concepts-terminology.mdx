---
title: "Core Concepts and Terminology"
description: "Get familiar with essential terms like assertions, test fixtures, parameterized tests, death tests, mock objects, and expectations. Learn how these concepts interrelate to support expressive, maintainable C++ tests."
---

# Core Concepts and Terminology

Understanding the foundational concepts and specialized terminology in GoogleTest and GoogleMock is key to writing expressive, maintainable, and effective C++ tests. This guide introduces the essential terms, explains how they interrelate, and lays the groundwork for mastering the framework.

---

## Assertions

Assertions are statements in your tests that verify whether certain conditions hold true. They form the basic building blocks to validate expectations about your code.

- **EXPECT_*** assertions allow the test to continue even if they fail, recording the failure for later report.
- **ASSERT_*** assertions immediately abort the current test upon failure.

Example:

```cpp
EXPECT_EQ(5, ComputeSum(2, 3));  // Test that the sum is correct
ASSERT_NE(nullptr, ptr);         // Abort if pointer is null
```

These constructs are vital for detecting incorrect behavior during test execution.

## Test Fixtures

Test fixtures organize and provide common setup and teardown for a group of tests.

- Defined as C++ classes inheriting from `::testing::Test`.
- Use `SetUp()` and `TearDown()` methods to prepare the environment.
- Support shared resources to avoid code duplication.

Example:

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  void SetUp() override {
    db.Connect();
  }

  void TearDown() override {
    db.Disconnect();
  }

  Database db;
};

TEST_F(DatabaseTest, InsertTest) {
  EXPECT_TRUE(db.Insert("data"));
}
```

Using fixtures promotes cleaner, DRY tests, and ensures consistent test environments.

## Parameterized Tests

Parameterized tests let you run the same test logic with different input values, increasing test coverage.

- Define a test class inheriting from `::testing::TestWithParam<T>` where `T` is the type of parameters.
- Use `TEST_P` macros to write the test body.
- Instantiate tests with various parameter sets via `INSTANTIATE_TEST_SUITE_P`.

Example:

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesFactorial) {
  int n = GetParam();
  EXPECT_GT(Factorial(n), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, FactorialTest, ::testing::Values(1, 2, 3, 10));
```

This approach reduces redundancy and automatically tests multiple cases.

## Death Tests

Death tests verify that your program terminates in expected ways when given invalid input or under error conditions.

- Use `EXPECT_DEATH()` or `ASSERT_DEATH()` macros.
- The test runs in a subprocess to isolate the abnormal termination.

Example:

```cpp
EXPECT_DEATH(SomeFunctionThatExits(), "error message");
```

They help ensure your code gracefully handles catastrophic failures.

## Mock Objects

Mock objects simulate complex or unavailable dependencies, allowing you to define expected interactions with those dependencies.

- Provide the same interface as the original object.
- Allow you to specify which methods will be called, how often, with what arguments, and what they return.
- Enable verification that your code under test uses dependencies correctly.

Example:

```cpp
class MockDatabase : public Database {
 public:
  MOCK_METHOD(bool, Insert, (const std::string& data), (override));
};

TEST(DataProcessorTest, CallsInsert) {
  MockDatabase mock_db;
  EXPECT_CALL(mock_db, Insert("record"))
      .Times(1)
      .WillOnce(Return(true));
  DataProcessor processor(&mock_db);
  processor.Process("record");
}
```

Mocks empower interaction-based testing and improve test reliability.

## Expectations

Expectations specify how and when mock object methods should be invoked.

- Setup using `EXPECT_CALL(mock, Method(args))`.
- Determine the number of calls (cardinality) with `.Times()`.
- Specify the behavior using `.WillOnce()` and `.WillRepeatedly()` actions.
- Can constrain call order with `.InSequence()` or `.After()`.

Example:

```cpp
EXPECT_CALL(mock_db, Insert("data"))
    .Times(AtLeast(1))
    .WillRepeatedly(Return(true));
```

They enforce and verify correct usage of mocks, helping catch logic errors early.

---

## How These Concepts Interrelate

- Assertions verify outcomes within tests.
- Fixtures prepare and clean up test environments.
- Parameterized tests run the same logic on varied inputs.
- Death tests ensure program robustness against fatal errors.
- Mock objects replace dependencies to isolate the unit under test.
- Expectations define precise interactions with mock objects.

Together, these concepts build a powerful structure for comprehensive, maintainable unit tests aimed at producing reliable C++ software.

---

## Practical Tips

- Start with writing clear assertions to describe expected outcomes.
- Use fixtures to reduce repeated setup logic.
- Parameterize tests to cover edge cases efficiently.
- Mock complex dependencies to focus on logic, not setup.
- Carefully write expectations to avoid brittle tests; use `ON_CALL` for default mock behavior, and `EXPECT_CALL` only when call verification is necessary.
- Use sequences and ordering clauses to test interaction order.
- Employ death tests to verify handling of critical failures.

---

## Troubleshooting Common Pain Points

- **Unmet expectations:** Use `--gmock_verbose=info` to trace mock invocations.
- **Unexpected calls:** Add catch-all expectations or adjust mock strictness.
- **Test brittleness:** Avoid overly strict call order unless necessary.
- **Mock leaks:** Ensure mocks with expectations are properly destroyed or explicitly allow leaks.

---

## Next Steps

To deepen your understanding and apply these concepts practically:

- Explore [gMock for Dummies](../gmock_for_dummies.md) for beginner-friendly mock usage.
- Learn how to [Create and Use Mocks](../guides/mocking-best-practices/creating-mocks.md).
- See how to write precise [Expectations and Actions](../guides/mocking-best-practices/writing-expectations-actions.md).
- Manage mock behavior with [Mock Strictness](../guides/mocking-best-practices/mock-strictness.md).

Leverage these foundations to write robust tests that scale with your projectâ€™s complexity.

---