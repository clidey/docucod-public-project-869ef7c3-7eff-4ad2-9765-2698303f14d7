---
title: "Core Concepts & Terminology"
description: "Familiarize yourself with fundamental GoogleTest terms—test cases, assertions, fixtures, mocks, and death tests. This section concisely defines the building blocks you’ll use in every test suite, demystifying key terms for both new and experienced users."
---

# Core Concepts & Terminology

Welcome to the foundation of effective testing with GoogleTest. This section familiarizes you with the essential C++ testing terms and constructs that you'll use in writing, organizing, and understanding tests. Whether you are new to testing or refining your expertise, mastering these key concepts will empower you to craft robust and maintainable test suites.

---

## Test Cases

A **test case** is the fundamental unit of test grouping. It encapsulates one or more related tests that validate a particular feature or behavior of your code.

- **Structure:**
  - Consists of multiple _test functions_ (often called test methods or test bodies).
  - Each test function focuses on a specific aspect or scenario.
  - Provides a scope for sharing setup and teardown logic if needed (via fixtures).

- **Purpose:**
  - Organizes tests logically, making your testing suite easier to navigate.
  - Supports systematic coverage of functionalities.

- **Example:**

  ```cpp
  TEST(MathTests, AdditionWorks) {
    EXPECT_EQ(2 + 2, 4);
  }

  TEST(MathTests, SubtractionWorks) {
    EXPECT_EQ(5 - 3, 2);
  }
  ```

Here, `MathTests` is a test case, grouping tests about math operations.

---

## Assertions

Assertions are statements that check if a condition holds true during a test run. They are the core mechanism for verification.

- **Types:**
  - **`EXPECT_` assertions:** Check conditions but continue executing the test even if the assertion fails. Useful when you want to see all failures in one run.
  - **`ASSERT_` assertions:** Abort the current test immediately if the assertion fails. Use when subsequent checks depend on prior ones.

- **Commonly used Assertions:**
  - `EXPECT_EQ(val1, val2)` - expects the two values to be equal.
  - `ASSERT_TRUE(condition)` - expects the condition to be true.
  - `EXPECT_NE(val1, val2)` - expects the two values to be not equal.
  - `ASSERT_THROW(statement, ExceptionType)` - expects a statement to throw an exception of a specific type.

- **Benefit:**
  - Provides immediate feedback on test pass/fail.
  - Helps isolate faulty code behavior.

- **Example:**

  ```cpp
  TEST(FooTest, Bar) {
    int x = 5;
    EXPECT_EQ(x, 5);  // Continues even if fails.
    ASSERT_TRUE(x > 0);  // Stops test if false.
  }
  ```

---

## Fixtures

Fixtures let you create a reusable context for running multiple related tests with common setup and teardown code.

- **Key Concept:**
  - Create a class derived from `::testing::Test`.
  - Implement `SetUp()` and `TearDown()` methods to prepare and clean the environment.
  - Tests use this fixture by declaring `TEST_F` instead of `TEST`.

- **Advantages:**
  - Avoid repetition of initialization and cleanup steps.
  - Share test utilities, mocks, and test data across multiple tests.

- **Example:**

  ```cpp
  class DatabaseTest : public ::testing::Test {
   protected:
    void SetUp() override {
      db.Connect();
    }

    void TearDown() override {
      db.Disconnect();
    }

    Database db;
  };

  TEST_F(DatabaseTest, QueryReturnsExpectedResults) {
    auto result = db.Query("SELECT * FROM users");
    EXPECT_FALSE(result.empty());
  }

  TEST_F(DatabaseTest, InsertIncreasesCount) {
    int old_count = db.Count();
    db.Insert(User("Alice"));
    EXPECT_EQ(db.Count(), old_count + 1);
  }
  ```

---

## Mocks

Mock objects simulate the behavior of complex or external components your code depends on. They are essential in isolating units for testing.

- **Purpose:**
  - Remove dependencies on slow, unstable, or unavailable components (e.g., databases, networks).
  - Allow precise control over expected interactions and behaviors.
  - Enable validation that your code interacts correctly with collaborators.

- **GoogleMock Integration:**
  - Define mock classes that implement the interfaces your code uses.
  - Use `MOCK_METHOD()` to create mocked versions of virtual methods.
  - Set expectations on mock methods with `EXPECT_CALL()` to specify calls, arguments, and behaviors.

- **Example:**

  ```cpp
  class MockDatabase : public DatabaseInterface {
   public:
    MOCK_METHOD(bool, Connect, (), (override));
    MOCK_METHOD(bool, Disconnect, (), (override));
    MOCK_METHOD(std::vector<User>, Query, (const std::string&), (override));
  };

  TEST(UserManagerTest, CallsDatabaseQuery) {
    MockDatabase mock_db;
    EXPECT_CALL(mock_db, Query("SELECT * FROM users"))
        .Times(1)
        .WillOnce(Return(std::vector<User>{User("Alice")}));

    UserManager manager(&mock_db);
    auto users = manager.GetUsers();
    EXPECT_EQ(users.size(), 1);
  }
  ```

- **Benefit:**
  - Keep tests fast and deterministic.
  - Verify both the state and interaction behaviors.

---

## Death Tests

Death tests verify that your code terminates or crashes under expected erroneous or fatal conditions.

- **Why Use Death Tests:**
  - Ensure that improper usage triggers fatal failures as planned.
  - Validate error handling robustness and safety-critical safeguards.

- **GoogleTest Support:**
  - Use the `EXPECT_DEATH(argument, regex)` macro.
    - `argument` runs code expected to cause process termination.
    - `regex` matches expected stderr output or death message.

- **Example:**

  ```cpp
  TEST(FooDeathTest, AbortsOnNullPointer) {
    EXPECT_DEATH(
        Foo(nullptr),
        "Received null pointer, aborting"
    );
  }
  ```

- **Important Notes:**
  - Death tests may spawn subprocesses for isolation.
  - Their execution can be slower; use judiciously.
  - Only test truly fatal conditions that should terminate the program.

---

## Summary

Understanding these core concepts ensures you build tests that are clear, maintainable, and reliable. Test cases structure your tests, assertions verify behavior, fixtures reduce redundancy, mocks isolate dependencies, and death tests safeguard catastrophic failure points. Mastery of these terms creates a strong foundation for efficient and effective C++ testing using GoogleTest.

---

## Further Reading and Next Steps

- [Writing Your First Test](../guides/core-testing-workflows/writing-basic-tests) - learn how to start writing test cases and assertions.
- [Organizing and Running Test Suites](../guides/core-testing-workflows/organizing-and-running-tests) - advance your testing strategy with fixtures.
- [Getting Started with Mocks](../guides/mocking-and-advanced-scenarios/mocking-basics) - dive into creating and using mock objects for interaction testing.

For a comprehensive understanding of GoogleTest fundamentals, begin with [What is GoogleTest?](../overview/product-intro-core-concepts/what-is-googletest) and explore [Writing Your First Test Case](../getting-started/configuring-using-tests/write-first-test-case).