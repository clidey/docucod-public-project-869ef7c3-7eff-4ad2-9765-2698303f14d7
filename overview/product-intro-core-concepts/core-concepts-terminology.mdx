---
title: "Core Concepts and Terminology"
description: "Get familiar with the essential vocabulary and ideas in GoogleTest: tests, fixtures, test cases, assertions, matchers, mocks, and test discovery. Each concept is defined accessibly, so you can confidently navigate the rest of the documentation."
---

# Core Concepts and Terminology

Welcome to the foundational guide of GoogleTest, where you'll find clear, practical definitions and explanations of the essential vocabulary and ideas that power this robust testing framework. Understanding these core concepts ensures you can successfully navigate and leverage the full potential of GoogleTest.

---

## What Are Tests?

At its heart, a *test* is a program or a piece of code written to verify that another piece of code behaves as expected under certain conditions. GoogleTest structures these concepts as:

- **Test Cases**
- **Tests**

A **test** is the smallest unit that checks a particular behavior or property. A **test case** groups related tests, making organization and maintenance easier.

### Example

Here's a simple test example:

```cpp
#include <gtest/gtest.h>

TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}
```

In the code above,

- `MathTest` is the **test case**, under which related tests are grouped.
- `Addition` is a single **test** checking that addition works correctly.

Tests consist of assertions that can pass or fail, determining whether the code meets the criteria.

---

## Fixtures: Setting the Stage for Tests

Tests often require a specific environment or setup to run properly. **Fixtures** provide this context by preparing common objects or states before tests run and cleaning them up afterward.

Fixtures help you:

- Avoid redundant setup code across multiple tests.
- Maintain consistent state to make tests reliable and independent.

### Defining a Fixture

Fixtures are implemented by defining a test class derived from `::testing::Test`:

```cpp
class MyFixture : public ::testing::Test {
protected:
  void SetUp() override {
    // Code here will run before each test.
  }

  void TearDown() override {
    // Code here will run after each test.
  }

  // Shared objects for multiple tests.
  int common_value;
};
```

### Using a Fixture

When writing tests using a fixture, you write `TEST_F` instead of `TEST`:

```cpp
TEST_F(MyFixture, TestSomething) {
  common_value = 42;
  EXPECT_EQ(common_value, 42);
}
```

Each `TEST_F` will execute with its own fresh fixture, ensuring independence.

---

## Test Cases and Test Suites

- A **test case** is a group of related tests that share common setup or belong logically together.
- These are implemented by the first argument to the `TEST` or `TEST_F` macros (e.g., `MathTest` in the example above).

Test suites are a higher-level organizational structure grouping test cases, especially when using advanced test discovery and filtering.

---

## Assertions: The Checks That Matter

Assertions are conditions that must hold true for a test to pass. If an assertion fails, the test fails, providing detailed diagnostic information.

### Common Assertions

| Assertion     | Description                                         |
|---------------|-----------------------------------------------------|
| `EXPECT_EQ`   | Checks equality; test continues on failure.         |
| `ASSERT_EQ`   | Checks equality; test aborts on failure.            |
| `EXPECT_TRUE` | Checks if expression is true; continues on failure. |
| `ASSERT_TRUE` | Checks if expression is true; aborts on failure.    |

### Example

```cpp
EXPECT_EQ(5, result);
ASSERT_TRUE(ptr != nullptr);
```

- *EXPECT* allows the test to continue and capture multiple failures.
- *ASSERT* stops the test immediately on failure.

---

## Matchers: Expressive Conditions

Matchers are predicates used inside assertions or mock expectations to express detailed checks on values or arguments.

- The wildcard matcher `_` matches any value.
- Matchers like `Eq()`, `Ge()`, `Lt()`, and others provide expressive ways to specify expectations.

Example matcher usage with GoogleMock:

```cpp
EXPECT_CALL(mock_object, Method(Ge(5)));
```

This expects the method to be called with an argument greater than or equal to 5.

---

## Mocks: Controlling and Verifying Interactions

Mocks (mock objects) are simulated implementations of classes or interfaces, allowing you to:

- Specify expected calls, arguments, and call counts.
- Provide simulated return values or behaviors.
- Verify that the code under test interacts as intended.

### Why Use Mocks?

- To isolate the component under test by replacing its dependencies.
- To simulate rarely occurring scenarios like errors or timeouts.
- To verify interaction patterns and correct sequencing.

### Creating Mocks

GoogleMock provides macros to easily create mocks. A mock class inherits from the real interface and declares mock methods using `MOCK_METHOD`:

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
};
```

### Using Mocks in Tests

With the mock defined, setting expectations and testing is straightforward:

```cpp
MockTurtle turtle;
EXPECT_CALL(turtle, PenDown()).Times(1);
EXPECT_CALL(turtle, Forward(100)).Times(1);

// Code under test that uses turtle...
```

If the expected calls are not made, the test will fail with detailed diagnostics.

---

## Test Discovery

GoogleTest automatically discovers tests defined using `TEST` or `TEST_F` macros, making it easy to compile and run test suites without manual registration.

Run your tests via the generated test binary or command line:

```bash
test_binary --gtest_filter=TestCaseName.TestName
```

Filtering and selective running enable targeted test efforts.

---

## Summary

This page covered foundational GoogleTest concepts:

- Defining **tests** and **test cases**
- Creating and using **fixtures** to share setup and teardown
- Writing **assertions** to verify behaviors
- Using **matchers** for expressive conditions
- Creating and employing **mocks** to isolate and verify code interactions
- Leveraging built-in **test discovery** mechanisms

Understanding these concepts will empower you to write effective, maintainable, and robust C++ tests with GoogleTest.

---

## Related Documentation and Resources

- [gMock for Dummies](gmock_for_dummies.md) - A beginner-friendly introduction to mocking.
- [Mocking Reference](docs/reference/mocking.md) - Detailed descriptions of mocking APIs.
- [gMock Cookbook](docs/gmock_cook_book.md) - Practical recipes for using GoogleMock.
- [gMock Cheat Sheet](docs/gmock_cheat_sheet.md) - Quick reference to common mocking patterns and syntax.
- [Core Concepts and Terminology](overview/product-intro-core-concepts/core-concepts-terminology) (this page)

For advanced topics on test organization and running tests:

- [Writing Your First Test](guides/getting-started/writing-your-first-test)
- [Test Discovery and Execution Workflow](guides/getting-started/test-discovery-and-execution)

Make sure you have included `<gtest/gtest.h>` in your test files to access the GoogleTest framework.

---

## Next Steps

To start writing your tests:

- Define test fixtures for common setup.
- Create mock classes using `MOCK_METHOD` macros.
- Compose expectations using `EXPECT_CALL` with matchers.
- Use assertions like `EXPECT_EQ` and `ASSERT_TRUE` to validate outcomes.

Explore the friendly tutorials and recipes in the gMock and GoogleTest documentation to deepen your skills and take full advantage of these powerful tools.