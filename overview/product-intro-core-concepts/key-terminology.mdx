---
title: "Key Concepts & Terminology"
description: "Master the essential terminology: test fixtures, assertions, death tests, parameterized and type-parameterized tests, and mocking. This reference will help you confidently navigate the rest of the documentation and features."
---

# Key Concepts & Terminology

Mastering the essential terminology in GoogleTest is fundamental to using the framework effectively and confidently. This page introduces and explains key concepts like test fixtures, assertions, death tests, parameterized and type-parameterized tests, and mocking. Understanding these terms will empower you to navigate the rest of the documentation and leverage GoogleTest’s powerful features.

---

## Test Fixtures

A *test fixture* is a class that holds the shared setup and teardown code for a group of related tests. It allows you to reuse initialization code and share objects among multiple tests, improving organization and test maintenance.

- Typically, a test fixture inherits from `testing::Test`.
- Use `TEST_F(FixtureName, TestName)` to write individual tests that use this fixture.
- Each test runs in a fresh fixture object to maintain isolation.

Example:

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Set up queues
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(0, q0_.size());
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q1_.Dequeue();
  ASSERT_NE(nullptr, n);
  EXPECT_EQ(1, *n);
  delete n;
}
```

**Tip:** Use the constructor or `SetUp()` method to initialize shared fixtures. Remember that GoogleTest creates a new fixture instance for each test, ensuring independence.

---

## Assertions

Assertions verify conditions within tests and determine whether the test passes or fails. GoogleTest provides two categories:

- **Fatal assertions** (`ASSERT_*`): Abort the current function on failure.
- **Nonfatal assertions** (`EXPECT_*`): Record the failure but continue running the current function.

All assertions can include streaming messages for enhanced failure diagnostics.

Example:

```cpp
ASSERT_EQ(expected_size, actual_size) << "Container sizes differ";
EXPECT_TRUE(IsSorted(container)) << "Container is not sorted";
```

Key types of assertions include:

- Equality and relational comparisons (`EXPECT_EQ`, `EXPECT_NE`, `EXPECT_LT`, etc.)
- Boolean conditions (`EXPECT_TRUE`, `EXPECT_FALSE`)
- String comparisons (`EXPECT_STREQ`, `EXPECT_STRNE`)
- Floating-point comparisons (`EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`)
- Exception assertions (`EXPECT_THROW`, `EXPECT_NO_THROW`)
- Death assertions (`EXPECT_DEATH`, `ASSERT_DEATH`)

**Best practice:** Prefer nonfatal assertions to enable more comprehensive test feedback unless continued execution makes no sense.

---

## Death Tests

Death tests check that code causes program termination as expected, such as through assertions or crashes in unsafe states.

- Use `EXPECT_DEATH(statement, "regex")` to verify `statement` causes the program to exit with an error matching the given regex.
- They run in a separate process to isolate crashes from the parent test process.
- Naming convention: Test suites that include death tests should have names ending with `DeathTest` for correct execution ordering and safety.

Example:

```cpp
TEST(FooDeathTest, CheckCrash) {
  ASSERT_DEATH(Foo(nullptr), "null pointer");
}
```

**Note:** Death tests run in a separate process, so side effects they produce won’t affect the parent process.

---

## Parameterized Tests

Parameterized tests enable running the same test logic with different input values without duplicating code. They come in two flavors:

### Value-Parameterized Tests

- Derive your fixture from `testing::TestWithParam<T>` where `T` is the parameter type.
- Define tests with `TEST_P(FixtureName, TestName)`.
- Instantiate test suites using `INSTANTIATE_TEST_SUITE_P` with parameter generators like `Values()`, `Range()`, or `Combine()`.

Example:

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveTests, FooTest, testing::Values(1, 2, 3));
```

Tests are named to indicate parameter values, aiding identification.

### Type-Parameterized Tests

- Useful for testing the same logic across multiple types.
- Define a fixture template and register tests using `TYPED_TEST_SUITE` and `TYPED_TEST` macros.
- Instantiate the suite by specifying the list of types.

Example:

```cpp
template <typename T>
class MyTypeTest : public testing::Test {
  //...
};
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypeTest, MyTypes);

TYPED_TEST(MyTypeTest, WorksForAllTypes) {
  TypeParam value = TypeParam();
  EXPECT_GE(value, 0);
}
```

---

## Mocking

GoogleTest's mocking framework GoogleMock allows you to create mock objects and define expectations on method calls.

- Define mock classes by inheriting from your interface and using `MOCK_METHOD` to declare mocked methods.
- Use `EXPECT_CALL` to set expectations, specifying the method, arguments, call count, and behavior.

Example:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(void, DoSomething, (int x), ());
};

MockFoo mock;
EXPECT_CALL(mock, DoSomething(5)).Times(1);

mock.DoSomething(5); // Expectation met.
```

You can chain modifiers like `.Times()`, `.WillOnce()`, `.WillRepeatedly()`, `.InSequence()`, and `.After()` to control mock behavior and sequencing.

---

## Additional Key Terms

- **Assertions:** Conditions checked during tests to validate behavior.
- **Test Suite:** A collection of related tests, often sharing a fixture.
- **Test Fixture:** A class providing setup and teardown for tests within a suite.
- **Parameterized Test:** Tests run multiple times with varying parameters.
- **Death Test:** Test that verifies program termination under specific conditions.
- **Mock Object:** An object that simulates behavior of real dependencies, allowing for controlled testing.

---

## Practical Tips & Common Pitfalls

- Always name test suites and tests without underscores to avoid internal conflicts.
- Remember to call `InitGoogleTest` before running tests with `RUN_ALL_TESTS()`.
- Don't ignore the return value of `RUN_ALL_TESTS()`; it signals overall test success.
- For parameterized tests, ensure instantiations exist for every `TEST_P` fixture used.
- For death tests, keep in mind they run in a separate process, so side effects are isolated.
- When mocking, carefully specify expectations with correct argument matchers to avoid false positives or unnoticed failures.

---

## What’s Next?

Now that you know these fundamental concepts and terminology, you are equipped to dive into writing effective tests, exploring advanced testing strategies, and understanding the GoogleTest API in detail.

Consider visiting these pages next:

- [Writing and Running Your First Tests](../guides/core-workflows/writing-first-tests)
- [Parameterized and Type-Parameterized Tests](../guides/advanced-testing-strategies/parameterized-and-typed-tests)
- [Death Tests and Failure Handling](../guides/advanced-testing-strategies/death-and-failure-tests)
- [Mocking C++ Objects with GoogleMock](../guides/advanced-testing-strategies/mocking-with-googlemock)

---

For full details on syntax, usage, and more examples, explore the [Testing Reference](../reference/testing.md) and [Assertions Reference](../reference/assertions.md).


---

<Callout title="Note">
This page focuses exclusively on foundational concepts and terminology to provide a solid base for your GoogleTest journey. It complements other documentation pages that delve into implementation details and workflows.
</Callout>

