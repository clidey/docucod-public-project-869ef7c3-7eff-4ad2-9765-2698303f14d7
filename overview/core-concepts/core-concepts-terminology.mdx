---
title: "Core Concepts and Terminology"
description: "Demystify essential concepts including test cases, assertions, fixtures, parameterized tests, type-parameterized tests, death tests, mocks, matchers, and cardinalities. Recognize the role each plays in typical testing workflows."
---

# Core Concepts and Terminology

GoogleTest offers a rich vocabulary that empowers you to write clear, organized, and effective C++ tests. Understanding the foundational concepts and terminology is crucial to harnessing the framework's full potential. This page breaks down essential elements such as test cases, assertions, fixtures, parameterized tests, mocks, and more, illustrating how they fit into typical testing workflows.

---

## Why Knowing These Terms Matters

Imagine you're assembling a complex puzzle. Knowing the shape and role of each piece makes the assembly smoother and the final picture clear. In GoogleTest, terms like "test suite," "assertions," or "death tests" are those puzzle pieces. Recognizing what each means and how they interconnect enables you to write tests that are:

- **Isolated and Predictable**: Each test focused on a single behavior.
- **Maintainable**: Organized logically, easing future changes.
- **Informative**: Clear feedback when something goes wrong.

---

## Tests, Test Suites, and Test Programs

- **Test (`TEST()`)**: An individual examination verifying a particular aspect or behavior of your code, such as checking that a function returns an expected value for given input. It corresponds to a “Test Case” in standard testing vocabulary (ISTQB).

- **Test Suite**: A collection of related tests that typically test the same class or module. Grouping your tests into suites reflects your code's structure and helps maintain clarity.

- **Test Program**: An executable that contains one or more test suites. Running the test program executes all its tests unless filtered.


### Naming Notes

- GoogleTest uses `TEST(TestSuiteName, TestName)` macro, where both names **must be valid C++ identifiers without underscores** to avoid internal conflicts and maintain composability.

> See [Why test suite names and test names must not contain underscores](https://github.com/google/googletest/blob/main/docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore) for detailed reasoning.

---

## Assertions: Verifying Behavior

At the heart of each test are **assertions** — checks that confirm your code behaves as expected. GoogleTest offers a spectrum of assertions, including pairs of macros:

- `EXPECT_*`: Non-fatal assertions that report failure but continue the current test.
- `ASSERT_*`: Fatal assertions that abort the current test function immediately upon failure.

### Example

```cpp
ASSERT_EQ(x.size(), y.size()) << "Vectors x and y are of unequal length.";
for (int i = 0; i < x.size(); ++i) {
  EXPECT_EQ(x[i], y[i]) << "Vectors x and y differ at index " << i;
}
```

This combination lets you catch critical failures that prevent further checks, while still able to report multiple errors when appropriate.

### Types of Assertions Covered

- Boolean conditions (`EXPECT_TRUE`, `ASSERT_FALSE`)
- Binary comparisons (`EXPECT_EQ`, `ASSERT_GT`)
- String comparisons for C strings (`EXPECT_STREQ`)
- Floating-point comparisons with tolerances (`EXPECT_FLOAT_EQ`, `EXPECT_NEAR`)
- Exception handling (`EXPECT_THROW`, `ASSERT_NO_THROW`)
- Predicate assertions for custom conditions
- Death assertions that verify that code crashes or exits as expected

> For a deeper list and details, see [Assertions Reference](reference/assertions.md).

---

## Test Fixtures: Reusing Configurations

When multiple tests share common objects or setup code, **test fixtures** allow you to write that setup once and reuse it efficiently.

### How Fixtures Work

1. Define a class derived from `testing::Test`.
2. Declare common objects and write `SetUp()`/`TearDown()` methods for initialization and cleanup.
3. Use `TEST_F(FixtureClassName, TestName)` to write tests that can access fixture members.

Each test gets a **fresh** fixture instance, guaranteeing test isolation.

### Example

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
     q1_.Enqueue(1);
     q2_.Enqueue(2);
     q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

---

## Parameterized and Typed Tests

These advanced test forms enable you to run the same test logic on multiple inputs or types without code duplication.

- **Value-Parameterized Tests (`TEST_P`)**: Write tests that receive different values as parameters. Great for data-driven testing.

- **Typed Tests (`TYPED_TEST`)**: Write tests once for a suite of types (classes or built-in types).

- **Type-Parameterized Tests (`TYPED_TEST_P`)**: Define test logic template-like and instantiate with types later, enabling reusable abstract tests.

These patterns increase coverage and reduce boilerplate while keeping tests clean.

For example, with value-parameterized tests:

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, HandlesValues) {
  int value = GetParam();
  EXPECT_TRUE(HandleValue(value));
}

INSTANTIATE_TEST_SUITE_P(IntValues, FooTest, testing::Values(1, 2, 3));
```

Learn more in the [Advanced Guide](advanced.md#value-parameterized-tests).

---

## Death Tests

Death tests verify that your code correctly terminates the program (e.g., via assertions failing) under specific conditions.

- Use `EXPECT_DEATH` or `ASSERT_DEATH` macros to check that a statement kills the process and produces expected error messages.

- Death tests run in separate processes to keep the test program alive for other tests.

- GoogleTest offers two death test styles:
  - **Fast** (default): Runs the test in a child process immediately.
  - **Thread-safe**: More robust, suitable for multithreaded environments, but slower.

> To ensure correct sequencing and reduce issues, name your death-test suites with the suffix `DeathTest`. If mixing with regular tests, use type aliases to differentiate.

See details at [Death Tests and Exception Handling](advanced.md#death-tests) and [Death Assertions](reference/assertions.md#death).

---

## Mocks, Matchers, and Cardinalities

GoogleTest supports mocking through its companion framework, **GoogleMock** (gMock), enabling you to simulate dependencies and verify behaviors.

### Key Components:

- **Mocks**: Classes where member functions are replaced by mock methods declared with `MOCK_METHOD`. These methods simulate behavior and track calls.

- **Matchers**: Flexible tools to specify criteria for expected arguments in mock method calls, enhancing expressiveness beyond simple equality.

- **Expectations (`EXPECT_CALL`)**: Statements that declare how many times and in which order mock methods should be called.

- **Cardinalities (`Times`)**: Specify how many times the mock method is expected to be invoked:

  - `AnyNumber()`: Unlimited times
  - `AtLeast(n)`: At least n times
  - `AtMost(n)`: Up to n times
  - `Between(m, n)`: Between m and n times
  - `Exactly(n)`: Exactly n times

### Example

```cpp
class MockDatabase {
 public:
  MOCK_METHOD(bool, Connect, (), ());
  MOCK_METHOD(int, Query, (std::string query), ());
};

MockDatabase mock_db;
EXPECT_CALL(mock_db, Connect()).Times(1).WillOnce(Return(true));
EXPECT_CALL(mock_db, Query(_)).Times(AtLeast(1));

// Code under test...
```

GoogleMock's rich syntax helps you create precise and maintainable behavioral tests.

---

## Cardinalities in Expectations

Cardinalities define the allowed number of times a mocked method is expected to be invoked. They provide control over how strictly you want to enforce call counts:

| Cardinality           | Description                                           |
| --------------------- | ----------------------------------------------------- |
| `AnyNumber()`         | Mock method can be called any number of times         |
| `AtLeast(n)`          | Called at least *n* times                              |
| `AtMost(n)`           | Called at most *n* times                               |
| `Between(m, n)`       | Called between *m* and *n* times, inclusive           |
| `Exactly(n)` or `n`   | Called exactly *n* times                               |

If `Times()` is not specified, GoogleTest infers it based on other clauses.

---

## Putting It All Together: Typical Flow

1. **Define tests** with either simple tests (`TEST()`), fixture-based tests (`TEST_F()`), or parameterized/typed tests.
2. **Add assertions** in tests to verify conditions and expected outputs.
3. **Group related tests** logically into test suites to mirror your code's structure.
4. **Use fixtures** to share common setup/teardown.
5. **Leverage mocks and expectations** to simulate dependencies.
6. **Run tests** via `RUN_ALL_TESTS()` for automated discovery and execution.

This layered approach ensures your tests are isolated, maintainable, and expressive.

---

<Info>
For more examples and detailed explanations, consult these related resources:

- [GoogleTest Primer](primer.md) — Learn the basics with code examples.
- [Assertions Reference](reference/assertions.md) — Complete list of assertion macros.
- [Advanced GoogleTest Topics](advanced.md) — Deep dive into parameterized tests and death tests.
- [Mocking Reference](reference/mocking.md) — Detailed guide on mocks and expectations.
- [Testing Reference](reference/testing.md) — Overview of test macros and classes.
</Info>

---