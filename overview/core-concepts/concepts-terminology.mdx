---
title: "Core Concepts and Terminology"
description: "Demystify essential GoogleTest concepts such as test cases, test fixtures, assertions, matchers, mocks, and parameterized tests. Quickly become fluent in the vocabulary used by the framework and its documentation."
---

# Core Concepts and Terminology

Dive deep into the foundational vocabulary of GoogleTest to master its testing capabilities efficiently. In this guide, you'll explore essential concepts such as test cases, test fixtures, assertions, matchers, mocks, and parameterized tests. Understanding these terms will empower you to read the framework's documentation fluently and leverage its power to write robust, maintainable tests.

---

## What Are Test Cases and Test Fixtures?

### Test Cases
A *test case* is a logical grouping of tests that verify a certain aspect of your code. In GoogleTest, a test case usually corresponds to a class or module under test.

### Test Fixtures
*Test fixtures* refer to the setup and teardown environment shared across multiple tests. This enables you to:

- Initialize common objects before each test runs.
- Clean up resources after test completion.

#### Example: Using Test Fixtures

```cpp
#include <gtest/gtest.h>

class CalculatorTest : public ::testing::Test {
 protected:
  void SetUp() override {
    calc = new Calculator();
  }

  void TearDown() override {
    delete calc;
  }

  Calculator* calc;
};

TEST_F(CalculatorTest, Addition) {
  EXPECT_EQ(calc->Add(2, 3), 5);
}
```

Here, `CalculatorTest` is a test fixture that prepares a `Calculator` object for testing. Each test using `TEST_F` shares this fixture, promoting DRY and consistent test setup.

---

## Assertions and Matchers

### Assertions
Assertions verify expected outcomes in your tests and express pass/fail conditions. Common assertions include:

- `EXPECT_EQ(val1, val2)`: expects values to be equal.
- `ASSERT_TRUE(condition)`: expects condition to be true and aborts the test if not.

Assertions help communicate the intent clearly and detect failures accurately.

### Matchers
Matchers are a powerful and expressive way to specify argument expectations in mock objects and parameter validations in assertions. Unlike simple equality, matchers allow you to specify complex conditions on arguments:

- `_`: wildcard matcher that accepts any argument.
- `Ge(5)`: expects a value greater than or equal to 5.
- `HasSubstr("hello")`: expects a string containing "hello".

#### Example: Using Matchers in Assertions

```cpp
EXPECT_THAT(my_vector, ::testing::ElementsAre(1, 2, 3));
EXPECT_CALL(mock_obj, DoSomething(Ge(5), _));
```

Using matchers allows for precise, readable, and flexible specifications.

---

## Mocks and Their Use

### What Is a Mock?
A *mock* is a test double that simulates the behavior of real objects by:

- Providing expected interfaces.
- Allowing verification of interactions.
- Controlling behavior via expectations and default actions.

Mocks are particularly valuable in interaction-based testing, where verifying **how** and **when** collaborators are used is as important as the final state.

### Creating Mock Classes
Mocks are defined by inheriting from an interface or base class and using the `MOCK_METHOD` macro to specify mocked methods.

```cpp
class MockDatabase : public Database {
 public:
  MOCK_METHOD(bool, Connect, (const std::string& uri), (override));
  MOCK_METHOD(int, GetRecordCount, (), (const, override));
};
```

### Controlling Behavior with ON_CALL and EXPECT_CALL

- `ON_CALL` sets default behavior but does not fail if not called.
- `EXPECT_CALL` sets both behavior and expectations about calls.

### Nice, Naggy, and Strict Mocks

- `NiceMock<T>`: suppresses warnings for uninteresting calls.
- `NaggyMock<T>` (default): warns on uninteresting calls.
- `StrictMock<T>`: treats uninteresting calls as test failures.

#### Usage Example

```cpp
using ::testing::StrictMock;
StrictMock<MockDatabase> mock_db;
EXPECT_CALL(mock_db, Connect(_));
// Test code that uses mock_db
```

### Tips for Mock Usage

- Use `ON_CALL` to define general mock behavior.
- Use `EXPECT_CALL` to enforce specific call expectations.
- Avoid over-specification to keep tests maintainable.
- Use `NiceMock` to reduce noise during test development.

---

## Parameterized Tests

Parameterized tests allow you to run the same test logic over a set of different inputs or types, reducing code duplication and increasing test coverage.

### Using Parameterized Tests

```cpp
class FactorialTest : public ::testing::TestWithParam<std::tuple<int, int>> {};

TEST_P(FactorialTest, ComputesCorrectly) {
  int n, expected;
  std::tie(n, expected) = GetParam();
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(
    Factorials, FactorialTest,
    ::testing::Values(
        std::make_tuple(0, 1),
        std::make_tuple(1, 1),
        std::make_tuple(4, 24),
        std::make_tuple(5, 120)));
```

This runs `ComputesCorrectly` test for multiple input-output pairs.

---

## Vocabulary Quick Reference

| Term              | Description                                                           |
|-------------------|-----------------------------------------------------------------------|
| Test Case         | Group of related tests                                                 |
| Test Fixture      | Setup/teardown environment for tests                                  |
| Assertion         | Condition verification in tests                                       |
| Matcher           | Predicate defining argument/parameter expectations                    |
| Mock              | Test double that simulates real object with configurable behaviors     |
| Parameterized Test | Test template covering multiple input sets                            |

---

## Best Practices and Common Pitfalls

- Always mock interfaces with virtual destructors to avoid undefined behavior.
- Use `EXPECT_CALL` only when call ordering or frequency matters.
- Suppress uninteresting call warnings using `NiceMock` during initial test development.
- Avoid setting expectations after mocks are in use; set them upfront.
- Leverage parameterized tests to avoid redundant test cases.
- Use `.RetiresOnSaturation()` to prevent over-saturation errors with repeated calls.

---

## Next Steps

You are now equipped with a solid understanding of the terminology GoogleTest uses. To put it into practice, explore these pages:

- [Your First Test: Quick Success](/getting-started/core-setup/first-test) to quickly write and run your initial tests.
- [Feature Overview](/overview/core-concepts/feature-quick-overview) to see what GoogleTest can do at a glance.
- [Introducing Mocking with GoogleMock](/guides/getting-started/integrate-mocking) for deeper mocking integration.

Unlock the full power of GoogleTest by mastering these concepts and testing patterns.

---