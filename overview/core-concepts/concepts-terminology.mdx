---
title: "Core Concepts & Terminology"
description: "Get fluent in the essential terminology of GoogleTest and GoogleMock: tests, test suites, fixtures, assertions, death tests, mocks, expectations, matchers, and actions. Understand how these building blocks fit into the workflow of writing and reading tests."
---

# Core Concepts & Terminology

## Understanding the Building Blocks of GoogleTest & GoogleMock

To effectively write and read tests with GoogleTest and GoogleMock, it is essential to become fluent with the core terminology and concepts that form their foundation. These concepts represent the ingredients of your testing workflow and help you orchestrate powerful, maintainable tests.

---

### Tests and Test Suites

- **Test:** A single test verifies a specific behavior or property of the code under test. It's a function that contains assertions checking conditions.
- **Test Suite:** A collection of related tests grouped together to share setup, teardown, or context. It usually corresponds to a logical unit or class being tested.

**Why It Matters:** Organizing tests in suites provides structure and promotes code reuse, making your testing code more navigable and maintainable.

---

### Fixtures

**Test Fixtures** provide a stable and reusable environment around your tests. They are classes derived from `testing::Test` that hold common setup and teardown logic along with shared data members.

- Helps you avoid duplicating initialization and cleanup code across multiple tests.
- Each test using a fixture is run with a fresh instance, ensuring test independence.

**Example:** 
```cpp
class QueueTest : public testing::Test {
 protected:
  Queue<int> q0_;
  void SetUp() override {
    q0_.Enqueue(10);
  }
};

TEST_F(QueueTest, IsNotEmptyInitially) {
  EXPECT_GT(q0_.size(), 0);
}
```

---

### Assertions

Assertions are your test’s checks—simple or complex conditions that verify if the code behaves as expected. Failures in assertions mark tests as failed.

- Use `EXPECT_` macros for non-fatal failures (test continues).
- Use `ASSERT_` macros for fatal failures (test aborts immediately).

**Example:**
```cpp
EXPECT_EQ(Add(2, 3), 5) << "Addition failed";
ASSERT_TRUE(IsValid(user)) << "User validation failed";
```

---

### Death Tests

A special kind of test that verifies code terminates the process under certain error conditions (e.g., assertion failures).

- Encapsulate potentially crashing code in a separate process.
- Use macros like `EXPECT_DEATH()` and `ASSERT_DEATH()`.

**Example:**
```cpp
EXPECT_DEATH(CheckNull(nullptr), "null pointer");
```

---

### Mock Objects

Mocks simulate parts of your system and allow you to verify interactions and control behaviors.

- Implement interfaces using the `MOCK_METHOD` macros.
- Set expectations with `EXPECT_CALL` about how the mock should be used.
- Verify calls, call order, arguments, and more.

**Why Use Mocks:** They isolate your unit under test, replace slow or complex dependencies, and enable precise control and verification.

---

### Matchers

Matchers define constraints on function arguments in both expectations (e.g., `EXPECT_CALL`) and assertions.

- Allow flexible matching beyond literal values.
- Common matchers: `_` (wildcard), `Eq()`, `Ge()`, `HasSubstr()`, and many more.

**Example:**
```cpp
EXPECT_CALL(mock, Foo(Ge(10), _));  // First argument ≥ 10, second can be anything
EXPECT_THAT(str, HasSubstr("needle"));  // Assert str contains "needle"
```

---

### Actions

Actions specify the behavior of mock methods when called.

- `Return(value)`: Return a specific value.
- `ReturnRef(variable)`: Return a reference.
- `Invoke(function)`: Invoke a user function or lambda.
- `DoAll(...)`: Combine multiple actions.

**Example:**
```cpp
EXPECT_CALL(mock, GetValue())
    .WillOnce(Return(42))
    .WillRepeatedly(Return(0));
```

---

### Expectations

These are assertions about how mocks are used.

- Defined via `EXPECT_CALL`.
- Specify argument matchers, call counts (`Times()`), order (`InSequence`, `After`), and actions.

**Example:**
```cpp
EXPECT_CALL(mock, Process(_))
    .Times(3)
    .WillRepeatedly(Return(true));
```

---

### Sticky Expectations and Uninteresting Calls

- Mocks have "sticky" expectations by default: once an expectation matches a call, it remains active until saturated.
- Calls not covered by any expectation are considered uninteresting and generate warnings but not failures.

You can control the strictness using `NiceMock`, `NaggyMock`, and `StrictMock` wrappers.

---

### User Workflow Fit

When you write tests with GoogleTest and GoogleMock, you usually follow this flow:

1. Define what you want to test (**Tests** and **Test Suites**).
2. Prepare your test environment (**Fixtures**).
3. Use assertions to validate outcomes.
4. For interaction testing, define **Mock Objects** with **Expectations**.
5. Use **Matchers** to specify argument constraints.
6. Use **Actions** to control mock behaviors.
7. Employ **Death Tests** to validate fatal failure handling.

---

## Practical Example: Mocking a Turtle Interface Using GoogleMock

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
};

using ::testing::AtLeast;
using ::testing::_;
using ::testing::Return;

TEST(DrawTest, DrawLine) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown())
      .Times(AtLeast(1));
  EXPECT_CALL(turtle, Forward(_)).Times(1);

  // Code under test that uses turtle
  turtle.PenDown();
  turtle.Forward(100);
}
```

---

## Summary

Becoming familiar with these core terms and how they interact lays the foundation for mastering GoogleTest and GoogleMock. From defining simple tests to creating complex mock interactions, this vocabulary unlocks the full power of the framework and guides you toward writing clear, reliable, and maintainable C++ tests.



---

# Additional Resources

- Learn more about the full [product introduction](../overview/getting-started-value/product-intro).
- Explore [common use cases and targeted audience](../overview/getting-started-value/audience-use-cases).
- See detailed [feature overviews](../overview/getting-started-value/quick-features).
- Deep dive into [mocking strategies and recipes](../docs/gmock_cook_book.md).
- Understand [expectations and actions](../docs/reference/mocking.md).
- Discover how to use [matchers effectively](../docs/reference/matchers.md).

---

GoogleTest and GoogleMock empower C++ developers by providing expressive, automated testing and mocking capabilities. Mastering the core concepts described here is your first step toward writing tests that deliver confidence and accelerate development.

---