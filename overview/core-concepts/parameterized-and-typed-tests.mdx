---
title: "Parameterized and Typed Test Patterns"
description: "Explore the advanced mechanisms for parameterized and type-parameterized tests, enabling broad code coverage with minimal boilerplate. Learn where and why to use these patterns for greater test flexibility."
---

# Parameterized and Typed Test Patterns

Unlock the power of writing flexible, reusable tests that cover broad scenarios with minimal code duplication. This guide explores how GoogleTest supports **value-parameterized tests**, **typed tests**, and **type-parameterized tests** â€” advanced patterns that enable you to systematically vary input parameters or data types in your test suites.

---

## Why Parameterized and Typed Tests Matter

Imagine you have a function that processes numbers, and you want to verify it behaves correctly for multiple inputs. Writing separate tests for every input value quickly becomes tedious and error-prone. Similarly, if your code uses templates or multiple types, writing identical test logic for each type results in duplicated effort and fragmented test maintenance.

GoogleTest's parameterized and typed test mechanisms elegantly solve this by allowing you to define one test pattern that runs multiple times with different parameter values or types. This approach improves coverage, reduces boilerplate, and keeps your tests DRY (Don't Repeat Yourself).

---

## Value-Parameterized Tests: Vary Input Data with Ease

Value-parameterized tests let you run the same test logic with a range of input values. This is useful when you want to verify functionality across different inputs without writing repetitive tests.

### How It Works

1. **Define a Test Fixture Class**
   - Derive from `::testing::TestWithParam<T>`, where `T` is the parameter type.

2. **Write TEST_P() Tests**
   - Define your parameterized test cases using the `TEST_P` macro.
   - Inside each test, use `GetParam()` to access the current test parameter.

3. **Instantiate Tests with Parameters**
   - Use `INSTANTIATE_TEST_SUITE_P` with parameter generators, such as `Values()`, `Range()`, `ValuesIn()`, `Bool()`, or `Combine()`, to supply test inputs.

### Example

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {};

TEST_P(FooTest, HandlesString) {
  EXPECT_TRUE(ProcessString(GetParam()));
}

INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    ::testing::Values("hello", "world", "test"));
```

Each parameterized test instance is uniquely named using a prefix and indexed suffix to distinguish test runs.

### Handy Parameter Generators

- `Range(begin, end[, step])`: Generates values from begin to just before end.
- `Values(v1, v2, ..., vN)`: Use explicit values.
- `ValuesIn(container)`: Use values from arrays or STL containers.
- `Bool()`: Generates two values `{false, true}`.
- `Combine(g1, g2, ...)`: Cartesian product for multiple parameter sets.
- `ConvertGenerator<T>(generator, converter)`: Converts generated types.

<Tip>
Use `Combine()` to comprehensively test multi-parameter functions by generating all possible combinations.
</Tip>

### Best Practices

- Always choose meaningful parameter names or provide custom name generators to keep test outputs clear.
- Manage pointer lifetimes if you use pointers as parameters.
- Avoid overly large parameter sets that can cause test explosion and slow runs.

---

## Typed Tests: Run Tests Across Multiple Types

Typed tests let you verify that your class templates or functions behave correctly across multiple types without rewriting tests.

### How It Works

1. **Define a Test Fixture Template**
   - Derive from `testing::Test` and parameterize by a type `T`.

2. **Specify the List of Types to Test**
   - Use `::testing::Types<T1, T2, ...>` to declare the types.

3. **Associate Types with the Test Suite**
   - Use `TYPED_TEST_SUITE(FooTest, MyTypes)` to bind your fixture template to the type list.

4. **Write TYPED_TEST() Tests**
   - Use `TYPED_TEST(FooTest, TestName)` to define tests.
   - Inside tests, use the special identifier `TypeParam` to refer to the current type.

### Example

```cpp
template <typename T>
class MyContainerTest : public ::testing::Test {
 public:
  T container;
};

typedef ::testing::Types<std::vector<int>, std::list<int>> ContainerTypes;
TYPED_TEST_SUITE(MyContainerTest, ContainerTypes);

TYPED_TEST(MyContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container.empty());
}
```

Each type in `ContainerTypes` causes all `TYPED_TEST` tests to run once for that type.

### Custom Type Names

You can define a custom naming class with a static template `GetName(int)` method to produce readable type suffixes.

---

## Type-Parameterized Tests: Define Abstract Test Patterns for Types

Type-parameterized tests extend typed tests by allowing test patterns to be defined without committing to the types upfront. Different translation units or components can then instantiate the tests with arbitrary types.

### How It Works

1. **Define a Test Fixture Template**
   - Derive from `::testing::Test`.

2. **Declare Test Suite as Type-Parameterized**
   - Use `TYPED_TEST_SUITE_P` to declare the suite.

3. **Write TYPED_TEST_P() Tests**
   - Define tests using `TYPED_TEST_P(FooTest, TestName)`.

4. **Register Test Names**
   - Use `REGISTER_TYPED_TEST_SUITE_P(FooTest, Test1, Test2, ...)` to register.

5. **Instantiate with Types**
   - In any translation unit, use `INSTANTIATE_TYPED_TEST_SUITE_P(InstantiationName, FooTest, Types<...>)` to instantiate.

### Example

```cpp
template <typename T>
class MyAbstractTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyAbstractTest);

TYPED_TEST_P(MyAbstractTest, WorksForType) {
  TypeParam val = TypeParam();
  EXPECT_EQ(val, val);
}

REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, WorksForType);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyAbstractTest, MyTypes);
```

This decouples test suite definition from the types, enabling flexible reuse in shared libraries and complex projects.

---

## Summary Workflow

<Steps>
<Step title="Create Test Fixture">
Define your test fixture as a class template or value-parameterized class inheriting appropriate GoogleTest base classes (`TestWithParam<T>`, `Test`).
</Step>
<Step title="Write Test Cases">
Use `TEST_P`, `TYPED_TEST`, or `TYPED_TEST_P` macros to write test logic that uses parameters or types.
</Step>
<Step title="Register Tests and Parameters/Types">
Instantiate test suites with parameter generators for value-parameterized tests or specify type lists for typed tests.
</Step>
<Step title="Run and Analyze">
Run all generated test instances uniformly. Analyze results, benefiting from extensive, automated coverage.
</Step>
</Steps>

---

## Troubleshooting and Tips

- **Duplicate Test Names:** When instantiating parameterized or typed tests, ensure unique names or use custom name generators to prevent collisions.
- **Memory Management:** For pointer parameters in value-parameterized tests, manage object lifetimes carefully to avoid leaks or dangling references.
- **Performance:** Avoid generating excessively large Cartesian products with `Combine()` unless necessary.
- **Naming Conventions:** Use alphanumeric characters and underscores in test names to comply with GoogleTest naming rules.

<Tip>
Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTestSuite)` if your value-parameterized test suite is defined but not instantiated yet to suppress warnings.
</Tip>

---

## How This Fits in GoogleTest

This page deepens your understanding of test patterns that maximize efficiency and maintainability in years-long C++ projects. These patterns complement the core GoogleTest concepts of test fixtures, assertions, and test execution to enable robust and scalable test suites.

Be sure to explore related documentation to master full testing workflows:

- [What is GoogleTest?](../overview/introduction-value/what-is-googletest)
- [Parameterized and Typed Tests Guide](../guides/core_workflows/parameterized-tests)
- [Testing Reference: TEST, TEST_P, TYPED_TEST macros](../docs/reference/testing.md)
- [Typed Tests and Type-Parameterized Test APIs](../googletest/include/gtest/gtest-typed-test.h)

---

## Visual Overview

```mermaid
flowchart TD
  subgraph Value-Parameterized Tests
    A[Test Fixture: TestWithParam<T>]
    B[Define TEST_P Cases]
    C[Instantiate with Generators (Values, Range, etc.)]
    A --> B --> C
  end

  subgraph Typed Tests
    D[Test Fixture: Template <T> : Test]
    E[Bind with Typedef Types<T1, T2, ...>]
    F[Define TYPED_TEST Cases]
    D --> E --> F
  end

  subgraph Type-Parameterized Tests
    G[Test Fixture: Template <T> : Test]
    H[Declare with TYPED_TEST_SUITE_P]
    I[Define TYPED_TEST_P Cases]
    J[Register with REGISTER_TYPED_TEST_SUITE_P]
    K[Instantiate in Translation Units]
    G --> H --> I --> J --> K
  end

  style A fill:#f9f,stroke:#333,stroke-width:2px;
  style D fill:#9f9,stroke:#333,stroke-width:2px;
  style G fill:#99f,stroke:#333,stroke-width:2px;
```

---

## Next Steps

- Begin experimenting with **value-parameterized tests** to validate edge cases against your functions or algorithms.
- Transition to **typed tests** to ensure your templates behave consistently across types.
- Explore **type-parameterized tests** for reusable, abstract test definitions in larger projects.
- Review the [Parameterized Tests Guide](../guides/core_workflows/parameterized-tests) for detailed examples and patterns.


---

## References and Related Documentation

- [Value-Parameterized Tests in API Reference](../docs/reference/testing.md#TEST_P)
- [Typed Tests API](../googletest/include/gtest/gtest-typed-test.h)
- [Parameterized Tests Guide](../guides/core_workflows/parameterized-tests)
- [Introduction to GoogleTest](../overview/introduction-value/what-is-googletest)

---

Leverage these advanced test patterns to write high-coverage, maintainable tests that save time and increase confidence in C++ codebases of any size.
