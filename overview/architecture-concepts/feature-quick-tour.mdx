---
title: "Feature Quick Tour"
description: "Take a rapid-fire look at GoogleTest’s most useful features: automatic test discovery, assertion macros, user-defined assertions, death tests, fatal/non-fatal failures, parameterized and type-parameterized tests, running individual or parallel tests, and integration with GoogleMock. See how these tools fit into common user workflows."
---

# Feature Quick Tour

## Explore GoogleTest’s Essential Features in Action

GoogleTest equips you with a rich set of capabilities that streamline C++ testing — from automatic test discovery to powerful assertion macros and seamless integration with GoogleMock. This quick tour offers a rapid-fire overview of its most useful features, showcasing how they map to common testing workflows and help you write more effective tests faster.

---

### Automatic Test Discovery

Say goodbye to manual test registration. GoogleTest automatically finds all tests defined across your codebase, so you can focus on writing tests rather than configuring them.

**What You Get:**
- No boilerplate to register tests
- Easy addition of new tests without extra setup
- Support for both test functions and test fixtures

**Example:**
```cpp
TEST(MyComponentTest, HandlesSimpleCase) {
  // Test code here
}
```
Simply building and running your test binary runs this and all other discovered tests.

---

### Assertion Macros

GoogleTest provides expressive assertion macros that empower you to verify expected conditions clearly and concisely.

- `EXPECT_*` macros report failures but allow tests to continue.
- `ASSERT_*` macros stop the test immediately on failure.

**Common Assertions:** `EXPECT_EQ`, `EXPECT_NEAR`, `EXPECT_TRUE`, `ASSERT_FALSE`, and many more.

**Example:**
```cpp
EXPECT_EQ(result, expected_value) << "Failure message with details.";
ASSERT_TRUE(is_valid) << "Setup is invalid.";
```

These macros improve your test readability and debugging experience.

---

### User-Defined Assertions

When built-ins don’t suffice, define your own assertion macros for tailored checks.

**Example:**
```cpp
[[maybe_unused]]
#define EXPECT_IS_EVEN(x) \
  EXPECT_PRED_FORMAT1(IsEvenFormat, x)

::testing::AssertionResult IsEvenFormat(const char* expr, int value) {
  if (value % 2 == 0) {
    return ::testing::AssertionSuccess();
  } else {
    return ::testing::AssertionFailure() << expr << " evaluates to " << value << ", which is not even.";
  }
}
```
Use it like:
```cpp
EXPECT_IS_EVEN(my_number);
```

This keeps your tests descriptive and focused.

---

### Death Tests

Verify that your code crashes or terminates as expected under erroneous conditions, a vital tool for ensuring robust failure handling.

**Supports:**
- Testing `exit()`, `abort()`, or fatal errors
- Checking for expected error messages

**Example:**
```cpp
EXPECT_DEATH(
  my_function_that_crashes(),
  "Segmentation fault"
);
```

Run death tests in a separate process safely without affecting your test suite.

---

### Fatal and Non-Fatal Failures

Use **fatal failures** (`ASSERT_*`) to abort a test immediately when a critical condition fails, preventing subsequent code execution in invalid states.

Use **non-fatal failures** (`EXPECT_*`) to log failures but continue running the test, useful for checking multiple related conditions.

This balance enables efficient and effective test failure management.

---

### Parameterized and Type-Parameterized Tests

Write one test logic and run it across multiple data sets or types, reducing boilerplate and increasing coverage.

**Parameterized Tests:**
- Define test logic once
- Supply multiple parameter values
- GoogleTest runs the test for each parameter

**Type-Parameterized Tests:**
- Define test logic once
- Run for multiple types

**Example:**
```cpp
class MyTest : public ::testing::TestWithParam<int> {};

TEST_P(MyTest, WorksWithParams) {
  int param = GetParam();
  // Test using param
}

INSTANTIATE_TEST_SUITE_P(MyGroup, MyTest, ::testing::Values(1, 2, 3));
```

---

### Running Individual or Parallel Tests

You can run specific tests by name, or run multiple tests in parallel to speed up your test suite.

**Examples:**
- Run a single test:
```sh
./my_tests --gtest_filter=MyTestSuite.MyTestCase
```
- Run in parallel (with custom setup):
```sh
# Use test runners or CI tools that support parallel execution
```

Focus on test granularity and isolation to maximize parallel execution benefits.

---

### Integration with GoogleMock

GoogleTest seamlessly integrates with GoogleMock, a powerful framework for creating and using mock classes in C++.

With GoogleMock, you can:
- Automatically generate mock classes from interfaces
- Set expectations on mock method calls
- Define custom behaviors and return values
- Verify interactions between components

This enables comprehensive and interaction-based testing alongside classic unit tests.

**Basic Workflow:**
```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
};

TEST(FooTest, UsesMock) {
  MockFoo foo;
  EXPECT_CALL(foo, GetSize()).WillOnce(::testing::Return(42));
  // Exercise code using foo
}
```

---

### How These Features Fit Together

GoogleTest's design harmonizes these features into balanced workflows where:

1. Tests are auto-discovered and run efficiently.
2. Assertions check correctness precisely.
3. Death tests validate critical failure modes.
4. Parameterized tests maximize coverage with minimal redundancy.
5. Users can run focused tests speeding up development loops.
6. Integration with GoogleMock adds interaction-based testing to your toolkit.

This quick tour serves as a springboard into the deeper guides where you’ll master writing tests, using assertions, configuring mocks, and applying best practices.

---

### Practical Tips and Best Practices

- Use `EXPECT_*` assertions for multiple checks inside a test, and `ASSERT_*` when failure should abort immediately.
- When testing error paths or crashes, reach for death tests to catch unwanted side effects early.
- Employ parameterized tests to avoid duplication and ensure systematic testing.
- Leverage GoogleMock to test complex interactions and dependencies effectively.
- Run tests frequently and selectively during development for immediate feedback.

---

### Troubleshooting Common Issues

- **Tests not discovered?** Ensure test functions follow the `TEST()`/`TEST_F()` macros and your test binary executes without filters blocking discovery.
- **Assertions fail unexpectedly?** Use verbose failure messages and `--gmock_verbose=info` to trace mock expectations.
- **Death tests hang?** Confirm that the code inside the death test triggers the expected fatal condition and doesn’t deadlock.
- **Mock expectations not met?** Remember that `EXPECT_CALL()` must be set *before* exercising the mock; verify call order if sequences are involved.

For detailed troubleshooting, consult the [GoogleTest FAQ](faq.md) and [gMock Cookbook](gmock_cook_book.md).

---

### Getting Started Preview

To begin harnessing GoogleTest’s powerful capabilities:

1. Write your first simple test using the `TEST()` macro.
2. Learn to organize tests into test suites and fixtures.
3. Explore writing assertions for validating conditions.
4. Create mock classes and set expectations using GoogleMock for interaction testing.

Start your journey here: [Writing Your First Test](../getting-started/first-test-validation/writing-first-test-case.md) and explore the complete [Guides](../guides/core-testing-workflows/introduction-to-mocking.md).

---

For code examples, detailed reference, and additional tips, refer to:
- [gMock Cheat Sheet](gmock_cheat_sheet.md)
- [gMock for Dummies](gmock_for_dummies.md)
- [Mocking Reference](reference/mocking.md)
- [gMock Cookbook](gmock_cook_book.md)

Unlock the full power of GoogleTest with this foundational quick tour.

---