---
title: "Core Concepts & Terminology"
description: "Defines vital terms such as test cases, test suites, assertions, matchers, death tests, parameterized tests, test fixtures, mock objects, expectations, and actions. Ensures new users grasp essential building blocks for authoring and understanding tests."
---

# Core Concepts & Terminology

Welcome to the foundational guide to GoogleTest and GoogleMock’s essential concepts and terminology. This document equips you with the vocabulary and understanding needed to navigate the testing framework successfully and write effective tests.

---

## What You Will Learn Here

This page defines and explains critical terms such as:

- **Test Case** and **Test Suite**
- **Assertions** and **Matchers**
- **Death Tests**
- **Parameterized Tests**
- **Test Fixtures**
- **Mock Objects** and related concepts like **Expectations** and **Actions**

Mastering these terms will give you the clarity and confidence to build, run, and interpret tests with GoogleTest and GoogleMock.

---

## Test Case and Test Suite

- **Test Case**: The fundamental unit of testing. A test case checks a particular situation or behavior in your code.

- **Test Suite**: A collection of related test cases grouped logically, often targeting the same component or functionality.

When you write tests, you typically organize them into test suites for maintainability and ease of execution.

---

## Assertions

**Assertions** are the checkpoints inside your tests that verify if conditions hold true. If an assertion fails, the test case fails, indicating a potential problem.

### Key Points

- Use assertions to validate expected outcomes.
- GoogleTest provides a rich library of assertion macros such as `EXPECT_EQ`, `ASSERT_TRUE`, and the powerful `EXPECT_THAT` which uses matchers.

### Example

```cpp
EXPECT_EQ(result, expected_value);  // Checks if result equals expected_value
EXPECT_TRUE(is_valid);              // Checks if is_valid is true
```

---

## Matchers

Matchers are predicates used within assertions and expectations to specify how arguments or values should be examined.

- They allow flexible and expressive checks, such as verifying if a number is greater than a threshold or a string starts with a specific prefix.

- Common matchers include `_` (wildcard), `Eq()`, `Gt()` (greater than), `StartsWith()`, and many more.

### Usage Example

```cpp
EXPECT_THAT(value, Gt(10));            // Checks if value > 10
EXPECT_THAT(text, StartsWith("Hello")); // Checks if text begins with "Hello"
```

Matchers improve test readability and give you fine control over verification logic.

---

## Death Tests

**Death Tests** verify that your code exits or crashes in a controlled way under specific circumstances.

- Useful for testing error handling and ensuring critical failures behave as expected.
- GoogleTest manages death tests by running them in separate processes to avoid affecting test harness stability.

### Example

```cpp
EXPECT_DEATH(FunctionThatShouldDie(), "expected error message");
```

This asserts that `FunctionThatShouldDie` terminates the process and outputs the expected error message.

---

## Parameterized Tests

Parameterized tests enable you to run the same test logic with different input values, increasing code reuse and coverage.

- Define a test case template.
- Supply parameters via generators or typed data.
- GoogleTest runs the test case for each parameter set automatically.

### Example

```cpp
template <typename T>
class MyTest : public ::testing::Test { /* ... */ };

TYPED_TEST_SUITE(MyTest, MyTypes);

TYPED_TEST(MyTest, HandlesValue) {
  TypeParam value = GetParam();
  EXPECT_TRUE(Process(value));
}
```

This pattern tests multiple data types or values with the same code structure.

---

## Test Fixtures

Test fixtures provide a way to set up and tear down a consistent environment for tests in the same suite.

- They allow you to define shared objects or state for the tests.
- Facilitate DRY code by avoiding repetitive setup code.

### Usage

Inherit from `::testing::Test` and override `SetUp()` and `TearDown()` if needed:

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  void SetUp() override {
    db.Connect();
  }

  void TearDown() override {
    db.Disconnect();
  }

  Database db;
};

TEST_F(DatabaseTest, CanInsert) {
  EXPECT_TRUE(db.Insert("data"));
}
```

All tests in `DatabaseTest` will share this setup and teardown.

---

## Mock Objects

Mocks are simulated objects that mimic the behavior of real objects in a controlled way.

They are fundamental for testing how your code interacts with external dependencies or collaborators.

### Key Concepts Related to Mocks

- **Mock Class**: A class created using `MOCK_METHOD` macros that replicates an interface.

- **Expectations**: Statements specifying which mock methods are expected to be called, with which arguments, how many times, and in what order.

- **Actions**: Behaviors prescribed to mock methods when called — e.g., returning values, invoking callbacks, or throwing errors.

- **NiceMock**, **StrictMock**, **NaggyMock**: Variants controlling how unexpected or uninteresting calls are handled (suppress warnings, fail tests, or emit warnings).

### Example

```cpp
class MockFile : public FileInterface {
 public:
  MOCK_METHOD(bool, Open, (const std::string& filename), (override));
};

TEST(FileTest, OpensCorrectFile) {
  MockFile mock_file;
  EXPECT_CALL(mock_file, Open("test.txt")).WillOnce(Return(true));

  ASSERT_TRUE(UseFile(&mock_file));
}
```

This test expects `Open("test.txt")` to be called exactly once and return true.

---

## Expectations

Expectations define what interactions with mocks should occur.

- Use `EXPECT_CALL()` macro to specify.
- Can specify argument matchers, call counts (`Times()`), invocation order (`InSequence()`, `After()`), and behaviors (`WillOnce()`, `WillRepeatedly()`).

### Typical Flow

```cpp
EXPECT_CALL(mock_obj, MethodName(args))
    .Times(3)
    .WillOnce(Return(value1))
    .WillRepeatedly(Return(value2));
```

Meaning method `MethodName` will be called 3 times, returning `value1` first, then `value2` thereafter.

---

## Actions

Actions control what happens when a mock method is called:

- Returning values
- Invoking callbacks or lambdas
- Modifying arguments

You specify actions using: 

- `WillOnce(action)` for first or specific calls
- `WillRepeatedly(action)` for all subsequent calls

Examples of built-in actions include `Return()`, `ReturnRef()`, `Invoke()`, `SetArgPointee()`, and more.

### Example

```cpp
EXPECT_CALL(mock_obj, GetData())
    .WillOnce(Return(42))
    .WillRepeatedly(Return(0));
```

---

## Why These Concepts Matter

Understanding these core building blocks empowers you to:

- Write expressive, maintainable tests
- Control mock interactions precisely
- Test complex scenarios including error handling and asynchronous behavior
- Organize your tests using fixtures and parameters

---

## Your Next Step

Now that you understand the core concepts and terminology, explore these documentation pages for practical guidance and deeper insights:

- [Creating and Running a Basic Test](../getting-started/initial-usage/hello-world-test.md) — Start writing your first test.
- [Using Mocks in Tests (gMock for Dummies)](../gmock_for_dummies.md) — Hands-on introduction to mocking.
- [Mocking Reference](../reference/mocking.md) — For detailed APIs and macros for mocks.

---

<AccordionGroup title="Frequently Asked Questions">  <Accordion title="What is the difference between an assertion and an expectation?">An <strong>assertion</strong> verifies conditions within a test and can cause test failure immediately on failure. An <strong>expectation</strong> is a declaration on mock methods about how they should be called during tests, including argument checks, call counts, and behaviors.</Accordion>  <Accordion title="When should I use NiceMock, StrictMock, or NaggyMock?">Use <code>NiceMock</code> when you want to suppress warnings on uninteresting calls. Prefer <code>NaggyMock</code> (the default) during development to get warnings. Use <code>StrictMock</code> only when you want failures on any unexpected calls.</Accordion>  <Accordion title="How does GoogleTest handle method overloads in mocks?">You must mock each overloaded method with its exact signature using <code>MOCK_METHOD</code>. If you omit some overloads, use <code>using</code> to bring the base class methods into scope to avoid hiding them.</Accordion>  <Accordion title="Can I write death tests with GoogleTest?">Yes. Death tests verify that code causes the process to exit or crash in a controlled way. Use <code>EXPECT_DEATH()</code> macros with expected error message matching.</Accordion></AccordionGroup>

<Note>
Master these core terms early for a smooth testing experience. This page is your glossary and roadmap to mastering GoogleTest and GoogleMock.
</Note>
