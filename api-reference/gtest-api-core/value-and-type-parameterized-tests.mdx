---
title: "Value and Type-Parameterized Tests"
description: "Describes how to write tests that run over multiple input values or types using the GoogleTest parameterization APIs, with guidance on generators, registration macros, and typical use cases."
---

# Value and Type-Parameterized Tests

This page explains how to write tests that run repeatedly over multiple input values or types, using GoogleTest's parameterization APIs. It guides you through the process of defining value-parameterized and type-parameterized test fixtures, using parameter generators, employing registration macros, and understanding typical scenarios where these tests add value.

---

## Overview of Parameterized Tests

Parameterized tests enable you to write a single test logic and run it multiple times with different data inputs or types. This not only reduces redundant code but also increases coverage by systematically testing variations.

GoogleTest provides two powerful forms of parameterized tests:

- **Value-Parameterized Tests:** Test the same code against multiple input values.
- **Type-Parameterized Tests:** Test the same code against multiple types.

---

## Writing Value-Parameterized Tests

### Step 1: Define a Value-Parameterized Test Fixture

Create a test fixture class derived from `::testing::TestWithParam<T>`, where `T` is the type of parameter you want to test with. This class can contain any setup or helper methods required.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // Optional fixture setup and member variables
};
```

### Step 2: Define Parameterized Tests Using `TEST_P`

Use the `TEST_P` macro to declare test cases that leverage the parameter. Inside test bodies, access the current parameter with `GetParam()`.

```cpp
TEST_P(MyValueTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

### Step 3: Instantiate Tests with Parameter Generators Using `INSTANTIATE_TEST_SUITE_P`

Instantiate the test suite with the desired parameter values using provided generators, such as `Values()`, `Range()`, `ValuesIn()`, `Bool()`, and `Combine()`. The first argument is a unique prefix for the instantiation.

```cpp
INSTANTIATE_TEST_SUITE_P(
  PositiveNumbers, MyValueTest,
  ::testing::Values(1, 2, 3, 10));

// Or a range from 1 to 5 (excluding 5)
INSTANTIATE_TEST_SUITE_P(
  RangeTest, MyValueTest,
  ::testing::Range(1, 5));
```

#### Common Parameter Generators

| Generator | Description |
|-----------|-------------|
| `Range(begin, end [, step])` | Produces numeric sequences from `begin` up to but not including `end`, stepping by `step` (default is 1).|
| `Values(v1, v2, ..., vN)` | Uses explicit list of values.| 
| `ValuesIn(container or iterators)` | Uses values from containers or iterator ranges.| 
| `Bool()` | Generates `{false, true}`.| 
| `Combine(g1, g2, ..., gN)` | Produces Cartesian product (all combinations) of multiple generators.| 

---

## Practical Example: Value-Parameterized Test

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEvenness) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, IsEvenTest,
    ::testing::Values(2, 4, 6, 8));
```

Runs the test `CheckEvenness` four times, each with a different parameter.

### Accessing Parameters

Within your `TEST_P`, use `GetParam()` to fetch the parameter value. `GetParam()` returns the type `T` from your fixture inheritance.

---

## Advanced: Using Combined Parameters

To test multiple parameters simultaneously, use `Combine()` to produce tuples of parameters.

```cpp
class CombinedTest : public testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(CombinedTest, DoesWork) {
  int num = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  // Test logic here...
}

INSTANTIATE_TEST_SUITE_P(
    ComboInstantiation, CombinedTest,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

This runs 4 tests with parameter combinations (1,false), (1,true), (2,false), (2,true).

---

## Writing Type-Parameterized Tests

Type-parameterized tests allow reuse of test logic for multiple data types.

### Step 1: Define a Typed Test Fixture Template

Define a fixture class template parameterized on a type:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_{};
  // Setup data or utilities
};
```

### Step 2: Specify a List of Types

Use `::testing::Types<>` to define the types you want to test:

```cpp
using TestedTypes = ::testing::Types<int, float, double>;
```

### Step 3: Associate the Types with the Test Suite Using `TYPED_TEST_SUITE`

```cpp
TYPED_TEST_SUITE(MyTypedTest, TestedTypes);
```

### Step 4: Write Tests Using `TYPED_TEST`

In the test body, you can access the current type as the special identifier `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultZero) {
  TypeParam zero{};
  EXPECT_EQ(this->value_, zero);
}
```

---

## Type-Parameterized Tests with Registration Macros

| Macro | Purpose |
|-------|----------|
| `TYPED_TEST_SUITE` | Associates types to a typed test fixture template. |
| `TYPED_TEST` | Defines an individual typed test. |

### Type-Parameterized Test Example

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {
 protected:
  T min_ = std::numeric_limits<T>::min();
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, MinIsNotZero) {
  EXPECT_NE(this->min_, 0);
}
```

---

## Type-Parameterized Tests vs Typed Tests

- **Typed Tests** (`TYPED_TEST_SUITE`) require the list of types at definition time and are instantiated once.
- **Type-Parameterized Tests** (`TYPED_TEST_SUITE_P`) allow defining abstract test patterns without fixed types. Types can be instantiated later, often across multiple files, for more flexibility.

You can register type-parameterized test patterns with `REGISTER_TYPED_TEST_SUITE_P` and instantiate them with `INSTANTIATE_TYPED_TEST_SUITE_P`.

---

## Using Macros for Type-Parameterized Tests Pattern

- Define the test pattern with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`.
- Register the test names with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate with types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

Example:

```cpp
template <typename T>
class MyPatternTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyPatternTest);

TYPED_TEST_P(MyPatternTest, WorksCorrectly) {
  TypeParam value{};
  EXPECT_EQ(value + value, value * 2);
}

REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, WorksCorrectly);

using ImplTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImplementations, MyPatternTest, ImplTypes);
```

---

## Tips and Best Practices

- **Naming**: Avoid underscores in test suite and test names.
- **Parameter Access**: Use `GetParam()` for value-parameterized, and `TypeParam` for type-parameterized tests.
- **Instantiation Timing**: Parameter generators run during `InitGoogleTest()`, not at macro expansion.
- **Custom Parameter Naming**: Provide a name generator in `INSTANTIATE_TEST_SUITE_P` to produce readable test names.
- **Avoid Duplicates**: Ensure test parameter names are unique within instantiations.
- **Fixtures**: Fixtures can encapsulate setup and helper methods shared by parameterized tests.
- **Combining Multiple Parameters**: Use `Combine()` to test all combinations comprehensively.

---

## Common Pitfalls and Troubleshooting

- **Test Not Running**: Not instantiating a test suite with `INSTANTIATE_TEST_SUITE_P` leads to no tests being executed for that parameterized test.
- **Duplicate Names**: Duplicate parameter names cause runtime errors during test registration.
- **Invalid Parameter Names**: Parameter names cannot contain spaces or special characters other than underscores.
- **Parameter Conversion Issues**: Use `ConvertGenerator<T>` when parameter type conversion is non-trivial.
- **Dangling References in Lambdas**: Avoid passing temporary strings to lambdas that capture by reference; use explicit type declarations or value capture.

---

## Summary

Value and type-parameterized tests in GoogleTest enable concise, maintainable test code that exhaustively exercises code under a variety of inputs and types. By understanding and applying the structured macros—`TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, `TYPED_TEST`, etc.—and utilizing parameter generators effectively, you can significantly enhance your test coverage with minimal boilerplate.

---

## References

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [GoogleTest Primer](../primer.md)
- [GoogleTest Macros and Lifecycle APIs](api-reference/gtest-api-core/test-macros-and-lifecycle)
- [GoogleTest Parameter Generators](docs/reference/testing.md#INSTANTIATE_TEST_SUITE_P)

---

## Example: Complete Value-Parameterized Test Sample

```cpp
#include <gtest/gtest.h>

class FactorialTest : public ::testing::TestWithParam<int> {};

int Factorial(int n) {
  return n <= 1 ? 1 : n * Factorial(n - 1);
}

TEST_P(FactorialTest, HandlesPositiveInput) {
  int n = GetParam();
  int expected = 1;
  for (int i = 1; i <= n; ++i) expected *= i;
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(
    FactorialTests, FactorialTest,
    ::testing::Values(0, 1, 2, 3, 8));
```

This setup runs the test `HandlesPositiveInput` with values 0,1,2,3,8 using the single test logic.

---

## Example: Complete Typed Test Sample

```cpp
#include <gtest/gtest.h>

template <typename T>
class NumericLimitsTest : public ::testing::Test {
 public:
  T value_{};
};

using MyTypes = ::testing::Types<int, double, float>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsZeroInitially) {
  TypeParam zero{};
  EXPECT_EQ(this->value_, zero);
}
```

This runs the test over all specified types, checking the initial value.

---

<Info>
For more detailed guidance on parameterized and typed tests, consult the [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) and [Typed Tests](../advanced.md#typed-tests) sections in the Advanced Guide.
</Info>
