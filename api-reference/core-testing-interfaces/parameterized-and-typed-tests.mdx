---
title: "Parameterized and Typed Tests"
description: "Explains how to use value-parameterized and type-parameterized tests, including required macros and registration patterns. Guides users through best practices for maximizing test coverage across values and types."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write tests that run over multiple values or types with minimal duplication and maximum clarity. This page explains how to leverage value-parameterized and type-parameterized tests effectively, highlighting the required macros, fixture patterns, and registration strategies. By following these patterns, you ensure broad test coverage and maintain clean, scalable test suites.

---

## Value-Parameterized Tests

Value-parameterized tests let you write a test once and run it with various input values to validate behavior under differing conditions. This technique is especially useful for testing different input data, algorithm configurations, or varying implementation parameters without repeating test code.

### Defining Value-Parameterized Tests

1. **Define a Fixture Class**

Create a test fixture deriving from `::testing::TestWithParam<T>`, where `T` is the parameter type you wish to use. This class gains a `GetParam()` method to access the parameter value inside tests.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture members and helper methods...
};
```

Alternately, if extending an existing fixture class hierarchy, inherit from your base fixture and `::testing::WithParamInterface<T>` separately.

2. **Write Tests Using the `TEST_P` Macro**

Use `TEST_P` instead of `TEST_F` or `TEST` to define parameterized test methods. Inside these tests, access the current parameter with `GetParam()`.

```cpp
TEST_P(FooTest, IsEven) {
  int param = GetParam();
  EXPECT_EQ(param % 2, 0);
}
```

3. **Instantiate the Test Suite with Parameters**

Use `INSTANTIATE_TEST_SUITE_P` to create test instances with different parameter values. GoogleTest offers builtin parameter generators such as `Range()`, `Values()`, `ValuesIn()`, `Bool()`, and `Combine()`.

```cpp
INSTANTIATE_TEST_SUITE_P(Numbers,
                         FooTest,
                         ::testing::Values(2, 4, 6, 8));
```

This example generates four executions of `FooTest.IsEven`, passing `2`, `4`, `6`, and `8` respectively.

### Parameter Generators

| Generator | Description |
|-----------|-------------|
| `Range(start, end [, step])` | Produces values from `start` up to but not including `end`, incrementing by `step` (defaults to 1). |
| `Values(v1, v2, ..., vN)` | Produces exactly the listed values. |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Generates values from arrays, containers, or iterator ranges. |
| `Bool()` | Generates boolean values `{false, true}`. |
| `Combine(g1, g2, ..., gN)` | Produces the Cartesian product of the generators, yielding `std::tuple`s. |

You can customize test names by providing a **name generator** lambda or functor as the last argument in `INSTANTIATE_TEST_SUITE_P`. The name generator receives `testing::TestParamInfo` and returns a string safe for use in test names.

### Example: Value-Parameterized Test with Custom Names

```cpp
class IsPrimeTest : public ::testing::TestWithParam<int> {};

TEST_P(IsPrimeTest, CheckPrime) {
  int n = GetParam();
  EXPECT_TRUE(IsPrime(n));
}

INSTANTIATE_TEST_SUITE_P(
    PrimeTests, IsPrimeTest,
    ::testing::Values(2, 3, 5, 7, 11),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Prime_" + std::to_string(info.param);
    });
```

This generates tests named `PrimeTests/IsPrimeTest.CheckPrime/Prime_2`, `Prime_3`, etc.

### Important Best Practices & Notes

- Place `INSTANTIATE_TEST_SUITE_P` calls at global or namespace scope, **not inside functions**.
- If your value-parameterized test suite is not instantiated, GoogleTest flags it as an error by default. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress this.
- Fixtures that implement `SetUpTestSuite()` or `TearDownTestSuite()` must declare them as `public` to work with `TEST_P`.
- If your parameter type requires explicit conversion from generated types, use `ConvertGenerator<T>` or provide a conversion callable.

---

## Typed Tests

Typed tests allow running the same test logic over a set of types at compile-time, enabling uniform validation across different implementations or type variants.

### Defining Typed Tests

1. **Define a Fixture Class Template**

Create a class template deriving from `::testing::Test`, templated on a type `T`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  // Optional: typedefs, static members
};
```

2. **Register the List of Types**

Define a type list using `::testing::Types<...>` and associate it with the test suite using `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write Tests with `TYPED_TEST` Macro**

Inside typed test bodies, use the special identifier `TypeParam` to refer to the current type.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Avoid unused variable warning
}
```

### Example: Typed Test

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
 protected:
  std::vector<T> data_;
};

using IntFloatTypes = ::testing::Types<int, float>;
TYPED_TEST_SUITE(ContainerTest, IntFloatTypes);

TYPED_TEST(ContainerTest, StartsEmpty) {
  EXPECT_TRUE(this->data_.empty());
}
```

### Custom Type Names

Optionally, supply a name generator class with a static templated method `GetName(int)` to generate fixtures names.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, float>) return "Float";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## Type-Parameterized Tests

Type-parameterized tests provide flexibility by allowing the test suite to be defined without knowing the types ahead of time. The types can then be instantiated later, possibly multiple times and in different translation units.

### Defining Type-Parameterized Tests

1. **Define a Fixture Class Template**

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {
  // Define test logic here
};
```

2. **Declare a Type-Parameterized Test Suite Using `TYPED_TEST_SUITE_P`**

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define Tests Using `TYPED_TEST_P`**

```cpp
TYPED_TEST_P(MyTypeParamTest, TestProperty) {
  TypeParam value{};
  EXPECT_TRUE(SomeCheck(value));
}
```

4. **Register Test Names With `REGISTER_TYPED_TEST_SUITE_P`**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestProperty);
```

5. **Instantiate With Specific Types Using `INSTANTIATE_TYPED_TEST_SUITE_P`**

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTypeParamTest, MyTypes);
```

### Example: Type-Parameterized Test Suite

```cpp
template <typename T>
class NumericTraitsTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(NumericTraitsTest);

TYPED_TEST_P(NumericTraitsTest, DefaultIsZero) {
  EXPECT_EQ(TypeParam(), 0);
}

REGISTER_TYPED_TEST_SUITE_P(NumericTraitsTest, DefaultIsZero);

using MyTypes = ::testing::Types<int, long>;
INSTANTIATE_TYPED_TEST_SUITE_P(Default, NumericTraitsTest, MyTypes);
```

### Notes

- Like typed tests, you can provide a custom name generator as a fourth argument in instantiation.
- Type-parameterized tests must explicitly register test names to be instantiated.
- This approach supports reuse of abstract test patterns across projects or components.

---

## Best Practices for Parameterized and Typed Tests

- **Choose the Right Parameterization Strategy**
  - Use *value-parameterized tests* when the test varies by input values.
  - Use *typed tests* when the test varies by types known at compile time.
  - Use *type-parameterized tests* when you want reusable abstract test patterns instantiated with varying type lists.

- **Define Fixtures Carefully**
  - Ensure `SetUpTestSuite()` and `TearDownTestSuite()` are public for `TEST_P` fixtures.
  - Access parameter type via `GetParam()` or `TypeParam` clearly in your tests.

- **Naming and Instantiation**
  - Always provide meaningful and unique instantiation names in `INSTANTIATE_TEST_SUITE_P` and `INSTANTIATE_TYPED_TEST_SUITE_P`.
  - Use custom name generators for clarity when default names are insufficient.
  - Place instantiation macros at namespace or global scope.

- **Manage Test Coverage**
  - Use combinators like `Combine()` and converters like `ConvertGenerator()` for complex parameter spaces.
  - Avoid omitting instantiations; if unavoidable, suppress warnings with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

- **Debugging and Maintenance**
  - Use `SCOPED_TRACE` to add context inside parameterized tests.
  - Carefully factor shared code into fixtures to keep tests readable.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Pitfalls in Parameterized and Typed Tests">
<Accordion title="Uninstantiated Parameterized Tests Cause Failures">
By default, defining a parameterized test suite with `TEST_P` but not instantiating it with `INSTANTIATE_TEST_SUITE_P` produces a failure in a special verification test suite. To suppress this, use:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTestSuite);
```
</Accordion>
<Accordion title="Wrong Fixture Access and Macro Usage">
Remember that `TEST_P` requires fixtures with `TestWithParam<T>` or equivalent, and `TEST_F` requires regular fixtures. Mixing them or using `TEST` with parameterized fixtures leads to compilation or runtime errors.
</Accordion>
<Accordion title="Failed Conversions in Parameter Generators">
If your fixture parameter type does not implicitly convert from the generator's value types, use `ConvertGenerator<T>` or provide a conversion lambda.

Beware of dangling references when using lambdas with string views; favor explicit type annotations or safe copies.
</Accordion>
<Accordion title="Test Names Contain Underscores or Invalid Characters">
Avoid underscores `_` in test suite and test names, as they interfere with GoogleTest's naming conventions and can cause conflicts or unclear test names.
</Accordion>
</AccordionGroup>

---

## References and Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for deeper conceptual understanding.
- [Typed Tests](../advanced.md#typed-tests) for comprehensive typed test patterns.
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for abstract reusable suite designs.
- [GoogleTest Testing Reference](reference/testing.md#parameterized-and-typed-tests) for full macro definitions.
- [Sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) and [Sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc) for example implementations.

---

## Summary

This page equips you with the knowledge to effectively write parameterized and typed tests in GoogleTest, enabling broad and robust test coverage across various data values and types. Leveraging the macros `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, `TYPED_TEST`, and their type-parameterized counterparts dramatically reduces duplication and improves test organization.

For practical mastery, start with value-parameterized tests when covering multiple inputs, move to typed tests for multiple related types, and adopt type-parameterized tests for reusable, flexible testing patterns. Custom naming and conversion options provide control over test identification and parameter handling, ensuring clear, maintainable test output.
