---
title: "Argument Matchers"
description: "API documentation for argument matcher macros and utilities, enabling users to perform expressive and flexible matching on arguments passed to mock methods or assertions. Includes built-in matchers, custom matcher creation, and integration hints."
---

# Argument Matchers

GoogleTest supports rich **argument matchers** that let you express powerful expectations on the parameters passed to mock methods or assertions. Argument matchers enable fine-grained control over which calls are considered valid and can verify that inputs satisfy specific conditions, improving the precision and usefulness of your tests.

This page documents the argument matcher macros and utilities available, guiding you to write expressive, maintainable, and flexible tests.

---

## Overview

Matchers specify **criteria** against which function arguments are checked during expectations or assertions. They evaluate each argument and decide if it matches or not.

Matchers can be:

- Built-in, provided by GoogleTest/gMock for common types and conditions.
- User-defined/custom, created using macros or by implementing matcher interfaces.

Matchers can be composed, combined, and parameterized to create sophisticated constraints.

## Using Matchers in Expectations

Matchers are used primarily within `EXPECT_CALL` and `ON_CALL` to specify which mock calls are expected or to define default behavior:

```cpp
EXPECT_CALL(mock_object, Method(MatcherForArg1, MatcherForArg2, ...));
```

If your mock method takes multiple arguments, you can specify one matcher per argument. Use `_` to state "match anything" for arguments you don't care about.

Example:

```cpp
using ::testing::_;
using ::testing::Gt;

EXPECT_CALL(mock_turtle, Forward(Gt(100)));  // Expects Forward with argument > 100
EXPECT_CALL(mock_turtle, GoTo(50, _));       // Expects GoTo where x = 50 and y is anything
```

## Common Built-in Matchers

GoogleTest provides a comprehensive set of built-in matchers to cover the majority of testing needs. Some core categories:

### Wildcard Matchers

- **`_`**
  - Matches any value of any type.
- **`A<T>()`**, **`An<T>()`**
  - Matches any value of the specified type `T`.

### Equality and Comparison

- **`Eq(value)`** or direct value
  - Matches arguments equal (`==`) to `value`.
- **`Ne(value)`**
  - Matches arguments not equal to `value`.
- **Relational Matchers:** `Lt()`, `Le()`, `Gt()`, `Ge()`
  - Matches arguments less than, less or equal, greater than, or greater or equal to `value`.

### Pointer Matchers

- **`IsNull()`**
  - Matches `nullptr` pointers.
- **`NotNull()`**
  - Matches pointers that are not `nullptr`.
- **`Pointee(matcher)`**
  - Matches pointers whose pointed-to value matches the inner matcher.
- **`Ref(variable)`**
  - Matches an argument that is a reference to `variable`.

### String Matchers

- **`StrEq(s)`**, **`StrNe(s)`**
  - Matches strings equal/not equal to `s`, case sensitive.
- **`StrCaseEq(s)`**, **`StrCaseNe(s)`**
  - Case-insensitive string matching.
- **`HasSubstr(sub)`**
  - Matches strings containing substring `sub`.
- **`StartsWith(prefix)`**
  - Matches strings starting with `prefix`.
- **`EndsWith(suffix)`**
  - Matches strings ending with `suffix`.

### Container Matchers

- **`ElementsAre(...)`**, **`UnorderedElementsAre(...)`**
  - Match containers against sequences of expected elements (ordered/unordered).
- **`Contains(matcher)`**
  - Matches containers containing at least one element satisfying `matcher`.
- **`Each(matcher)`**
  - Matches containers whose **all** elements satisfy the matcher.

### Compound Matchers

- **`AllOf(m1, m2, ...)`**
  - Matches if all sub-matchers match.
- **`AnyOf(m1, m2, ...)`**
  - Matches if any one of the sub-matchers matches.
- **`Not(matcher)`**
  - Matches if the given matcher does *not* match.

### Specialized Matchers

- **`Key(matcher)`**
  - Matches `std::pair` or map element whose *key* matches.
- **`Pair(matcher1, matcher2)`**
  - Matches pairs whose first and second fields match respective matchers.
- **`Field(&Class::member, matcher)`**
  - Matches objects whose member field satisfies the matcher.
- **`Property(&Class::method, matcher)`**
  - Matches objects whose method return value satisfies the matcher.

## Creating Custom Matchers

GoogleTest provides multiple paths to define your own matchers to express domain-specific conditions:

### Using the `MATCHER` Macros

The `MATCHER` family of macros lets you quickly define simple or parameterized matchers with minimal boilerplate.

#### Basic Matcher Example

```cpp
MATCHER(IsEven, "") {  // Matcher name IsEven
  return (arg % 2) == 0;
}
```

Usage:

```cpp
EXPECT_CALL(mock, Bar(IsEven()));
EXPECT_THAT(value, IsEven());
```

Fails will print messages like:

```
Value of: value
Expected: is even
  Actual: 7
```

#### Parameterized Matcher Example

```cpp
MATCHER_P(HasAbsoluteValue, val, "") {
  return abs(arg) == val;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(5));
```

Produces description with parameter value.

#### Tips for Custom Matchers

- Provide a descriptive matcher string if needed.
- Use the `result_listener` variable to stream helpful diagnostic info on failure.
- Keep your matcher logic pure and side-effect free.

### Implementing Matcher Interface Directly

For full control, implement the matcher interface by defining:

- `bool MatchAndExplain(const T& value, MatchResultListener* listener)`
- `void DescribeTo(std::ostream* os)`
- `void DescribeNegationTo(std::ostream* os)`

Then wrap it inside a factory function returning a `Matcher<T>`.

This is suited for reusable and complex matchers.

### Polymorphic Matchers

You may implement polymorphic matchers to work with multiple types (e.g., `Eq(5)` can match both `int` and `double`). These are matcher factories convertible to `Matcher<T>` as needed.

```cpp
class NotNullMatcher {
 public:
  template <typename T>
  bool MatchAndExplain(T* p, std::ostream* /*listener*/) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

## Using Matchers in Assertions

Matchers can be used with the `EXPECT_THAT` and `ASSERT_THAT` macros to assert conditions:

```cpp
EXPECT_THAT(value, StartsWith("Hello"));
EXPECT_THAT(container, Contains(42));
```

These assertions give rich, readable messages on failure.

## Matcher Composition & Utilities

Matchers can be composed and combined to express complex conditions.

### Combining Matchers

- `AllOf(m1, m2, ...)` matches if all sub-matchers match.
- `AnyOf(m1, m2, ...)` matches if any sub-matcher matches.
- `Not(matcher)` matches if the inner matcher does not match.

### Tuple and Container Helpers

- `FieldsAre(m0, m1, ...)` matches structures, tuples, and aggregates field-by-field.
- `Pair(m1, m2)` matches pairs.
- `Pointwise(tuple_matcher, container)` matches containers element-wise.

### Casting and Type Safety

Match types are strictly checked. Use `SafeMatcherCast<T>(matcher)` to convert safely or `MatcherCast<T>(matcher)` for more permissive cast at the risk of unsafe conversions.

### Special Parameter Handling

- Use `_` (underscore) as a wildcard matcher.
- Use `Ref(variable)` for matching exact references.

---

## Practical Examples

### Example 1: Basic Use of Argument Matchers

```cpp
using ::testing::_;
using ::testing::Gt;
using ::testing::Return;

EXPECT_CALL(mock_turtle, Forward(Gt(100)))
    .WillOnce(Return());
```

This sets an expectation that `Forward` is called with an argument greater than 100.

### Example 2: Ignoring Some Arguments

```cpp
EXPECT_CALL(mock_turtle, GoTo(50, _));
```

Matches calls to `GoTo` where the first argument equals 50; the second argument can be anything.

### Example 3: Using Compound Matchers

```cpp
EXPECT_CALL(mock, DoWork(AllOf(Ge(1), Le(10))));
```

Matches calls where `DoWork` argument is between 1 and 10 inclusive.

### Example 4: Defining a Custom Matcher

```cpp
MATCHER_P(IsMultipleOf, divisor, "") {
  return (arg % divisor) == 0;
}

EXPECT_CALL(mock, DoCalc(IsMultipleOf(5)));
```

Matches calls where argument is a multiple of 5.

---

## Tips and Best Practices

- **Specify only necessary argument conditions.** Don't over-specify, or tests become fragile.
- **Use `_` for unconcerned arguments** to keep tests flexible.
- **Leverage built-in matchers** for common cases, avoiding reinventing the wheel.
- **Compose matchers** with `AllOf`, `AnyOf`, and `Not` to express complex expectations clearly.
- **When creating custom matchers,** provide helpful descriptions and explanations for easier debugging.
- **Use `SafeMatcherCast`** to help with type conversions and avoid surprising template errors.

## Common Pitfalls and Troubleshooting

- **Mixing argument matchers and raw values:** Use matchers consistently within the same `EXPECT_CALL`.
- **Overly rigid expectations:** Can cause tests to break unnecessarily when unrelated changes occur.
- **Incorrect matcher order:** GoogleTest matches expectations in reverse order — specific expectations should be declared after more general ones.
- **Omitting `EXPECT_CALL`** on mocks leads to "uninteresting mock function call" warnings—use `NiceMock` to suppress if intentional.

## Additional References

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) — Introduction and simple examples
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Recipes and detailed usage
- [Matchers Reference](reference/matchers.md) — Full list of built-in matchers
- [Mocking Reference](reference/mocking.md) — Details on mock usage and expectations
- [Assertions Reference](reference/assertions.md) — Using matchers in assertions like `EXPECT_THAT`

---

## Summary

Argument matchers are the cornerstone of precise, expressive mocking and assertions in GoogleTest. They allow you to constrain and verify individual parameters flexibly and are highly composable to match nearly any criteria.

Armed with built-in matchers, custom matcher creation tools, and clear usage patterns, you can significantly improve the robustness, clarity, and maintainability of your C++ tests.
