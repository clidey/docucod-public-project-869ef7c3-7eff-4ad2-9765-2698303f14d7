---
title: "Matchers and Argument Checking"
description: "Covers built-in argument matchers, composing matchers, and extending with custom matchers. Demonstrates how matchers are used within expectations and how to match arguments flexibly using the library’s expressive constructs."
---

# Matchers and Argument Checking

This page presents a detailed overview of matchers in GoogleMock, covering built-in argument matchers, ways to compose them, and how to extend with custom matchers. It explains how matchers are integrated within expectations, enabling flexible and expressive argument matching in mock functions.

---

## What Are Matchers?

Matchers are predicates used to specify the conditions mocked function arguments must satisfy. Instead of hardcoding specific values, matchers allow you to make expectations that can accept any argument or match arguments based on properties or logic. This leads to more flexible and maintainable tests.

Matchers are essential in setting up expectations via `EXPECT_CALL()` or default behaviors with `ON_CALL()` by defining which function calls your mock objects should respond to.

## Using Built-in Argument Matchers

GoogleMock offers a comprehensive collection of built-in matchers covering common use cases and types.

### Wildcard Matchers

- `_`: Matches any value of the correct type; use when the argument is irrelevant to the test.
- `A<type>()` or `An<type>()`: Matches any value of the specified type.

Example:
```cpp
EXPECT_CALL(mock, Foo(_));               // Matches any argument
EXPECT_CALL(mock, Bar(A<int>()));        // Matches any int argument
```

### Generic Comparison Matchers

Matchers that test relational or equality conditions:

| Matcher             | Meaning                                      |
|---------------------|----------------------------------------------|
| `Eq(value)` or `value` | Argument must equal `value`                    |
| `Ne(value)`          | Argument must not equal `value`               |
| `Ge(value)`          | Argument must be >= `value`                   |
| `Gt(value)`          | Argument must be > `value`                    |
| `Le(value)`          | Argument must be <= `value`                   |
| `Lt(value)`          | Argument must be < `value`                    |
| `IsTrue()`           | Argument evaluates to true in Boolean context |
| `IsFalse()`          | Argument evaluates to false in Boolean context|
| `IsNull()`           | Argument is a `nullptr` (raw or smart pointer) |
| `NotNull()`          | Argument is a non-null pointer                 |

Example:
```cpp
EXPECT_CALL(mock, Foo(Ge(5)));       // Argument >= 5
EXPECT_CALL(mock, Bar(Eq("test")));  // Argument == "test"
```

### Matching Containers and Complex Values

Matchers exist for STL-style containers and sequences:

- `ElementsAre(e0, e1, ..., en)`: Container with exactly n+1 elements each matching the corresponding matcher or value.
- `UnorderedElementsAre(...)`: Like `ElementsAre` but order does not matter.
- `Contains(m)`: Container has at least one element matching m.
- `Each(m)`: Every element matches m.
- `SizeIs(m)`: Container size matches matcher `m`.
- `IsEmpty()`: Container is empty.

Example:
```cpp
EXPECT_CALL(mock, ProcessVector(ElementsAre(1, Gt(10), _)));
EXPECT_CALL(mock, ProcessSet(UnorderedElementsAre(2, 3, 1)));
```

### String Matchers

Flexible matchers for string arguments, supporting C strings, `std::string`, and wide strings:

- `StrEq(s)`, `StrNe(s)`: Exact case-sensitive string equality / inequality.
- `StrCaseEq(s)`, `StrCaseNe(s)`: Case-insensitive equality or inequality.
- `StartsWith(prefix)`: String begins with prefix.
- `EndsWith(suffix)`: String ends with suffix.
- `HasSubstr(sub)`: String contains a substring.
- `ContainsRegex(regex)`: String matches regex.
- `MatchesRegex(regex)`: Regex matches the entire string.

Example:
```cpp
EXPECT_CALL(mock, Print(StrCaseEq("hello")));
EXPECT_CALL(mock, LogMessage(HasSubstr("error")));
```

### Exception Matchers

Matchers for verifying that callable objects throw exceptions:

- `Throws<E>()`: Callable throws exception of type E.
- `Throws<E>(m)`: Exception thrown matches matcher `m`.
- `ThrowsMessage<E>(m)`: Exception’s message matches matcher `m`.

Example:
```cpp
auto lambda = [] { throw std::runtime_error("fail"); };
EXPECT_THAT(lambda, Throws<std::runtime_error>());
EXPECT_THAT(lambda, ThrowsMessage<std::runtime_error>(HasSubstr("fail")));
```

## Matching Arguments Using Matchers

Matchers are used inside `EXPECT_CALL()` or `ON_CALL()` to specify the expected or default argument values. For instance:

```cpp
EXPECT_CALL(mock_obj, Method(Eq(5), Ge(10), _));
```

This expects `Method` to be called with first argument equal to 5, second argument >= 10, and the third argument anything.

You can also omit the parameter list if the method is not overloaded, which means any arguments are accepted:

```cpp
EXPECT_CALL(mock_obj, Method).Times(3);
```

## Combining Matchers

You can build complex logical matchers using:

- `AllOf(m1, m2, ...)`: All must match.
- `AnyOf(m1, m2, ...)`: At least one must match.
- `Not(m)`: Matches if `m` does not match.
- `Conditional(cond, m1, m2)`: Matches `m1` if `cond` is true; otherwise `m2`.

Example:
```cpp
EXPECT_CALL(mock, Func(AllOf(Ge(5), Lt(10))));  // Argument in [5, 10)
EXPECT_CALL(mock, Func(Not(Eq(0))));            // Argument not equal to 0
```

## Matching Multiple Arguments as a Whole

Matchers can be combined to check relations between arguments as a tuple using:

- `.With(multi_arg_matcher)` on `EXPECT_CALL` or `ON_CALL`, where `multi_arg_matcher` is a matcher of a tuple.
- `AllArgs(m)` is equivalent to passing `m` to `.With()`.
- `Args<index...>(m)`: Matches a subset or permutation of arguments.

Example:
```cpp
EXPECT_CALL(mock, Func(_, _))
    .With(Lt());  // First argument less than second argument
EXPECT_CALL(mock, Func(_, _, _))
    .With(AllOf(Args<0, 1>(Ge(0)), Args<1, 2>(Lt(5))));
```

## Using Matchers as Predicates

Matchers can be used as predicates in other functions, such as STL algorithms, by wrapping them with `Matches()`. For example:

```cpp
std::vector<int> v = {1, 5, 7, 10};
// Count elements greater than or equal to 5
int count = std::count_if(v.begin(), v.end(), Matches(Ge(5)));
```

## Extending with Custom Matchers

### Writing Simple Matchers

Create custom matchers easily using `MATCHER` macros:

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }

EXPECT_CALL(mock, Method(IsEven()));
```

For parameterized custom matchers, use `MATCHER_P`, `MATCHER_P2`, ...

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  return (arg % divisor) == 0;
}

EXPECT_CALL(mock, Method(IsDivisibleBy(3)));
```

Add detailed failure messages using the `result_listener` stream:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  if ((arg % divisor) == 0) return true;
  *result_listener << "where the remainder is " << (arg % divisor);
  return false;
}
```

### Writing Advanced Matchers

For more control and polymorphism, define matcher classes that implement `MatchAndExplain`, `DescribeTo`, and `DescribeNegationTo` methods. Create factory functions returning a matcher instance.

Example:

```cpp
class DivisibleByMatcher {
 public:
  using is_gtest_matcher = void;
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os != nullptr) {
      *os << "remainder " << (n % divisor_);
    }
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_; 
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_; 
  }

 private:
  int divisor_;
};

inline testing::Matcher<int> DivisibleBy(int divisor) {
  return testing::MakeMatcher(new DivisibleByMatcher(divisor));
}
```

Use it as:

```cpp
EXPECT_CALL(mock, Foo(DivisibleBy(7)));
```

### Composite Matchers

Matchers can accept other matchers as parameters to build composite logic. For example, `AllOf()`, `AnyOf()`, or writing your own matcher that contains sub-matchers.

## Best Practices & Tips

- Use `_` wildcard for irrelevant arguments to avoid over-specification.
- For complex multi-argument constraints, use `.With()` and tuple matchers.
- Use `RetiresOnSaturation()` to make expectations retire after their upper count to avoid sticky expectation pitfalls.
- Prefer `ON_CALL()` to specify default mock method behaviors without adding call count constraints; use `EXPECT_CALL()` when expecting and verifying actual calls.
- Use composite and multi-argument matchers to write expressive and clear expectations.
- Suppress uninteresting call warnings using `NiceMock` if they clutter tests unintentionally.

## Common Pitfalls

- Over-specifying argument matchers leads to brittle tests.
- Expectation stickiness can cause unexpected upper bound violations if you don’t use `RetiresOnSaturation()` in sequential calls.
- Omitting `.With()` on multi-argument matchers when needed results in matches on individual arguments only.
- Using a matcher of the wrong type requires explicit casting via `SafeMatcherCast<T>(m)`.

## Practical Example

```cpp
class MockDatabase {
 public:
  MOCK_METHOD(bool, Connect, (const std::string& url), (override));
  MOCK_METHOD(int, Query, (int id, std::string* result), (override));
};

using ::testing::_;
using ::testing::Eq;
using ::testing::NotNull;
using ::testing::Return;

TEST(DatabaseTest, ConnectsAndQueries) {
  MockDatabase mock_db;

  EXPECT_CALL(mock_db, Connect(Eq("server_db"))).WillOnce(Return(true));
  EXPECT_CALL(mock_db, Query(_, NotNull())).WillRepeatedly(Return(1));

  ASSERT_TRUE(mock_db.Connect("server_db"));
  std::string result;
  EXPECT_EQ(1, mock_db.Query(42, &result));
}
```

This example shows using matchers like `Eq()`, `NotNull()`, and `_` in expectations to flexibly match arguments.

## Troubleshooting

- **Unexpected Call Errors:** Check whether argument matchers accurately reflect actual argument values.
- **Warnings about Uninteresting Calls:** Consider adding expectations or switching mock object to `NiceMock`.
- **Type Mismatches:** Use `SafeMatcherCast` to explicitly cast matchers when overloading or type differences occur.

## References & Further Reading

- [Matchers Reference](reference/matchers.md): Comprehensive list of built-in matchers.
- [Mocking Reference](docs/reference/mocking.md): Using mocks and expectations.
- [gMock Cookbook](docs/gmock_cook_book.md): Practical recipes including matchers.
- [gMock for Dummies](docs/gmock_for_dummies.md): Beginner-friendly guide to mocking.
- [Expectations and Sequencing](api-reference/gmock-api/expectations-and-sequencing.md): Deep dive on call expectations and ordering.

---

This page empowers you to write precise, readable, and maintainable mock expectations leveraging the expressive matchers and composition mechanisms of GoogleMock.
