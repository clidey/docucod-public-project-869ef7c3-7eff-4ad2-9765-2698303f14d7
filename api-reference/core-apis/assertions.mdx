---
title: "Assertions"
description: "Describes the set of assertion macros and classes that validate test outcomes. Covers equality, inequality, fatal/non-fatal failures, user-defined assertions, and exception verification. Explains syntax, usage patterns, and best practices with illustrative examples."
---

# Assertions Reference

This chapter details the comprehensive set of assertion macros and classes that GoogleTest provides to check and validate test outcomes effectively. Assertions form the heart of writing meaningful tests: they verify expected conditions, compare values, handle exceptions, and manage fatal and non-fatal failures, enabling you to catch bugs early and report useful diagnostics.

> **Note:** Include the GoogleTest header at the start of your test files:
>
> ```cpp
> #include <gtest/gtest.h>
> ```

---

## Assertion Fundamentals

Each assertion type in GoogleTest comes in a pair: an `EXPECT_` macro and an `ASSERT_` macro.

- `EXPECT_` macros generate *non-fatal failures* when the assertion fails, allowing the test to continue running and report multiple errors in one go.

- `ASSERT_` macros generate *fatal failures* which abort the current test function immediately, preventing further execution.

All assertion macros support streaming custom failure messages using the `<<` operator for enhanced diagnostics.

```cpp
EXPECT_TRUE(condition) << "Custom failure details here";
```

Any value streamable to an `ostream` can be used, including strings and pointers.

---

## Explicit Success and Failure

Sometimes you want to mark a test as explicitly succeeded or failed independent of any condition.

### SUCCEED()

```cpp
SUCCEED();
```

Generates a success note. This does *not* make the overall test succeed but records the explicit success point.

Currently, it produces no visible output but may do so in future GoogleTest versions.

### FAIL()

```cpp
FAIL();
```

Generates a *fatal failure* immediately aborting the current function.

This macro can only be used in functions returning `void` (i.e., not in functions with return values).

### ADD_FAILURE()

```cpp
ADD_FAILURE();
```

Adds a *non-fatal failure* while allowing the execution to continue.

### ADD_FAILURE_AT(file_path, line_number)

```cpp
ADD_FAILURE_AT("foo.cc", 42);
```

Generates a non-fatal failure at a specified file and line number.

---

## Boolean Condition Assertions

These assertions verify boolean expressions.

### EXPECT_TRUE / ASSERT_TRUE

```cpp
EXPECT_TRUE(condition);
ASSERT_TRUE(condition);
```

Verify that the condition evaluates to `true`.

### EXPECT_FALSE / ASSERT_FALSE

```cpp
EXPECT_FALSE(condition);
ASSERT_FALSE(condition);
```

Verify that the condition evaluates to `false`.


---

## Binary Comparison Assertions

Verify expected relationships between two values. Arguments are evaluated once and may be any types supporting the relation operators.

### Equality

- `EXPECT_EQ(val1, val2)`
- `ASSERT_EQ(val1, val2)`

Verify `val1 == val2`.

Special notes:
- For pointers, this checks address equality, not contents.
- For C strings, use [`EXPECT_STREQ`](#string-comparison) to compare contents.
- Use `nullptr` over `NULL` to avoid C++ type issues.

### Inequality

- `EXPECT_NE(val1, val2)`
- `ASSERT_NE(val1, val2)`

Verify `val1 != val2`.

Same notes regarding pointers and string contents as for equality assertions.

### Ordering

| Assertion     | Verifies  |
|---------------|-----------|
| `EXPECT_LT` / `ASSERT_LT` | `val1 < val2`  |
| `EXPECT_LE` / `ASSERT_LE` | `val1 <= val2` |
| `EXPECT_GT` / `ASSERT_GT` | `val1 > val2`  |
| `EXPECT_GE` / `ASSERT_GE` | `val1 >= val2` |

---

## String Comparison Assertions

Designed specifically to compare **C strings** (`const char*`) by content.

If you want to compare `std::string` objects, use the equality macros above.

They also support wide strings (`const wchar_t*`).

- `EXPECT_STREQ(str1, str2)`
- `ASSERT_STREQ(str1, str2)`


Verify that `str1` and `str2` have the same content (string equality).

- `EXPECT_STRNE(str1, str2)`
- `ASSERT_STRNE(str1, str2)`

Verify that the strings have different content.

- `EXPECT_STRCASEEQ(str1, str2)`
- `ASSERT_STRCASEEQ(str1, str2)`

Verify content equality ignoring case.

- `EXPECT_STRCASENE(str1, str2)`
- `ASSERT_STRCASENE(str1, str2)`

Verify content inequality ignoring case.

---

## Floating-Point Comparison Assertions

Floating-point comparisons are tricky due to precision and rounding errors. These macros provide utility for near-equality with sensible default error bounds based on Units in the Last Place (ULPs).

- `EXPECT_FLOAT_EQ(val1, val2)`
- `ASSERT_FLOAT_EQ(val1, val2)`

Verifies that the two `float` values are approximately equal within 4 ULPs.

- `EXPECT_DOUBLE_EQ(val1, val2)`
- `ASSERT_DOUBLE_EQ(val1, val2)`

Verifies that the two `double` values are approximately equal within 4 ULPs.

- `EXPECT_NEAR(val1, val2, abs_error)`
- `ASSERT_NEAR(val1, val2, abs_error)`

Verifies that the difference between `val1` and `val2` is no greater than `abs_error`.

Special rules:
- Both infinities of the same sign are treated as equal.
- Differences involving infinities are handled logically.

---

## Exception Assertions

These macros require that your build supports exceptions.

They verify that specific code throws or does not throw exceptions, supporting compound statements.

### EXPECT_THROW / ASSERT_THROW

```cpp
EXPECT_THROW(statement, exception_type);
ASSERT_THROW(statement, exception_type);
```

Verify that `statement` throws an exception of type `exception_type`.

### EXPECT_ANY_THROW / ASSERT_ANY_THROW

```cpp
EXPECT_ANY_THROW(statement);
ASSERT_ANY_THROW(statement);
```

Verify that `statement` throws an exception of any type.

### EXPECT_NO_THROW / ASSERT_NO_THROW

```cpp
EXPECT_NO_THROW(statement);
ASSERT_NO_THROW(statement);
```

Verify that `statement` does not throw any exception.

---

## Predicate Assertions

When assertions require more complex conditions and better failure messages than a simple boolean test, GoogleTest supports predicate and predicate-formatter assertions.

### Predicate Assertions: `EXPECT_PRED*` / `ASSERT_PRED*`

These macros allow you to pass a predicate (function or functor) returning `bool` and arguments. On failure, they print the values of all arguments for clarity.

```cpp
bool IsEven(int n);
EXPECT_PRED1(IsEven, 4); // Succeeds
EXPECT_PRED2(IsMutuallyPrime, a, b); // Fails if not mutually prime
```

You need to specify the argument counts explicitly (`PRED1`, `PRED2`, ..., `PRED5`).

### Predicate-Formatter Assertions: `EXPECT_PRED_FORMAT*` / `ASSERT_PRED_FORMAT*`

For full control over failure messages, predicate-formatters accept both the expressions' strings and their values, returning a `testing::AssertionResult` with an optional detailed message.

Example:

```cpp
AssertionResult AssertIsEven(const char* expr, int n) {
  if (IsEven(n)) return AssertionSuccess();
  return AssertionFailure() << expr << " is not even, was " << n;
}
EXPECT_PRED_FORMAT1(AssertIsEven, value);
```

---

## Windows HRESULT Assertions

On Windows, special macros test HRESULT values for success or failure, providing human-readable messages.

- `EXPECT_HRESULT_SUCCEEDED(expression)`
- `ASSERT_HRESULT_SUCCEEDED(expression)`

Verify that `expression` is a success HRESULT.

- `EXPECT_HRESULT_FAILED(expression)`
- `ASSERT_HRESULT_FAILED(expression)`

Verify that `expression` is a failure HRESULT.

Example:

```cpp
CComPtr<IShellDispatch2> shell;
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
```

---

## Death Assertions

Death tests verify that code terminates the process and produces expected output. They run the code in a child process created either by forking or re-executing your test program.

### EXPECT_DEATH / ASSERT_DEATH

```cpp
EXPECT_DEATH(statement, "regex_matcher");
ASSERT_DEATH(statement, "regex_matcher");
```

Verify that `statement` causes process termination and stderr output matches the regex.

Example:

```cpp
EXPECT_DEATH(CallDangerousFunction(42), "Error on line .* of CallDangerousFunction");
```

### EXPECT_DEATH_IF_SUPPORTED / ASSERT_DEATH_IF_SUPPORTED

These macros only verify death if death tests are supported on the current platform; otherwise, they succeed silently.

### EXPECT_DEBUG_DEATH / ASSERT_DEBUG_DEATH

These verify death only in debug builds; in release binaries they run `statement` normally.

### EXPECT_EXIT / ASSERT_EXIT

```cpp
EXPECT_EXIT(statement, predicate, matcher);
ASSERT_EXIT(statement, predicate, matcher);
```

Verify that `statement` exits the process with an exit status satisfying `predicate` and stderr output matching `matcher`.

The `predicate` can be one of:

- `::testing::ExitedWithCode(code)` - exited normally with `code`.
- `::testing::KilledBySignal(signal)` - terminated by specified signal (POSIX only).

Example:

```cpp
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
```

---

## General Notes & Best Practices

- Use `EXPECT_*` macros if you want to continue test execution after failure, e.g. to find multiple errors.
- Use `ASSERT_*` macros if continuing after failure doesn't make sense.
- Prefer `nullptr` over `NULL` when comparing pointers.
- Use `EXPECT_STREQ` and similar macros for C strings to compare content, not pointers.
- For complex checks, consider writing predicates with detailed error messages.
- Death tests require understanding multi-process semantics; side effects inside death tests are not visible in the parent.
- Streaming messages with `<<` provides expressive failure diagnostics.

---

## Example: Writing Assertions

```cpp
TEST(ExampleTest, IntegerAssertions) {
  int value = 5;

  EXPECT_EQ(value, 5) << "Value must be 5";
  EXPECT_NE(value, 0);
  ASSERT_LT(value, 10) << "Value is too large";
}

TEST(ExampleTest, StringAssertions) {
  const char* s1 = "hello";
  const char* s2 = "hello";
  EXPECT_STREQ(s1, s2) << "Strings differ";
  EXPECT_STRNE(s1, "world");
}

TEST(ExampleTest, FloatingPointAssertions) {
  float val1 = 1.0001f;
  float val2 = 1.0002f;
  EXPECT_FLOAT_EQ(val1, val2);
  EXPECT_NEAR(val1, val2, 0.001f);
}

#if GTEST_HAS_EXCEPTIONS
TEST(ExampleTest, ExceptionAssertions) {
  EXPECT_THROW(throw std::runtime_error("error"), std::runtime_error);
  EXPECT_ANY_THROW(throw 1);
  EXPECT_NO_THROW(int x = 5);
}
#endif

TEST(ExampleTest, PredicateAssertion) {
  auto IsPositive = [](int x) { return x > 0; };
  EXPECT_PRED1(IsPositive, 5);
}

TEST(ExampleTest, DeathTest) {
  EXPECT_DEATH({ abort(); }, "");
}
```

---

For detailed explanations and extended features, see the related reference sections below.

---

## See Also

- [GoogleTest Primer](../../docs/primer.md): Basic introduction and how to write simple tests.
- [Advanced Assertions and Custom Matchers](../../guides/writing-and-running-tests/advanced-assertions-matchers.md): For composing complex assertion logic.
- [Matchers Reference](matchers.md): Use custom matchers for expressive assertions.
- [Death Assertions](reference/assertions.md#death): Deeper dive in death tests and their semantics.
- [Mocking Reference](../../docs/reference/mocking.md): For writing mock-based tests.

---