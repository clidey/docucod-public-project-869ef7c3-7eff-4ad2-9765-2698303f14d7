---
title: "Test Case and Suite Definition"
description: "Describes the macros, classes, and conventions for defining, registering, and organizing test cases and test suites. Includes syntax variations, parameterized tests, and best practices for test structure."
---

# Test Case and Suite Definition

This section provides you with an in-depth understanding of how to define, organize, and register test cases and test suites in GoogleTest. It covers the macros, classes, and naming conventions essential to structure your tests effectively, including variations for parameterized tests and guidelines for best practices.

---

## Overview of Test Cases and Test Suites

In GoogleTest, tests are organized hierarchically:

- **Test Suites** (earlier called Test Cases) group related tests, usually reflecting the structure or component of the software under test.
- **Test Cases** (or individual tests) define specific, atomic tests that assert particular behaviors.

Each test resides within one test suite and is identified by a unique name within it. GoogleTest automatically discovers and runs these tests.

---

## Defining Tests

GoogleTest uses a set of macros to define tests. These macros handle test registration, fixture setup, and test execution.

### 1. `TEST`

Use to define a simple test without a test fixture.

```cpp
TEST(TestSuiteName, TestName) {
  ... // test code
}
```

- **TestSuiteName** groups logically related tests.
- **TestName** identifies the specific test.
- Both parameters should be valid C++ identifiers without underscores.

Example:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}
```

### 2. `TEST_F`

Use when your tests require shared setup and teardown via a test fixture class.

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override { ... }
  void TearDown() override { ... }
};

TEST_F(MyFixture, TestName) {
  ... // test code with access to fixture members
}
```

- Fixture class provides reusable data and methods.

### 3. `TEST_P`

Defines a *value-parameterized* test, which runs the same test logic with different parameters.

```cpp
class MyParamTest : public testing::TestWithParam<int> {};

TEST_P(MyParamTest, HandlesValues) {
  int value = GetParam();
  ...
}

INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyParamTest,
                         testing::Values(1, 2, 3));
```

Use `GetParam()` inside the test body to access the test parameter.

### 4. `TYPED_TEST` and `TYPED_TEST_SUITE`

Typed tests allow running the same test logic with different *types* instead of values.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  ...
};

using MyTypes = testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam value = ...;
  ...
}
```

### 5. Registering Tests Programmatically with `RegisterTest`

In complex scenarios, tests can be registered dynamically at runtime.

```cpp
::testing::RegisterTest(
  "TestSuiteName", "TestName", nullptr, nullptr,
  __FILE__, __LINE__,
  []() -> MyFixture* { return new MyFixtureSubclass; });
```

This allows tests to be created with dynamic data or customized fixtures.

---

## Understanding Test Fixtures

Test fixtures prepare a consistent environment for multiple tests, avoiding duplication and ensuring proper isolation.

- Declared by subclassing `testing::Test`.
- Members and setup/teardown methods define common state.
- Each test runs on a fresh instance of the fixture.

Example:

```cpp
class WidgetTest : public testing::Test {
 protected:
  void SetUp() override {
    widget_.Initialize();
  }

  Widget widget_;
};

TEST_F(WidgetTest, DoesThis) {
  EXPECT_TRUE(widget_.DoesThis());
}
```

Ensure to avoid shared mutable globals to keep tests independent.

---

## Parameterized Tests

### Value-Parameterized Tests (`TEST_P`)

Ideal for running tests over different input values without duplication.

- Fixture inherits from `TestWithParam<T>`.
- Tests use `GetParam()`.
- Tests instantiated via `INSTANTIATE_TEST_SUITE_P` with generators such as `Values`, `Range`, or `Combine`.

Example:

```cpp
class MyTest : public testing::TestWithParam<int> {};

TEST_P(MyTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyTest, testing::Values(2, 4, 6));
```

### Type-Parameterized Tests and Type-Parameterized Suites

Facilitate testing templates or polymorphic code across multiple types by defining tests once and instantiating on changing type lists.

Use `TYPED_TEST_SUITE`, `TYPED_TEST`, `TYPED_TEST_SUITE_P`, and related macros to define and instantiate these tests.

---

## Best Practices for Test Structure

- **Naming:** Avoid underscores in test suite and test names to prevent conflicts.
- **Fixture Usage:** Use fixtures for shared context rather than globals.
- **Isolation:** Each test should be independent.
- **Ordering:** Tests normally run in arbitrary order; do not rely on side effects.
- **Clarity:** Use descriptive test and suite names for easy identification.
- **Parameterized Tests:** Use parameterized tests to validate code against different inputs systematically.

---

## Common Pitfalls and Troubleshooting

### Underscore Usage in Names

Underscores have special meaning inside GoogleTest macros and may cause name conflicts or undefined behavior. Avoid them.

### Constructors and Assertion Restrictions

Fatal assertions (`ASSERT_*`) may only be used in `void` returning functions (i.e., not in constructors or destructors). Use `SetUp()` instead.

### Test Fixture Access

`TEST_F` requires the fixture class to have a default constructor.

### Disabled Tests

Prefix test or suite names with `DISABLED_` to exclude them from runs without removing the code.

### Parameterized Test Instantiation

Ensure all `TEST_P` suites are instantiated with `INSTANTIATE_TEST_SUITE_P`, or disable the orphan check with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## Additional Utilities

### Access Current Running Test Name

At runtime inside tests or fixtures, you can query:

```cpp
const testing::TestInfo* info = testing::UnitTest::GetInstance()->current_test_info();
std::cout << "Test: " << info->test_suite_name() << "." << info->name() << std::endl;
```

### Record Properties

Inside a test, you can log key-value properties:

```cpp
testing::Test::RecordProperty("CustomKey", "CustomValue");
```

This information is included in XML reports.

---

## Summary

GoogleTest organizes tests into suites and cases using macros for defining, registering, and parameterizing tests. Fixtures provide reusable setup/teardown support; parameterized tests simplify testing over multiple inputs or types. Following naming conventions and instantiating tests properly ensures reliable execution and reporting.

---

## References

- [GoogleTest Primer](../primer.md) — Introduction to tests and fixtures.
- [Assertions Reference](../reference/assertions.md) — Assertions used within test cases.
- [Advanced GoogleTest Topics](../advanced.md) — Covers fixtures, parameterized tests, and more.
- [Mocking Reference](../reference/mocking.md) — For mock definitions used alongside test cases.
- [gMock Cookbook](../gmock_cook_book.md) — Advanced mock usage patterns.

---

For comprehensive understanding, complement this with the GoogleTest Primer and Advanced Guides, which walk through writing, running, and structuring tests from basics to advanced patterns.