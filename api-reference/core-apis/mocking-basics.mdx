---
title: "Mock Classes and Methods"
description: "Describes how to declare and use mocks within GoogleMock, including use of the MOCK_METHOD macro, handling const/volatile specifiers, and controlling mock object behavior in tests."
---

# Mock Classes and Methods

GoogleMock allows you to create mock classes and methods to simulate and control the behavior of C++ interfaces and classes within tests. This functionality enables precise verification of interactions between components and facilitates isolated testing.

---

## Defining Mock Classes with `MOCK_METHOD`

The cornerstone of GoogleMock's mocking capability is the `MOCK_METHOD` macro. It enables you to declare mock methods in your mock class that override virtual methods of the interface or base class.

### Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Qualifiers));
```

- `ReturnType`: The return type of the method.
- `MethodName`: The method's name.
- `Args...`: Parenthesized argument list.
- `Qualifiers`: Optional qualifiers like `const`, `override`, `noexcept`, or reference qualifiers (`ref(&)`).

### Example

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

**Key Points:**

- Put all `MOCK_METHOD` declarations in the `public:` section, even if the original method is `protected` or `private`. This ensures mock methods are accessible for setting expectations.
- When mocking const methods, include `const` and `override` in the qualifiers.
- For methods with non-standard calling conventions (e.g., Windows `STDMETHODCALLTYPE`), use the `Calltype()` qualifier.

### Handling Commas in Types

If your method uses types with commas (e.g., template types), wrap the type with extra parentheses or use aliases:

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());

using MapIntDouble = std::map<int, double>;
MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
```

---

## Using `EXPECT_CALL` to Set Expectations

Once you've defined your mock class, you can set expectations on mock methods to specify how they are expected to be called during testing.

### Basic Example

```cpp
MockTurtle turtle;
EXPECT_CALL(turtle, Forward(100)).Times(AtLeast(1));
```

This expects the `Forward` method to be called at least once with the argument 100.

### Matchers

Instead of concrete values, you can use matchers to specify flexible argument expectations:

```cpp
using ::testing::_;  // wildcard matcher
EXPECT_CALL(turtle, GoTo(50, _));  // x must be 50, y can be anything
```

If you want to ignore arguments entirely for non-overloaded methods, simply omit the parentheses:

```cpp
EXPECT_CALL(turtle, Forward);  // Expect Forward to be called, with any args
```

### Chainable Clauses

The `EXPECT_CALL` macro supports a fluent syntax with chained clauses to specify:

- `.With()` to apply a multi-argument matcher.
- `.Times()` to specify call cardinality.
- `.InSequence()` to place expectations in sequences.
- `.After()` to enforce ordering after other expectations.
- `.WillOnce()` to specify behavior on each expected call.
- `.WillRepeatedly()` to specify behavior for subsequent calls.
- `.RetiresOnSaturation()` to deactivate expectation after it's satisfied.

### Example with Multiple Clauses

```cpp
using ::testing::Return;
using ::testing::AtLeast;
using ::testing::InSequence;

MockTurtle turtle;
{
  InSequence s;

  EXPECT_CALL(turtle, PenDown())
      .Times(1);
  EXPECT_CALL(turtle, Forward(100))
      .Times(AtLeast(1))
      .WillRepeatedly(Return());
  EXPECT_CALL(turtle, PenUp())
      .Times(1)
      .WillOnce(Return());
}
```

---

## `ON_CALL` for Setting Default Behavior

`ON_CALL` lets you specify behavior of mock methods without setting expectations on the number of calls.

### Syntax

```cpp
ON_CALL(mock_obj, Method(matchers...)).WillByDefault(action);
```

### Behavior

- Sets default action that applies when no matching `EXPECT_CALL` is found.
- Useful for specifying reasonable defaults to avoid test failure on uninteresting calls.

### Example

```cpp
ON_CALL(turtle, GetX()).WillByDefault(Return(42));
```

---

## Mock Object Strictness: NiceMock, NaggyMock, StrictMock

GoogleMock provides wrappers to control how uninteresting calls (method calls without expectations) are handled.

| Wrapper Type   | Behavior on Uninteresting Calls                      |
| -------------- | --------------------------------------------------- |
| `NiceMock<T>`  | Suppresses warnings; calls allowed silently         |
| `NaggyMock<T>` | Default; warns on uninteresting calls               |
| `StrictMock<T>`| Errors on uninteresting calls                        |

### Usage

Simply wrap your mock class:

```cpp
NiceMock<MockTurtle> nice_turtle;
NaggyMock<MockTurtle> naggy_turtle;
StrictMock<MockTurtle> strict_turtle;
```

These wrappers inherit constructors of the underlying mock class.

### Important Notes

- Only works for mock methods declared directly in the mock class.
- Does not support nesting (e.g., `NiceMock<StrictMock<T>>` is unsupported).
- Prefer `NiceMock` for general testing to avoid brittle tests.

---

## Mocking Overloaded Methods

You can mock overloaded methods just like regular methods. GoogleMock disambiguates based on the method signature.

### Example

```cpp
class Foo {
  virtual int GetValue() = 0;
  virtual int GetValue(int x) = 0;
  virtual int GetValue(int x) const = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (override));
  MOCK_METHOD(int, GetValue, (int x), (override));
  MOCK_METHOD(int, GetValue, (int x), (const, override));
};
```

Use `Const(mock)` to set expectations on the const overload.

```cpp
EXPECT_CALL(Const(mock_foo), GetValue(5)).WillOnce(Return(7));
```

### SelectOverload Utility

If ambiguity arises, disambiguate with `Const()` or by explicitly casting matchers.

---

## Mocking Class Templates

Template classes can be mocked similarly by specializing the mock for each template instantiation.

Example:

```cpp
template <typename T>
class Stack {
 public:
  virtual ~Stack() {}
  virtual void Push(const T&) = 0;
  virtual int Size() const = 0;
};

template <typename T>
class MockStack : public Stack<T> {
 public:
  MOCK_METHOD(void, Push, (const T&), (override));
  MOCK_METHOD(int, Size, (), (const, override));
};
```

---

## Mocking Non-Virtual Methods

While gMock traditionally mocks virtual methods, it can mock non-virtual methods for use in template polymorphism or compile-time polymorphism.

Example:

```cpp
class Concrete {
 public:
  void DoSomething();
  int GetValue() const;
};

class MockConcrete {
 public:
  MOCK_METHOD(void, DoSomething, ());
  MOCK_METHOD(int, GetValue, (), (const));
};
```

In this scenario, your code would be templatized to use either `Concrete` or `MockConcrete`.

---

## Mocking Destructors

GoogleMock does not support mocking destructors directly. To test destructor behavior or ordering:

- Define a mock method such as `Die()`.
- Call this method explicitly in the destructor.
- Set expectations on `Die()`.

Example:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() { Die(); }
};

EXPECT_CALL(mock_foo, Die()).Times(1);
```

---

## Verifying and Resetting Mocks

GoogleMock automatically verifies expectations at mock object destruction. You can force verification and clearing manually:

```cpp
bool success = ::testing::Mock::VerifyAndClearExpectations(&mock_obj);
bool cleared = ::testing::Mock::VerifyAndClear(&mock_obj);
```

- `VerifyAndClearExpectations` verifies and clears expectations.
- `VerifyAndClear` also clears default actions.

**Tip:** Avoid setting new expectations after verification to prevent undefined behavior.

---

## Best Practices and Troubleshooting

- Set expectations **before** exercising code that calls the mock methods.
- Use `ON_CALL` for default behaviors without imposing call expectations.
- Use matchers to avoid over-specification and brittle tests.
- Use `NiceMock` to suppress warning noise when uninteresting calls are acceptable.
- Carefully manage sequence and order constraints with `InSequence` and `After` clauses to model call order.
- Always declare virtual destructors in interfaces/classes you mock.

---

## Further References

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [Nice, Naggy, and Strict Mocks](https://google.github.io/googletest/reference/mocking.html#StrictMock)

---

## Example: Defining and Using a Mock

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};

TEST(PainterTest, DrawsCircle) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown()).Times(AtLeast(1));
  EXPECT_CALL(turtle, Forward(testing::_)).Times(testing::AnyNumber());
  EXPECT_CALL(turtle, PenUp()).Times(1);

  // Exercise code that uses turtle...
}
```

---