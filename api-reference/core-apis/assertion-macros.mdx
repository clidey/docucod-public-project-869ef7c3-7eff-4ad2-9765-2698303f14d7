---
title: "Assertion Macros"
description: "Complete reference for built-in assertion macros. Learn how to verify values, states, exceptions, and error-handling logic, including detailed macro behavior and usage guidelines. Practical examples illustrate best practices for fatal vs. non-fatal assertions and advanced scenarios."
---

# Assertion Macros Reference

Comprehensive documentation on built-in assertion macros in GoogleTest. Learn how to verify values, states, exceptions, and error-handling logic effectively. This guide explains the behavior and usage of each assertion macro with practical examples, guiding you through choosing between fatal and non-fatal assertions and mastering advanced assertion scenarios.

---

## Overview

Assertion macros are the fundamental building blocks for validation and error reporting in GoogleTest. They allow you to specify expected conditions and verify program behavior in your tests.

Assertions come in pairs:

- **EXPECT_*** macros generate *non-fatal* failures, allowing the test function to continue executing.
- **ASSERT_*** macros generate *fatal* failures, aborting the current function immediately.

Each assertion macro can also accept an optional custom failure message appended through the stream insertion operator (`<<`).

Use assertions to catch errors early and clearly, improving test reliability and debugging ease.


## 1. Explicit Success and Failure Assertions

These macros allow you to directly mark a test check as success or failure, useful for control flow based validations.

### SUCCEED()

Marks an explicit test success at the point of invocation.

- Use when a particular code path represents an unconditional success.
- Does *not* cause the entire test to succeed; failures elsewhere override.

```cpp
SUCCEED();
SUCCEED() << "Reached this point without error";
```


### FAIL()

Generates a fatal failure, causing immediate return from the current function.

- Use to indicate an unconditional failure or unreachable code.
- Can only be used in functions returning void.

```cpp
if (unexpected_condition) {
  FAIL() << "Unexpected condition encountered!";
}
```


### ADD_FAILURE()

Generates a non-fatal failure, allowing the current function to continue.

- Use when you want to record a failure but proceed to check other conditions.

```cpp
if (condition_fails) {
  ADD_FAILURE() << "Condition failed but continuing";
}
```


### ADD_FAILURE_AT(file, line)

Generates a non-fatal failure at the specified file and line number.

Useful for reporting errors at a different location than code execution.

```cpp
ADD_FAILURE_AT("foo.cc", 42) << "Failure reported at foo.cc:42";
```


## 2. Boolean Condition Assertions

Verify that a Boolean expression has the expected truth value.

### EXPECT_TRUE(condition)
### ASSERT_TRUE(condition)

Verifies that the provided condition evaluates to `true`.

Example:
```cpp
EXPECT_TRUE(x > 0) << "x must be positive";
ASSERT_TRUE(IsValid(y));
```

If the assertion fails:
- `EXPECT_TRUE` logs a non-fatal failure,
- `ASSERT_TRUE` aborts the current function immediately.


### EXPECT_FALSE(condition)
### ASSERT_FALSE(condition)

Verifies that the provided condition evaluates to `false`.

Example:
```cpp
EXPECT_FALSE(error_occurred) << "Error should not occur here";
ASSERT_FALSE(ptr == nullptr);
```

Failure behavior is as per the `EXPECT_TRUE` and `ASSERT_TRUE` definitions.


## 3. Binary Comparison Assertions

Compare two values using standard relational operators. Arguments must be comparable. Both narrow and wide strings are supported.

### Equality and Inequality

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)` — verifies `val1 == val2`.
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)` — verifies `val1 != val2`.

*Note on pointers:* For pointer types, these macros compare pointer equality, not the pointed-to content. For C strings, use specialized string assertions instead.

Example:
```cpp
EXPECT_EQ(expected, actual);
ASSERT_NE(pointer1, pointer2);
```


### Ordering Comparisons

- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)` — verifies `val1 < val2`.
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)` — verifies `val1 <= val2`.
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)` — verifies `val1 > val2`.
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)` — verifies `val1 >= val2`.

Example:
```cpp
EXPECT_LT(value, upper_bound);
ASSERT_GE(minimum, threshold);
```


## 4. String Comparison Assertions

Specifically designed for C strings (`const char*`) and wide strings (`const wchar_t*`). They verify content equality or inequality.

### EXPECT_STREQ(str1, str2)
### ASSERT_STREQ(str1, str2)

Verifies that two C strings have the *same* contents.

### EXPECT_STRNE(str1, str2)
### ASSERT_STRNE(str1, str2)

Verifies that two C strings have *different* contents.

### EXPECT_STRCASEEQ(str1, str2)
### ASSERT_STRCASEEQ(str1, str2)

Verifies that two C strings are equal, ignoring case differences.

### EXPECT_STRCASENE(str1, str2)
### ASSERT_STRCASENE(str1, str2)

Verifies that two C strings differ, ignoring case differences.

Example:
```cpp
EXPECT_STREQ("hello", ptr);
ASSERT_STRNE(cstr1, cstr2);
EXPECT_STRCASEEQ("FOO", "foo");
```


## 5. Floating-Point Comparison Assertions

Due to the nature of floating-point arithmetic, perfect equality is rare. Use these macros to compare floating-point numbers within tolerance.

### EXPECT_FLOAT_EQ(val1, val2)
### ASSERT_FLOAT_EQ(val1, val2)

Verifies two `float` numbers are approximately equal within 4 ULPs (Units in Last Place).

### EXPECT_DOUBLE_EQ(val1, val2)
### ASSERT_DOUBLE_EQ(val1, val2)

Verifies two `double` numbers are approximately equal within 4 ULPs.

### EXPECT_NEAR(val1, val2, abs_error)
### ASSERT_NEAR(val1, val2, abs_error)

Verifies the absolute difference between `val1` and `val2` does not exceed `abs_error`.

Example:
```cpp
EXPECT_FLOAT_EQ(computed_float, expected_float);
ASSERT_NEAR(computed_double, expected_double, 0.001);
```


## 6. Exception Assertions

Verify that code throws or does not throw expected exceptions. Requires exceptions enabled in the build environment.

### EXPECT_THROW(statement, exception_type)
### ASSERT_THROW(statement, exception_type)

Verifies that `statement` throws an exception of type `exception_type`.

### EXPECT_ANY_THROW(statement)
### ASSERT_ANY_THROW(statement)

Verifies that `statement` throws *any* exception.

### EXPECT_NO_THROW(statement)
### ASSERT_NO_THROW(statement)

Verifies that `statement` does *not* throw any exception.

Example:
```cpp
EXPECT_THROW(FunctionThatMayThrow(), std::runtime_error);
ASSERT_NO_THROW(FunctionThatDoesNotThrow());
```


## 7. Predicate Assertions

When an assertion requires a complex predicate and you want detailed failure messages, use predicate assertions.

### EXPECT_PREDn(pred, val1, val2, ...)

Verifies that the predicate `pred` returns `true` for the provided values.

Example:
```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, value);
```

### EXPECT_PRED_FORMATn(pred_formatter, val1, val2, ...)

Verifies that the predicate formatter `pred_formatter` succeeds for the given values. The predicate formatter returns an `AssertionResult` including detailed messages.

Example:
```cpp
testing::AssertionResult IsEven(const char* expr, int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess();
  } else {
    return testing::AssertionFailure() << n << " is odd";
  }
}
EXPECT_PRED_FORMAT1(IsEven, value);
```

See [Advanced GoogleTest Topics](docs/advanced.md#more-assertions) for guidance on custom predicates.


## 8. Generalized Matcher Assertions

To write expressive tests, you can use GoogleMock matchers within assertions.

### EXPECT_THAT(value, matcher)
### ASSERT_THAT(value, matcher)

Verifies that `value` satisfies the matcher `matcher`.

Supports sophisticated matching of strings, containers, objects, and more.

Example:
```cpp
EXPECT_THAT("hello world", StartsWith("hello"));
EXPECT_THAT(numbers, ElementsAre(1, 2, _, 4));
```

Use the rich set of built-in matchers or create custom ones for advanced test scenarios.


## 9. Fatal vs. Non-fatal Assertions

Choose your assertion macro based on how you want the test to proceed on failure:

- Use `ASSERT_*` (fatal) macros when subsequent test code depends on previous conditions; aborts early to prevent cascading errors.
- Use `EXPECT_*` (non-fatal) macros when you want to record failures but allow further checks within the same test.

## 10. Best Practices and Tips

- **Evaluate expressions only once:** Assertions guarantee single evaluation, so you can safely use functions with side effects as arguments.
- **Use `EXPECT_NO_FATAL_FAILURE` or `ASSERT_NO_FATAL_FAILURE`** to verify that a subroutine doesn’t produce fatal failures inside it.
- **Use `HasFatalFailure()`** to check dynamically if any fatal failure has occurred so far in the test.
- **Use `SCOPED_TRACE`** to add context to nested assertions, helping debug failures inside helper functions.
- **Use `EXPECT_THAT` with matchers** for readable and informative assertions.
- **For death tests**, use assertion macros like `EXPECT_DEATH` to verify behavior that results in process termination.


## 11. Example Usage

```cpp
// Simple equality check
TEST(FooTest, IntEquality) {
  int result = ComputeValue();
  EXPECT_EQ(42, result) << "Result should be 42";
}

// Verify string equality ignoring case
TEST(StringTest, CaseInsensitive) {
  const char* output = GetOutput();
  ASSERT_STRCASEEQ("HELLO", output);
}

// Verify approximate floating-point equality
TEST(MathTest, FloatApprox) {
  float x = ComputeFloat();
  EXPECT_FLOAT_EQ(3.14f, x);
}

// Check that a call throws an exception
TEST(ExceptionTest, ThrowsOnInvalidInput) {
  EXPECT_THROW(FunctionThatThrows(), std::runtime_error);
}

// Use a predicate assertion
bool IsEven(int n) { return n % 2 == 0; }
TEST(PredicateTest, CheckEven) {
  EXPECT_PRED1(IsEven, GetNumber());
}

// Using matcher assertion
using ::testing::HasSubstr;
TEST(MatcherTest, StringContains) {
  std::string s = GetMessage();
  EXPECT_THAT(s, HasSubstr("Success"));
}
```


## 12. Troubleshooting and Common Pitfalls

- **Using ASSERT_* in non-void functions:** Fatal assertions can only be used safely within `void` functions. Using them elsewhere can cause confusing compile errors.
- **Assertion side effects:** Expression arguments are evaluated exactly once but avoid side effects within streaming messages.
- **Distinguish pointer vs string comparisons:** Use string specific macros (`EXPECT_STREQ` etc.) for C-string content comparisons.
- **Negative cases for predicates:** Provide informative failure messages for both success and failure cases in custom predicates.
- **Mixing fatal failures in subroutines:** Fatal failures abort only the current function, not the entire test, which might cause unexpected behavior if not handled properly; use `HasFatalFailure()` or exceptions to propagate failures correctly.


---

For a deeper understanding of how assertion macros integrate into your test design and the API details, visit related documentation pages.

---

<Note>
The full list of assertion macros is also included in the GoogleTest [Assertions Reference](docs/reference/assertions.md).
</Note>

<Note>
GoogleMock's [EXPECT_CALL](docs/reference/mocking.md#EXPECT_CALL) works closely with assertion macros for specifying mock expectations and behaviors.
</Note>

---

## See Also

- [GoogleTest Assertions Reference](docs/reference/assertions.md)
- [GoogleMock Mocking Reference](docs/reference/mocking.md)
- [GoogleTest Advanced Topics](docs/advanced.md)
- [GoogleMock Cookbook](docs/gmock_cook_book.md)
- [GoogleTest Primer](primer.md)

---

For implementation source and tests, see the [GoogleTest GitHub Repository](https://github.com/google/googletest/tree/main/googletest) and the [GoogleMock GitHub Repository](https://github.com/google/googletest/tree/main/googlemock).


---

### Troubleshooting Checklist

- Fatal assertions only usable in void-returning functions
- Use the correct string comparison macro for C-string content
- Provide detailed messages for predicates using AssertionResult
- Understand uninteresting vs unexpected calls for mocks
- Use scoped traces to add useful contextual information
- Check environment compatibility for death tests

---

This concludes the detailed reference and usage guidelines for GoogleTest's assertion macros. Use assertions tailored to your test’s needs for expressive, maintainable, and reliable tests.