---
title: "Assertions Reference"
description: "Detailed reference for all built-in test assertions, covering expressions for checking expected values, errors, exceptions, and test outcomes. Includes syntax, macro usage patterns, and examples for writing expressive, robust tests."
---

# Assertions Reference

This page provides an exhaustive guide to the built-in test assertions available in GoogleTest, empowering you to verify your code behavior precisely and expressively. By using these assertions, you can check expected values, confirm error handling, and assess overall test outcomes with clarity and control.

GoogleTest assertions are provided as macros in two primary variants:

- `EXPECT_` variants, which generate **nonfatal failures** and allow the test function to continue running after a failure.
- `ASSERT_` variants, which generate **fatal failures** and immediately abort the current test function when a failure occurs.

Both variants support appending custom messages via the `<<` operator, enabling detailed diagnostics.

```cpp
EXPECT_TRUE(my_condition) << "Detailed failure reason";
```

All macros support streaming any `ostream`-compatible type, including C-style strings, C++ strings, and wide strings (which are converted to UTF-8 on output).

---

## 1. Success and Failure Assertions

These provide explicit success or failure indications regardless of a Boolean condition. Useful when you need to control test flow.

### SUCCEED()

- Generates a success indication.
- Does NOT make the overall test succeed by itself; the test can still fail if other assertions fail.
- Purely documentary; currently produces no visible output.

### FAIL()

- Generates a **fatal failure**, aborting the current function.
- Can only be used in `void`-returning functions.

### ADD_FAILURE()

- Generates a **nonfatal failure** without aborting the current function.

### ADD_FAILURE_AT(file_path, line_number)

- Generates a nonfatal failure associated with a specific file and line, enhancing diagnostics.

---

## 2. Matcher-Based Assertions

These enable rich, expressive assertion syntax by utilizing matchers, which describe expected value properties in readable ways.

### EXPECT_THAT(value, matcher)
ASSERT_THAT(value, matcher)

- Verifies that `value` satisfies the `matcher`.
- Matchers can express complex conditions like string prefixes, containment, ranges, or custom logic.

Example:

```cpp
#include <gmock/gmock.h>

using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(value1, StartsWith("Hello"));
EXPECT_THAT(value2, MatchesRegex("Line \\d+"));
ASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));
```

Failures provide clear output:

```
Value of: value1
  Actual: "Hi, world!"
Expected: starts with "Hello"
```

For a full list of built-in matchers, see the [Matchers Reference](matchers.md).

---

## 3. Boolean Condition Assertions

Test simple Boolean conditions directly.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: checks that condition is `true`.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: checks that condition is `false`.

Example:

```cpp
EXPECT_TRUE(is_initialized);
ASSERT_FALSE(is_error);
```

---

## 4. Binary Comparison Assertions

These verify relationships between two comparable values, such as equality and order.

They work with both narrow and wide strings (using special string comparison macros, see below).

Assertions:

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)` — verifies `val1 == val2`.
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)` — verifies `val1 != val2`.
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)` — verifies `val1 < val2`.
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)` — verifies `val1 <= val2`.
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)` — verifies `val1 > val2`.
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)` — verifies `val1 >= val2`.

Important notes:

- Use `EXPECT_STREQ` for equality of C strings (rather than pointer equality).
- For pointers compared against `NULL`, prefer `nullptr` instead of `NULL` for type safety.

Example:

```cpp
EXPECT_EQ(result, expected_value);
ASSERT_LT(count, max_count);
```

---

## 5. C String Comparison Assertions

Specialized assertions exist for comparing **C strings** (null-terminated char arrays) by content rather than address.

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)` — checks C strings are equal.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)` — checks C strings differ.
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)` — equal ignoring case.
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)` — not equal ignoring case.

Supports wide strings as well, printing values as UTF-8. To compare against `NULL`, use `nullptr`.

Example:

```cpp
EXPECT_STREQ(actual_c_str, "expected");
EXPECT_STRCASEEQ(user_input, "yes");
```

---

## 6. Floating-Point Comparisons

Due to rounding issues, exact equality checks on floats/doubles are inappropriate; these specialized assertions use error bounds or Units in the Last Place (ULPs).

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)` — checks floats approximately equal within 4 ULPs.
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)` — same for doubles.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)` — absolute difference within `abs_error`.

Special treatment for infinities: infinities of the same sign are equal within error bounds.

Example:

```cpp
EXPECT_FLOAT_EQ(calculated_float, expected_float);
EXPECT_NEAR(measured, reference, 0.01);
```

---

## 7. Exception Assertions

Requires that the build environment supports C++ exceptions.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)` — verifies statement throws exception of specified type.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)` — verifies statement throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)` — verifies statement throws no exception.

You can pass compound statements in `{}` to group multiple lines.

Example:

```cpp
EXPECT_THROW({ DoSomethingRisky(); }, std::runtime_error);
EXPECT_NO_THROW({ InitializeSystem(); });
```

---

## 8. Predicate Assertions

Use more complex predicates to check conditions, with clearer failure messages than plain `EXPECT_TRUE`.

### EXPECT_PREDn(pred, val1, val2, ..., valn)

- `n` can be 1–5, matching the number of predicate arguments.
- `pred` is a function or functor returning `bool`.
- On failure, prints values of the arguments.

Example:

```cpp
bool IsMutuallyPrime(int a, int b) { ... }
EXPECT_PRED2(IsMutuallyPrime, x, y);
```

### EXPECT_PRED_FORMATn(pred_formatter, val1, val2, ..., valn)

- Similar to `EXPECT_PREDn` but uses a *predicate-formatter* that returns `testing::AssertionResult` for detailed output.
- The formatter has signature:

  ```cpp
  testing::AssertionResult PredicateFormatter(const char* expr1, ..., val1, ...);
  ```

- Allows constructing rich failure messages that include values and explanation.

Example:

```cpp
testing::AssertionResult AssertMutuallyPrime(const char* expr_a, const char* expr_b, int a, int b) { ... }
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, x, y);
```

---

## 9. Windows HRESULT Assertions

Used for Windows COM programming to verify HRESULT success/failure status codes.

- `EXPECT_HRESULT_SUCCEEDED(expression)` / `ASSERT_HRESULT_SUCCEEDED(expression)` — verifies the HRESULT indicates success.
- `EXPECT_HRESULT_FAILED(expression)` / `ASSERT_HRESULT_FAILED(expression)` — verifies the HRESULT indicates failure.

The failure output includes human-readable error messages for HRESULT codes.

Example:

```cpp
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
```

---

## 10. Death Assertions

Verify that a piece of code causes the process to terminate. Useful for testing fatal errors, assertions, or program exits.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH(statement, matcher)` — verifies process dies with nonzero exit and `stderr` output matching `matcher`.
- `EXPECT_DEATH_IF_SUPPORTED(statement, matcher)` / `ASSERT_DEATH_IF_SUPPORTED` — same as `EXPECT_DEATH` if supported, else no-op.
- `EXPECT_DEBUG_DEATH(statement, matcher)` / `ASSERT_DEBUG_DEATH` — runs death test only in debug mode: in release mode just executes statement.
- `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT` — verifies process exits with code satisfying predicate and output matching matcher.

The `matcher` can be a matcher for a string or a regular expression; bare strings treated as `ContainsRegex`.

Predicates include:

```cpp
// Exits normally with given code.
::testing::ExitedWithCode(code);
// Process killed by signal.
::testing::KilledBySignal(signal);
```

Example:

```cpp
EXPECT_DEATH(DoSomething(42), "My error message");
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
```

---

# Practical Tips & Best Practices

- Use `EXPECT_` macros when you want the test to continue after a failure and `ASSERT_` when failure should abort the test immediately.
- Always provide informative messages using `<<` when assertions are likely to fail to speed up debugging.
- For floating-point numbers, always prefer specialized comparisons over `EXPECT_EQ` to avoid false negatives.
- Use matchers in `EXPECT_THAT` to write readable, flexible assertions over complex or structured data.
- Use sequences (`InSequence`) and ordering clauses (`After`, `InSequence`) when the order of expected calls matters in tests.
- Avoid mixing `EXPECT_CALL` statements with calls to mock methods; always set expectations before exercising mocks.
- When comparing C strings, use `EXPECT_STREQ` variants to compare by content.
- Use death assertions carefully and only where appropriate to validate fatal behaviors.

---

# Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Common Problems">
<Accordion title="Using EXPECT_EQ with Floating-Point Values">
Avoid using `EXPECT_EQ` with floats or doubles directly; use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ` or `EXPECT_NEAR` instead to handle rounding errors.
</Accordion>
<Accordion title="Unintended Pointer Comparisons">
Remember `EXPECT_EQ` on pointers compares addresses, not contents. Use `EXPECT_STREQ` for C strings or appropriate matchers for pointer types.
</Accordion>
<Accordion title="Compiler Errors on Mocking Overloaded Functions">
Help the compiler by specifying the exact overload with `Const()` wrappers or explicit casts when mocking or setting expectations on overloaded methods.
</Accordion>
<Accordion title="Death Test Fails Without Dying">
Check that your environment supports death testing and that the tested code actually calls `exit()`, crashes, or aborts. Use `EXPECT_DEATH_IF_SUPPORTED` to gracefully handle unsupported platforms.
</Accordion>
</AccordionGroup>

---

# Sample Usage

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::Return;
using ::testing::StartsWith;

TEST(MyTestSuite, SimpleAssertions) {
  int x = 42;
  int y = 40 + 2;

  EXPECT_EQ(x, y) << "x and y should be equal";
  EXPECT_TRUE(x > 0);
  EXPECT_THAT("Hello World", StartsWith("Hello"));

  EXPECT_THROW(throw std::runtime_error("error"), std::runtime_error);
}

// Using death assertion
TEST(MyDeathTest, DeathCheck) {
  EXPECT_DEATH({ std::abort(); }, "");
}
```

This example highlights the simplicity, expressiveness, and power of GoogleTest assertions.

---

For complete details of each assertion macro, parameter, and example, refer to the [Assertions Reference source file](https://github.com/google/googletest/blob/main/docs/reference/assertions.md).