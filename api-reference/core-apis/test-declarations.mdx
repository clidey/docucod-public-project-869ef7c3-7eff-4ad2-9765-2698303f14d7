---
title: "Test Declarations & Test Cases"
description: "Covers the API for defining, organizing, and running tests in GoogleTest. This includes how to declare TEST and TEST_F macros, create test fixtures, and leverage parameterized test facilities. Practical usage examples guide the reader through the process of building structured and maintainable test suites."
---

# Test Declarations & Test Cases

This document provides a complete reference to the GoogleTest API for declaring and organizing test cases. It details how to use the primary macros to define tests, how to create and leverage test fixtures, and how to utilize value- and type-parameterization to build scalable and maintainable test suites.

All GoogleTest tests start with including the header:

```cpp
#include <gtest/gtest.h>
```

---

## Defining Simple Tests with `TEST()`

The core mechanism to declare a test is the `TEST` macro.

### Syntax

```cpp
TEST(TestSuiteName, TestName) {
  ... // test code and assertions
}
```

- **`TestSuiteName`**: identifier grouping related tests.
- **`TestName`**: unique test name within the suite.

*Both identifiers must be valid C++ identifiers without underscores.*

### Behavior

- Each `TEST` defines one independent test.
- Tests in the same test suite logically group related tests.
- Tests can contain any C++ code.
- Test outcomes are determined by assertions.

### Example

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
}
```

### Best Practices

- Group logically related tests in the same test suite.
- Use descriptive test suite and test names.
- Avoid underscores in test names to adhere to naming conventions.

<Check>
Remember: Tests from different test suites can share the same test names without conflict.
</Check>

---

## Using Test Fixtures with `TEST_F()` to Share Setup

When multiple tests share a common test class or require setup/teardown, use test fixtures.

### Defining a Fixture

Create a class inheriting from `testing::Test`:

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override {
    // Code here runs before each test.
  }

  void TearDown() override {
    // Code here runs after each test.
  }

  // Shared data members
};
```

### Using the Fixture

Define tests with `TEST_F()` macro:

```cpp
TEST_F(MyFixture, Test1) {
  // Access fixture data members
  EXPECT_TRUE(...);
}

TEST_F(MyFixture, Test2) {
  // Each test gets a fresh fixture instance.
}
```

### Notes

- The first argument to `TEST_F` must match the fixture class name exactly.
- Each test runs with a separate fixture instance.
- You can override the fixture's `SetUp()` and `TearDown()` to prepare/cleanup test state.

### Example

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Elements can be pushed in constructor
    q1_.Enqueue(1);
  }

  Queue<int> q0_;
  Queue<int> q1_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueReturnsCorrectElement) {
  int* val = q1_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, 1);
  delete val;
}
```

<Check>
Do not reuse the same fixture instance for multiple tests â€” GoogleTest creates a fresh fixture for each test.
</Check>

---

## Value-Parameterized Tests with `TEST_P()` and `INSTANTIATE_TEST_SUITE_P()`

For tests that need to run the same logic with multiple input values, use value-parameterized tests.

### Define the Test Suite and Test

A value-parameterized test inherits from `TestWithParam<T>`:

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // You can add helpers or data members here
};

TEST_P(MyParamTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(SomeFunction(param));
}
```

- Use `GetParam()` to access the current test parameter.

### Instantiate the Test Suite

Use `INSTANTIATE_TEST_SUITE_P()` to generate tests for a list of parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
  RangeTests,
  MyParamTest,
  testing::Range(1, 5)  // parameters 1, 2, 3, 4
);
```

### Parameter Generators

GoogleTest offers a variety of parameter generators:

| Generator | Description |
|-----------|-------------|
| `Range(begin, end [, step])` | Generates values from `begin` to `end` (exclusive) with optional `step` (default 1).
| `Values(v1, v2, ..., vN)` | Enumerates exact values.
| `ValuesIn(container_or_range)` | Generates from a container or iterator range.
| `Bool()` | Generates `false` and `true`.
| `Combine(g1, g2, ..., gN)` | Combines multiple generators as tuples (Cartesian product).
| `ConvertGenerator<T>(g)` | Converts generated values to type `T`.

### Customizing Test Names

You can provide a naming function for parameterized test suffixes:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyParamTest,
    testing::Values(...),
    [](const testing::TestParamInfo<MyParamTest::ParamType>& info) {
      return "CustomName" + std::to_string(info.index);
    });
```

### Example

```cpp
TEST_P(MyTest, ReturnsTrueForPositiveParams) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, MyTest,
    testing::Values(1, 2, 3, 5, 8));
```

<Info>
Remember to place your fixture class and test definitions in the proper order before instantiation.
</Info>

---

## Typed Tests with `TYPED_TEST_SUITE()` and `TYPED_TEST()`

Typed tests let you run the same test logic on multiple types.

### Defining a Typed Fixture

Create a class template inheriting from `testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 protected:
  T value_;
};
```

### Registering the Type List

Use `TYPED_TEST_SUITE` to specify the list of types:

```cpp
using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Defining Typed Tests

Parametrize using the `TypeParam` alias:

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value_;
  // Test code using val
}
```

### Example

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_;
};

using MyTypes = ::testing::Types<int, float>;
TYPED_TEST_SUITE(MyFixture, MyTypes);

TYPED_TEST(MyFixture, DefaultInitialized) {
  EXPECT_EQ(TypeParam(), this->value_);
}
```

---

## Type-Parameterized Tests with `TYPED_TEST_SUITE_P()`, `TYPED_TEST_P()`, and Registration

Enables value-agnostic typed tests.

### Defining the Test Suite

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyTypeParamTest);
```

### Defining Type-Parameterized Tests

```cpp
TYPED_TEST_P(MyTypeParamTest, TestA) {
  TypeParam value = ...;
  EXPECT_EQ(..., value);
}

TYPED_TEST_P(MyTypeParamTest, TestB) {
  // ...
}
```

### Registering Test Names

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestA, TestB);
```

### Instantiating with Types

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```

---

## Friend Test Declaration

Use `FRIEND_TEST()` macro inside a class to allow a test access to its private members:

```cpp
class MyClass {
  FRIEND_TEST(MyClassTest, FeatureTest);
 private:
  int secret_;
};
```

Tests must be in the same namespace and have the matching fixture class.

---

## Adding Scoped Trace Information with `SCOPED_TRACE()`

Wrap test code with `SCOPED_TRACE(message)` to add contextual information to failure messages:

```cpp
SCOPED_TRACE("Tracking variable x");
EXPECT_EQ(x, 3);
```

This appends the message and source location to all assertions within the scope.

---

## Skipping Tests at Runtime with `GTEST_SKIP()`

Use `GTEST_SKIP()` in test code or setup to skip test execution:

```cpp
TEST(MyTestSuite, SomeTest) {
  if (!IsFeatureAvailable()) {
    GTEST_SKIP() << "Feature not supported";
  }
  // Rest of the test
}
```

Skips gracefully and reports test as skipped.

---

## Summary

GoogleTest's test declaration API empowers you to organize your tests via:

- `TEST()` for simple isolated tests.
- `TEST_F()` for tests sharing fixtures and common setup.
- `TEST_P()` and `INSTANTIATE_TEST_SUITE_P()` for value-parameterized tests.
- `TYPED_TEST_SUITE()`, `TYPED_TEST()` for typed tests on multiple types.
- `TYPED_TEST_SUITE_P()`, `TYPED_TEST_P()`, and registration for flexible type-parameterized tests.
- Utility macros like `FRIEND_TEST`, `SCOPED_TRACE`, and `GTEST_SKIP` for advanced control.

Make sure to place your test declarations properly, follow naming conventions, and use the features progressively to create maintainable, scalable, and clear test suites.

---

## Additional Resources

* See [GoogleTest Primer](../primer.md) for comprehensive beginners' guidance.
* Explore [Parameterized Tests](../advanced.md#value-parameterized-tests) for advanced parameterization.
* Consult the [Assertions Reference](../reference/assertions.md) for assertion details.
* For test fixtures and advanced patterns, refer to [Real-World Practices](../guides/real-world-practices/maintainable-test-suites.mdx).

---

## Diagram: Test Life Cycle Overview

```mermaid
flowchart TD
  A[Define Tests with `TEST()` / `TEST_F()`]
  B[Run `main()` calls `RUN_ALL_TESTS()`]
  C[GoogleTest Discovers All Tests]
  D[Executes Each Test Separately]
  E[Each Test Creates Fixture (if any)]
  F[Calls `SetUp()` and Runs Test Body]
  G[Runs Assertions and Records Results]
  H[Calls `TearDown()` and Destroys Fixture]
  I[Aggregates and Reports Test Results]
  J[Ends with Pass / Fail Exit Code]

  A --> C
  B --> C
  C --> D
  D --> E
  E --> F
  F --> G
  G --> H
  H --> D
  D --> I
  I --> J
```

This flow guides you from writing tests to execution and reporting.

---

# Code Example: Full Minimal Test Program

```cpp
#include <gtest/gtest.h>

// Simple test with TEST macro
TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}

// Test fixture
class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    q_.Enqueue(1);
  }

  Queue<int> q_;
};

TEST_F(QueueTest, DequeueReturnsSameValue) {
  int* val = q_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, 1);
  delete val;
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

# Practical Tips and Best Practices

- **Prefer `TEST_F` over `TEST` when multiple tests share common data or setup.**
- **Avoid underscores in test suite and test names for consistency.**
- **Use parameterized tests (`TEST_P`) for repetitive tests differing only by inputs.**
- **Leverage typed tests to verify template classes or methods for various types.**
- **Use `SCOPED_TRACE()` to add clarity when debugging complex assertions in loops.**
- **Use `GTEST_SKIP()` to gracefully bypass unsupported or irrelevant scenarios at runtime.**
- **Group expectations, setup, and test logic clearly to enhance readability and maintainability.**

---

# Troubleshooting Common Issues

- **Test not running?** Verify `TEST` or `TEST_F` macros' correctness; names must be valid identifiers.
- **Fixture setup/teardown not called?** Ensure `SetUp()` and `TearDown()` are overridden with proper signature and `override` keyword.
- **Skipping tests unexpectedly?** Check use of `GTEST_SKIP()` or test filters.
- **Parameterization problems?** Confirm correct use of `INSTANTIATE_TEST_SUITE_P` and that parameter types match fixture.

---