---
title: "Core Assertions"
description: "Documents macros and functions for verifying expected behaviors—such as equality, inequality, string matching, and exception handling—in tests. Provides guidance on when to use fatal (ASSERT_*) versus non-fatal (EXPECT_*) assertions."
---

# Core Assertions

GoogleTest provides a rich collection of macros and functions for verifying expected behaviors in your tests. This page specifically documents the core assertions available to validate equality, inequality, string content, exception throwing, and more, while also guiding you on when to choose fatal (`ASSERT_`) versus non-fatal (`EXPECT_`) assertion variants.

---

## Understanding Fatal vs. Non-Fatal Assertions

GoogleTest assertion macros come in **pairs**:

- `EXPECT_*` macros generate **non-fatal failures**, allowing the test function to continue running and report multiple failures in one run.
- `ASSERT_*` macros generate **fatal failures**, immediately aborting the current function to avoid running further code that would make no sense after this failure.


> **When to use which?** Use `EXPECT_*` when you want to verify conditions but still gather multiple failures in a single test run. Use `ASSERT_*` if continuing after failure could cause undefined behavior, crashes, or misleading results.


### Example Use Case

```cpp
TEST(VectorTest, ElementsAreEqual) {
  std::vector<int> v = {1, 2, 3};

  ASSERT_EQ(v.size(), 3) << "Size mismatch - cannot compare elements.";
  EXPECT_EQ(v[0], 1) << "Element 0 mismatch.";
  EXPECT_EQ(v[1], 2) << "Element 1 mismatch.";
  EXPECT_EQ(v[2], 3) << "Element 2 mismatch.";
}
```

Here, the test aborts early if a size mismatch occurs (using `ASSERT_EQ`), but continues to check element values, collecting multiple failures.

---

## Explicit Success and Failure

Sometimes, your logic dictates success or failure without an expression to check.

### `SUCCEED()`

- **Purpose:** Generates a success (useful for documenting that certain code paths are expected to reach a success state).
- **Note:** Does *not* make the entire test succeed if previous assertions have failed; it is purely informative.

**Example:**
```cpp
switch (value) {
  case 42:
    SUCCEED() << "Value 42 is valid.";
    break;
  default:
    FAIL() << "Unexpected value: " << value;
}
```

### `FAIL()`

- **Purpose:** Generates a fatal failure immediately, aborting the current function.
- **Constraint:** Only usable in functions returning `void` (e.g., test bodies).

**Example:**
```cpp
if (!condition_met) {
  FAIL() << "Required condition not met.";
  // Code past this point will not run
}
```

### `ADD_FAILURE()`

- **Purpose:** Generates a non-fatal failure, allowing test continuation.
- **Use Case:** When you want to report an error that doesn’t need to abort the test.

---

## Boolean Condition Assertions

You can verify boolean expressions or predicates with these:

| Assertion            | Checks if...                      |
|----------------------|---------------------------------|
| `EXPECT_TRUE(cond)`   | `cond` is `true`                |
| `ASSERT_TRUE(cond)`   | `cond` is `true`; aborts on failure |
| `EXPECT_FALSE(cond)`  | `cond` is `false`                |
| `ASSERT_FALSE(cond)`  | `cond` is `false`; aborts on failure |

**Important:** These can also be used with predicates returning `AssertionResult` for richer messages (see [Advanced Topics](../advanced.md#predicate-assertions)).

### Example

```cpp
EXPECT_TRUE(user.IsValid()) << "User should be valid.";
ASSERT_FALSE(container.empty()) << "Container must not be empty";
```

---

## Binary Comparison Assertions

These macros verify relational conditions between two values.

| Macro Pair          | Meaning                          |
|---------------------|---------------------------------|
| `EXPECT_EQ(a, b)`   | `a == b`                        |
| `ASSERT_EQ(a, b)`   | `a == b`; abort on failure      |
| `EXPECT_NE(a, b)`   | `a != b`                        |
| `ASSERT_NE(a, b)`   | `a != b`; abort on failure      |
| `EXPECT_LT(a, b)`   | `a < b`                         |
| `ASSERT_LT(a, b)`   | `a < b`; abort on failure       |
| `EXPECT_LE(a, b)`   | `a <= b`                        |
| `ASSERT_LE(a, b)`   | `a <= b`; abort on failure      |
| `EXPECT_GT(a, b)`   | `a > b`                         |
| `ASSERT_GT(a, b)`   | `a > b`; abort on failure       |
| `EXPECT_GE(a, b)`   | `a >= b`                        |
| `ASSERT_GE(a, b)`   | `a >= b`; abort on failure      |

**Note:**

- Pointer comparisons compare pointer addresses, **not values pointed to**.
- For C strings (`const char*`), `EXPECT_EQ` compares pointer equality, **not content**; use [`EXPECT_STREQ`](#string-comparison) to check content equality.
- Arguments are evaluated **exactly once** to avoid side effects.

### Example

```cpp
EXPECT_EQ(result, expected) << "Result differs from expected value.";
ASSERT_LT(index, container.size()) << "Index out of range.";
```

---

## String Comparison Assertions

Compare **C strings** (null-terminated `const char*` and wide strings `const wchar_t*`) by content.

| Macro                 | Checks that...                                     |
|-----------------------|--------------------------------------------------|
| `EXPECT_STREQ(s1, s2)` | `s1` and `s2` have **identical contents**         |
| `ASSERT_STREQ(s1, s2)` | `s1` and `s2` have **identical contents**; abort on failure |
| `EXPECT_STRNE(s1, s2)` | `s1` and `s2` have **different contents**          |
| `ASSERT_STRNE(s1, s2)` | `s1` and `s2` have **different contents**; abort on failure |
| `EXPECT_STRCASEEQ(s1, s2)` | `s1` and `s2` have identical contents ignoring case |
| `ASSERT_STRCASEEQ(s1, s2)` | `s1` and `s2` have identical contents ignoring case; abort on failure |
| `EXPECT_STRCASENE(s1, s2)` | `s1` and `s2` differ ignoring case               |
| `ASSERT_STRCASENE(s1, s2)` | `s1` and `s2` differ ignoring case; abort on failure |

These macros accept both narrow and wide strings. They also gracefully handle `nullptr`.

### Example

```cpp
EXPECT_STREQ(expected_cstr, actual_cstr) << "Strings differ.";
ASSERT_STRCASEEQ("hello", input) << "Input must be 'hello' ignoring case.";
```

---

## Floating-Point Comparison Assertions

Floating-point values should **not** be compared with simple equality due to rounding errors. GoogleTest provides approximate comparisons:

| Macro                    | Verifies that...                                        |
|--------------------------|---------------------------------------------------------|
| `EXPECT_FLOAT_EQ(a, b)`  | `a` and `b` of type `float` are almost equal (within 4 ULPs) |
| `ASSERT_FLOAT_EQ(a, b)`  | fatal version of above                                    |
| `EXPECT_DOUBLE_EQ(a, b)` | `a` and `b` of type `double` are almost equal            |
| `ASSERT_DOUBLE_EQ(a, b)` | fatal version of above                                    |
| `EXPECT_NEAR(a, b, error)` | `a` and `b` differ by no more than `error` (absolute difference) |
| `ASSERT_NEAR(a, b, error)` | fatal version of above                                   |

### Notes

- Special values like infinity are supported correctly.
- Use `EXPECT_NEAR` when you have a domain-specific absolute error margin.

### Example

```cpp
EXPECT_FLOAT_EQ(computed_value, 3.14f) << "Wrong approximation.";
ASSERT_NEAR(computed_value, 3.14, 0.01) << "Value out of tolerance.";
```

---

## Exception Assertions (requires exceptions enabled)

Verify that pieces of code throw or do not throw exceptions.

| Macro                  | Verifies that...                                   |
|------------------------|--------------------------------------------------|
| `EXPECT_THROW(stmt, ex)`   | `stmt` throws an exception of type `ex`              |
| `ASSERT_THROW(stmt, ex)`   | fatal version of above                               |
| `EXPECT_ANY_THROW(stmt)`   | `stmt` throws any exception                          |
| `ASSERT_ANY_THROW(stmt)`   | fatal version of above                               |
| `EXPECT_NO_THROW(stmt)`    | `stmt` does not throw any exceptions                 |
| `ASSERT_NO_THROW(stmt)`    | fatal version of above                               |

### Usage Example

```cpp
EXPECT_THROW(DoSomething(), std::runtime_error);
ASSERT_NO_THROW(SafeOperation());
```

You can use compound statements in the form:

```cpp
EXPECT_NO_THROW({
  int x = Compute();
  UseResult(x);
});
```

---

## Predicate Assertions

Use predicate assertions if you want to assert complex conditions with detailed messages. These macros invoke your predicate (a function or functor) and show argument values on failure.

| Macro family                            | Usage                                                        |
|---------------------------------------|--------------------------------------------------------------|
| `EXPECT_PRED1(pred, val1)` to `EXPECT_PRED5` | Calls `pred(val1, ...)` and expects to return `true`          |
| `ASSERT_PRED1` to `ASSERT_PRED5`      | fatal versions of above                                       |
| `EXPECT_PRED_FORMAT1(predFmt, val1)` to `EXPECT_PRED_FORMAT5` | Uses a predicate-formatter with detailed failure messages     |
| `ASSERT_PRED_FORMAT1` to `ASSERT_PRED_FORMAT5` | fatal variants                                               |

### Predicate vs Predicate-Formatter

- A **predicate** returns `bool`. Failure prints only the arguments.
- A **predicate-formatter** returns `AssertionResult` which can describe why it failed (recommended for clearer messages).

### Example

```cpp
bool IsEven(int n) { return (n % 2) == 0; }
...
EXPECT_PRED1(IsEven, 4); // Succeeds
EXPECT_PRED1(IsEven, 3); // Fails; prints argument
```

Using predicate-formatter for better messages:

```cpp
AssertionResult IsEvenFmt(const char* expr, int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << expr << " evaluates to " << n << ", which is not even.";
}
...
EXPECT_PRED_FORMAT1(IsEvenFmt, 3);  // Prints detailed failure
```

---

## Windows HRESULT Assertions (Windows only)

GoogleTest includes assertions for testing Windows `HRESULT` values.

| Macro                       | Checks that...                           |
|-----------------------------|----------------------------------------|
| `EXPECT_HRESULT_SUCCEEDED(expr)` | `expr` returns a success HRESULT       |
| `ASSERT_HRESULT_SUCCEEDED(expr)` | fatal version of above                 |
| `EXPECT_HRESULT_FAILED(expr)`    | `expr` returns a failure HRESULT       |
| `ASSERT_HRESULT_FAILED(expr)`    | fatal version of above                  |

The failure messages include the hexadecimal error code and a human-readable error string (if available).

### Example

```cpp
CComPtr<IShellDispatch> shell;
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
```

---

## Death Assertions

Used to verify that code crashes or causes process termination in an expected way.

These spawn a child process and verify that the child terminates with the expected signal, exit code, or diagnostic message.

| Macro                   | Checks that...                                               |
|-------------------------|-------------------------------------------------------------|
| `EXPECT_DEATH(statement, matcher)` | `statement` causes the process to die; `stderr` matches `matcher` |
| `ASSERT_DEATH`           | Fatal version of above                                       |
| `EXPECT_DEATH_IF_SUPPORTED` | Same as `EXPECT_DEATH` if supported, else no check          |
| `ASSERT_DEATH_IF_SUPPORTED` | Fatal variant                                               |
| `EXPECT_DEBUG_DEATH`     | Checks in debug mode only                                    |
| `ASSERT_DEBUG_DEATH`     | Fatal variant                                               |
| `EXPECT_EXIT(statement, predicate, matcher)` | `statement` causes the process to terminate with exit status matching `predicate` and `stderr` matching `matcher` |
| `ASSERT_EXIT`            | Fatal variant                                               |

`predicate` can be a function or functor, e.g.: 

```cpp
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
```

### When to Use

Death tests are crucial for validating abort conditions and program termination behavior where exceptions are not used.

---

## Best Practices and Tips

- Prefer non-fatal `EXPECT_*` assertions to reveal multiple failures in one test unless premature termination makes results unreliable.
- Use `ASSERT_*` when failure invalidates subsequent test logic (e.g., null pointers, size checks).
- Always stream clear and informative failure messages to assertions with `<<` for quick debugging.
- For complex assertions, use predicate-format assertions to produce better diagnostics.
- Use `EXPECT_STREQ`/`EXPECT_STRNE` for C strings instead of `EXPECT_EQ`.
- Use floating-point comparison macros instead of `EXPECT_EQ`.
- Avoid placing fatal assertions in non-void returning functions or constructors; use alternatives or restructure code.

---

## Troubleshooting Common Issues

- **Failure messages lack context:** Use predicate-format assertions for detailed failure strings.
- **Unexpected continued test execution after fatal assertion:** Understand that `ASSERT_*` aborts only the current function.
- **String comparison failures:** Verify use of correct macros (`EXPECT_STREQ` instead of `EXPECT_EQ` for strings).
- **Comparisons with pointers behave oddly:** Confirm you are comparing values, not pointer addresses.

---

## Related Documentation

- [Advanced GoogleTest Topics - Assertions](../advanced.md#more-assertions)
- [Assertions Reference](reference/assertions.md)
- [Writing Your First Test](../guides/getting-started/writing-your-first-test.md)
- [Understanding Assertions and Test Results](../guides/getting-started/common-assertions.md)
- [Death Tests and Specialized Assertions](../api-reference/assertions-matchers/specialized-assertions.md)
- [Matchers Reference (for EXPECT_THAT)](../api-reference/assertions-matchers/expressive-matchers.md)

---

## Summary

This page provides comprehensive guidance and reference for GoogleTest's core assertion macros crucial for verifying the correctness of C++ code in tests. It covers boolean assertions, value comparisons, string and floating-point comparisons, exception handling, predicate and predicate-format assertions, Windows HRESULT checks, and death tests, explaining their usage, differences between fatal and non-fatal types, and best practices.

---