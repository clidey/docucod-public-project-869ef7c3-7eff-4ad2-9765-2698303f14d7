---
title: "Assertions and Expectations"
description: "Exhaustive catalog of all core and extended assertion macros, including equality, comparison, exception, and fatal/non-fatal variants. Provides guidance on choosing assertions, controlling failure behavior, and crafting expressive test diagnostics."
---

# Assertions and Expectations

This page provides an exhaustive catalog and guide to the assertion macros available in GoogleTest, designed to help you validate your code's behavior with clarity and precision. You will find detailed explanations of each assertion type, their behavior (fatal vs nonfatal), usage patterns, and practical examples for real-world scenarios.

## Understanding Assertions in GoogleTest

At the heart of your testing strategy are assertions — statements that test whether a condition holds true. GoogleTest provides two variants for most assertions:

- `EXPECT_*`: Generates a nonfatal failure and allows the current test function to continue running.
- `ASSERT_*`: Generates a fatal failure and immediately aborts the current test function.

Use `EXPECT_*` when you want to check multiple conditions and see all failures at once. Use `ASSERT_*` when continuing after a failure does not make sense or may cause cascading errors.

All assertion macros support streaming user-defined failure messages using the `<<` operator to make your diagnostics richer and clearer.

```cpp
EXPECT_TRUE(condition) << "Custom failure message if condition is false.";
```

---

## Explicit Success and Failure Assertions

Sometimes, you need to explicitly indicate success or failure based on control flow rather than an evaluated Boolean expression.

### SUCCEED

```cpp
SUCCEED();
```

- Generates a success record.
- Does **not** make the entire test succeed if there are previous failures.
- Mainly used for documentation or future-proofing test output.


### FAIL

```cpp
FAIL();
```

- Generates a fatal failure, aborting the current function.
- Only callable in `void` functions.


### ADD_FAILURE

```cpp
ADD_FAILURE();
```

- Generates a nonfatal failure but allows the test to continue.


### ADD_FAILURE_AT

```cpp
ADD_FAILURE_AT("file_path", line_number);
```

- Generates a nonfatal failure at a specific file and line number.

<Info>
Use these explicit macros to handle cases where failures or successes are decided outside typical Boolean checks, such as switch-case default paths.
</Info>

---

## Generalized Assertions with Matchers

GoogleTest lets you combine assertions with [gMock matchers](matchers.md) to write expressive checks.

### EXPECT_THAT and ASSERT_THAT

```cpp
EXPECT_THAT(value, matcher);
ASSERT_THAT(value, matcher);
```

- Verify that `value` satisfies the provided matcher.
- Produce clear failure messages that describe which condition was not met.

Example:

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(str, StartsWith("Hello"));
EXPECT_THAT(str2, MatchesRegex("Line \\d+"));
ASSERT_THAT(num, AllOf(Gt(5), Lt(10)));
```

<Note>
Matchers enhance readability and produce detailed expectations, making your tests easier to maintain.
</Note>

---

## Boolean Assertions

Verify simple true/false conditions.

### EXPECT_TRUE / ASSERT_TRUE

```cpp
EXPECT_TRUE(condition);
ASSERT_TRUE(condition);
```

- Check that `condition` evaluates to true.

### EXPECT_FALSE / ASSERT_FALSE

```cpp
EXPECT_FALSE(condition);
ASSERT_FALSE(condition);
```

- Check that `condition` evaluates to false.

<Info>
Prefer using these over complex Boolean expressions for clarity and better diagnostics.
</Info>

---

## Binary Comparisons

Compare two values with various relational operators. Arguments must be comparable.

> Note: These macros evaluate their arguments exactly once, allowing safe usage with expressions with side effects.

### Equality

#### EXPECT_EQ / ASSERT_EQ

```cpp
EXPECT_EQ(val1, val2);
ASSERT_EQ(val1, val2);
```

- Verifies `val1 == val2`.
- For pointers, compares addresses; for C strings use `EXPECT_STREQ`.

#### EXPECT_NE / ASSERT_NE

```cpp
EXPECT_NE(val1, val2);
ASSERT_NE(val1, val2);
```

- Verifies `val1 != val2`.

### Inequality

- `<`: `EXPECT_LT` / `ASSERT_LT`
- `<=`: `EXPECT_LE` / `ASSERT_LE`
- `>`: `EXPECT_GT` / `ASSERT_GT`
- `>=`: `EXPECT_GE` / `ASSERT_GE`

Example:

```cpp
EXPECT_LT(value, threshold) << "Value exceeds threshold";
```

---

## String Comparisons

For C strings (`const char*` or `wchar_t*`), which compare pointers by default, use special macros to compare contents.

### EXPECT_STREQ / ASSERT_STREQ

```cpp
EXPECT_STREQ(str1, str2);
ASSERT_STREQ(str1, str2);
```

- Checks if two C strings have equal contents.

### EXPECT_STRNE / ASSERT_STRNE

```cpp
EXPECT_STRNE(str1, str2);
ASSERT_STRNE(str1, str2);
```

- Checks if two C strings have different contents.

### EXPECT_STRCASEEQ / ASSERT_STRCASEEQ

```cpp
EXPECT_STRCASEEQ(str1, str2);
ASSERT_STRCASEEQ(str1, str2);
```

- Case-insensitive equality check.

### EXPECT_STRCASENE / ASSERT_STRCASENE

```cpp
EXPECT_STRCASENE(str1, str2);
ASSERT_STRCASENE(str1, str2);
```

- Case-insensitive inequality check.

<Warning>
When comparing wide strings, `wchar_t*` is converted to UTF-8 UTF-8 encoding when printing failure messages.
</Warning>

---

## Floating-Point Comparisons

Due to precision issues with floating-point numbers, use dedicated macros.

### EXPECT_FLOAT_EQ / ASSERT_FLOAT_EQ

```cpp
EXPECT_FLOAT_EQ(val1, val2);
ASSERT_FLOAT_EQ(val1, val2);
```

- Checks approximate equality of `float` values within 4 Units in the Last Place (ULPs).

### EXPECT_DOUBLE_EQ / ASSERT_DOUBLE_EQ

```cpp
EXPECT_DOUBLE_EQ(val1, val2);
ASSERT_DOUBLE_EQ(val1, val2);
```

- Checks approximate equality of `double` values within 4 ULPs.

### EXPECT_NEAR / ASSERT_NEAR

```cpp
EXPECT_NEAR(val1, val2, abs_error);
ASSERT_NEAR(val1, val2, abs_error);
```

- Checks that difference between `val1` and `val2` is within `abs_error`.
- Correctly handles infinite values.

---

## Exception Assertions

Verify that code throws or does not throw exceptions. Requires exceptions enabled in build.

### EXPECT_THROW / ASSERT_THROW

```cpp
EXPECT_THROW(statement, exception_type);
ASSERT_THROW(statement, exception_type);
```

- Verifies `statement` throws the specified exception.

### EXPECT_ANY_THROW / ASSERT_ANY_THROW

```cpp
EXPECT_ANY_THROW(statement);
ASSERT_ANY_THROW(statement);
```

- Verifies `statement` throws an exception of any type.

### EXPECT_NO_THROW / ASSERT_NO_THROW

```cpp
EXPECT_NO_THROW(statement);
ASSERT_NO_THROW(statement);
```

- Verifies `statement` does not throw any exception.

<Warning>
You can test compound statements by wrapping them in braces `{ ... }`.
</Warning>

---

## Predicate Assertions

Use predicate assertions to verify complex logic with better failure messages than raw `EXPECT_TRUE`.

### EXPECT_PRED* / ASSERT_PRED*

```cpp
EXPECT_PRED2(pred, val1, val2);
ASSERT_PRED3(pred, val1, val2, val3);
```

- `pred` is a function or functor returning `bool`.
- Each macro supports from 1 to 5 parameters.
- Failure messages show the values of each argument.

Example:

```cpp
bool IsMutuallyPrime(int m, int n) { ... }
EXPECT_PRED2(IsMutuallyPrime, 3, 4);  // Succeeds
EXPECT_PRED2(IsMutuallyPrime, 4, 10); // Fails and shows arguments
```

### EXPECT_PRED_FORMAT* / ASSERT_PRED_FORMAT*

```cpp
EXPECT_PRED_FORMAT2(pred_formatter, val1, val2);
```

- Allows full custom formatting of the failure message.
- `pred_formatter` is a callable returning `testing::AssertionResult`.
- Use when you want detailed or custom assertion diagnostics.

Example:

```cpp
testing::AssertionResult AssertMutuallyPrime(const char* m_expr,
                                             const char* n_expr,
                                             int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << m_expr << " and " << n_expr
         << " are not mutually prime.";
}

EXPECT_PRED_FORMAT2(AssertMutuallyPrime, 4, 10);  // Shows detailed failure message
```

---

## Windows HRESULT Assertions

Check success or failure status returned by Windows COM methods.

### EXPECT_HRESULT_SUCCEEDED / ASSERT_HRESULT_SUCCEEDED

```cpp
EXPECT_HRESULT_SUCCEEDED(expression);
ASSERT_HRESULT_SUCCEEDED(expression);
```

- Verifies that the HRESULT indicates success.

### EXPECT_HRESULT_FAILED / ASSERT_HRESULT_FAILED

```cpp
EXPECT_HRESULT_FAILED(expression);
ASSERT_HRESULT_FAILED(expression);
```

- Verifies that the HRESULT indicates failure.

<Info>
Failure messages show both the HRESULT code and a human-readable error string.
</Info>

---

## Death Assertions

Validate that your code causes the process to terminate under certain conditions.

### EXPECT_DEATH / ASSERT_DEATH

```cpp
EXPECT_DEATH(statement, matcher);
ASSERT_DEATH(statement, matcher);
```

- Checks that `statement` terminates the process with a nonzero exit status.
- `matcher` is a regex or a gMock string matcher that matches the `stderr` output.

Example:

```cpp
ASSERT_DEATH({ int n = 5; Foo(&n); }, "Error on line .* of Foo()");
```

### EXPECT_DEATH_IF_SUPPORTED / ASSERT_DEATH_IF_SUPPORTED

- Like `EXPECT_DEATH` / `ASSERT_DEATH` but passes silently if death tests are unsupported on your platform.

### EXPECT_DEBUG_DEATH / ASSERT_DEBUG_DEATH

- Performs death test only in debug mode; in release mode, just executes `statement`.

### EXPECT_EXIT / ASSERT_EXIT

```cpp
EXPECT_EXIT(statement, predicate, matcher);
ASSERT_EXIT(statement, predicate, matcher);
```

- Verifies `statement` terminates with exit status satisfying `predicate`.
- Checks `stderr` output matches `matcher`.
- `predicate` can be:
  - `::testing::ExitedWithCode(int exit_code)`
  - `::testing::KilledBySignal(int signal_number)` (POSIX only)

---

## Practical Tips & Best Practices

- Use `EXPECT_*` assertions when you want to proceed after failure to discover multiple issues in one test.
- Use `ASSERT_*` assertions to prevent executing code that depends on previous successful assertions.
- Prefer streaming custom failure messages for clarity and debugging ease.
- For floating-point comparisons, favor `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` over naïve equality.
- Use `EXPECT_THAT` with matchers for expressive, readable assertions.
- When testing exception throwing behavior, use `EXPECT_THROW`, `EXPECT_NO_THROW`, and related macros only if exceptions are enabled in your build.
- For validating death behavior, ensure your statements are safe to execute in isolated processes and be cautious about side effects.
- Use predicate assertions (`EXPECT_PRED*`) to capture complex conditions while receiving detailed diagnostics automatically.

---

## Troubleshooting Common Issues

<Warning>
- Using `ASSERT_*` macros inside non-void functions or constructors results in confusing compile errors; refactor or use `EXPECT_*` instead.
- Be aware that failed `ASSERT_*` macros abort only the current function, not the entire test. Use `ASSERT_NO_FATAL_FAILURE()` or exceptions to propagate failures.
- Fragile tests relying on pointer equality should use string comparison macros if comparing strings.
- Death tests should be named carefully (test suite should end with "DeathTest") to ensure correct execution order and behavior.
</Warning>

---

## Complete List of Assertion Macros

### Success and Failure
- `SUCCEED()`
- `FAIL()`
- `ADD_FAILURE()`
- `ADD_FAILURE_AT(file, line)`

### Boolean
- `EXPECT_TRUE(condition) / ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition) / ASSERT_FALSE(condition)`

### Equality and Inequality
- `EXPECT_EQ(val1, val2) / ASSERT_EQ(val1, val2)`
- `EXPECT_NE(val1, val2) / ASSERT_NE(val1, val2)`

### Relational
- `EXPECT_LT(val1, val2) / ASSERT_LT(val1, val2)`
- `EXPECT_LE(val1, val2) / ASSERT_LE(val1, val2)`
- `EXPECT_GT(val1, val2) / ASSERT_GT(val1, val2)`
- `EXPECT_GE(val1, val2) / ASSERT_GE(val1, val2)`

### C String Comparisons
- `EXPECT_STREQ(str1, str2) / ASSERT_STREQ(str1, str2)`
- `EXPECT_STRNE(str1, str2) / ASSERT_STRNE(str1, str2)`
- `EXPECT_STRCASEEQ(str1, str2) / ASSERT_STRCASEEQ(str1, str2)`
- `EXPECT_STRCASENE(str1, str2) / ASSERT_STRCASENE(str1, str2)`

### Floating-Point
- `EXPECT_FLOAT_EQ(val1, val2) / ASSERT_FLOAT_EQ(val1, val2)`
- `EXPECT_DOUBLE_EQ(val1, val2) / ASSERT_DOUBLE_EQ(val1, val2)`
- `EXPECT_NEAR(val1, val2, abs_error) / ASSERT_NEAR(val1, val2, abs_error)`

### Exceptions
- `EXPECT_THROW(statement, exception_type) / ASSERT_THROW(statement, exception_type)`
- `EXPECT_ANY_THROW(statement) / ASSERT_ANY_THROW(statement)`
- `EXPECT_NO_THROW(statement) / ASSERT_NO_THROW(statement)`

### Predicate Assertions
- `EXPECT_PRED*` / `ASSERT_PRED*` (1-5 arguments)
- `EXPECT_PRED_FORMAT*` / `ASSERT_PRED_FORMAT*` (1-5 arguments, custom messages)

### Windows HRESULT
- `EXPECT_HRESULT_SUCCEEDED(expr) / ASSERT_HRESULT_SUCCEEDED(expr)`
- `EXPECT_HRESULT_FAILED(expr) / ASSERT_HRESULT_FAILED(expr)`

### Death Tests
- `EXPECT_DEATH(statement, matcher) / ASSERT_DEATH(statement, matcher)`
- `EXPECT_DEATH_IF_SUPPORTED / ASSERT_DEATH_IF_SUPPORTED`
- `EXPECT_DEBUG_DEATH / ASSERT_DEBUG_DEATH`
- `EXPECT_EXIT(statement, predicate, matcher) / ASSERT_EXIT(statement, predicate, matcher)`

---

## Example: Combining Assertions

```cpp
TEST(FactorialTest, HandlesPositiveInput) {
  int val = Factorial(3);
  ASSERT_GT(val, 0) << "Factorial should be positive";
  EXPECT_EQ(val, 6) << "3! should be 6";
  EXPECT_NE(val, 7);
}
```

This test uses a fatal assertion to guarantee it proceeds only if the factorial is positive, followed by several nonfatal assertions to check equality and inequality.

---

## Related Documentation

- [Matchers Reference](matchers.md): For rich expressive conditions with `EXPECT_THAT` macro.
- [Mocking Reference](mocking.md): Learn combining assertions with mocks.
- [Advanced GoogleTest Topics](advanced.md): Covers predicate assertions and failures handling.
- [GoogleTest Primer](primer.md): For introductory concepts and workflow.

---

Mastering assertions is vital for creating robust, maintainable tests with GoogleTest. This guide equips you with concrete tools and essential practices for writing accurate and informative tests that speed your debugging and improve code quality.
