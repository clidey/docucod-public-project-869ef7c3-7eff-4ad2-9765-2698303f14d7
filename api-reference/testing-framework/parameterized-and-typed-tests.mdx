---
title: "Parameterized and Typed Tests"
description: "API guide for running tests against multiple values or types. Explains usage of parameterized tests, value generators, and type-parameterized tests, with examples of appropriate macros and registration routines for reusable, scalable test coverage."
---

# Parameterized and Typed Tests

GoogleTest empowers you to automate exhaustive testing scenarios by allowing tests to run multiple times against different values or types. This page guides you through parameterized tests that use value-based parameters and typed tests that operate with type parameters, enabling scalable and reusable test coverage.

---

## 1. Value-Parameterized Tests

Value-parameterized tests let you write a test once and run it against a range of input values. This avoids duplicating test logic for similar cases and makes it easy to cover a wide spectrum of scenarios.

### 1.1 Defining a Parameterized Test Fixture

Create a test fixture class derived from `::testing::TestWithParam<T>`, where `T` is the type of your test parameter.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Test fixture setup and helpers, if any
};
```

### 1.2 Writing Parameterized Tests

Use the `TEST_P` macro to define tests that will be run once per parameter value.

```cpp
TEST_P(FooTest, DoesBlah) {
  // Access the current parameter value via GetParam()
  EXPECT_TRUE(foo.DoSomething(GetParam()));
}
```

### 1.3 Instantiating Tests with Parameter Generators

Instantiate your parameterized test suite with desired parameter sets using `INSTANTIATE_TEST_SUITE_P`. The first argument is a unique instantiation name, the second is the test suite (fixture) name, the third is a parameter generator, and optionally the fourth is a custom test name generator.

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, FooTest,
                         ::testing::Values("meeny", "miny", "moe"));
```

#### Parameter Generator Functions

GoogleTest includes several convenient functions to generate parameters:

| Generator            | Description                                                                                |
|---------------------|--------------------------------------------------------------------------------------------|
| `Range(begin, end [, step])` | Produces a sequence `{begin, begin+step, ...}` excluding `end`. Default `step` is 1. |
| `Values(v1, v2, ..., vN)`      | Supplies explicit values `{v1, v2, ..., vN}`.                                            |
| `ValuesIn(container)`          | Generates from elements in a C-style array, STL container, or iterator range `[begin, end)`. |
| `Bool()`                      | Yields `{false, true}` for boolean testing.                                              |
| `Combine(g1, g2, ..., gN)`    | Cartesian product of values generated by multiple generators, producing `std::tuple`s.  |
| `ConvertGenerator<T>(g)`      | Converts generated values from one type to another via static cast or user-defined callable. |

### 1.4 Customizing Test Names

You can optionally customize the suffixes of instantiated test names by supplying a name generator functor or lambda:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### 1.5 Example Workflow

1. Define a parameterized test fixture by subclassing `TestWithParam<T>`.
2. Write tests with `TEST_P` that use `GetParam()` to fetch parameter values.
3. Instantiate tests across value sets using `INSTANTIATE_TEST_SUITE_P` with parameter generators.
4. Optionally provide custom test name suffixes.

#### Resulting Generated Names
For the instantiation:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInst, FooTest, Values("cat", "dog"));
```

The test cases generated will be:

- `MyInst/FooTest.DoesBlah/0` for "cat"
- `MyInst/FooTest.DoesBlah/1` for "dog"

You can filter tests by these names using `--gtest_filter`.

### 1.6 Common Pitfalls and Tips

- Always ensure unique `InstantiationName`s to avoid test name collisions.
- Generators are evaluated at `InitGoogleTest()`, so parameter values can be dynamically configured.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors if a parameterized test is defined but not instantiated.
- When using pointers as parameters, manage the lifespan of the pointed data carefully.

---

## 2. Typed Tests

Typed tests allow you to run the same test logic for multiple _types_ instead of values. This is invaluable for generic data structures or algorithms.

### 2.1 Defining Typed Test Suites

Write a fixture class template parameterized on a type `T`:

```cpp
template <typename T>
class MyContainerTest : public ::testing::Test {
 public:
  T container;
};
```

Define a list of types to test using `::testing::Types<>`:

```cpp
using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
```

Register the typed test suite:

```cpp
TYPED_TEST_SUITE(MyContainerTest, MyTypes);
```

### 2.2 Writing Typed Test Cases

Use `TYPED_TEST` instead of `TEST_F`. Inside the test, refer to the current type as `TypeParam`:

```cpp
TYPED_TEST(MyContainerTest, IsInitiallyEmpty) {
  EXPECT_TRUE(this->container.empty());
  // TypeParam is the container type
  TypeParam new_container;
  EXPECT_EQ(0U, new_container.size());
}
```

### 2.3 Type-Parameterized Tests

Type-parameterized tests enhance typed tests by allowing test definitions independently from the list of types, enabling multiple instantiations of the same pattern.

#### 2.3.1 Define Type-Parameterized Test Suite

```cpp
template <typename T>
class NumericTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(NumericTest);
```

#### 2.3.2 Write Typed Test Patterns

```cpp
TYPED_TEST_P(NumericTest, DefaultIsZero) {
  EXPECT_EQ(0, TypeParam());
}

TYPED_TEST_P(NumericTest, ZeroLessThanOne) {
  EXPECT_LT(TypeParam(0), TypeParam(1));
}
```

#### 2.3.3 Register Tests

```cpp
REGISTER_TYPED_TEST_SUITE_P(NumericTest, DefaultIsZero, ZeroLessThanOne);
```

#### 2.3.4 Instantiate With Types

```cpp
using NumericTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, NumericTest, NumericTypes);
```

### 2.4 Customizing Typed Test Suite Names

You can define a `NameGenerator` class with a static templated method `GetName(int)` that returns a string suffix to describe each type.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyContainerTest, MyTypes, MyTypeNames);
```

### 2.5 Tips for Typed Tests

- All typed test code is instantiated once per type.
- Use typed tests to verify generic code works properly for different template arguments.
- Type names in test reports differentiate each type-instantiated suite.
- For type-parameterized tests, you may define tests once and instantiate multiple times with different type lists across translation units.

---

## 3. Practical Usage Patterns

### 3.1 Combining Value and Type Parameterization

GoogleTest supports running comprehensive test coverage by combining value-parameterized and typed tests through the use of Cartesian products via `Combine` and `ConvertGenerator` for parameter generators.

### 3.2 Managing Test Naming and Avoiding Duplication

- Use meaningful instantiation and suite names.
- Avoid duplicated test names by customizing suffix generators.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` for tests defined but not yet instantiated.

### 3.3 Organizing Tests Across Translation Units

- Parameterized tests can be declared in one source file and instantiated in another.
- Typed tests and type-parameterized tests support multiple instantiations in different translation units, facilitating modular test design.

### 3.4 Troubleshooting Common Issues

- **No tests run:** Check whether tests are instantiated properly.
- **Duplicate test names:** Provide a unique prefix or use a custom name generator.
- **Dangling references in generators:** Beware of passing temporary objects to parameter generators; prefer owning containers.

---

## 4. Summary Mermaid Diagram (Test Flow for Parameterized Instantiation)

```mermaid
flowchart TD
  DefineFixture[Test Fixture Class (derived from TestWithParam<T>)]
  DefineTests[Define TEST_P tests using GetParam()]
  InstantiateTests[Call INSTANTIATE_TEST_SUITE_P with parameter generator]
  GenValues[Parameter Generator produces value sequence]
  RunTests[GoogleTest runs each test instance once per parameter]
  DefineFixture --> DefineTests --> InstantiateTests --> GenValues --> RunTests
```

---

## 5. References and Related Documentation

- [Testing Reference: TEST_P and INSTANTIATE_TEST_SUITE_P](https://github.com/google/googletest/blob/main/docs/reference/testing.md#TEST_P)
- [Typed Tests](https://github.com/google/googletest/blob/main/docs/reference/testing.md#TYPED_TEST)
- [GoogleTest Primer on Parameterized and Typed Tests](../overview/introduction-and-value/what-is-googletest)

---

## Appendix: Code Example - Fully Parameterized Test

```cpp
class MyFooTest : public ::testing::TestWithParam<int> {};

TEST_P(MyFooTest, HandlesMultipleValues) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}

INSTANTIATE_TEST_SUITE_P(
    MyInts, MyFooTest,
    ::testing::Values(1, 2, 3, 5, 8, 13));

// Typed test example

template <typename T>
class ContainerTest : public ::testing::Test {
 public:
  T container;
};

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, EmptyInitially) {
  EXPECT_TRUE(this->container.empty());
}
```

This example illustrates key concepts covered here: defining fixtures, writing parameterized and typed tests, and instantiation.

---

For deep mastery, visit the Parameterized and Typed Tests section in the [GoogleTest Advanced Guide](../guides/practical-testing-patterns/parameterized-testing).
