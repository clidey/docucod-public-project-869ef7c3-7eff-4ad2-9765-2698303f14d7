---
title: "Mock Strictness: Nice, Naggy, and Strict Mocks"
description: "Details the options for handling uninteresting mock calls. Introduces NiceMock, NaggyMock, and StrictMock with use cases, best practices, and practical trade-offs for test maintenance and error detection."
---

# Mock Strictness: Nice, Naggy, and Strict Mocks

Understanding how mock objects handle uninteresting calls—that is, calls to mock methods without explicit expectations—is crucial to maintaining clean, effective tests. GoogleMock offers three distinct mock strictness types to help you control the verbosity and sensitivity of tests regarding such calls: **NiceMock**, **NaggyMock**, and **StrictMock**. This page dives into these options, their behaviors, use cases, and best practices to help you craft maintainable and reliable tests.

---

## Why Mock Strictness Matters

Imagine you’re testing a component that depends on a mock of a collaborator interface. Your mock object has many methods, but your test only cares about verifying a handful of them. What happens when some other methods get called unexpectedly or without explicit expectations?

- If the mock complains loudly on every uninteresting call, test output becomes noisy, slowing development and obscuring real issues.
- If the mock ignores uninteresting calls silently, you might miss bugs caused by unexpected interactions.

GoogleMock’s mock strictness types let you balance between these extremes based on your current testing needs.

---

## Overview of Mock Strictness Types

| Mock Type    | Uninteresting Calls Behavior                        | Typical Use Case                               |
|--------------|----------------------------------------------------|-----------------------------------------------|
| **NiceMock** | Silently ignores uninteresting calls (no warnings) | Stable test suites needing less noise          |
| **NaggyMock**| Warns on uninteresting calls but does not fail test | Default behavior during development and debugging |
| **StrictMock**| Fails the test on any uninteresting call            | Critical tests where unexpected calls signal errors |

### Current Default Behavior

By default, a raw mock object behaves like a **NaggyMock**, warning on uninteresting calls. However, there are plans to change this default to **NiceMock** to promote cleaner tests with less warning noise.

---

## Using NiceMock

**NiceMock** suppresses warnings about uninteresting calls, allowing such method invocations to pass quietly.

### When to Use

- When you want cleaner test output and trust other aspects of your test to ensure correctness.
- For mature tests where uninteresting calls are expected and harmless.

### How to Use

Wrap your mock type with `NiceMock`:

```cpp
using ::testing::NiceMock;

NiceMock<MockClass> nice_mock;
EXPECT_CALL(nice_mock, DoSomething());
// Use nice_mock as usual
```

If your mock class has constructors, you can pass arguments through:

```cpp
NiceMock<MockClass> nice_mock(arg1, arg2);
```

### Important Notes

- `NiceMock<T>` works only for mock methods defined **directly** in `T` using `MOCK_METHOD`. Mock methods inherited from base classes might still generate warnings.
- For proper behavior, the mock class destructor should be virtual.

---

## Using NaggyMock

**NaggyMock** prints warnings whenever uninteresting calls occur but does not cause test failures.

### When to Use

- As the default during test development to catch potential oversights.
- If you want visibility into unexpected calls without interrupting test runs.

### How to Use

```cpp
using ::testing::NaggyMock;

NaggyMock<MockClass> naggy_mock;
EXPECT_CALL(naggy_mock, DoSomething());
// Use naggy_mock as usual
```

Since raw mocks behave like `NaggyMock` by default, explicit use is only necessary for clarity.

### Important Notes

- Like `NiceMock`, `NaggyMock<T>` only affects mock methods defined **directly** in `T`.
- The destructor of `T` should be virtual for consistent behavior.

---

## Using StrictMock

**StrictMock** enforces the strongest discipline: any uninteresting call results in an immediate test failure.

### When to Use

- When you want exhaustive verification of all calls, including those without explicit expectations.
- Critical system tests where ignoring unexpected interactions could hide errors.

### How to Use

```cpp
using ::testing::StrictMock;

StrictMock<MockClass> strict_mock;
EXPECT_CALL(strict_mock, DoSomething());
// Use strict_mock as usual
```

Construction with arguments is supported:

```cpp
StrictMock<MockClass> strict_mock(arg1, arg2);
```

### Important Notes

- Only methods declared directly with `MOCK_METHOD` in `T` are affected.
- Non-virtual destructors in `T` can cause inconsistent behavior.

---

## How to Switch Mock Strictness

You don't modify your existing mock class but wrap it:

```cpp
NiceMock<MockFoo> nice_foo;
NaggyMock<MockFoo> naggy_foo;
StrictMock<MockFoo> strict_foo;
```

Since these wrappers subclass your mock, they can replace it wherever you use `MockFoo`.

---

## Practical Scenarios and Recommendations

### Scenario 1: Developing New Tests

Start with **NaggyMock** to get warnings about likely oversights without failing tests prematurely. This helps detect calls you might have forgotten to expect.

### Scenario 2: Stable, Mature Tests

Switch to **NiceMock** for less cluttered test outputs once you trust the correctness and don't want warnings for benign uninteresting calls.

### Scenario 3: Critical Interaction Contracts

Use **StrictMock** to ensure no unexpected calls occur, catching unexpected dependencies or side effects in complex systems.

### General Recommendation

Avoid mixing different strictness types on the same mock hierarchy. Use the wrappers consistently to get predictable behavior.

---

## Common Pitfalls

- **Expectations Order:** Remember that expectations must be set _before_ exercising the mock. Setting expectations afterward leads to undefined behavior.

- **Base Class Mock Methods:** Wrapping a derived mock with `NiceMock`, `NaggyMock`, or `StrictMock` may not affect methods inherited from a base mock class due to C++ limitations.

- **Destructor Non-Virtual:** Failure to define a virtual destructor in your mock class can compromise strictness modifiers and cleanup behavior.

- **Nested Wrappers Unsupported:** Nesting strictness wrappers (e.g., `NiceMock<StrictMock<MockFoo>>`) is not supported and will cause assertion failures.

---

## Example: Using the StrictMock Wrapper

```cpp
#include <gmock/gmock.h>

class MockFoo {
 public:
  MOCK_METHOD(void, DoSomething, (), ());
};

using ::testing::StrictMock;

TEST(MyTest, StrictMockExample) {
  StrictMock<MockFoo> mock_foo;

  EXPECT_CALL(mock_foo, DoSomething());

  mock_foo.DoSomething();  // Passes

  mock_foo.DoSomething();  // Fails if not expected
}
```

---

## How Strictness Changes Uninteresting Calls Behavior

| Call Type          | Raw Mock / NaggyMock                | NiceMock                    | StrictMock                 |
|--------------------|-----------------------------------|----------------------------|----------------------------|
| **Uninteresting**  | Logs warning but test continues    | Silently ignores            | Test failure               |
| **Unexpected**     | Test failure                      | Test failure                | Test failure               |

---

## Internals and Implementation Notes

For completeness, these wrappers internally register and deregister call reaction behaviors with GoogleMock. They subclass your mock and alter the default behavior for uninteresting calls.

```cpp
NiceMock<T>    // Allows uninteresting calls silently
NaggyMock<T>   // Warns on uninteresting calls
StrictMock<T>  // Errors on uninteresting calls
```

These wrappers inherit constructors from your mock and maintain size to avoid layout changes. Limitations and caveats regarding inheritance, destructors, and compiler behavior apply.

---

## Troubleshooting

- **No Warning or Failures on Uninteresting Calls?**
  - Verify that you are using the wrapper type (`NiceMock`, `NaggyMock`, or `StrictMock`) correctly.
  - Confirm your mock methods are defined directly in your mock class with `MOCK_METHOD`, not inherited.
  - Ensure the mock class destructor is virtual.

- **Unexpected Calls Pass Silently?**
  - Make sure `EXPECT_CALL` is set before exercising the mock.
  - Use `StrictMock` if you want failures on uninteresting calls.

- **Issues With Wrapped Constructor Arguments?**
  - Confirm that constructor argument forwarding matches `MockClass` constructors exactly.

- **Nesting Wrappers Causes Errors?**
  - Avoid nesting mock strictness wrappers; create only one level per mock.

- **Warning Messages Seem Overwhelming?**
  - Consider switching to `NiceMock` to suppress uninteresting call warnings during routine testing.

---

## Related Documentation

- [GoogleMock for Dummies](docs/gmock_for_dummies.md) — Beginner-friendly overview and use cases.
- [Creating and Using Mock Objects](guides/mocking-techniques/creating-mocks.mdx) — How to create mocks effectively.
- [Setting Expectations and Actions](guides/mocking-techniques/expectations-and-actions.mdx) — Detailed usages of `EXPECT_CALL` and `ON_CALL`.
- [Using Matchers](api-reference/core-apis/matchers.mdx) — For designing argument matchers.
- [Defining Custom Actions and Matchers](guides/advanced-and-integration/custom-actions-matchers.mdx) — Extending mock capabilities.
- [Understanding Uninteresting vs Unexpected Calls](guides/mocking-techniques/creating-mocks.mdx#uninteresting-vs-unexpected) — Deeper distinctions.

---

## Summary of Best Practices

- **Start with NaggyMock during development.** It will alert you to unanticipated mock calls.
- **Move to NiceMock for stable tests** where uninteresting calls are expected and fine.
- **Apply StrictMock** only when exact interaction verification is crucial.
- **Never nest strictness wrappers.**
- **Always define virtual destructors** on your mock classes.
- **Always set expectations before exercising mocks.**

---