---
title: "Advanced Matchers for Mocking"
description: "Describes matcher APIs provided specifically for use with mocks, including custom matchers and prebuilt matchers for containers, function arguments, and complex types. Covers matcher extensibility and composition."
---

# Advanced Matchers for Mocking

This page details the specialized matcher APIs designed specifically for use with mocks in GoogleMock. These include both prebuilt matchers aimed at matching containers, function arguments, and complex types, as well as how you can extend and compose custom matchers. This comprehensive overview will empower you to express sophisticated expectations in your mocks, increasing the precision and robustness of your tests.

---

## Understanding the Role of Matchers in Mocks

Matchers are the foundation for specifying which argument values a mock method expects. While basic matchers cover simple value comparisons or wildcards, advanced matchers allow you to express rich conditions about containers, nested data structures, or even combined predicates for complex scenarios.

Matchers do not concern themselves with how the matching is implemented internally but focus solely on evaluating the input against your criteria. When writing tests, your goal is to clearly specify the intent — what argument patterns you expect — for better verification and test diagnostics.


## Prebuilt Matchers for Containers and Complex Types

GoogleMock provides an extensive set of built-in matchers that simplify expressing expectations involving containers like vectors, maps, sets, and other STL-compliant types.

### Key Container Matchers

- **`ElementsAre(m1, m2, ...)`**: Matches containers whose elements match the specified matchers in order and count exactly.

  ```cpp
  EXPECT_CALL(mock, Foo(ElementsAre(1, Gt(0), _, 5)));
  ```
  _This expects the container to have exactly 4 elements, with the first equal to 1, the second greater than 0, the third anything, and the last equal to 5._

- **`UnorderedElementsAre(m1, m2, ...)`**: Similar to `ElementsAre`, but order does not matter.

- **`ElementsAreArray(array_or_container)`**: Matches container elements against an array or another container.

- **`UnorderedElementsAreArray(array_or_container)`**: Like above, but order-agnostic.

- **`Contains(matcher)`**: Matches containers that have at least one element matching the matcher.

- **`Each(matcher)`**: Matches containers in which every element matches the matcher.

- **`SizeIs(matcher)`**: Matches containers whose size matches the size matcher (e.g., `SizeIs(3)`).

- **`WhenSorted(matcher)`**: Matches containers that, when sorted, match the given matcher.

### Pair and Key Matchers

- **`Pair(key_matcher, value_matcher)`**: Matches a `std::pair` whereby the first and second elements satisfy the corresponding matchers.

- **`Key(matcher)`**: Matches pairs where the key matches the matcher, commonly used with maps.


## Prebuilt Matchers for Function Arguments

In addition to container matchers, GoogleMock offers matchers tailored for common argument validation patterns:

- **`_` (underscore)**: Matches any argument value.
- **`NotNull()`** / **`IsNull()`**: Match pointer arguments which are (non-)null.
- **`Ref(variable)`**: Matches a reference argument that refers to the specified variable.
- **`Pointee(matcher)`**: For pointer arguments, matches the value pointed to.
- **`Property(&Class::method, matcher)`**: Matches an argument whose method return value satisfies the matcher.
- **`Field(&Class::member, matcher)`**: Matches an argument whose member variable matches.

Example:

```cpp
EXPECT_CALL(mock, Foo(Property(&MyClass::GetValue, Gt(5))));
```

This expects `Foo` to be called with an argument whose `GetValue()` result is greater than 5.


## Defining Custom Matchers

While many needs are met by built-in matchers, GoogleMock enables you to create custom matchers for domain-specific constraints.

### Using the `MATCHER` Family of Macros

The simplest way to create a matcher is by using the `MATCHER` macro family which defines predicate matchers at the namespace scope.

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

This defines an `IsDivisibleBy7()` matcher usable in expectations:

```cpp
EXPECT_CALL(mock, Bar(IsDivisibleBy7()));
```

You can also provide a description string and stream additional failure diagnostic messages to `result_listener`.

For parameterized matchers, `MATCHER_P`, `MATCHER_P2`, ..., `MATCHER_P10` enable creating matchers with up to 10 parameters.

Example:

```cpp
MATCHER_P(InRange, bound, "") {
  return arg >= 0 && arg <= bound;
}
EXPECT_CALL(mock, Foo(InRange(10)));
```

### Writing Matcher Classes for Advanced Scenarios

For more control, especially with polymorphic matching or when composing sub-matchers, define matcher classes implementing the gMock matcher interface:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected_sum) : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /*listener*/) const {
    return foo.bar() + foo.baz() == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  int expected_sum_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return ::testing::MakeMatcher(new BarPlusBazEqMatcher(expected_sum));
}
```


## Matcher Composition and Extensibility

GoogleMock allows you to combine matchers logically with:

- `AllOf(m1, m2, ...)`: Matches if *all* sub-matchers match.
- `AnyOf(m1, m2, ...)`: Matches if *any* sub-matcher matches.
- `Not(m)`: Matches if *not* m matches.

You can nest these arbitrarily for complex logical expressions.

For matching multiple arguments as a tuple or subset of arguments at once, use:

- `.With(multi_argument_matcher)`: Apply a matcher to all function arguments considered as a tuple.
- `Args<k1, k2, ...>(m)`: Matches selected arguments as tuple using matcher m.
- `AllArgs(m)`: Alias for matching all arguments with matcher m.


## Practical Tips and Best Practices

- Define mocks in the `public` section of your mock class to permit unqualified referencing.
- When your mocked method's argument types contain commas (e.g., template types), wrap the type in parentheses or define type aliases to avoid `MOCK_METHOD` parsing errors.
- Use `NiceMock<T>`, `NaggyMock<T>`, or `StrictMock<T>` wrapper classes to control warning and error behavior for uninteresting calls.
- For cases where exact argument matching is complicated, consider `SaveArg` actions to capture arguments and verify them afterwards explicitly.
- When composing matchers or reusing complex matchers, assign them to variables rather than rebuilding every time.


## Troubleshooting Matchers

- **Matcher Purity:** Matchers must have no side effects. Do not call mock methods or modify state inside matcher evaluations.
- **Matcher Types:** Use `SafeMatcherCast<T>(m)` when you must cast matchers between compatible types to avoid compile errors.
- **Overloaded Functions:** Disambiguate overloaded mock methods using the techniques described in the gMock Cookbook, especially with the `Const()` wrapper or explicit `Matcher<T>()` casting.
- **Managing Sequence and Order:** Use `InSequence`, `After`, and `RetiresOnSaturation()` clauses in `EXPECT_CALL` to control invocation order and matcher retirement.


## Code Examples

### Using Container Matchers

```cpp
using ::testing::ElementsAre;
using ::testing::Gt;

EXPECT_CALL(mock_obj, DoSomething(ElementsAre(1, Gt(0), _, 5)));

std::vector<int> vec = {1, 2, 3, 4};
EXPECT_THAT(vec, ElementsAre(1, Gt(0), _, 5));
```

### Defining a Custom Matcher Using `MATCHER`

```cpp
MATCHER(IsEven, "checks if number is even") {
  return (arg % 2) == 0;
}

EXPECT_CALL(mock_obj, ProcessValue(IsEven()));
```

### Using Matchers with Multiple Arguments

```cpp
using ::testing::_; // wildcard
using ::testing::Lt;

EXPECT_CALL(mock, Calculate(_, _))
    .With(Lt());  // First argument < second argument
```


## Summary

Matchers for mocking allow detailed and expressive constraints on mock method arguments, ranging from simple wildcards to complex container and tuple matchers and user-definable logic. This page equips you with the tools and best practices to specify, combine, and extend matchers to achieve robust, maintainable, and precise mock specifications.

---

## Related Documentation

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — recipes and practical examples on mocking, matchers, and actions.
- [Matchers Reference](reference/matchers.md) — detailed list and explanation of built-in matchers.
- [Expectations and Actions](reference/mocking-api/expectations-actions.md) — how matchers interact with expectations and actions in mocks.
- [Defining and Using Mock Objects](reference/mocking-api/defining-using-mocks.md) — foundational guide on mocks.

## Next Steps

- Explore how to use `EXPECT_CALL` clause `.With()` to combine multi-argument matchers.
- Implement custom parameterized or polymorphic matchers for domain-specific testing needs.
- Harness matcher composition (`AllOf`, `AnyOf`, `Not`) for complex logical constraints.
- Employ container matchers to verify containers passed as arguments precisely.
- Use `NiceMock`, `StrictMock`, and `NaggyMock` to adjust mock warning verbosity and strictness.

---

<AccordionGroup title="Quick Reference Examples">
<Accordion title="Basic Container Matcher">
```cpp
EXPECT_CALL(mock, Foo(ElementsAre(1, Ge(2), _, 10)));
```
</Accordion>
<Accordion title="Using Pointee Matcher">
```cpp
EXPECT_CALL(mock, ProcessData(Pointee(Eq(42))));
```
</Accordion>
<Accordion title="Custom Matcher with MATCHER">
```cpp
MATCHER(IsPositive, "checks if value is positive") {
  return arg > 0;
}
EXPECT_CALL(mock, Foo(IsPositive()));
```
</Accordion>
</AccordionGroup>

