---
title: "MOCK_METHOD Macro"
description: "How to use the MOCK_METHOD macro to declare mocked methods in your test doubles. Covers syntax, qualifiers, template and overload support, and integration with your own interfaces. Practical code snippets show how to use MOCK_METHOD in common scenarios."
---

# MOCK_METHOD Macro

The `MOCK_METHOD` macro in GoogleMock is your primary tool for declaring mocked methods within test doubles (mock classes). It automatically generates method stubs that record calls and enforce expectations, perfectly fitting into your testing workflow. This guide will take you through how to use `MOCK_METHOD` effectively, including handling method qualifiers, templates, overloads, and integration with your interfaces.

---

## Overview

At its core, `MOCK_METHOD` lets you specify, inside your mock class, methods with the exact signature needed to replace real implementations for testing. When invoked during tests, these methods track calls, enable argument matching, and support defining return values or side effects.

### Basic Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- **ReturnType** — the type returned by the method.
- **MethodName** — the name of the mocked method.
- **Args...** — the parameter types wrapped inside parentheses.
- **Specs...** — optional method qualifiers wrapped inside parentheses (e.g., `const`, `override`).


#### Mandatory Use in `public:`

Mock methods declared with `MOCK_METHOD` must always be placed in the *public* section of your mock class, regardless of the base class method's accessibility level. This ensures `EXPECT_CALL` and `ON_CALL` can reference the mock method without access restrictions.


## Handling Method Qualifiers

The fourth parameter of `MOCK_METHOD` supports a closed set of specifiers which match the qualifiers of the method you are mocking. These allow your mock to fully simulate the behavior and override semantics of the original method:

| Qualifier                | Description                                                |
|--------------------------|------------------------------------------------------------|
| `const`                  | Mocks a `const` method. Required if base method is `const`.
| `override`               | Marks mock method with `override`. Recommended when overriding `virtual`s.
| `noexcept`               | Marks mock method with `noexcept`.
| `Calltype(calltype)`     | Specifies calling convention (e.g., `STDMETHODCALLTYPE`) — useful on Windows.
| `ref(&)` or `ref(&&)`    | Marks a reference qualifier (lvalue or rvalue). Needed if base method uses reference qualifiers.

Example with qualifiers:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, DoSomething, (), (const, override));
  MOCK_METHOD(int, GetValue, (int x), (noexcept, override));
};
```

## Managing Commas in Types

Complex types like `std::pair` or `std::map` include commas. Since `MOCK_METHOD` parses parameters separated by commas, unprotected commas will confuse the macro.

### Solutions:

- **Wrap return or argument types with extra parentheses:**

  ```cpp
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
  ```

- **Use type aliases:**

  ```cpp
  using BoolAndInt = std::pair<bool, int>;
  using MapIntDouble = std::map<int, double>;

  MOCK_METHOD(BoolAndInt, GetPair, ());
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
  ```

> Note: The extra parentheses are removed by the macro internally. They are purely a workaround for the macro parser.

## Mocking Overloaded Methods

When mocking overloaded methods, declare each overload normally with `MOCK_METHOD`, specifying full signatures. If you omit some overloads, C++ warns about hidden base methods; to fix this, bring unmocked overloads into scope with a `using BaseClass::Method;` statement.

Example:

```cpp
class Foo {
 public:
  virtual int Add(int x);
  virtual int Add(int times, int x);
  virtual const Bar& GetBar() const;
  virtual Bar& GetBar();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
  MOCK_METHOD(Bar&, GetBar, (), (override));
};
```

Or, selectively mock one overload and use `using` for the others:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Prevents hiding other overloads
  MOCK_METHOD(int, Add, (int x), (override));
};
```

## Mocking Class Templates

Just like with normal classes, you mock template classes by mocking each instance's methods explicitly. Specify the qualifiers appropriately. Example:

```cpp
template<typename T>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template<typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

## Mocking Non-Virtual Methods

Though typically methods to mock should be virtual, GoogleMock supports mocking non-virtual methods used with High-Performance Dependency Injection. In this case, the mock class does not inherit from the real class but implements the same interface:

```cpp
class RealStream {
 public:
  void AppendPacket(Packet* p);
  const Packet* GetPacket(size_t index) const;
};

class MockStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t), (const));
};
```

You can use templates in your code to switch between real and mock at compile time.

## Integration with Your Interfaces

- Always place `MOCK_METHOD` declarations in the `public:` section of your mock class.
- Include `<gmock/gmock.h>` in your header or test files to use the macro.
- `MOCK_METHOD` generates all necessary definitions internally — there's no need for separate implementation.

### Example: Mocking an Interface

```cpp
#include <gmock/gmock.h>

class MyInterface {
 public:
  virtual int Calculate(int x, int y) = 0;
  virtual void Reset() const = 0;
  virtual ~MyInterface() {}
};

class MockMyInterface : public MyInterface {
 public:
  MOCK_METHOD(int, Calculate, (int x, int y), (override));
  MOCK_METHOD(void, Reset, (), (const, override));
};
```

## Best Practices

- **Use `override` and `const` qualifiers** to match the base class declaration exactly.
- **Avoid duplicating method declarations:** `MOCK_METHOD` defines both declaration and definition.
- **Wrap complex types with parentheses or typedefs** to avoid parsing errors.
- **For overloaded functions, either mock all versions or bring unmocked overloads into scope with `using`**.
- If you want to mock methods with specific calling conventions (Windows), use `Calltype(...)` qualifier.

## Common Pitfalls

- Omitting parentheses around argument lists or specs causes compile errors.
- Declaring mock methods in protected/private sections blocks use of `EXPECT_CALL` / `ON_CALL`.
- Forgetting to add `override` for virtual base methods can cause silent bugs.
- Not wrapping types with commas inside parentheses or aliases leads to macro parsing errors.

## Complete Example

```cpp
#include <gmock/gmock.h>
#include <map>
#include <utility>

class Service {
 public:
  virtual ~Service() {}
  virtual std::pair<int, bool> GetData() = 0;
  virtual bool Configure(std::map<int, double> config, bool flag) = 0;
};

class MockService : public Service {
 public:
  // Using parentheses around complex type return type.
  MOCK_METHOD((std::pair<int, bool>), GetData, (), (override));
  MOCK_METHOD(bool, Configure, ((std::map<int, double>), bool), (override));

  // Alternative: Using type aliases to manage nested commas.
  using ConfigMap = std::map<int, double>;
  MOCK_METHOD(bool, ConfigureAlt, (ConfigMap, bool), (override));
};


// Usage in test:

TEST(ServiceTest, ConfigureWorks) {
  MockService mock;
  EXPECT_CALL(mock, Configure(_, true)).WillOnce(::testing::Return(true));

  EXPECT_TRUE(mock.Configure({{1, 2.0}}, true));
}
```


## Troubleshooting

### Method Not Called as Expected
Ensure you used `MOCK_METHOD` in the public section and correctly matched qualifiers. Check you set expectations *before* exercising the mock.

### Comma Parsing Errors
Wrap complex types with parentheses or typedefs. Incorrect example:

```cpp
MOCK_METHOD(std::pair<int, bool>, GetData, ());  // Compile error
```

Correct:

```cpp
MOCK_METHOD((std::pair<int, bool>), GetData, ());
```

### Qualifiers Don't Match
Specifying `const` and `override` exactly as in base class method signature avoids unexpected behavior.

### Overloads Hidden
When mocking only some overloads, expose others with `using Base::Method` to prevent hiding.

---

For full usage of mock methods with expectations, actions, matchers, and behaviors, see the [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) and the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html).

---

## Related Macros and Concepts

- `EXPECT_CALL`: Set expectations on method calls.
- `ON_CALL`: Set default behaviors for mock methods without enforcing calls.
- `NiceMock`, `StrictMock`, `NaggyMock`: Control warning and failure levels on uninteresting calls.


---

This page focuses explicitly on `MOCK_METHOD` usage. For best results, combine it with these tools for setting expectations and behaviors in your tests.

---