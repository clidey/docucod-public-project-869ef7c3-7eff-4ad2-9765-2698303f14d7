---
title: "Creating and Using Mock Objects"
description: "Explains how to define mock classes and methods using the MOCK_METHOD macros. Covers support for interfaces, overloads, and custom signatures."
---

# Creating and Using Mock Objects

This page explains how to define mock classes and methods using the `MOCK_METHOD` macros in GoogleMock. It covers support for interfaces, method overloads, and custom signatures, providing a user-centric guide to creating powerful mocks in C++.

---

## Overview

In GoogleMock, mock objects represent classes whose methods you want to simulate and verify during testing. The core mechanism to create mocks is the `MOCK_METHOD` macro, which declares mock methods inside your mock classes. These mock methods enable you to set expectations on function calls, specify behaviors, and verify interactions.

This documentation focuses exclusively on defining mock classes and methods using `MOCK_METHOD`, including handling method overloads and qualifiers.

---

## Defining Mock Classes and Methods

### Using `MOCK_METHOD`

The `MOCK_METHOD` macro declares a mocked method within a mock class. It accepts three mandatory parameters and an optional fourth parameter with method qualifiers.

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- **ReturnType**: The return type of the method.
- **MethodName**: The method name.
- **Args...**: The argument types in parentheses.
- **Specs...** (optional): Method qualifiers such as `const`, `override`, `noexcept`, calling conventions, and reference qualifiers.

Example:

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

> The mock methods declared with `MOCK_METHOD` are always placed in the `public:` section of the mock class, regardless of the original access level in the base class. This is required to enable GoogleMock's expectation and behavior macros (`ON_CALL` and `EXPECT_CALL`) to access the mock methods properly.

### Handling Types with Commas

If your return type or argument types contain commas (e.g., `std::pair<int, int>`), wrap them in extra parentheses to avoid parsing errors:

```cpp
class MyMock {
 public:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
};
```

Alternatively, you may define type aliases to simplify the `MOCK_METHOD` declaration:

```cpp
using BoolAndInt = std::pair<bool, int>;
using MapIntDouble = std::map<int, double>;

class MyMock {
 public:
  MOCK_METHOD(BoolAndInt, GetPair, ());
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

### Using Method Qualifiers

When mocking methods that have qualifiers, specify them in the fourth argument as a comma-separated list inside parentheses. Supported qualifiers include:

| Qualifier                  | Meaning                                                          |
| -------------------------- | ---------------------------------------------------------------- |
| `const`                    | Declares the mock method as `const`. Required if overriding a `const` method. |
| `override`                 | Marks the mock method with `override`. Recommended for overriding virtual methods. |
| `noexcept`                 | Declares the mock method as `noexcept`. Required if overriding a `noexcept` method. |
| `Calltype(...)`            | Specifies the calling convention (e.g., `Calltype(STDMETHODCALLTYPE)`), useful on Windows. |
| `ref(&)` or `ref(&&)`      | Marks the mock method with reference qualifiers. Required if overriding methods with reference qualifiers. |

Example:

```cpp
MOCK_METHOD(std::string, Describe, (int type), (const, override));
MOCK_METHOD(void, Close, (), (noexcept, override));
```

### Mocking Overloaded Methods

You can mock all overloads of a method by providing separate `MOCK_METHOD` declarations for each variant.

Example:

```cpp
class Foo {
 public:
  virtual int Add(Element x);
  virtual int Add(int times, Element x);
  virtual Bar& GetBar();
  virtual const Bar& GetBar() const;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (Element x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));

  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

**Tip:** If you mock some but not all overloads, unmocked overloads can become hidden, causing compiler warnings. Use `using BaseClass::MethodName;` in your mock class to bring the unmocked overloads into scope.

### Mocking Template Classes

Template classes can be mocked naturally by defining template mock classes that inherit from them and redeclare the mock methods:

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};

template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

### Mocking Non-Virtual Methods

If you want to mock non-virtual methods for high-performance dependency injection, your mock class does not inherit from the real one but declares mock methods with matching signatures.

Example:

```cpp
class ConcretePacketStream {
 public:
  void AppendPacket(Packet* new_packet);
  const Packet* GetPacket(size_t packet_number) const;
  size_t NumberOfPackets() const;
};

class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

### Mocking Free Functions

GoogleMock cannot mock free functions directly. To mock such functions, define an interface with virtual methods and mock that interface. Alternatively, use `MockFunction` to mock `std::function` objects and refactor your code to use the interface or callbacks.

### Summary

- Use `MOCK_METHOD` to define mock methods with the signature and qualifiers of the target method.
- Wrap return types or argument types that contain commas in extra parentheses, or use type aliases.
- Place all mock methods in the `public` section, even if overriding protected or private base methods.
- Mock each overload explicitly and use `using` statements to bring unmocked overloads into scope.

---

## Working with Mock Methods

`MOCK_METHOD` generates method stubs that you can control and set expectations on using macros like `EXPECT_CALL` and `ON_CALL`. These provide the ability to specify:

- Call count and order
- Argument matching
- Return values and behaviors
- Sequences and call ordering constraints

The next steps after defining mocks typically involve:

1. Setting default method behaviors (`ON_CALL`)
2. Declaring expected calls and their return actions (`EXPECT_CALL`)
3. Executing code under test that depends on the mocks

For detailed usage of `EXPECT_CALL` and `ON_CALL`, refer to the [Specifying Expectations](../mocking-api/specifying-expectations) page.

---

## Additional Tools: `MockFunction` and Helpers

### Mocking std::function Callbacks

`MockFunction` is a handy template mock class that can mock callbacks implemented as `std::function` objects. It contains a single mock method `Call()` with the signature of the function type, allowing easy setting of expectations and forwarding.

Example usage:

```cpp
MockFunction<int(std::string)> mock_func;
EXPECT_CALL(mock_func, Call("bar")).WillOnce(Return(1));
```

Then pass `mock_func.AsStdFunction()` to your code expecting a `std::function<int(std::string)>`.

### Const Method Mocking

To mock overloaded methods that differ only in const-qualification, use the `Const()` helper:

```cpp
EXPECT_CALL(Const(mock_obj), Method());
```

### Handling Methods with Reference Qualifiers

Use the `ref(&)` or `ref(&&)` qualifier in `MOCK_METHOD` to declare mock methods matching base class methods with lvalue or rvalue reference qualifiers.


---

## Best Practices and Common Pitfalls

- Always place `MOCK_METHOD` declarations in the `public` section of your mock class.
- When mocking overloaded methods, declare mocks for **all** overloads you'll be calling or use `using` to bring unmocked ones into scope.
- Wrap complex argument or return types that contain commas with parentheses or use type aliases to avoid macro parsing errors.
- Use the optional fourth parameter in `MOCK_METHOD` for method qualifiers consistent with the base method.
- To mock move-only types (e.g., `std::unique_ptr`), use lambdas or callable objects in `EXPECT_CALL` actions.
- Remember `MOCK_METHOD` generates the mock implementation for you; no additional manual method definitions are necessary.

---

## Troubleshooting Tips

- If you get macro parsing errors due to commas in types, try wrapping those types in extra parentheses or use aliases.
- If you see warnings about hidden overloads, use `using BaseClass::MethodName;` in your mock class.
- If an uninteresting call warning appears even though you use `ON_CALL` to define default behavior, consider whether you should add an `EXPECT_CALL` to express your expectation or use a `NiceMock`.
- Use `Const()` wrapper to disambiguate const overload expectations.
- For slow compilation, move mock class constructor and destructor definitions outside the header.

---

For comprehensive understanding of mock behavior, expectations, and usage patterns, see the following documentation:

- [Mocking Reference](../mocking-api/creating-mock-objects)
- [gMock Cookbook](../../docs/gmock_cook_book.md)
- [Matchers and Actions Reference](../mocking-api/argument-matching)


---

<Info>
This page focuses specifically on how to create and use mock classes and methods with the `MOCK_METHOD` macro in GoogleMock. For setting expectations and behaviors on your mocks, consult the `EXPECT_CALL` and `ON_CALL` documentation.
</Info>
