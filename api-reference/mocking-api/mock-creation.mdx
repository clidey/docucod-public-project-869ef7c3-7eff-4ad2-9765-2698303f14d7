---
title: "Mock Object and Method Creation"
description: "Introduces the MOCK_METHOD macro and associated patterns for defining mock classes and methods in GoogleMock. Step-by-step guidance on creating mocks, handling different method signatures, and integrating mocks into test suites. Highlights compile-time checks and best practices to ensure type safety and maintainable test code."
---

# Mock Object and Method Creation

GoogleMock (gMock) offers a powerful and expressive mechanism to define *mock classes* and *mock methods* in C++ with ease and type safety. This page delves into the core macro `MOCK_METHOD`, guiding you through the process of creating mock objects, handling various method signatures, and integrating mocks seamlessly into your test suites.

---

## Overview of MOCK_METHOD

The `MOCK_METHOD` macro is your gateway to defining mock methods in class declarations. It generates method implementations for you that integrate with gMock’s rich expectations and behaviors:

```cpp
MOCK_METHOD(return_type, method_name, (arg_types...), (qualifiers));
```

- ***return_type***: The method’s return type.
- ***method_name***: The name of the method you want to mock.
- ***(arg_types...)***: The argument list, enclosed in parentheses.
- ***(qualifiers)***: Optional (comma-separated) method qualifiers like `const`, `override`, `noexcept`, and platform-specific calling conventions.

### Key Characteristics

- Must be used in the `public` section of your mock class, irrespective of the original method’s visibility.
- Supports overloaded, `const`-qualified, and reference-qualified methods.
- Handles methods with complex argument types, including those with unprotected commas, via parentheses or type aliases.
- Automatically generates all the plumbing required for gMock’s expectations.

---

## Defining Mock Classes: Step-by-Step

### 1. Start With An Interface

Suppose your production system uses an abstract interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual void GoTo(int x, int y) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};
```

### 2. Create a Mock Class

Derive your mock class from the interface and mock each virtual method using `MOCK_METHOD`. For methods marked `const`, specify the `const` qualifier in the fourth parameter:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

This concise declaration suffices—the macro generates all necessary mock method implementations behind the scenes.

### 3. Use Your Mock in Tests

Instantiate the mock and specify expectations with `EXPECT_CALL`:

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::AtLeast;

TEST(PainterTest, CanDrawCircle) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown()).Times(AtLeast(1));

  Painter painter(&turtle);    // Code under test that uses Turtle
  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));
}
```

If the underlying code calls `PenDown()` fewer times than expected, the test will fail with a detailed message.

---

## Handling Complex Method Signatures

### Dealing with Unprotected Commas in Types

Types like `std::pair<bool, int>` or `std::map<int, double>` contain commas that confuse the macro parser. Solve it by either:

- Wrapping the type in parentheses:

  ```cpp
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
  ```

- Using type aliases:

  ```cpp
  using BoolAndInt = std::pair<bool, int>;
  MOCK_METHOD(BoolAndInt, GetPair, ());
  using MapIntDouble = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
  ```

### Mocking Overloaded Methods

Simply mock all overloads you expect to use by defining their signatures. If you omit some, use `using BaseClass::method;` to bring the others into scope and avoid hiding base class methods.

```cpp
MOCK_METHOD(int, Add, (Element x), (override));
MOCK_METHOD(int, Add, (int times, Element x), (override));
```

### Mocking Const and Reference-Qualified Methods

Honor qualifiers exactly to avoid mismatch:

```cpp
MOCK_METHOD(int, GetBar, (), (override));
MOCK_METHOD(int, GetBar, (), (const, override));
MOCK_METHOD(void, Foo, (), (ref(&), override));  // For ref-qualified methods
```

---

## Best Practices

### Always Mock Methods You Own

Avoid mocking classes you do not own if possible. If necessary, mock classes in their own test-specific subdirectory or package to limit spread of breakage when interfaces change.

### Use `override` in Qualifiers

Mark mock methods with `override` to catch discrepancies at compile time when the base method changes.

### Provide Type Aliases to Simplify Declarations

Define aliases for complex types to improve readability and prevent macro parsing issues.

### Keep Mock Methods in Public Section

Define all `MOCK_METHOD` declarations in `public:` to ensure gMock can properly access and instrument them.

### Leverage `NiceMock` and `StrictMock`

Use `NiceMock<T>` to silence warnings about uninteresting calls and `StrictMock<T>` to make uninteresting calls errors for stricter enforcement.

### Verify Expectations Before Mock Destruction

By default, gMock verifies expectations upon mock destruction. If mocks outlive tests or lifetimes are unclear, you can call `::testing::Mock::VerifyAndClearExpectations(&mock)` explicitly to enforce verification earlier.

---

## Common Pitfalls

- **Omitting parentheses when argument types contain commas** leads to macro parsing errors.
- **Mismatch in qualifiers** (e.g., forgetting `const` or incorrect reference qualifiers) causes compilation errors or warnings.
- **Missing virtual destructors** in interfaces may cause undefined behavior or leaks.
- **Setting `EXPECT_CALL` after method calls** can break expectations as order matters and expectations set *after* calls may not track those calls.
- **Not accounting for multiple overloads** can result in unexpected method hiding.

---

## Example: Mocking a Class Template

Given a template interface:

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};
```

You can define a mock template:

```cpp
template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

---

## Real-World Usage Patterns

### Delegating Mock Calls to a Fake or Real Object

If you already have a fake or real implementation handy, you can delegate default actions to it within your mock using `ON_CALL()`:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Calculate, (int x), (override));

  void DelegateToFake() {
    ON_CALL(*this, Calculate).WillByDefault([this](int x) {
      return fake_.Calculate(x);
    });
  }

 private:
  FooFake fake_;  // Your existing fake.
};
```

This preserves the ability to specify expectations while reusing real logic.

### Handling Non-Virtual Methods

Mocking non-virtual methods requires alternative dependency injection techniques like templating mock classes without inheritance.

---

## Compile-time Validations by MOCK_METHOD

- Ensures argument list is enclosed in parentheses.
- Validates method signature correctness.
- Confirms that qualifiers are among accepted tokens: `const`, `override`, `noexcept`, `Calltype(...)`, `ref(&)`, `ref(&&)`.
- Provides clear compiler errors if usage is incorrect.

These validations prevent common mistakes early, improving test code maintainability.

---

## Summary

`MOCK_METHOD` is the foundational macro for creating mock methods within mock classes in GoogleMock, profoundly simplifying mock class definitions while enforcing type safety and correct method signatures. Mastery of this macro enables robust, maintainable, and expressive mock-based unit tests in C++.

---

## Additional Resources

- [GoogleMock for Dummies](../guides/core_testing_workflows/using_googlemock.md): A beginner-friendly introduction to GoogleMock.
- [gMock Cheat Sheet](../api-reference/mocking-api/mock-creation.md): Quick reference for mocking syntax and usage.
- [Mocking Reference](../docs/reference/mocking.md): Formal documentation covering all mocking features.
- [gMock Cookbook](../docs/gmock_cook_book.md): Recipes and advanced scenarios.
- [Matchers Reference](../reference/matchers.md): For defining argument matchers.

---

## Practical Tips

- Prefer `ON_CALL` in test fixtures to set common default actions.
- Use `EXPECT_CALL` sparingly to verify interactions you care about.
- Utilize `NiceMock` to reduce noise from irrelevant mock calls.
- Retire expectations with `.RetiresOnSaturation()` when appropriate.
- Handle overloaded methods carefully, explicitly specifying overloads if necessary.


---

<Source url="https://github.com/google/googletest" branch="main" paths='[{"path": "docs/reference/mocking.md", "range": "1-600"},{"path": "docs/gmock_for_dummies.md", "range": "1-200"},{"path": "docs/gmock_cheat_sheet.md", "range": "1-180"},{"path": "googlemock/include/gmock/gmock-function-mocker.h", "range": "1-400"}]' />