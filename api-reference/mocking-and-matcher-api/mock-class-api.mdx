---
title: "Mock Class and Method Macros"
description: "Learn to declare mock classes and methods for interface-based testing. Focus on the core MOCK_METHOD macros, their syntax, supported C++ features, and advanced constructs such as strict and nice mocks."
---

# Mock Class and Method Macros

GoogleTest facilitates interface-based testing in C++ by providing a powerful set of macros to declare mock classes and mock methods. This page documents the core macros and constructs you need to create mocks, specify method behaviors, and control the strictness of mocks.

---

## Table of Contents

1. [Introduction to Mock Classes and Methods](#introduction-to-mock-classes-and-methods)
2. [The `MOCK_METHOD` Macro](#the-mock_method-macro)
3. [Using `EXPECT_CALL` and `ON_CALL` to Specify Behavior](#using-expect_call-and-on_call-to-specify-behavior)
4. [Qualifiers and Overloads in Mock Methods](#qualifiers-and-overloads-in-mock-methods)
5. [Handling Complex Signatures and Templates](#handling-complex-signatures-and-templates)
6. [The Nice, the Strict, and the Naggy Mocks](#the-nice-the-strict-and-the-naggy-mocks)
7. [Best Practices and Common Pitfalls](#best-practices-and-common-pitfalls)
8. [Advanced Constructs and Customization](#advanced-constructs-and-customization)
9. [Troubleshooting Mock Class Issues](#troubleshooting-mock-class-issues)

---

## Introduction to Mock Classes and Methods

In C++, a **mock class** acts as a stand-in for an interface or abstract class, allowing you to specify, verify, and control the behavior of class methods in tests. GoogleTest's built-in mocking support (GoogleMock) offers macros that generate mock implementation automatically.

- **Why mock?**
  - Allows testing components in isolation.
  - Controls expected calls and their behaviors.
  - Validates that interactions between classes happen as designed.

To create a mock class, you typically:

1. Derive it from the class (interface) you want to mock.
2. Declare mock methods mirroring virtual methods using `MOCK_METHOD` macros.


## The `MOCK_METHOD` Macro

The heart of GoogleMock mocking is the `MOCK_METHOD` macro, which defines a mock method within your mock class.

```cpp
MOCK_METHOD(return_type, method_name, (argument_types...), (qualifiers...));
```

Key points:

- Must appear in the `public:` section of your mock class.
- Supports a robust list of qualifiers to reflect the original method's signature.
- Wrap argument types with extra parentheses if they include commas to avoid macro parsing issues.

### Example - Defining a Mock Class

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() = default;
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual bool Process(int x, int y) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int x, int y), (override));
};
```

### Handling Commas in Arguments

If your return type or arguments contain commas (e.g., templates like `std::pair`), you have two options:

1. **Wrap the type in parentheses:**

```cpp
MOCK_METHOD((std::pair<int, int>), GetPair, ());
```

2. **Use type aliases:**

```cpp
using IntPair = std::pair<int, int>;
MOCK_METHOD(IntPair, GetPair, ());
```


## Using `EXPECT_CALL` and `ON_CALL` to Specify Behavior

After creating mock objects, you control their behavior with `EXPECT_CALL` and `ON_CALL` macros.

- `EXPECT_CALL(mock_obj, Method(matchers...))` sets an **expectation** that a specific call **will happen**, permitting verification and specifying behavior.
- `ON_CALL(mock_obj, Method(matchers...))` sets the default behavior for matching calls but does not impose expectations on whether the call must occur.

Example:

```cpp
using ::testing::Return;
using ::testing::_;

MockFoo mock;

ON_CALL(mock, GetSize()).WillByDefault(Return(10));  // Default behavior

EXPECT_CALL(mock, Describe("test")).WillOnce(Return("desc"));  // Expected call

int size = mock.GetSize();             // Returns 10 by default
std::string desc = mock.Describe("test");  // Returns "desc"
```

## Qualifiers and Overloads in Mock Methods

`MOCK_METHOD` supports qualifiers needed to match the original methods flawlessly:

| Qualifier      | Usage                                                                                  |
|----------------|-----------------------------------------------------------------------------------------|
| `const`        | Marks the method as a const method. Required for overriding const methods.               |
| `override`     | Marks the method as override to catch mismatches early. Recommended.                     |
| `noexcept`     | Marks the method noexcept to match noexcept virtuals.                                  |
| `Calltype(x)`  | Specifies calling convention. Often used on Windows for COM interfaces (e.g. `STDMETHODCALLTYPE`). |
| `ref(&)` or `ref(&&)` | Supports reference qualified methods introduced in C++11 (`&` or `&&` qualifiers).      |

Example of mocking a const and overloaded method:

```cpp
MOCK_METHOD(int, GetBar, (), (const, override));
MOCK_METHOD(int, GetBar, (), (override));
```

If you don't mock all overloads, inherit and use `using Base::Method;` to avoid hiding base class methods.

## Handling Complex Signatures and Templates

Mocking class templates and functions with move-only types is supported:

```cpp
template <typename T>
class MockStack {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

For move-only types like `std::unique_ptr`, use the usual syntax, but specify custom behaviors via lambdas if needed.

## The Nice, the Strict, and the Naggy Mocks

By default, uninteresting calls (calls without any matching `EXPECT_CALL`) generate warnings.

GoogleMock lets you control this behavior on a per-mock basis using three modifiers:

| Mock Type         | Behavior on Uninteresting Calls                           |
|-------------------|-----------------------------------------------------------|
| `NiceMock<T>`     | Suppresses warning, allows uninteresting calls silently. |
| `NaggyMock<T>`    | Prints warnings on uninteresting calls (default mock).    |
| `StrictMock<T>`   | Treats uninteresting calls as test failures.              |

Example:

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> nice_mock;
```

These wrappers inherit constructors from `T` and can be constructed with the same arguments.

## Best Practices and Common Pitfalls

- Always place `MOCK_METHOD` in the `public:` section even if overriding protected or private methods.
- Use `override` qualifier to catch mismatches early.
- Remember that if your method is overloaded, you should mock all needed overloads or bring base overloads into scope.
- Prefer `ON_CALL` to set default behaviors to avoid overconstraining tests.
- Use `EXPECT_CALL` only when you want to verify call occurrence.
- Avoid nesting `NiceMock` or `StrictMock`; they only work when applied once.
- When mocking move-only types, prefer lambdas for specifying return behaviors.

## Advanced Constructs and Customization

- Use chaining methods with `EXPECT_CALL` to specify call count (`Times()`), order (`InSequence()`, `After()`), actions (`WillOnce()`, `WillRepeatedly()`), and lifecycle (`RetiresOnSaturation()`).
- Use `MOCK_METHOD` qualifiers like `Calltype()` and `ref()` to handle platform-specific calling conventions and reference qualifiers.
- When handling destructors, add a mocked method `Die()` and call it inside the destructor to observe mock destruction.

## Troubleshooting Mock Class Issues

- If your mock method is not invoked but calls to the real method execute, check that the base method is virtual.
- For const-qualified parameters, remove top-level `const` in declarations to avoid MSVC warnings.
- If uninteresting calls happen unexpectedly, verify if you set `EXPECT_CALL` correctly or consider using `NiceMock` to suppress warnings.
- Use `--gmock_verbose=info` to get detailed invocation trace for debugging.

---

## Summary

This documentation empowers you to define and utilize mock classes and methods effectively using GoogleTest's macros. Starting with the `MOCK_METHOD` macro, it guides you through advanced features including qualifiers, handling overloads, and controlling mock strictness with `NiceMock`, `NaggyMock`, and `StrictMock` wrappers. By blending best practices with concrete examples, this page helps you leverage interface mocking to write expressive, maintainable tests.

For a smooth learning curve, combine this reference with guides like the [gMock Cookbook](docs/gmock_cook_book.md) and [Mocking Reference](docs/reference/mocking.md).

---

### Code Snippet Reference

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int x, int y), (override));
};

// Using NiceMock
using ::testing::NiceMock;
NiceMock<MockFoo> nice_mock;
EXPECT_CALL(nice_mock, GetSize()).WillOnce(Return(42));
```

---

### Further Reading and Related Sections

- [gMock Cookbook](docs/gmock_cook_book.md) — practical recipes
- [Mocking Reference](docs/reference/mocking.md) — detailed macro and class API
- [gMock FAQ](docs/gmock_faq.md) — troubleshooting and common questions
- [gMock for Dummies](docs/gmock_for_dummies.md) — beginner-friendly conceptual introduction

---

<Callout type="tip">
Remember that using mocks effectively is key to writing robust unit tests. Keep your expectations focused and avoid over-specification.
</Callout>

