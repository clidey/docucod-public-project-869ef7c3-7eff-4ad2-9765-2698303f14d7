---
title: "Mock Class Definition and Method Mocking"
description: "Shows how to define mock classes using GoogleMock, including use of the MOCK_METHOD macro and controlling signature variations. Details configuration of mocks, inheritance, qualifiers, and the integration into test code."
---

# Mock Class Definition and Method Mocking

This documentation page demonstrates how to define mock classes using GoogleMock. It covers using the `MOCK_METHOD` macro for declaring mock methods, managing signature variations, and integrating mocks into your test code with proper use of qualifiers and inheritance. Follow this guide to accurately and effectively create mocks tailored for your testing needs.

---

## Defining Mock Classes with `MOCK_METHOD`

At the heart of GoogleMock is the `MOCK_METHOD` macro, which facilitates generating mock methods for your classes. To mock a virtual method, follow these steps:

1. **Derive a mock class from your interface or base class.**
2. **Declare each virtual method to be mocked using `MOCK_METHOD`.**
3. **Place all `MOCK_METHOD` declarations in the `public:` section of your mock class, regardless of the original methods’ visibility.**

Example:

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

- The macro accepts three required parameters: **return type**, **method name**, and **argument list (with parentheses)**.
- Optionally, you can pass a fourth parameter with qualifiers such as `(const, override)`, `(noexcept)`, or special calling conventions.

### Handling Return Types or Arguments With Commas

Commas inside template types or compound types must be protected to avoid parsing errors by `MOCK_METHOD`. There are two ways to do this:

- **Wrap the entire type in parentheses:**

  ```cpp
  class MyMock {
   public:
    MOCK_METHOD((std::pair<bool, int>), GetPair, ());
    MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
  };
  ```

- **Use type aliases:**

  ```cpp
  using BoolAndInt = std::pair<bool, int>;
  using MapIntDouble = std::map<int, double>;
  class MyMock {
   public:
    MOCK_METHOD(BoolAndInt, GetPair, ());
    MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
  };
  ```

### Qualifiers and Specifiers for Mock Methods

You can modify mocked methods with these qualifiers in the fourth parameter of `MOCK_METHOD`:

| Qualifier                  | Purpose                                                                   |
|----------------------------|---------------------------------------------------------------------------|
| `const`                    | To mock a `const` method.                                                  |
| `override`                 | To mark the method as `override`. Recommended for overriding virtual methods. |
| `noexcept`                 | To mock a method declared as `noexcept`.                                  |
| `Calltype(...)`            | To specify calling conventions (e.g., `Calltype(STDMETHODCALLTYPE)`) for Windows. |
| `ref(&)` or `ref(&&)`      | To specify reference qualifiers when mocking methods with ref qualifiers. |

### Mocking Overloaded Methods

To mock overloaded functions, just declare each variation individually:

```cpp
class Foo {
 public:
  virtual int Add(int x);
  virtual int Add(Element e);
  virtual Bar& GetBar();
  virtual const Bar& GetBar() const;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (Element e), (override));
  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

If you don't mock all overloads, use `using BaseClass::MethodName;` to avoid hiding base class methods.

### Mocking Class Templates

Class templates can be mocked similarly to normal classes:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

### Mocking Private or Protected Methods

Even if methods are private or protected in the base class, your mock class should declare mocks in the `public:` section. This allows GoogleMock’s macros (`ON_CALL` and `EXPECT_CALL`) to access them properly.

Example:

```cpp
class Foo {
 protected:
  virtual void Resume();
 private:
  virtual int GetTimeout();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Resume, (), (override));
  MOCK_METHOD(int, GetTimeout, (), (override));
};
```

---

## Creating and Using Mock Objects in Tests

Once your mock class is defined, the typical workflow to use mock objects is:

1. Import GoogleMock symbols, e.g., `using ::testing::_;`.
2. Instantiate mock objects.
3. Use `ON_CALL` to set default behaviors without enforcing call expectations.
4. Use `EXPECT_CALL` to specify expected calls, arguments, call counts, and actions.
5. Exercise your test code that interacts with the mock.
6. Upon destruction or explicit invocation, GoogleMock verifies expectations.

Example:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using ::testing::_;
using ::testing::Return;

TEST(FooTest, Example) {
  MockFoo mock;

  ON_CALL(mock, GetSize())
      .WillByDefault(Return(1));

  EXPECT_CALL(mock, Describe("test"))
      .Times(1)
      .WillOnce(Return("Description"));

  // Exercise the code under test
  EXPECT_EQ(mock.GetSize(), 1);
  EXPECT_EQ(mock.Describe("test"), "Description");
}
```

**Remember:**

- Always set expectations *before* exercising the mock.
- Use matchers like `_` when you don't care about specific argument values.
- Use `NiceMock<>` or `StrictMock<>` wrappers to control uninteresting calls (see the [Advanced Mocking Patterns](reference/mocking-apis/strictness-and-uninteresting-calls)).

---

## Additional Mock Class Types

GoogleMock offers different mock object modifiers to control how mocks behave on uninteresting calls (method calls without expectations):

- `NiceMock<T>`: suppresses warnings on uninteresting calls.
- `NaggyMock<T>`: prints warnings on uninteresting calls (default behavior).
- `StrictMock<T>`: treats uninteresting calls as test failures.

Usage example:

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> mock_foo;
EXPECT_CALL(mock_foo, DoSomething());
```

---

## Practical Tips

- **Virtual destructors:** Ensure the base class destructor is virtual to avoid issues when mock objects are deleted. This is crucial to prevent resource leaks and undefined behavior.
- **Avoid mocking non-virtual functions unless using advanced techniques.**
- **Control call order:** Use `InSequence` objects or the `.InSequence()` clause to expect calls in order.
- **Controlling call frequency:** Use `.Times()`, `.WillOnce()`, `.WillRepeatedly()`, and `.RetiresOnSaturation()` clauses on `EXPECT_CALL`.
- **Mock move-only types:** Use the standard `MOCK_METHOD` macros to mock methods with move-only argument or return types like `std::unique_ptr`. When returning move-only values, prefer lambdas or functors to avoid reuse issues.
- **To verify mocks early,** use `Mock::VerifyAndClearExpectations(&mock_obj)`.

---

## Integration With Source Code

The mocked methods behave like real methods with user-defined behavior controlled by `ON_CALL` and `EXPECT_CALL`. The generated mock methods:

- Use `MOCK_METHOD` macro expansions.
- Handle const, noexcept, reference qualifiers, and calling conventions automatically.
- Provide generated `gmock_MethodName()` methods to set expectations and default behaviors.

Example of a mock method declaration and implementation using `MOCK_METHOD`:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
};

// Usage inside test
MockFoo mock;
EXPECT_CALL(mock, GetSize()).WillOnce(Return(42));
int size = mock.GetSize();  // Returns 42.
```

---

## Troubleshooting Common Issues

- **Mock method names conflicting with macros:** If method names are defined as macros in included headers (e.g., Windows APIs), GoogleMock handles macro expansions correctly, so no special action needed.
- **Uninteresting calls warnings:** You see these when a mock method with no expectation is invoked. Use `NiceMock` to suppress or add a catch-all `EXPECT_CALL` with `Times(AnyNumber())`.
- **Mismatch in method qualifiers:** Always match `const`, `noexcept`, and reference qualifiers exactly in `MOCK_METHOD` declarations.
- **Compilation failures with complex types:** Parenthesize types involving commas or use type aliases.

---

## Further Resources

- GoogleMock **[Mocking Reference](https://google.github.io/googletest/reference/mocking.html)**: Authoritative macro and class references.
- **[gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)**: Beginner-friendly tutorial on mocks.
- **[gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)**: Recipes for advanced mocking scenarios.
- **[Matchers Reference](https://google.github.io/googletest/reference/matchers.html)**: Complete list of argument matching utilities.

---

## Example Summary

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};

// Test Example
TEST(FooTest, Usage) {
  MockFoo mock;
  ON_CALL(mock, GetSize()).WillByDefault(::testing::Return(1));
  EXPECT_CALL(mock, Describe("test")).WillOnce(::testing::Return("desc"));

  EXPECT_EQ(mock.GetSize(), 1);
  EXPECT_EQ(mock.Describe("test"), "desc");
}
```

This example shows defining a mock class and setting both default and expected behaviors.

---