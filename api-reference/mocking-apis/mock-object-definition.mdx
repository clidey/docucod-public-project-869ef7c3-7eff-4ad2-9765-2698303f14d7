---
title: "Mock Object Definition"
description: "How to declare and implement mock classes and methods, using the MOCK_METHOD macros and customization points. Covers supported signatures, constness, overrides, and advanced qualifiers, offering practical examples for seamless integration."
---

# Mock Object Definition

Learn how to define and implement mock classes and methods seamlessly using GoogleMock's `MOCK_METHOD` macros. This guide covers supported method signatures, including const, override, and other advanced qualifiers, with practical examples to help you integrate mocks efficiently into your C++ tests.

---

## Overview

Mock objects enable you to simulate and control the behavior of real interfaces in your tests. GoogleMock provides a declarative, type-safe syntax to define mock classes by mocking virtual functions using the `MOCK_METHOD` macro. Proper use ensures clean, readable, and maintainable tests.

---

## Defining Mock Classes and Mock Methods

To create a mock class:

- Derive from the interface or base class you want to mock.
- Declare mock methods using the `MOCK_METHOD` macro inside the `public:` section.
- Mocked methods must be **virtual** in the base class.
- Include appropriate qualifiers such as `const`, `override`, or `noexcept` in the `MOCK_METHOD` macro.

### Syntax of `MOCK_METHOD`

```cpp
MOCK_METHOD(return_type, method_name, (argument_types), (optional_qualifiers));
```

- **`return_type`**: The return type of the method.
- **`method_name`**: The name of the method being mocked.
- **`argument_types`**: The parameter list in parentheses; if the parameters include commas, surround the whole argument list with an extra pair of parentheses.
- **`optional_qualifiers`**: Qualifiers such as `(const)`, `(override)`, `(noexcept)`, or combinations like `(const, override)`.


---

## Example: Basic Mock Class

Given an interface:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};
```

You define its mock class like this:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

### Notes:
- The destructor in the base class should be virtual.
- All mock methods must be declared `public:` regardless of the access level in the original interface to allow `ON_CALL` and `EXPECT_CALL` macros to access them.
- Use `(override)` to catch any mismatches during compilation.

---

## Qualifiers and Modifiers in Mock Methods

You can use the following qualifiers in the fourth argument parentheses:

| Qualifier                  | Meaning                                                    |
|----------------------------|------------------------------------------------------------|
| `const`                    | Marks the method as a `const` method.                       |
| `override`                 | Marks the method as overriding a `virtual` method.         |
| `noexcept`                 | Marks the method as `noexcept`. Required if overriding such.|
| `Calltype(X)`              | Specifies calling convention, e.g., `Calltype(STDMETHODCALLTYPE)`. Useful on Windows.|
| `ref(&)` or `ref(&&)`      | Adds reference qualifiers for lvalue or rvalue references. |

Example for a const and override mock method:

```cpp
MOCK_METHOD(int, GetValue, (), (const, override));
```

### Commas in Arguments

If your return type or arguments have commas (e.g., template types like `std::pair<bool, int>`), you must wrap those types in parentheses or use type aliases to avoid parsing errors.

```cpp
// This won't compile:
MOCK_METHOD(std::pair<bool, int>, GetPair, ());

// Solutions:
MOCK_METHOD((std::pair<bool, int>), GetPair, ());

using BoolInt = std::pair<bool, int>;
MOCK_METHOD(BoolInt, GetPair, ());
```

---

## Mocking Overloaded Methods

You can mock overloaded functions by declaring all overloaded versions you want to mock, each with the correct signature:

```cpp
class Foo {
 public:
  virtual ~Foo();

  virtual int Add(int x);
  virtual int Add(int times, int x);

  virtual Bar& GetBar();
  virtual const Bar& GetBar() const;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));

  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

If you don't mock all versions of the overload, make sure to bring hidden base class overloads into scope with `using`:

```cpp
class MockFoo : public Foo {
  public:
    using Foo::Add;  // Bring other overloads into scope
    MOCK_METHOD(int, Add, (int x), (override));
};
```

---

## Mocking Class Templates

Mock class templates work like normal classes:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

---

## How to Use Mock Objects

1. **Import gMock names:** Usually `using ::testing::...;`.
2. **Create mock objects:** Instantiate your mock classes.
3. **Set behaviors and expectations:** Use `ON_CALL()` for default behaviors and `EXPECT_CALL()` for expected calls.
4. **Exercise code under test:** Run your tests that interact with the mocks.
5. **Automatic verification:** When mocks are destructed, expectations are automatically verified.

Example:

```cpp
using ::testing::Return;

TEST(ExampleTest, Basic) {
  MockFoo mock_foo;

  ON_CALL(mock_foo, GetSize()).WillByDefault(Return(10));
  EXPECT_CALL(mock_foo, Process(_, 5)).Times(1).WillOnce(Return(true));

  // Code under test uses mock_foo
}
```

---

## Additional Mock Types

GoogleMock supports variants of mock objects with different handling for uninteresting calls:

- **NiceMock<T>**: Suppresses warnings on uninteresting calls.
- **NaggyMock<T>**: (default) Warns on uninteresting calls.
- **StrictMock<T>**: Treats uninteresting calls as test failures.

Usage:

```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_mock;
StrictMock<MockFoo> strict_mock;
```

---

## Common Pitfalls and Best Practices

- Always declare mock methods in the `public` section.
- Make sure the base class destructor is virtual.
- Use `override` to catch method signature mismatches early.
- Wrap complex argument types containing commas in extra parentheses or use type aliases.
- Set expectations **before** exercising code under test.
- Use `RetiresOnSaturation()` if multiple expectations on the same method exist and some should deactivate after use.
- Avoid mocking non-virtual methods unless using specific patterns (see [Mocking Non-virtual Methods](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md#MockingNonVirtualMethods)).

---

## Summary

Defining mock objects in GoogleMock hinges on using the `MOCK_METHOD` macro correctly in mock classes derived from interfaces. Qualifiers like `const`, `override`, and `noexcept` are crucial for signature matching. Overloaded and templated methods are fully supported, with straightforward mechanisms to disambiguate. Variations of mocks (`NiceMock`, `NaggyMock`, and `StrictMock`) allow tuning warning and failure behavior for uninteresting calls. Follow best practices to prevent common errors and ensure robust test designs.

---

## See Also

- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [Mocking Reference](https://github.com/google/googletest/blob/main/docs/reference/mocking.md)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [Writing and Running Your First Test](../../guides/getting-started/writing-your-first-test)
- [Setting Expectations & Call Strictness](../mocking-apis/expectations-and-strictness)

<Tip>
Remember, defining robust mock classes early in your testing workflow helps decrease test maintenance overhead and increases confidence in your unit tests as your project evolves.
</Tip>
