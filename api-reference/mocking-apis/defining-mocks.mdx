---
title: "Defining and Using Mocks"
description: "Guides users through defining mock classes and methods, leveraging macros for easy setup, and integrating mocks into tests. Focuses on standard workflows and code annotation best practices."
---

# Defining and Using Mocks

GoogleMock (gMock) is a powerful C++ mocking framework that simplifies creating mock classes, setting expectations, and verifying behaviors in tests. This guide walks you through the process of defining mock classes using macros, setting up expectations on methods, and integrating them seamlessly into your unit testing workflows with GoogleTest.

---

## Overview of Mock Definition

Mocks are specialized test doubles that let you specify expected interactions with an object’s methods during tests. With gMock, you define mock classes by subclassing the interface or base class and use simple macros to generate mocked methods. These mocks help you:

- Specify how many times methods should be called
- Specify argument constraints on method calls
- Define default behaviors or custom return values
- Verify interactions automatically when tests finish

---

## Defining a Mock Class

The heart of GoogleMock's power lies in how you define your mock classes. Here’s the standard workflow:

1. **Derive your mock class from the interface or base class** you want to mock.
2. **Use `MOCK_METHOD` macros** inside the public section to declare mock methods.
3. Add any constructors or helper methods as needed.

### Basic Mocking Example

Suppose you have a simple interface:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};
```

You define a corresponding mock class as:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

- The macro `MOCK_METHOD` takes the return type, method name, parameter list, and optionally qualifiers like `const` and `override`.
- You place `MOCK_METHOD` declarations in the `public` section, **regardless of the access specifier in the base class**.


### Notes on Macro Usage

- **Function qualifiers**: Add `(const, override)` or `(override)` as needed.
- **Embedded commas**: For parameter or return types with commas (e.g., `std::pair<int, int>` or `std::map`), wrap them in parentheses to avoid parsing errors, or use type aliases.

Example:

```cpp
MOCK_METHOD((std::pair<int, int>), GetPair, ());
MOCK_METHOD(bool, CheckMap, ((std::map<int, double>)), ());
```

---

## Types of Mocks: Nice, Naggy, and Strict

GoogleMock provides convenient wrappers to control the strictness of mocks regarding uninteresting calls (calls to methods without explicit expectations):

| Mock Type             | Description                                                  |
|----------------------|--------------------------------------------------------------|
| `NiceMock<T>`        | Suppresses warnings on uninteresting calls.                  |
| `NaggyMock<T>`       | Prints warnings on uninteresting calls (the default).        |
| `StrictMock<T>`      | Treats uninteresting calls as failures, generating test errors. |

They are simple subclasses that inherit your mock class, altering how uninteresting calls are handled.

**Usage Example:**

```cpp
using ::testing::NiceMock;

NiceMock<MockFoo> nice_foo;  // No warnings on uninteresting calls
EXPECT_CALL(nice_foo, DoThis());
nice_foo.DoThis();
```

**Tip:** Generally, use `NiceMock` when you want fewer noise messages, and `StrictMock` when you want to tightly enforce that only expected calls occur.

---

## Mocking Class Templates

You can mock templates normally by following the same macro syntax, specifying the template parameter in the mock class:

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};

template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

---

## Typical Workflow to Use Mocks in Tests

1. **Include gMock symbols:**
   ```cpp
   using ::testing::Return;
   using ::testing::_;
   ```
2. **Create mock objects:**
   ```cpp
   MockFoo foo;
   ```
3. **Set default behaviors with `ON_CALL`:**
   ```cpp
   ON_CALL(foo, GetSize()).WillByDefault(Return(1));
   ```
4. **Set expectations with `EXPECT_CALL`:**
   ```cpp
   EXPECT_CALL(foo, Describe(5))
       .Times(3)
       .WillRepeatedly(Return("Info"));
   ```
5. **Exercise your code that uses the mock:**
   ```cpp
   EXPECT_EQ( "Info", MyFunctionUsingFoo(&foo) );
   ```
6. **Completion:**
   - Destruction of the mock object automatically verifies expectations.

### Simplified Example

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using ::testing::Return;
using ::testing::_;

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (int), (override));
};

TEST(ExampleTest, UsesMock) {
  MockFoo foo;

  ON_CALL(foo, GetSize()).WillByDefault(Return(10));

  EXPECT_CALL(foo, Describe(5)).Times(1).WillOnce(Return("Five"));

  EXPECT_EQ(10, foo.GetSize());
  EXPECT_EQ("Five", foo.Describe(5));
}
```

---

## Setting Expectations: Key Clauses

The `EXPECT_CALL` macro supports several clauses to control expectations:

| Clause                | Description                                                      |
| --------------------- | ----------------------------------------------------------------|
| `.Times(n)`           | Specifies expected number of calls (`0` means never called).      |
| `.WillOnce(action)`   | Specifies discrete behaviors for single invocations.             |
| `.WillRepeatedly(action)` | Behavior for all subsequent matching calls after `WillOnce`s.  |
| `.InSequence(seq...)` | Specifies call order among a group of expectations.               |
| `.RetiresOnSaturation()` | Retires the expectation after it’s saturated (no longer active).|
| `.With(matcher)`      | Matches all arguments as a tuple using matcher.                   |
| `.After(expectation...)` | Call must happen after other expectations.                      |

Examples:

```cpp
EXPECT_CALL(foo, DoThis(_))
    .Times(3)
    .WillOnce(Return(1))
    .WillRepeatedly(Return(2));
```

---

## Default Actions with `ON_CALL`

`ON_CALL` specifies default behavior for mock methods without setting calls expectations.

Example:

```cpp
ON_CALL(foo, GetSize()).WillByDefault(Return(42));
```

This means when `GetSize()` is called and no matching `EXPECT_CALL` is present, it returns 42.

---

## Notes and Best Practices

- Always define `EXPECT_CALL` **before** exercising the mock. Defining it afterward is undefined behavior.
- Use `_` matcher for arguments you don't care about.
- To reduce test brittleness, only specify the minimal necessary matchers and cardinalities.
- If your mock class has no virtual destructor, some behaviors (e.g., nice/strict mocks) may work incorrectly.
- Consider delegating to fakes or real objects if default behaviors are complex.
- `NiceMock`, `NaggyMock`, and `StrictMock` classes only work with mocks using macros directly in the class; base class mocks may not be affected.

---

## Troubleshooting Common Issues

- **Uninteresting calls warning:** Occurs when a mock method without `EXPECT_CALL` is invoked. Use `NiceMock` to suppress or explicitly handle calls with `EXPECT_CALL(...).Times(AnyNumber())`.
- **Unexpected call failures:** Your code is invoking methods with arguments not matched by any active expectation.
- **Call counts mismatch:** Review `Times()` clause to make sure the number of expected calls matches reality.
- **Ambiguous expectations for overloaded methods:** Use proper qualifiers or disambiguate with `Const()` or explicit matcher types.

---

## Summary

Defining and using mocks effectively is fundamental to writing maintainable, robust unit tests. By using `MOCK_METHOD` macros and the `EXPECT_CALL` and `ON_CALL` APIs, GoogleMock streamlines mocking workflows in C++. The wrappers `NiceMock`, `NaggyMock`, and `StrictMock` let you customize how strictly your tests treat uninteresting calls, balancing noise and strictness.

---

## Additional Resources

- [GoogleMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) – Quick reference for mocking macros and syntax.
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) – Friendly introduction with detailed examples.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) – Recipes for advanced mocking patterns.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) – Full macro and class reference for mocking.
- [Nice, Naggy, and Strict Mocks](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy) – Deep dive into mock strictness levels.

---

This guide fits within the broader GoogleTest and GoogleMock documentation, complementing guides on writing tests, assertion macros, and mocking workflows.

---

### Code Group: Basic Mock Example

<CodeGroup>
```cpp
// Mock class for interface Foo
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};
```
```cpp
// Sample test using MockFoo
TEST(MyTest, Sample) {
  MockFoo foo;

  ON_CALL(foo, GetSize()).WillByDefault(Return(10));
  EXPECT_CALL(foo, Describe(_)).Times(2);

  EXPECT_EQ(10, foo.GetSize());
  foo.Describe("Simple");
  foo.Describe("Example");
}
```
</CodeGroup>

---

### Tips

<Tip>
For large interfaces or complex mocks, define simpler adaptor interfaces and mock those to reduce test maintenance overhead.
</Tip>

<Tip>
Use `RetiresOnSaturation()` for expectations that should become inactive after reaching the expected call count, to avoid sticky expectation pitfalls.
</Tip>

<Tip>
Always tear down dynamically allocated mocks properly or register them as leaks if intentionally kept to avoid false positives.
</Tip>
