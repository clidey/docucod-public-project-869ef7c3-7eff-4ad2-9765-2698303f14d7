---
title: "Defining and Using Mocks"
description: "Guidance and API reference on defining mock classes and methods using the provided macros and utilities. Covers support for various method signatures, constness, and advanced overrides."
---

# Defining and Using Mocks in GoogleMock

GoogleMock is a powerful C++ framework designed to help you create mock classes and methods easily. By defining mocks, you gain precise control over how objects in your tests behave and what interactions they expect, enabling effective unit testing of complex systems.

This document outlines how to define mock classes with the `MOCK_METHOD` macro, specify the expected behavior and call sequences, handle constness and overloads, and advanced topics like delegating calls, default actions, cardinalities, and strictness.

---

## Defining Mock Classes

Mock classes are normal C++ classes that inherit from interfaces or base classes whose behavior you want to simulate in tests. GoogleMock provides the `MOCK_METHOD` macro to generate mock implementations for virtual methods conveniently.

### Basic Mock Method Definition

Use `MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (Qualifiers));` inside the `public:` section of your mock class:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual bool Process(int count, double value) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int count, double value), (override));
};
```

**Key Points:**
- Place all `MOCK_METHOD` declarations in `public:` regardless of base method visibility.
- Specify qualifiers like `const`, `override`, or `noexcept` explicitly.
- The macro creates methods that override the virtual methods of the base class.

### Handling Commas and Complex Types
Sometimes argument or return types contain commas, such as template arguments. To handle these gracefully:

- Wrap the entire type in extra parentheses to disambiguate.
- Alternatively, use `using` aliases to simplify types.

Example:

```cpp
using BoolAndInt = std::pair<bool, int>;
using MapIntDouble = std::map<int, double>;

class MockFoo {
 public:
  MOCK_METHOD((BoolAndInt), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((MapIntDouble), bool));
};
```


### Mocking Overloaded Methods

Define a mock method for **each overload** you want to simulate. Use the same signature with the right qualifiers:

```cpp
class Base {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int times, int x) = 0;
  virtual const std::string& GetName() const = 0;
  virtual std::string& GetName() = 0;
};

class MockBase : public Base {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
  MOCK_METHOD(const std::string&, GetName, (), (const, override));
  MOCK_METHOD(std::string&, GetName, (), (override));
};
```

If you mock only some overloads, use `using` declarations to bring the base versions into scope and avoid hiding:

```cpp
class MockBase : public Base {
 public:
  using Base::Add;  // Avoid hiding other overloads
  MOCK_METHOD(int, Add, (int x), (override));
};
```

### Mocking Class Templates

You can mock class templates similarly by defining a template mock class:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual void Push(const T& x) = 0;
  virtual int Size() const = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(void, Push, (const T& x), (override));
  MOCK_METHOD(int, Size, (), (const, override));
};
```


---

## Setting Expectations and Behaviors

Mocks can be configured to expect certain calls with specified arguments, order, call counts, and behaviors.

### `EXPECT_CALL` for Setting Expectations

`EXPECT_CALL(mock_object, Method(matchers...))` declares the expectation that `Method` will be called with arguments satisfying the provided matchers. This must be declared **before** exercising the object:

```cpp
using ::testing::Return;
using ::testing::_;

MockFoo foo;
EXPECT_CALL(foo, Describe("test"))
    .Times(3)
    .WillRepeatedly(Return("description"));

// Code exercising foo ...
```


Key modifier clauses (used in this order):

- `.With(multi_argument_matcher)`: Match all method arguments as a tuple.
- `.Times(cardinality)`: Specify expected number of calls (`Exactly(n)`, `AtLeast(n)`, etc).
- `.InSequence(seq...)`: Enforce call ordering within sequences.
- `.After(expectations...)`: Specify dependencies for partial ordering.
- `.WillOnce(action)`: Set behavior for one call, repeated for multiple `WillOnce`.
- `.WillRepeatedly(action)`: Set behavior for all subsequent calls after `WillOnce`s.
- `.RetiresOnSaturation()`: Disable expectation after its call count is met.


Example with multiple behaviors:

```cpp
EXPECT_CALL(foo, GetSize())
    .WillOnce(Return(1))
    .WillOnce(Return(2))
    .WillRepeatedly(Return(3));
```

This configures `GetSize()` to return 1, then 2, then 3 thereafter.

### `ON_CALL` for Setting Default Actions

`ON_CALL(mock_object, Method(matchers...))` configures default **behavior** without setting an expectation that the method will be called.

```cpp
ON_CALL(foo, Describe(_))
    .WillByDefault(Return("default description"));
```

This means that calls to `Describe` with any arguments will return "default description" unless an overriding `EXPECT_CALL` applies.


### Matchers and Arguments

- Use explicit matchers like `_` (wildcard), `Eq(value)`, `Lt(value)`, or custom matchers.
- Combine matchers with `AllOf()`, `AnyOf()`, `Not()`, `Field()`, and `Property()`.
- For overloaded methods, help disambiguate calls with `Const()` or type-specific helpers.

### Cardinalities (Call Counts)

Partial list of cardinalities:

| Cardinality   | Meaning                                   |
|---------------|-------------------------------------------|
| `AnyNumber()` | May be called any number of times         |
| `Exactly(n)`  | Must be called exactly n times             |
| `AtLeast(n)`  | Must be called at least n times            |
| `AtMost(n)`   | Must be called at most n times             |
| `Between(m,n)`| Must be called between m and n times       |

If omitted, inferred from `WillOnce` and `WillRepeatedly` clauses.

### Controlling Call Order

Use `InSequence` blocks or `Sequence` objects combined with `.InSequence()` on expectations to enforce strict call order.

```cpp
Sequence s1, s2;
EXPECT_CALL(foo, Reset()).InSequence(s1, s2);
EXPECT_CALL(foo, Step1()).InSequence(s1);
EXPECT_CALL(foo, Step2()).InSequence(s2);
```

Alternatively, specify partial orders with `.After()`:

```cpp
Expectation e1 = EXPECT_CALL(foo, Init1());
Expectation e2 = EXPECT_CALL(foo, Init2());
EXPECT_CALL(foo, Run()).After(e1, e2);
```

### Specifying Behavior with Actions

Available built-in actions include:

- `Return(value)`: Return a fixed value.
- `ReturnRef(var)`: Return a reference.
- `ReturnPointee(ptr)`: Return the value pointed to by a pointer.
- `SetArgPointee<N>(value)`: Set the N-th argument's pointee.
- `Invoke(func)`: Call a function, lambda, or functor.
- `DoAll(action1, action2, ...)`: Perform multiple actions sequentially.

You can combine or chain actions to define complex behavior.

---

## Advanced Mocking Topics

### Nice, Naggy, and Strict Mocks

- **NiceMock** suppresses warnings on uninteresting calls (calls without expectations).
- **NaggyMock** (default) warns on uninteresting calls.
- **StrictMock** treats uninteresting calls as test failures.

Example:

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> nice_foo;
EXPECT_CALL(nice_foo, DoSomething());
``` 

### Mocking Move-Only Types

GoogleMock supports methods that accept or return non-copyable move-only types like `std::unique_ptr`. Just use `MOCK_METHOD` normally. Use lambdas or functors with `WillOnce`/`WillRepeatedly` to provide meaningful behavior with move-only types.

Example:

```cpp
class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));
};

EXPECT_CALL(mock_buzzer, MakeBuzz("hello"))
    .WillOnce(Return(std::make_unique<Buzz>(AccessLevel::kInternal)));
```

### Delegating Calls to Fake or Real Objects

Mocks can delegate method calls to real or fake implementations using `ON_CALL`:

```cpp
ON_CALL(*this, DoThis).WillByDefault([this](int n) {
  return fake_.DoThis(n);
});
```

This delegates the behavior to `fake_` while allowing verification with the mock.

### Verifying and Clearing Expectations Explicitly

You can force verification of a mock object before it is destroyed:

```cpp
ASSERT_TRUE(::testing::Mock::VerifyAndClearExpectations(&mock_obj));
```

Do not set new expectations after verifying and clearing.

### Setting Up Retiring Expectations

Use `.RetiresOnSaturation()` to retire an expectation after its call count is saturated. This allows subsequent calls to match other expectations (useful for overloaded or fallback expectations).

### Using `MockFunction` for Std Function Callbacks

`MockFunction` lets you mock plain `std::function` callback types by providing a single mock method `Call()`.

Example:

```cpp
MockFunction<int(std::string)> mock_func;
EXPECT_CALL(mock_func, Call("test"))
    .WillOnce(Return(42));
auto callback = mock_func.AsStdFunction();
```

---

## Troubleshooting and Best Practices

- Always set expectations before calling mock methods.
- Use `EXPECT_CALL` sparingly to prevent brittle tests; prefer `ON_CALL` for default behavior.
- For complex expectations, compose matchers carefully and use `With()` for multi-argument conditions.
- Use `InSequence` or `After` to specify call order.
- `NiceMock` is recommended to suppress spurious warnings during development.
- Mock destructors by adding a mock method (e.g. `Die()`) called from your destructor.
- Avoid mocking non-virtual methods unless using advanced techniques.
- Remember, mocks verify expectations during destruction unless explicitly verified earlier.

---

## Summary

GoogleMock simplifies C++ mocking by generating mock classes and methods with `MOCK_METHOD`. Expectations are set with `EXPECT_CALL` and default behaviors with `ON_CALL`. The framework supports const and overloaded methods, class templates, move-only types, and flexible call order constraints. Strictness levels (`NiceMock`, `StrictMock`) control warning and failure behaviors for unexpected or uninteresting calls.

For comprehensive workflows, best practices, and advanced usage, explore the [gMock Cookbook](../gmock_cook_book.md), [gMock for Dummies](../gmock_for_dummies.md), and the [Mocking Reference](reference/mocking.md).

---

<AccordionGroup title="Key Code Examples and Patterns">
<Accordion title="Mock Class Definition">
```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int count, double value), (override));
};
```
</Accordion>
<Accordion title="Setting Expectations with EXPECT_CALL">
```cpp
EXPECT_CALL(mock_foo, GetSize())
    .Times(3)
    .WillRepeatedly(Return(42));
```
</Accordion>
<Accordion title="Using Sequences for Call Order">
```cpp
Sequence s1;
EXPECT_CALL(foo, Init()).InSequence(s1);
EXPECT_CALL(foo, Run()).InSequence(s1);
```
</Accordion>
<Accordion title="Delegating to a Fake Object">
```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(char, DoThis, (int n), (override));

  void DelegateToFake() {
    ON_CALL(*this, DoThis).WillByDefault([this](int n) {
      return fake_.DoThis(n);
    });
  }

 private:
  FakeFoo fake_;
};
```
</Accordion>
<Accordion title="Mocking Move-Only Types">
```cpp
class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));
};

EXPECT_CALL(mock_buzzer, MakeBuzz("hello"))
    .WillOnce(Return(std::make_unique<Buzz>(AccessLevel::kInternal)));
```
</Accordion>
</AccordionGroup>
