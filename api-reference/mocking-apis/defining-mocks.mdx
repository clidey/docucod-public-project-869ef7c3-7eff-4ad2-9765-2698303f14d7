---
title: "Mock Object and Method Definition"
description: "Step-by-step guidance on declaring mock classes and methods using GoogleMock's macros. Includes the usage of MOCK_METHOD and its variants to mock functions and methods with flexible argument and return type configurations."
---

# Mock Object and Method Definition

GoogleMock (gMock) enables you to declare mock classes and methods easily to support interaction-based testing in C++. This page offers step-by-step guidance on defining mock classes and their methods using gMock macros, emphasizing the practical usage of the powerful `MOCK_METHOD` macro and its variants. By following these guidelines, you will create robust, expressive mocks that integrate seamlessly with your test workflows.

---

## Introduction to Mock Classes

A **mock class** is a C++ class that simulates the behavior of a real class or interface, allowing you to control and verify method calls during testing. GoogleMock automates much of the boilerplate by generating the necessary code from succinct macro invocations.

To define a mock class:

- Derive from the base class or interface you want to mock.
- Use the `MOCK_METHOD` macro to declare mock methods that override virtual methods.
- Place all `MOCK_METHOD` declarations in the `public:` section of your mock class, regardless of the base method's visibility. This permits testing frameworks to access them for setting expectations and default actions.

Example mock class definition:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

---

## Using `MOCK_METHOD`

The `MOCK_METHOD` macro is the cornerstone for declaring mock methods. It closely follows the natural C++ method declaration split into parts:

```cpp
MOCK_METHOD(ReturnType, MethodName, (ArgumentTypes...), (Qualifiers...));
```

- **`ReturnType`**: The return type of the mocked method.
- **`MethodName`**: The name of the method to mock.
- **`ArgumentTypes...`**: The types and names of parameters in parentheses (`()`), including commas protected inside parentheses.
- **`Qualifiers...`**: Optional method qualifiers such as `const`, `override`, `noexcept`, calling conventions, and reference qualifiers.

### Key Points

- Must be declared in the `public` section.
- If the method overrides a virtual method with any qualifiers, include them to ensure correct overriding (`const`, `override`, `noexcept`, etc.).
- When argument or return types contain commas (e.g., `std::pair<int, int>`), wrap the type in parentheses or use a *type alias* to avoid macro parsing errors.

### Examples

```cpp
class MockFoo {
 public:
  // Simple mocking of a method returning void with no arguments
  MOCK_METHOD(void, DoThis, (), (override));

  // Method returning int with one boolean argument
  MOCK_METHOD(int, DoThat, (bool flag), (override));

  // For types with commas in the signature, wrap with parentheses or use typedef
  MOCK_METHOD((std::pair<int, int>), GetPair, (), (override));

  using MapType = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (MapType, bool), (override));

  // Const method
  MOCK_METHOD(int, GetSize, (), (const, override));

  // noexcept method
  MOCK_METHOD(void, Clear, (), (noexcept, override));

  // Method with reference qualifiers
  MOCK_METHOD(int, RefMethod, (), (ref(&), override));
};
```

---

## Overloaded and Template Methods

GoogleMock handles overloaded methods and template classes naturally:

- Declare mock methods matching each overload you want to mock.
- If some overloads are not mocked, bring them into scope using `using BaseClass::MethodName;` to avoid hiding.
- For template classes, follow the same syntax; add `(override)` to each mocked virtual method.

Example:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

---

## Mocking Non-Virtual Methods

Directly mocking non-virtual or free functions is not supported because polymorphism is required. Instead, you can:

- Encapsulate non-virtual functions into interfaces with virtual methods.
- Use dependency injection with interfaces.
- Use the `MOCK_METHOD` macro to declare virtual methods that wrap or replace the non-virtual functionality.

For high-performance cases, you can mock non-virtual methods in unrelated mock classes with matching signatures and template your code to accept them.

---

## Old-Style `MOCK_METHODn` Macros

GoogleMock historically provided `MOCK_METHODn` family for each number of arguments. They are still supported but are deprecated in favor of `MOCK_METHOD` which is clearer.

Legacy to modern mapping:

| Legacy                             | Modern Syntax                                     |
|-----------------------------------|--------------------------------------------------|
| `MOCK_METHOD1(Foo, bool(int))`    | `MOCK_METHOD(bool, Foo, (int))`                   |
| `MOCK_CONST_METHOD1(Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (const))`       |

Avoid using these macros in new code.

---

## Handling Unprotected Commas in Types

Unprotected commas in argument or return types confuse the `MOCK_METHOD` macro. Fixes:

- Wrap the entire return or argument type in extra parentheses.
- Declare type aliases (`using`) before the mock class and use those aliases.

Example:

```cpp
using BoolAndInt = std::pair<bool, int>;

class MockExample {
 public:
  MOCK_METHOD(BoolAndInt, GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
};
```

---

## Nice, Strict, and Naggy Mocks

GoogleMock provides wrappers that modify how uninteresting calls (calls with no expectations) are handled:

- `NiceMock<T>`: Suppresses warnings on uninteresting calls. Use when you want to ignore irrelevant calls to ease test maintenance.
- `NaggyMock<T>`: The default behavior. Prints warnings on uninteresting calls.
- `StrictMock<T>`: Treats all uninteresting calls as failures, making tests strict about unintended calls.

These are subclasses of your mock class `T` and inherit all constructors, so you can construct like `NiceMock<MockFoo> nice(ctor_args...)`.

**Example:**

```cpp
using ::testing::NiceMock;

NiceMock<MockFoo> nice_mock;
EXPECT_CALL(nice_mock, ImportantMethod());
```

**Important Caveats:**

- Applies only to mock methods declared directly in the mock class.
- Nesting strictness wrappers like `NiceMock<StrictMock<MockFoo>>` is not supported.
- Virtual destructors are recommended for proper behavior.

---

## Mocking Destructors

You cannot mock destructors directly using `MOCK_METHOD`. To test when a mock's destructor is called, use the recommended pattern:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() override { Die(); }
};
```

Then you can set expectations on `Die()` to verify destruction order, sequences, or behavior.

---

## Best Practices and Tips

- **Define mocks in a separate header and source file**: This speeds up compilation and isolates mock changes.
- **Set expectations before exercising code**: `EXPECT_CALL` must be called before the mock methods are used.
- **Use `ON_CALL` to specify default actions without imposing expectations**.
- **Prefer `NiceMock` for most cases** to reduce noise, use `StrictMock` when strict verification is needed.
- **Avoid over-specifying matchers and times** to keep tests maintainable.
- **When mocking complicated interfaces, consider adapting or delegating to fakes or real objects.**

For complex mocking scenarios, see the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html).

---

## Example: Defining a Complex Mock Class

```cpp
class MockBar {
 public:
  explicit MockBar(const std::string& s) : str_(s) {}

  MOCK_METHOD(int, This, (), ());
  MOCK_METHOD(std::string, That, (int x, bool flag), ());

  const std::string& str() const { return str_; }

 private:
  std::string str_;
  MockBar(const MockBar&) = delete;
  MockBar& operator=(const MockBar&) = delete;
};

// Usage
MockBar bar("hello");
EXPECT_CALL(bar, This()).WillOnce(Return(42));
int value = bar.This();  // Returns 42
```

---

## Summary

Defining mock classes and methods with GoogleMock is streamlined and expressive thanks to `MOCK_METHOD`. Understanding the syntax, qualifiers, and nuances around qualifiers and overloads is essential for creating effective mocks. Additionally, controlling the behavior of uninteresting calls with `NiceMock`, `StrictMock`, and `NaggyMock` empowers you to tune your mocks to your testing needs.

By following the best practices detailed here, you ensure your tests are reliable, maintainable, and insightful.

---

For additional insights and detailed recipes on advanced mocking techniques, consult the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) and the official [Mocking Reference](reference/mocking.md).


<AccordionGroup title="Mock Object and Method Definition Examples">
<Accordion title="Simple Mock Class Example">
```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```
</Accordion>
<Accordion title="Mocking Overloaded Methods">
```cpp
class Foo {
 public:
  virtual int Add(int x);
  virtual int Add(int x, int y);
  virtual ~Foo();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int), (override));
  MOCK_METHOD(int, Add, (int, int), (override));
  using Foo::Add;  // Bring non-mocked overloads into scope if needed
};
```
</Accordion>
<Accordion title="Non-Virtual Method Mocking">
Directly mocking non-virtual methods is not supported. Instead, consider refactoring:

```cpp
class FileInterface {
 public:
  virtual bool Open(const char* path, const char* mode) = 0;
};

class File : public FileInterface {
 public:
  bool Open(const char* path, const char* mode) override {
    return OpenFile(path, mode);
  }
};

class MockFile : public FileInterface {
 public:
  MOCK_METHOD(bool, Open, (const char* path, const char* mode), (override));
};
```
</Accordion>
<Accordion title="Nice, Naggy, and Strict Mock Usage">
```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_mock;  // Suppresses uninteresting call warnings
StrictMock<MockFoo> strict_mock;  // Fails on uninteresting calls
```
</Accordion>
</AccordionGroup>


<Note>
Always ensure mock class destructors are virtual to avoid memory leaks and undefined behavior.
</Note>

<Warning>
When argument or return types include commas, wrap them in parentheses or use type aliases to avoid compiler errors.
</Warning>

<Tip>
Use `NiceMock` as the default to minimize noisy warnings and reserve `StrictMock` for scenarios where uninteresting calls are errors.
</Tip>

---

# References

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [Mocking Reference](reference/mocking.md)
- [GoogleMock GitHub Repository](https://github.com/google/googletest)

---

# Source

<Source url="https://github.com/google/googletest" paths={[{"path":"googlemock/include/gmock/gmock.h","range":"1-100"},{"path":"googlemock/docs/gmock_cook_book.md","range":"1-500"}]} />