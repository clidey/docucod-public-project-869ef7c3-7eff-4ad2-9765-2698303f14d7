---
title: "Argument Matchers"
description: "Provides a detailed reference for argument matchers—both standard and custom—for verifying the values passed to mock methods. Illustrates patterns for flexible and expressive call verification."
---

# Argument Matchers

This page provides a detailed reference on *argument matchers* in GoogleMock, the mechanism used to verify values passed to mock methods. Matchers empower you to write expressive and flexible expectations that validate how your code under test interacts with mocks. Whether matching exact values, ranges, or complex conditions, argument matchers help you build precise and robust unit tests.

---

## Overview of Argument Matchers

Argument matchers in gMock are function objects used inside `EXPECT_CALL()` and `ON_CALL()` macros to specify how arguments to mock methods should be checked. They allow you to:

- Validate exact or partial properties of arguments.
- Match arguments flexibly using wildcards and predicates.
- Compose matchers to express complex constraints.

Matchers can be built-in ones, user-defined custom matchers, or matchers composed from simpler matchers.


## Using Argument Matchers

When you write an expectation such as:

```cpp
EXPECT_CALL(mock_obj, MethodName(matcher1, matcher2));
```

`matcher1` and `matcher2` describe what arguments are expected. If an argument matches the matcher, the expectation applies.


## Categories of Matchers

### Wildcard Matchers

| Matcher                           | Description                                       |
| -------------------------------- | ------------------------------------------------ |
| `_`                              | Matches anything. The argument can be any value of the correct type. |
| `A<type>()` or `An<type>()`      | Matches any value of the specified type `type`.                      |

Example:

```cpp
EXPECT_CALL(foo, DoSomething(_)); // Any argument
EXPECT_CALL(bar, Process(An<int>())); // Any int argument
```


### Generic Comparison Matchers

These match argument values by applying standard comparisons:

| Matcher          | Meaning                                                       |
| ---------------- | ------------------------------------------------------------- |
| `Eq(value)`      | Argument == value                                              |
| `Ne(value)`      | Argument != value                                              |
| `Gt(value)`      | Argument > value                                               |
| `Ge(value)`      | Argument >= value                                              |
| `Lt(value)`      | Argument < value                                               |
| `Le(value)`      | Argument <= value                                              |
| `IsTrue()`       | Argument evaluates to true                                     |
| `IsFalse()`      | Argument evaluates to false                                    |
| `IsNull()`       | Argument is a null pointer (raw or smart)                      |
| `NotNull()`      | Argument is non-null pointer (raw or smart)                    |
| `Optional(m)`    | For an `optional<>` argument, the contained value matches `m` |
| `Ref(variable)`  | Argument is a reference to `variable`                         |
| `TypedEq<T>(value)` | Argument of type `T` equal to `value`                        |

*Note:* `Ref()` matches reference identity and is helpful when you want to ensure that the exact object instance is passed.

Example:

```cpp
EXPECT_CALL(foo, Bar(Eq(10)));          // Matches argument == 10
EXPECT_CALL(foo, Baz(NotNull()));      // Matches any non-null pointer
EXPECT_CALL(foo, SetValue(Ref(my_var))); // Matches call with reference to my_var
```


### Floating-Point Matchers

Floating-point values can be matched approximately, accounting for small rounding errors.

| Matcher                         | Description                                                               |
| ------------------------------- | ------------------------------------------------------------------------- |
| `DoubleEq(value)`               | Approximate equality for `double` (excluding NaNs as equal)               |
| `FloatEq(value)`                | Approximate equality for `float` (excluding NaNs as equal)                |
| `NanSensitiveDoubleEq(value)`  | Approximate equality for `double`, treating NaNs as equal                |
| `NanSensitiveFloatEq(value)`   | Approximate equality for `float`, treating NaNs as equal                 |
| `DoubleNear(value, max_error)` | Equality with max absolute error tolerance for `double`                 |
| `FloatNear(value, max_error)`  | Equality with max absolute error tolerance for `float`                  |

Example:

```cpp
EXPECT_CALL(foo, Compute(DoubleEq(3.14)));
EXPECT_CALL(bar, SetThreshold(FloatNear(1.5, 0.001)));
```


### String Matchers

You can match strings (C strings, C++ `std::string`, or compatible types) with:

| Matcher                      | Description                                         |
| ---------------------------- | --------------------------------------------------- |
| `StrEq(string)`              | Exact equality                                      |
| `StrNe(string)`              | Not equal                                          |
| `StrCaseEq(string)`          | Equality ignoring case                             |
| `StrCaseNe(string)`          | Inequality ignoring case                           |
| `HasSubstr(string)`          | Contains substring                                 |
| `StartsWith(prefix)`         | Starts with the prefix                             |
| `EndsWith(suffix)`           | Ends with the suffix                               |
| `MatchesRegex(regex)`        | Matches entire string using regex                  |
| `ContainsRegex(regex)`       | Contains substring matching regex                  |
| `IsEmpty()`                  | Is empty string                                    |
| `WhenBase64Unescaped(matcher)` | Treats argument as unescaped base64, matches resulting string          |

Example:

```cpp
EXPECT_CALL(foo, Print(StrEq("Hello")));
EXPECT_CALL(bar, Validate(HasSubstr("error")));
EXPECT_CALL(baz, Fetch(MatchesRegex("\d+")));
```


### Container Matchers

Matchers specially designed to verify STL-style containers:

| Matcher                        | Description                                                    |
| ------------------------------ | -------------------------------------------------------------- |
| `Contains(value|matcher)`      | Container contains at least one element matching the matcher/value |
| `Each(matcher)`                | All elements of container match the matcher                   |
| `ElementsAre(...)`             | Match elements in order with given matchers                   |
| `ElementsAreArray(...)`        | Like `ElementsAre()`, from array/container/initializer list    |
| `UnorderedElementsAre(...)`    | Like `ElementsAre()`, but elements can be in any order        |
| `UnorderedElementsAreArray(...)` | Like `UnorderedElementsAre()`, from array/container/initializer list |
| `SizeIs(matcher)`              | Container size matches                                             |
| `IsEmpty()`                   | Container is empty                                            |
| `IsSubsetOf(...)`             | Container is subset of expected elements                      |
| `IsSupersetOf(...)`           | Container is superset of expected elements                    |
| `Pointwise(matcher, container)` | Element-wise matching against container                       |
| `UnorderedPointwise(matcher, container)` | Like `Pointwise`, ignores order                            |

Example:

```cpp
EXPECT_CALL(foo, ProcessData(ElementsAre(1, Gt(2), _)));
EXPECT_CALL(bar, HandleMap(UnorderedElementsAre(Pair(42, "Answer"))));
EXPECT_CALL(baz, Store(Each(Gt(0))));
```


### Member Matchers

You can match a member or property of an argument object with these:

| Matcher                                      | Description                                        |
| -------------------------------------------- | ------------------------------------------------- |
| `Field(&Class::field, matcher)`               | Matches if `argument.field` (or `argument->field`) matches `matcher` |
| `Field(name, &Class::field, matcher)`         | Same as above, with custom name for error messages    |
| `Property(&Class::method, matcher)`            | Matches if `argument.method()` matches matcher        |
| `Property(name, &Class::method, matcher)`      | Same as above, with custom name for error messages    |
| `Key(matcher)`                                | Matches if `argument.first` matches matcher            |
| `Pair(matcher1, matcher2)`                     | Matches if `argument.first` and `argument.second` match matchers |
| `FieldsAre(matcher...)`                        | Matches tuple-like object field-wise                     |

Example:

```cpp
EXPECT_CALL(foo, Update(Field(&MyClass::number, Ge(3))));
EXPECT_CALL(foo, Render(Property(&Window::title, StartsWith("Error"))));
EXPECT_CALL(foo, Insert(Key(Eq(42))));
EXPECT_CALL(foo, SetPair(Pair(_, Lt(0))));
```


### Matching the Result of a Function or Callback

You can match the result of a callable applied to the argument:

| Matcher                                | Description                                         |
| ------------------------------------- | --------------------------------------------------- |
| `ResultOf(f, matcher)`                 | Matches if `f(argument)` matches `matcher`           |
| `ResultOf(description, f, matcher)`   | Same as above, using description in error messages   |

Example:

```cpp
EXPECT_CALL(foo, DoSomething(ResultOf(&foo.GetName, StrEq("John"))));
```


### Pointer Matchers

Matching pointers and what they point to:

| Matcher                            | Description                                   |
| ---------------------------------- | --------------------------------------------- |
| `IsNull()`                        | Matches `NULL` pointers (raw and smart)        |
| `NotNull()`                      | Matches non-NULL pointers (raw and smart)      |
| `Pointer(matcher)`               | Matches pointer value against matcher          |
| `Pointee(matcher)`              | Matches the value pointed to by pointer matches matcher |
| `Address(matcher)`              | Matches whether `&argument` matches matcher     |
| `WhenDynamicCastTo<T>(matcher)` | Matches if `dynamic_cast<T>(argument)` matches matcher |

You can combine `Pointee` multiple times to match deeply nested pointers.

Example:

```cpp
EXPECT_CALL(foo, Save(Pointee(Gt(0))));
EXPECT_CALL(bar, SetPtr(Address(Ne(nullptr))));
EXPECT_CALL(baz, CastedPtr(WhenDynamicCastTo<Derived*>(NotNull())));
```


## Composing and Combining Matchers

Matchers can be combined to express compound conditions:

| Matcher                              | Description                                |
| ----------------------------------- | ------------------------------------------ |
| `AllOf(m1, m2, ..., mn)`            | Matches if *all* `m1` to `mn` match       |
| `AnyOf(m1, m2, ..., mn)`            | Matches if *any* of `m1` to `mn` match    |
| `Not(m)`                           | Matches if `m` does not match               |
| `Conditional(cond, m1, m2)`         | Matches `m1` if `cond` is true, otherwise `m2` |

Example:

```cpp
EXPECT_CALL(foo, Process(AllOf(Gt(0), Ne(2))));
EXPECT_CALL(bar, Check(Not(IsNull())));
```


## Using Matchers as Predicates

You can use matchers as predicates (unary functions returning bool) with:

- `Matches(m)` returns a predicate functor
- `ExplainMatchResult(m, value, listener)` explains matching result
- `Value(value, m)` returns true if `value` matches `m`

This enables integration with STL algorithms and custom logic.

Example:

```cpp
std::count_if(container.begin(), container.end(), Matches(Ge(10)));
```


## Defining Custom Matchers

For most use cases, the built-in matchers suffice, but you can create custom matchers for specialized validation:

- Use the `MATCHER` macro for simple custom matchers:

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }
```

- Use `MATCHER_P`, `MATCHER_P2`, ... for parameterized matchers.
- For more complex matchers with control over explanation and description, implement the matcher interface directly.
- For polymorphic matchers usable with multiple types, use `MakePolymorphicMatcher` and provide template `MatchAndExplain`.

Example:

```cpp
MATCHER_P(IsDivisibleBy, n, "") {
  if (arg % n == 0) return true;
  *result_listener << "remainder is " << (arg % n);
  return false;
}
EXPECT_CALL(mock, Foo(IsDivisibleBy(3)));
```


## Best Practices and Tips

- Prefer explicit matchers like `Eq(value)` over relying on implicit conversions.
- Use wildcard `_` when argument value is unimportant.
- Use `ON_CALL` to set default behavior without enforcing expectations.
- Use `EXPECT_CALL` to validate that calls happen as expected.
- When matching complex arguments, prefer `SaveArg` actions combined with predicate matchers for clarity.
- To avoid surprises, be careful when matching non-copyable or move-only types; use `std::ref` with matchers to match references without copying.
- Use `SafeMatcherCast<T>(m)` when matching arguments of different but compatible types to ensure type safety.
- Compose matchers using `AllOf`, `AnyOf`, and `Not` to express fine-grained conditions.
- For containers, prefer specialized container matchers to get better error messages.
- When matching pointers, `Pointee` is safer than manually combining `NotNull` and dereference.


## Troubleshooting Common Pitfalls

- **Unmatched calls:** Occur when the call arguments don't match any `EXPECT_CALL`. Use `--gmock_verbose=info` for call trace.
- **Uninteresting calls warning:** Occurs when mock method invoked without an `EXPECT_CALL`. Use `NiceMock` to suppress warnings.
- **Copy issues:** When arguments are non-copyable, wrap with `std::ref` in matchers to avoid copying.
- **Overload ambiguity:** Use `Const()` or `TypedEq` wrappers to select correct overload.
- **Move-only arguments:** Use lambdas or functors as actions; returning move-only types requires careful setup.


## Example: Using Argument Matchers in a Test

```cpp
using ::testing::_;             // wildcard matcher
using ::testing::Eq;            // exact value matcher
using ::testing::Gt;            // greater-than matcher
using ::testing::NotNull;       // non-null pointer matcher
using ::testing::Pointee;       // value pointed to matcher
using ::testing::HasSubstr;     // substring matcher
using ::testing::SaveArg;       // action to save argument for later check
using ::testing::Return;

class MockFoo {
 public:
  MOCK_METHOD(bool, ProcessData, (const std::string& input, int* out), ());
};

TEST(FooTest, ProcessDataBehavior) {
  MockFoo mock;

  ON_CALL(mock, ProcessData(HasSubstr("ABC"), NotNull()))
      .WillByDefault([&](const std::string& input, int* out) {
         *out = static_cast<int>(input.size());
         return true;
      });

  EXPECT_CALL(mock, ProcessData(Eq("ABC123"), Pointee(Gt(5))))
      .Times(1);

  int output = 0;
  bool result = mock.ProcessData("ABC123", &output);

  EXPECT_TRUE(result);
  EXPECT_GT(output, 5);
}
```


---

## Additional References

- [gMock Cheat Sheet](https://github.com/google/googletest/blob/main/docs/gmock_cheat_sheet.md) – Quick syntax reference for mocks and matchers.
- [Matchers Reference](reference/matchers.md) – Detailed descriptions of built-in matchers.
- [gMock Cookbook](docs/gmock_cook_book.md) – Examples and recipes for advanced mocking.
- [Mocking Reference](docs/reference/mocking.md) – Comprehensive guide for mock macros and expectations.


---

<Callout title="Tip">
Always use matchers to check arguments in `EXPECT_CALL`. When in doubt about argument matching behavior, prefer explicit matchers like `Eq`, `Ne`, `Gt` for clarity.
</Callout>


<Callout title="Warning">
Avoid using implicit argument conversions in matchers as it may cause unexpected successful matches. Use explicit matchers like `Eq(expected_value)` to make matching intent clear.
</Callout>


<Callout title="Note">
Custom matchers should be pure functions without side effects, as gMock may call matchers multiple times or in unspecified contexts.
</Callout>


---

<Source url="https://github.com/google/googletest" paths={[{"path": "docs/reference/matchers.md", "range": "1-669"}]} />

