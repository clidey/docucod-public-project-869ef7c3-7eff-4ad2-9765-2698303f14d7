---
title: "Mock Method Definition"
description: "API reference for defining mock methods with the MOCK_METHOD macro and related utilities. Covers method signature specifications, overloading, const qualifiers, overrides, noexcept support, and integration with test fixtures."
---

# Mock Method Definition

This page provides a comprehensive API reference for defining mock methods using the `MOCK_METHOD` macro and related utilities in GoogleMock. It guides you through specifying method signatures, handling overloading, managing qualifiers like `const` and `override`, supporting `noexcept`, and integrating with test fixtures. This reference is essential for creating mock classes that fit seamlessly within your C++ testing workflow.

---

## Overview of `MOCK_METHOD`

The `MOCK_METHOD` macro is the core facility to define mock methods inside mock classes. It generates the implementation necessary for GoogleMock to intercept calls, verify expectations, and provide stub behaviors automatically.

### Basic Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- **ReturnType**: The return type of the method.
- **MethodName**: The name of the method to mock.
- **Args...**: A parenthesized list of argument types.
- **Specs...** (optional): Comma-separated qualifiers enclosed in parentheses.

This macro must appear in the `public:` section of your mock class, regardless of the access level of the method in the base class being mocked.

### Example

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

In this example, virtual methods of the `Turtle` interface are mocked with proper overriding and const-qualification.

---

## Detailed Usage

### Handling Commas in Types

Types that internally contain commas, such as `std::pair<bool, int>`, must be parenthesized to avoid macro parsing errors.

```cpp
class MockFoo {
 public:
  // Incorrect: will not compile
  // MOCK_METHOD(std::pair<bool, int>, GetPair, ());

  // Correct: wrap return type in extra parentheses
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());

  // Alternative: use type alias for readability
  using BoolAndInt = std::pair<bool, int>;
  MOCK_METHOD(BoolAndInt, GetPair, ());
};
```

### Qualifiers in Specs

The optional fourth parameter `(Specs...)` accepts a closed list of qualifiers affecting the generated method:

| Qualifier          | Meaning                                                             |
|--------------------|---------------------------------------------------------------------|
| `const`            | Marks the mocked method as a `const` method.                        |
| `override`         | Marks the method with `override`. Recommended if overriding a virtual method. |
| `noexcept`         | Marks the method with `noexcept`. Required if overriding a noexcept method. |
| `Calltype(...)`    | Specifies the calling convention, e.g., `Calltype(STDMETHODCALLTYPE)`. Useful on Windows. |
| `ref(&)`, `ref(&&)`| Marks the method with a reference qualifier (`&` or `&&`). Required if overriding a method with reference qualification. |

**Example with multiple specs:**

```cpp
MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool), (const, override, noexcept));
```

### Overloaded Methods

To mock overloaded methods, simply define mocks for each overload distinctly, including const overloads if present.

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (Element x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));

  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

If you omit mocking some overloads, the compiler will warn about hidden base methods. You can use `using` to bring them into scope if needed.

### Mocking Non-Virtual Methods

You can mock non-virtual methods when using dependency injection techniques, but **do not** add `override`.

```cpp
class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

### Specifying Calling Conventions

If your methods require special calling conventions (e.g., on Windows), use the `Calltype` specifier:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
```

### Using the `MOCK_METHOD` Macro Correctly

- Always place `MOCK_METHOD` declarations in the `public:` section of your mock class.
- Wrap argument lists with parentheses.
- Wrap types with commas in extra parentheses or use type aliases.
- Add qualifiers as needed to match the base method signature perfectly (e.g., `const`, `override`, `noexcept`).

---

## Common Patterns & Tips

### Integration with Test Fixtures

Mocks defined with `MOCK_METHOD` integrate seamlessly with GoogleTest fixtures for managing lifecycle and common setup.

```cpp
class TurtleTest : public ::testing::Test {
 protected:
  MockTurtle mock_turtle_;
};

TEST_F(TurtleTest, ForwardMovesCorrectly) {
  EXPECT_CALL(mock_turtle_, Forward(5));
  // ... code using mock_turtle_ ...
}
```

### Mocking Methods with Move-Only Types

Starting with C++11, GoogleMock supports mocking methods taking or returning move-only types, like `std::unique_ptr<>`:

```cpp
class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));
};
```

Use lambda actions instead of `Return(std::move(...))` when returning move-only types repeatedly:

```cpp
EXPECT_CALL(mock_buzzer_, MakeBuzz("x"))
    .WillRepeatedly([](StringPiece text) {
      return std::make_unique<Buzz>(AccessLevel::kInternal);
    });
```

### Mocking Private and Protected Methods

Even when mocking private or protected methods, declare `MOCK_METHOD` in the `public:` section of your mock class so expectation macros can access them.

### Simplifying Long or Complex Interfaces

If a mocked method has a large or complex argument list, consider redispatching in your mock class to a more manageable mock method with a trimmed signature. This technique also helps with overloaded methods.

---

## Error Handling & Troubleshooting

- **Unprotected commas in arguments** will cause compile errors. Wrap such types in parentheses or use aliases.
- **Mismatch in qualifiers** can cause compiler warnings/errors. Verify `const`, `override`, and `noexcept` qualifiers exactly match the base method.
- **Overloads ambiguity:** If overload resolution issues arise, use `Const()` to disambiguate const overloads or explicitly specify matcher types.
- **Expectations on non-mocked overloads can hide methods.** Use `using BaseClass::MethodName;` to bring them into scope.
- **Move-only types:** Cannot be copied; use compatible actions such as lambdas.

---

## Example: Defining a Mock Class with Various Method Types

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetValue() const = 0;
  virtual bool ProcessData(std::unique_ptr<Data> data) noexcept = 0;
  virtual void Reset() = 0;
  virtual std::pair<int, int> ComputeResult(int x, int y) = 0;
};

class MockFoo : public Foo {
 public:
  // Const qualifier and override
  MOCK_METHOD(int, GetValue, (), (const, override));

  // noexcept and override
  MOCK_METHOD(bool, ProcessData, (std::unique_ptr<Data> data), (noexcept, override));

  // Simple void method
  MOCK_METHOD(void, Reset, (), (override));

  // Return type with commas wrapped in parentheses
  MOCK_METHOD((std::pair<int, int>), ComputeResult, (int x, int y), (override));
};
```

---

## Additional Resources

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) - Beginner-friendly introduction
- [Mocking Reference](../reference/mocking.md) - Core macros and classes
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) - Practical recipes
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) - Quick syntax guide
- [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html) - Common issues

---

For guidance on using mocks effectively, setting expectations, and managing call sequences, please refer to related guides such as [Using Mocks: Patterns and Best Practices](../guides/mocking-and-advanced-techniques/using-mocks.md) and [Matchers & Actions](../api-reference/matchers-and-actions/).

---

## Summary

This reference directs you through all aspects of mocking method definitions using the `MOCK_METHOD` macro within GoogleMock. It covers signature specification, handling qualifiers, overloading, and use with complex types including move-only types. Practical patterns and common pitfalls are addressed to ensure clean, maintainable mock classes.

---

## Troubleshooting Quick Tips

- Ensure all types with commas are parenthesized or aliased.
- Verify qualifiers mirror the base methodâ€™s signature exactly.
- Use `Const()` helper for const-overloaded methods in expectations.
- Always place `MOCK_METHOD` in the public section of your mock class.
- When mocking move-only types, prefer lambdas for repeated actions.

---

## Advanced Considerations

- Use `Calltype()` specifier on Windows to match calling conventions.
- Use `ref(&)` or `ref(&&)` for reference-qualified methods.
- For complex mocking scenarios, combine `MOCK_METHOD` with `ON_CALL` and `EXPECT_CALL` to control default behaviors and expectations.
- Integrate mocks with GoogleTest fixtures to manage setup, teardown, and sharing mock instances across tests seamlessly.

---

This page is part of the [Mocking APIs](../api-reference/mocking-apis/) group within the API Reference.

---