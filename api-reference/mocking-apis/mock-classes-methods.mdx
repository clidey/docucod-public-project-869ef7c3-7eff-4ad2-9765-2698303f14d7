---
title: "Defining and Using Mock Classes"
description: "A practical guide to the APIs and macros for declaring mock classes and methods, including the signature of MOCK_METHOD, handling of modifiers, and support for advanced C++ features. Covers best practices for structuring interfaces and mocks."
---

# Defining and Using Mock Classes

A practical guide to the APIs and macros for declaring mock classes and methods, including the signature of `MOCK_METHOD`, handling of modifiers, and support for advanced C++ features. Covers best practices for structuring interfaces and mocks.

---

## Overview

GoogleTest's mocking framework (gMock) empowers you to easily create mock classes for testing purposes. Mock classes simulate interfaces or concrete classes without real implementations, allowing precise control and verification of interactions.

This page focuses on **defining mock classes and methods** using the core macro `MOCK_METHOD`, handling various method qualifiers and complexities, and best practices on designing mock interfaces to write robust and maintainable tests.


## Defining Mock Methods with `MOCK_METHOD`

The central macro for defining mocked methods within a mock class is `MOCK_METHOD`. It generates a mock method matching the provided signature and supports advanced C++ features.

### Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Qualifiers...));
```

- **ReturnType**: The return type of the mocked method.
- **MethodName**: The name of the mocked method.
- **Args...**: Parenthesized list of argument types, e.g. `(int, const std::string&)`.
- **Qualifiers...** (optional): Comma-separated list of C++ qualifiers and specifiers such as `const`, `override`, `noexcept`, `Calltype(...)`, and `ref(...)`.

### Supported Qualifiers

| Qualifier              | Meaning                                                                                   |
|------------------------|-------------------------------------------------------------------------------------------|
| `const`                | Marks the mocked method as `const`. Required if overriding a `const` method.              |
| `override`             | Marks the method with `override`. Recommended if overriding a virtual method.             |
| `noexcept`             | Marks the method with `noexcept`. Required if overriding a `noexcept` method.             |
| `Calltype(calltype)`   | Specifies calling convention, e.g. `Calltype(STDMETHODCALLTYPE)` (useful on Windows).     |
| `ref(&)` or `ref(&&)`  | Marks the method with the specified reference qualifier, required for overriding refs.   |

### Handling Argument Types With Commas

If the return type or argument types contain commas (like template types: `std::pair<bool, int>`), unprotected commas confuse the macro parser.

You have two options:

#### 1. Wrap Types With Extra Parentheses

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());
MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
```

`MOCK_METHOD` removes these inner parentheses before compiling.

#### 2. Use Type Aliases

Define a type alias to avoid commas:

```cpp
using BoolAndInt = std::pair<bool, int>;
MOCK_METHOD(BoolAndInt, GetPair, ());
using MapIntDouble = std::map<int, double>;
MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
```

### Placement Within the Mock Class

Always put your `MOCK_METHOD` declarations **in the public section** of your mock class, regardless of the access specifier on the original method. This ensures that `EXPECT_CALL` and `ON_CALL` macros can refer to the mocked methods.


## Defining Mock Classes

Constructing a mock class involves inheriting from the interface or class to be mocked, then adding `MOCK_METHOD` macros for each method you want to mock.

### Example: Mocking a Simple Interface

```cpp
#include <gmock/gmock.h>  // Include GoogleMock

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```


### Notes on Mock Classes

- You do **not** need to implement these mock methods yourself; the macro generates definitions automatically.
- It's good practice to mark mocked methods with `override` if overriding virtual methods.
- For const methods, include `(const, override)` as the fourth parameter.


## Mocking Advanced C++ Features

### Overloaded Methods

Mock all versions you want to test. If you do not mock all overloads, users will get compiler warnings about hidden functions.

```cpp
class Foo {
 public:
  virtual ~Foo() {}
  virtual int Add(int x) = 0;
  virtual int Add(int x, int y) = 0;
  virtual const Bar& GetBar() const = 0;
  virtual Bar& GetBar() = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int x, int y), (override));

  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
  MOCK_METHOD(Bar&, GetBar, (), (override));
};
```

If you skip an overload, resolve hiding by bringing the base ones in with `using`:

```cpp
using Foo::Add;
```

### Mocking Methods With Calling Conventions

Specify calling convention using `Calltype`, for example:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
```

### Mocking Methods With Reference Qualifiers

If the base method is qualified with `&` or `&&`, mock with `ref(&)` or `ref(&&)`:

```cpp
MOCK_METHOD(void, Foo, (), (ref(&), override));

MOCK_METHOD(void, Foo, (), (ref(&&), override));
```

### Mocking Non-Virtual Methods

You **cannot** mock non-virtual methods directly as mocks rely on polymorphism.

Instead, use *Hi-perf dependency injection*:
- Create a mock class unrelated to the concrete implementation but with the same interface signature.
- Template or inject the dependency as the mock type.

Example:

```cpp
class ConcreteStream {
 public:
  void AppendPacket(Packet* new_packet);
  const Packet* GetPacket(size_t num) const;
  size_t NumberOfPackets() const;
};

class MockStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t num), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```


### Mocking Class Templates

Mock class templates just like concrete classes:

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};

template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```


### Mocking Private or Protected Methods

`MOCK_METHOD` macros must still be in the **public** section even if mocking private or protected methods. This is to enable gMock access for expectations and default behaviors.

```cpp
class Foo {
 protected:
  virtual void Reset() = 0;
 private:
  virtual int Timeout() = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Reset, (), (override));
  MOCK_METHOD(int, Timeout, (), (override));
};
```


### Old-Style `MOCK_METHODn` Macros

Before `MOCK_METHOD` was introduced, macros like `MOCK_METHOD1`, `MOCK_CONST_METHOD1`, etc. were used. These are now deprecated but still supported.

| Old Macro                         | New Equivalent                              |
|----------------------------------|---------------------------------------------|
| `MOCK_METHOD1(Foo, bool(int))`   | `MOCK_METHOD(bool, Foo, (int))`              |
| `MOCK_CONST_METHOD1(Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (const))` |
| `MOCK_METHOD1_T(Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int))`              |
| `MOCK_METHOD1_WITH_CALLTYPE(STDCALL, Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (Calltype(STDCALL)))` |

We recommend migrating to the more flexible and consistent `MOCK_METHOD` macro.


## Best Practices for Structuring Mock Classes

- **Code to interfaces**, not concrete classes, to facilitate mocking and loose coupling.
- Put all `MOCK_METHOD` declarations in the `public` section.
- Use `override` keyword for better compile-time checks and clarity.
- Prefer using `MOCK_METHOD` macro over older versions.
- When mocking overloaded functions, mock all important overloads and bring base overloads into scope with `using`.
- For complex or long signatures, consider using type aliases to improve readability and maintainability.
- For non-virtual methods, consider template-based design or interface adapters.


## Common Pitfalls and Troubleshooting

### Comma Issues in `MOCK_METHOD`

Unprotected commas in argument or return types cause compilation errors. Always wrap complex types with parentheses or use type aliases.


### Access Specifiers

Placing `MOCK_METHOD` in `private:` or `protected:` will cause failures in setting expectations or default actions. Always declare mocks `public`.


### Virtual Destructors

Interfaces and base classes should have virtual destructors to avoid issues when deleting mocks polymorphically.


### Compiler Warnings in MSVC

MSVC may warn about const qualifiers in parameters. These are harmless and can be silenced by removing top-level `const` on parameters where possible.


### Mocking Non-Virtual or Static Methods

Direct mocking of these is not supported. Refactor code to use interfaces or template the dependencies.


## Summary

Defining and using mock classes with GoogleMock revolves around the `MOCK_METHOD` macro. This macro handles method declaration, supports complex features like qualifiers and calling conventions, and integrates seamlessly with GoogleTest's expectation and action system.

By structuring interfaces and mocks thoughtfully, embracing best practices, and understanding nuances like handling overloaded or template methods, users achieve powerful, maintainable unit tests that effectively isolate and verify interactions.


## References and Next Steps

- [EXPECT_CALL - Setting Expectations and Actions](../mocking-apis/mock-expectations-actions.md) to define interaction expectations
- [Matchers Reference](../matchers-actions/argument-matchers.md) for argument matching
- [Actions Reference](../matchers-actions/mock-actions.md) for controlling mock behavior
- [Nice, Strict, and Naggy Mocks](../mocking-apis/nice-strict-mocks.md) for controlling mock call policies
- [gMock Cookbook](../../guides/core-workflows/mocking-techniques.md) for practical recipes and advanced tips
- [Understanding Uninteresting vs Unexpected Calls](../mocking-apis/mock-expectations-actions.md#uninteresting-vs-unexpected-calls)

---

For detailed implementation and internal mechanics, see the [gmock-spec-builders.h](https://github.com/google/googletest/blob/main/googlemock/include/gmock/gmock-spec-builders.h) and [spec-builders.cc](https://github.com/google/googletest/blob/main/googlemock/src/gmock-spec-builders.cc) source files.


---

### Example Mock Class

```cpp
#include <gmock/gmock.h>

// Interface
class Logger {
 public:
  virtual ~Logger() {}
  virtual void Log(const std::string& message) = 0;
  virtual int GetLogLevel() const = 0;
};

// Mock class
class MockLogger : public Logger {
 public:
  MOCK_METHOD(void, Log, (const std::string& message), (override));
  MOCK_METHOD(int, GetLogLevel, (), (const, override));
};
```

This mock can then be used in tests with `EXPECT_CALL` and `ON_CALL` to set behaviors and verify interaction details.


---

### Illustrative User Flow

1. **Define an Interface:** Create a pure virtual interface or use an existing class.
2. **Create a Mock Class:** Inherit from the interface and use `MOCK_METHOD` in the public section to declare mock methods.
3. **Write Tests:** Instantiate the mock, use `EXPECT_CALL` to set expectations with matchers and actions.
4. **Run Code Under Test:** Inject the mock, execute your code, and gMock will verify the calls based on your expectations upon destruction or explicit verification.

This approach keeps your tests focused, fast, and interaction-driven.
