---
title: "Advanced & More Matchers"
description: "Explores additional matcher utilities and extensions, including composite matchers, monomorphic and polymorphic behaviors, and advanced matching strategies."
---

# Advanced & More Matchers

Explore additional matcher utilities and extensions, including composite matchers, monomorphic and polymorphic behaviors, and advanced matching strategies.

---

## Introduction

Beyond the fundamental matchers provided in the core Matchers Reference, GoogleTest offers a rich suite of advanced matchers designed to handle complex matching scenarios with precision and expressive power. This page guides you through these advanced matchers, detailing their intended uses, syntax, and practical examples.

These advanced and more matchers empower you to write more expressive and readable tests, particularly when dealing with composite data, container contents, pointer relationships, and multi-argument conditions.

---

## Composite and Polymorphic Matchers

### Polymorphic vs Monomorphic Matchers

- **Monomorphic matchers** match a single specific type, i.e., `Matcher<T>`. They verify values of exactly that type.
- **Polymorphic matchers** act as matcher factories, convertible to `Matcher<T>` for many types `T`. Examples include `Eq(value)`, `NotNull()`, and compound matchers.

GoogleTest includes utilities to convert between matcher types safely using `MatcherCast<T>(m)` and `SafeMatcherCast<T>(m)` which help in casting between compatible types while maintaining type correctness.

### Composite Matchers

Composite matchers combine other matchers using logical conditions:

- `AllOf(m1, m2, ..., mn)` — matches if *all* matchers are satisfied.
- `AnyOf(m1, m2, ..., mn)` — matches if *any* matcher is satisfied.
- `Not(m)` — matches if matcher `m` does *not* match.
- `Conditional(cond, m1, m2)` — matches `m1` if condition is true, otherwise `m2`.

These allow for precise matching of complex argument conditions.

### Example: Combining Matchers

```cpp
EXPECT_CALL(mock, Foo(AllOf(Ge(5), Ne(10))))
    .WillOnce(Return(true));
```

This expects `mock.Foo()` to be called with an argument that is greater or equal to 5 and not equal to 10.

---

## Container Matchers

GoogleTest provides a broad set of matchers suited to STL-style containers and arrays. These matchers allow you to validate container contents, element-wise properties, sizes, and order with unmatched granularity.

### Key Container Matchers

| Matcher | Description |
|---------|-------------|
| `Contains(e)` | Checks if container contains at least one element matching `e`. `e` may be a value or matcher.
| `Each(e)` | Checks if *every* element in the container matches `e`.
| `ElementsAre(e0, e1, ..., en)` | Checks if container has exactly these elements in order.
| `ElementsAreArray(...)` | Like `ElementsAre`, but takes an array or container of expected elements or matchers.
| `UnorderedElementsAre(e0, e1, ..., en)` | Checks for an unordered match of exactly these elements.
| `UnorderedElementsAreArray(...)` | Like `UnorderedElementsAre` but from array or container.
| `IsEmpty()` | Checks if the container is empty.
| `SizeIs(m)` | Matches containers whose size matches matcher `m`.
| `Contains(...).Times(n)` | Checks how many times elements matching given condition appear.

### Matching Map-Like Containers

Specialized matchers help when working with key-value containers like maps.

- `Key(m)` matches the key of a pair, with matcher `m`.
- `Pair(m1, m2)` matches a pair where the first matches `m1` and the second matches `m2`.

Example:

```cpp
EXPECT_THAT(my_map, Contains(Key(Ge(5))));
EXPECT_THAT(my_map, ElementsAre(Pair("foo", 42)));
```

### Sorting and Pointwise Matching

- `WhenSorted(m)` matches the container if, after sorting with `<`, it matches container matcher `m`.
- `WhenSortedBy(comparator, m)` is similar but uses a custom comparator.
- `Pointwise(m, container)` matches if the container has the same number of elements as `container` and each pair of elements matches using tuple matcher `m`.
- `UnorderedPointwise(m, container)` is like Pointwise but ignores order.

Example:

```cpp
EXPECT_THAT(values, WhenSorted(ElementsAre(1, 2, 3)));
EXPECT_THAT(values, Pointwise(Eq(), expected_values));
```

---

## Member and Pointer Matchers

These matchers target properties of objects, members within structures, or the values that pointers refer to.

### Field and Property Matchers

- `Field(&Class::field, m)` matches an object whose `field` matches matcher `m`.
- `Property(&Class::getter, m)` matches an object whose `getter()` result matches matcher `m`.

These can check deep properties in complex objects.

Example:

```cpp
EXPECT_THAT(foo_obj, Field(&Foo::bar, Ge(3)));
EXPECT_THAT(foo_obj, Property(&Foo::name, StartsWith("John")));
```

### Pointer Matchers

Working with pointers is safer with these matchers:

- `Pointee(m)` matches a pointer whose pointed value matches matcher `m`. It returns false if the pointer is null.
- `Pointer(m)` matches a pointer that matches matcher `m` (matcher matches the raw pointer).
- `Address(m)` matches an object with address matching `m`.
- `Ref(variable)` matches an argument that references `variable`.
- `WhenDynamicCastTo<T>(m)` matches if `dynamic_cast<T>` applied to the argument yields a value matching `m`. (Requires RTTI.)

Example:

```cpp
EXPECT_CALL(mock, Func(Pointee(Eq(5))));
EXPECT_THAT(ptr, WhenDynamicCastTo<Derived*>(NotNull()));
```

Pointers to pointers can be matched by nesting `Pointee()`.

---

## Multi-Argument Matching

Sometimes you want to express conditions across multiple arguments together.

- The `.With()` clause in `EXPECT_CALL` and `ON_CALL` accepts a multi-argument matcher matching the whole argument tuple.
- Use `Args<N1, N2, ..., Nk>(m)` to select and reorder arguments for matching.
- Use `AllArgs(m)` to apply matcher `m` to all arguments collectively.

Example:

```cpp
EXPECT_CALL(mock, SetRange(_, _))
    .With(Lt());  // Expects 1st argument < 2nd argument
```

The matcher inside `.With()` must be a tuple matcher like `Lt()` that operates on the aggregate of all arguments.

---

## Defining Custom Matchers

### Quick Matchers using Macros

You can create simple to parameterized custom matchers using `MATCHER()`, `MATCHER_P()`, `MATCHER_P2()`, ..., `MATCHER_P10()`.

Example:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
EXPECT_CALL(mock, Foo(IsEven()));
```

### Custom Matcher Classes

For more control or complex logic, define matcher classes implementing:

- `bool MatchAndExplain(arg_type arg, MatchResultListener* listener) const`
- `void DescribeTo(std::ostream* os) const`
- `void DescribeNegationTo(std::ostream* os) const`

Wrap the matcher class in a factory function returning `Matcher<T>`.

Example:

```cpp
class DivisibleByMatcher {
 public:
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, MatchResultListener* listener) const {
    if (n % divisor_ == 0) return true;
    *listener << "which has remainder " << (n % divisor_);
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }

 private:
  int divisor_;
};

Matcher<int> DivisibleBy(int divisor) {
  return MakePolymorphicMatcher(DivisibleByMatcher(divisor));
}
```

---

## Tips & Best Practices

### Using Matchers as Predicates

Matchers can be used in STL algorithms via `Matches(m)` to filter or count.

### Sharing Matchers

Matchers are cheap to copy. Store complex matchers in variables for reuse.

### Pure Functional Requirement

Matchers should be pure: no side effects and deterministic results given the same input.

### Avoid Over-Specification

Prefer flexible matchers over exact values unless necessary to avoid brittle tests.

### Using with Move-Only Types

Matchers support move-only types like `unique_ptr`, but some actions and advanced matchers might not. Use lambdas or functors when needed.

---

## Troubleshooting

### Matcher Doesn’t Compile

- Ensure matcher argument types align with function parameter types. Use `SafeMatcherCast` if necessary.
- For overloaded functions, disambiguate using typed matchers or wrappers.

### Unexpected Match Failures

- Check if the matcher describes the expected behavior clearly.
- Use `ExplainMatchResult()` to get detailed mismatch explanations.

### Uninteresting Call Warnings

- Use `ON_CALL` to set default behavior without strict expectations.
- Use `NiceMock` to suppress warnings on uninteresting calls if appropriate.

### Problems with Argument References

- Use `Ref(variable)` to match arguments referencing a specific object.

---

For detailed examples and additional advanced utilities, refer to the [Matchers Reference](matchers.md), [Mocking Reference](mocking.md), and [gMock Cookbook](gmock_cook_book.md).

---

# References

- [Matchers Reference](matchers.md): Core matcher usage and list.
- [Mocking Reference](mocking.md): Using mocks and expectations.
- [gMock Cookbook](gmock_cook_book.md): Recipes on writing custom matchers and actions.
- [Writing Custom Matchers](custom-matchers.md): Deep dive into defining matchers.
- [GoogleTest Primer](primer.md): Introductory testing essential.

---

This page is part of the API Reference > Matchers & Customization suite, providing deep mastery of GoogleTest’s matcher capabilities.
