---
title: "Writing Custom Matchers"
description: "Guides users in defining custom matchers for domain-specific assertions, including best practices, interface requirements, and usage patterns."
---

# Writing Custom Matchers

GoogleTest enables you to extend its expressive and powerful validation capabilities by defining **custom matchers** tailored to your domain-specific assertions. Custom matchers allow you to specify precisely when a value should be considered a match, improving test readability and failure diagnostics.

This page guides you through the process of creating custom matchers, covers best practices, required interfaces, and common usage patterns.

---

## Why Define Custom Matchers?

Imagine you have a complex object or a specific property that isn't covered by the built-in matchers. Instead of writing cumbersome predicates or unlocking limited failure messages, custom matchers let you encapsulate the matching logic with rich, meaningful diagnostics that clearly explain failures.

For example, rather than checking:

```cpp
EXPECT_TRUE(IsValidTemperature(sensor_value));
```

which provides little feedback on failure, a custom matcher can offer:

```cpp
EXPECT_THAT(sensor_value, IsAcceptableTemperatureRange(20, 80));
```

If this check fails, the matcher can explain why, showing the expected range and the actual value.

---

## Approaches to Defining Custom Matchers

GoogleMock provides multiple ways to author custom matchers, ranging from simple macros for quick scenarios to implementing interfaces for full control.

### 1. Using `MATCHER` and `MATCHER_P` Macros

For most use cases, the `MATCHER` macros offer concise, readable, and maintainable code to create custom matchers quickly.

**Syntax:**

```cpp
MATCHER(Name, "description") { statements; }
```

- Inside the statements, `arg` represents the value being matched.
- You must return `true` if the match succeeds, or `false` if it fails.
- The last parameter is a string literal or expression describing the matcher to assist failure messages.

**Example:** Check if a number is even:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
```

Now you can write:

```cpp
EXPECT_THAT(value, IsEven());
EXPECT_CALL(mock, Foo(IsEven()));
```

The failure message will automatically read "is even" or "not is even".

#### Parameterized Matchers

If your matcher needs parameters, use `MATCHER_P`, `MATCHER_P2`, ... for 1 or more parameters.

**Syntax:**

```cpp
MATCHER_P(Name, param, "description expression") { statements; }
```

**Example:** Matcher checking absolute value:

```cpp
MATCHER_P(HasAbsoluteValue, n, "") {
  return std::abs(arg) == n;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

You can customize the description to include parameters:

```cpp
MATCHER_P(HasAbsoluteValue, n, absl::StrCat((negation ? "doesn't have" : "has"), " absolute value ", n)) {
  return std::abs(arg) == n;
}
```

Now failure messages show the value of `n` clearly.

#### Tips When Using `MATCHER` Macros

- Matchers must be **pure functions** without side effects.
- You can stream additional info to `*result_listener` (optional) for detailed failure explanation.
- Use `EXPECT_` macros inside the matcher body to leverage GoogleTest's assertion reporting.
- `MATCHER*` macros must be defined in **namespace or global scope**, not inside classes or functions.

---

### 2. Defining Matchers by Implementing Matcher Interface

For advanced usage or very reusable matchers, implement the matcher class manually:

```cpp
class MyMatcher {
 public:
  using is_gtest_matcher = void;  // Marker to participate in gMock

  explicit MyMatcher(param_type param) : param_(param) {}

  template <typename ArgType>
  bool MatchAndExplain(const ArgType& arg, ::testing::MatchResultListener* listener) const {
    // Actual matching logic here
    // Optionally stream explanation to listener
    return is_match;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "description of matcher";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "negated description";
  }

 private:
  param_type param_;
};

// Factory function to create matcher instance
::testing::Matcher<T> MakeMyMatcher(param_type param) {
  return ::testing::Matcher<T>(new MyMatcher(param));
}
```

**Pros:**
- Full control over how values are matched and described
- Better compilation errors on misuse
- Supports overloading for multiple parameter types

**Cons:**
- More boilerplate and complexity

---

## Best Practices for Writing Custom Matchers

- Ensure your matcher is **pure** and **side-effect free**.
- Use the `result_listener` (or `MatchResultListener` in interface methods) to provide detailed failure info.
- Define both `DescribeTo()` and `DescribeNegationTo()` for expressive failure and negation messages.
- Parameterize your matcher when appropriate for reusability.
- Leverage existing matchers within your matcher for composability.
- Name matchers meaningfully to communicate intent clearly.

---

## Examples of Custom Matchers

### Simple No-Parameter Matcher

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

EXPECT_THAT(number, IsDivisibleBy7());
```

### Parameterized Matcher with Custom Description

```cpp
MATCHER_P(InRange, range, absl::StrCat(negation ? "isn't" : "is", " in range [",
                                  range.first, ", ", range.second, "]")) {
  return arg >= range.first && arg <= range.second;
}

EXPECT_THAT(value, InRange(std::make_pair(5, 10)));
```

### Matcher Using ResultListener to Explain Failure

```cpp
MATCHER_P(IsEvenButNot42, "") {
  if ((arg % 2) != 0) {
    *result_listener << "which is odd";
    return false;
  }
  if (arg == 42) {
    *result_listener << "which is the forbidden 42";
    return false;
  }
  return true;
}

EXPECT_THAT(test_value, IsEvenButNot42());
```

---

## Integrating Custom Matchers into Tests

Once defined, custom matchers become first-class citizens:

- Use `EXPECT_THAT(value, Matcher())` to make readable assertions.
- Use in `EXPECT_CALL(mock, Method(Matcher()))` to match mock call arguments precisely.

Consider organizing your matchers into header files as part of your test utility library for reuse.

---

## Troubleshooting Common Issues

<Tip>
- **Match failures:** Ensure your predicate returns correct Boolean values and handles edge cases.
- **Description unclear:** Customize `DescribeTo()` and `DescribeNegationTo()` methods for clearer messages.
- **Compilation errors:** Check correct template and namespace scope for matcher declaration.
- **Side effects in matchers:** Avoid any state changes or function calls that alter mocks.
</Tip>

---

## Additional Resources

- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — recipes including custom matchers.
- [Matchers Reference](../reference/matchers.md) — built-in matcher functions and interfaces.
- [Mocking Reference](../reference/mocking.md) — complete guide on mocks, expectations, and actions.
- `MATCHER` macro documentation within the `gmock-matchers.h` file.
- [GoogleTest Primer](https://google.github.io/googletest/primer.html) for getting started.

---

Harnessing custom matchers transforms your tests from opaque checks into living documentation with vivid failure messages. Define them with clarity and precision to greatly enhance your test suite’s maintainability and effectiveness.