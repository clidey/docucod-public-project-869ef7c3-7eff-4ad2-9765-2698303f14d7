---
title: "Assertions: Expect, Assert, and Predicates"
description: "Documents core expectation and assertion macros (EXPECT_*, ASSERT_*, etc.), predicate-based assertions, and best practices for using fatal and non-fatal checks to control test flow."
---

# Assertions: Expect, Assert, and Predicates

This page comprehensively documents the core assertion macros in GoogleTest, including `EXPECT_*`, `ASSERT_*`, and predicate-based assertions. It guides you in writing effective tests by controlling test flow using fatal and nonfatal failures, explains predicate assertions with detailed failure output, and shares best practices on safely using assertions to check your code's behavior.

---

## Overview of Assertions

GoogleTest provides paired assertion macros for verification:

- `EXPECT_*`: Generates **nonfatal failures**, allowing your test function to continue beyond the failure.
- `ASSERT_*`: Generates **fatal failures**, aborting the current test function immediately on failure.

This structure lets you fine-tune how your tests behave upon different failure conditions. For example, use `ASSERT_*` when continuing beyond a failure would produce misleading results or cause crashes, and `EXPECT_*` when you want to collect multiple failures in one test run.

All assertions support custom failure messages using the stream insertion operator `<<`:

```cpp
EXPECT_TRUE(condition) << "Condition was false, needs fixing!";
```

Any value streamable to an `ostream` (including C-style strings and C++ string objects) can be used for detailed diagnostic messages.

---

## Types of Assertions

### Explicit Success and Failure

GoogleTest supports explicit, unconditioned success or failure macros, useful when control flow alone indicates failure:

- `SUCCEED()`: Generates success explicitly. Use to document a passed condition where no assertion is needed.
- `FAIL()`: Generates a **fatal failure** and aborts the current function. Typesafe for `void` returning functions only.
- `ADD_FAILURE()`: Generates a **nonfatal failure**.
- `ADD_FAILURE_AT(file, line)`: Like `ADD_FAILURE`, but points to a specific file and line number.

### Boolean Conditions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Verify the condition is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Verify the condition is false.

Use these for simple boolean predicates.

### Binary Comparisons

A rich set of macros compare two values using C++ comparison operators, with proper support for pointers and C strings:

| Macro           | Semantics        | Notes                                     |
|-----------------|------------------|-------------------------------------------|
| `EXPECT_EQ`     | Checks `val1 == val2` | For C strings, compares pointers (use `EXPECT_STREQ` for content) |
| `EXPECT_NE`     | Checks `val1 != val2` | As above                                  |
| `EXPECT_LT`     | Checks `val1 < val2`  | Supports all comparable types              |
| `EXPECT_LE`     | Checks `val1 <= val2` |
| `EXPECT_GT`     | Checks `val1 > val2`  |
| `EXPECT_GE`     | Checks `val1 >= val2` |

Each has a corresponding `ASSERT_` variant that aborts on failure.

For C strings (`const char*`), use dedicated macros:

- `EXPECT_STREQ` / `ASSERT_STREQ`: Equality comparison by content
- `EXPECT_STRNE` / `ASSERT_STRNE`: Inequality by content
- `EXPECT_STRCASEEQ` / `ASSERT_STRCASEEQ`: Equality ignoring case
- `EXPECT_STRCASENE` / `ASSERT_STRCASENE`: Inequality ignoring case

### Floating Point Comparisons

Due to floating point rounding, equality comparisons should use specialized macros:

- `EXPECT_FLOAT_EQ` / `ASSERT_FLOAT_EQ`: Approximately equal floats (within 4 ULPs).
- `EXPECT_DOUBLE_EQ` / `ASSERT_DOUBLE_EQ`: Approximately equal doubles (within 4 ULPs).
- `EXPECT_NEAR` / `ASSERT_NEAR`: Difference within absolute error bound.

These avoid common pitfalls in comparing floating point values.

### Exception Assertions

If your build environment supports exceptions, test for throwing behavior:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(...)`: Verifies specific exception thrown.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(...)`: Verifies any exception thrown.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(...)`: Verifies no exception thrown.

They support block statements enclosed in braces.

### Predicate Assertions

Predicate assertions enable custom predicates with concise reporting:

- `EXPECT_PRED1` through `EXPECT_PRED5` and corresponding `ASSERT_PRED*`: Check that a predicate function or functor returns true when passed the given arguments (up to 5).

Example:

```cpp
bool MutuallyPrime(int m, int n) { ... }

EXPECT_PRED2(MutuallyPrime, a, b);  // Succeeds if a and b are mutually prime
```

On failure, prints the values of each argument.

Predicate-formatter assertions:

- `EXPECT_PRED_FORMAT1` through `EXPECT_PRED_FORMAT5` and corresponding `ASSERT_PRED_FORMAT*`: Uses a predicate formatter that returns a richer `AssertionResult`, allowing better formatted failure messages.

Example:

```cpp
testing::AssertionResult AssertMutuallyPrime(const char* m_expr,
                                             const char* n_expr,
                                             int m,
                                             int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();

  return testing::AssertionFailure() << m_expr << " and " << n_expr
      << " are not mutually prime";
}
...
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);
```

---

## Choosing Between EXPECT and ASSERT

Use predicate-based assertions and standard EXPECT_ macros when the test can continue safely after failure.

Use ASSERT_ variants when failure means subsequent test code is invalid or might cause runtime errors.

**Best Practice:** Favor nonfatal failures (`EXPECT_`) to allow multiple checks per test, but apply `ASSERT_` carefully to avoid misleading results.

---

## Using Predicate Assertions for Complex Conditions

Predicate assertions provide clearer diagnostics compared to using `EXPECT_TRUE` with complex expressions. Define predicates as functions or functors returning `bool` or `testing::AssertionResult` and plug them into `EXPECT_PRED*` or `EXPECT_PRED_FORMAT*` macros.

They help track precisely which argument or condition caused failure.

Example:

```cpp
bool IsValidUser(const User& user);  // Complex validation predicate

EXPECT_PRED1(IsValidUser, user);
```

---

## Practical Tips and Best Practices

- **Always provide helpful failure messages** using `<<` streaming to assertions for easier diagnosis.

- **Avoid using `ASSERT_*` macros from setup functions or constructors,** as they may hide test failures.

- **Use `EXPECT_THAT(value, matcher)` when you want to use gMock matchers** for richer checks and failure messages (see Matchers documentation).

- **Use predicate assertions when you want to check custom conditions** that are too complex or unwieldy with built-in macros.

- **Prefer nonfatal assertions (`EXPECT_*`) when failure can be tolerated and test flow continued.** Use fatal assertions (`ASSERT_*`) only when failure should stop the test immediately.

---

## Troubleshooting Assertion Failures

- **Misuse of `ASSERT_*` leading to premature test abortion:** Check if a fatal failure is causing your test logic to skip subsequent steps.

- **Predicate macro confusion:** If using overloaded predicates, specify their types explicitly to avoid compiler errors.

- **Failed expectations on complex predicates:** Use predicate-format assertions for clearer diagnostics.

- **Stream multiple failure details:** Use streaming messages with assertions to provide context.

---

## Summary Table of Common Assertion Macros

| Assertion                | Behavior                            | Usage Example                                          |
|--------------------------|------------------------------------|-------------------------------------------------------|
| `EXPECT_TRUE(cond)`      | Nonfatal; verify condition true    | `EXPECT_TRUE(x > 5);`                                  |
| `ASSERT_TRUE(cond)`      | Fatal; verify condition true       | `ASSERT_TRUE(ptr != nullptr);`                         |
| `EXPECT_EQ(val1, val2)`  | Nonfatal; val1 == val2             | `EXPECT_EQ(result, expected);`                         |
| `ASSERT_EQ(val1, val2)`  | Fatal; val1 == val2                | `ASSERT_EQ(p.size(), 3U);`                             |
| `EXPECT_STREQ(s1, s2)`  | Nonfatal; C-string equality        | `EXPECT_STREQ(actual_cstr, expected_cstr);`           |
| `EXPECT_FLOAT_EQ(f1,f2)` | Approximate float comparison       | `EXPECT_FLOAT_EQ(distance, 3.14f);`                    |
| `EXPECT_THROW(stmt, ex)` | Expect exception thrown             | `EXPECT_THROW(Foo(), std::runtime_error);`             |
| `EXPECT_PRED2(pred, a,b)`| Custom predicate returns true      | `EXPECT_PRED2(IsPrime, n1, n2);`                       |

---

## See Also and Related Documentation

- [GoogleTest Primer](https://google.github.io/googletest/primer.html): Getting started guide including assertions basics.
- [Matchers Reference](reference/matchers.md): Rich matchers for expressive assertions using `EXPECT_THAT`.
- [Writing Custom Matchers](concepts/advanced-principles/custom-assertions-and-matchers.md) for extending assertions.
- [gMock Cookbook](gmock_cook_book.md#SettingExpectations) for related mock expectation and action handling.
- [Death Tests & Exception Assertions Guide](guides/core-test-workflows/death-tests-error-handling.mdx) for fatal test scenarios.

---