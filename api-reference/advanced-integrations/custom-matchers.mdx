---
title: "Custom Matchers"
description: "Guide to extending assertion and expectation matching with user-defined matchers. Learn the APIs for writing, registering, and using custom matcher objects to add domain-specific verification to your tests."
---

# Custom Matchers

Extend the power of GoogleMock's assertions and expectations by creating your own custom matchers. This guide provides practical instruction on how to write, parameterize, describe, and use custom matcher objects, empowering you to implement domain-specific and complex verification logic tailored to your tests.

---

## 1. Why Define Custom Matchers?

Built-in matchers cover most common scenarios, but sometimes your testing needs demand:

- Domain-specific criteria (e.g., validating that a number is a prime or that a data structure satisfies a particular invariant).
- Complex conditions involving one or more parameters.
- Improved error messages with contextual details about why a match failed.

Custom matchers let you express such constraints cleanly within `EXPECT_CALL`, `EXPECT_THAT`, and `ASSERT_THAT` assertions, making your tests more readable and maintainable.

## 2. Writing Simple Matchers Using Macros

GoogleMock provides a convenient family of macros to define custom matchers succinctly, avoiding boilerplate and focusing on the matching logic.

### Basic Matcher: `MATCHER`

Defines a parameterless matcher. The macro has this form:

```cpp
MATCHER(Name, "description string") {
  /* body*/
  return <bool expression involving 'arg'>;
}
```

- `arg` is the value being matched.
- The description string documents what the matcher checks. If empty (`""`), GoogleMock automatically generates a description from the matcher name.

Example:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
```

Usage:

```cpp
EXPECT_CALL(mock, Foo(IsEven()));
EXPECT_THAT(some_value, IsEven());
```

If the match fails, the description `is even` is automatically generated from `IsEven`.

### Parameterized Matcher: `MATCHER_P` and Variants

To add parameters to your matcher use `MATCHER_P`, `MATCHER_P2`, and so on.

Example:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

Message on failure incorporates the parameter:

```
Value of: x
Expected: has absolute value 10
  Actual: -9
```

You can write descriptions that depend on parameters and iteration over negations:

```cpp
MATCHER_P2(InClosedRange, low, high, 
  std::string(negation ? "is not" : "is") + " in range [" + 
  testing::PrintToString(low) + ", " + testing::PrintToString(high) + "]") {
  return low <= arg && arg <= high;
}
```

---

## 3. Enhancing Custom Matchers

### Streaming Additional Failure Info

If the failure explanation requires more than just the description string, stream to `*result_listener`:

```cpp
MATCHER_P(EqualsLongString, expected, "") {
  if (arg == expected) return true;
  *result_listener << "difference: " << CalculateDiff(expected, arg);
  return false;
}
```

This provides richer output when matches fail, improving debugging.

### Using `EXPECT_` Within Matchers

You can write GoogleTest expectations inside matcher bodies to leverage assertion conveniences:

```cpp
MATCHER_P(IsDivisibleBy7, "") {
  int remainder = arg % 7;
  EXPECT_EQ(remainder, 0);
  return true;
}
```

On failure, test output shows expected vs actual neatly:

```text
Expected equality of these values:
 remainder
   Which is: 6
 0
```

### Polymorphic Behavior

The type of `arg` is inferred by the compiler from matcher context, allowing your matcher to work with any compatible type without explicit templating.

---

## 4. Defining Custom Matcher Classes for Advanced Usage

You may want more explicit control or share a matcher extensively. Define a matcher class that:

- Marks itself with `using is_gtest_matcher = void;`.
- Implements:
  - `bool MatchAndExplain(const T& value, MatchResultListener* listener) const`
  - `void DescribeTo(std::ostream* os) const`
  - `void DescribeNegationTo(std::ostream* os) const`

Example:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected_sum) : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /* listener */) const {
    return (foo.bar() + foo.baz()) == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  const int expected_sum_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return BarPlusBazEqMatcher(expected_sum);
}
```

---

## 5. Using Custom Matchers

Any custom matcher you define can be used in all matcher contexts:

- `EXPECT_CALL(mock, Method(CustomMatcher()));`
- `EXPECT_THAT(value, CustomMatcher());`
- Combined within other matchers using `AllOf()`, `AnyOf()`, etc.

They integrate seamlessly with message formatting and error diagnostics.

---

## 6. Best Practices & Common Pitfalls

- **Purity:** Matchers must be *pure*: no side effects, no modifying external state.
- **No Mock Calls Within Matchers:** Do not invoke mock methods within your matcher logic.
- **Use Descriptions Wisely:** Provide meaningful descriptions including parameter values for clearer failures.
- **Prefer Macros for Most Cases:** For common patterns, `MATCHER*` macros are concise and idiomatic.
- **Implement Classes for Complex Cases:** When polymorphism, overloading, or explicit typing is needed.

---

## 7. Additional Resources

- [GoogleMock Cookbook - New Matchers](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers)
- [Matchers Reference](../docs/reference/matchers.md)

---

## Example: Defining and Using a Parameterized Matcher

```cpp
#include <gmock/gmock.h>
using ::testing::MATCHER_P;

// Matches whether a string has the specified prefix
MATCHER_P(StartsWithPrefix, prefix, 
          std::string(negation ? "doesn't start with " : "starts with ") + printer(prefix)) {
  return arg.compare(0, prefix.size(), prefix) == 0;
}

...
// Test usage:
EXPECT_THAT(std::string("foobar"), StartsWithPrefix("foo"));
EXPECT_THAT(std::string("barfoo"), Not(StartsWithPrefix("foo")));  
```

---

## Troubleshooting Custom Matchers

- **Compilation errors:** Ensure you define `using is_gtest_matcher = void;` in your matcher class.
- **Unexpected matches:** Use `ExplainMatchResult()` to debug why a matcher matches or not.
- **Poor error messages:** Stream detailed context to `result_listener` in `MatchAndExplain()`.

---

## Summary

Custom matchers offer flexible, expressive verification tools that integrate with GoogleMock's framework. By writing simple macros or sophisticated matcher classes, you can validate nuanced conditions, improving test clarity and failure diagnostics.

For practical usage, begin with macros (`MATCHER`, `MATCHER_P`) and escalate to classes when you need full control or polymorphism.

Use these matchers as predicates inside assertions like `EXPECT_THAT()` and in mock expectations for robust and domain-specific testing.

---