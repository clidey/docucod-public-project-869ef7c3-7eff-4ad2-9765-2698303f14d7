---
title: "Test Case and Test Suite API"
description: "Describes the types, macros, and functions for defining and managing test cases (now known as test suites), how tests are registered and discovered, and the lifecycle of test execution. Includes usage of TEST, TEST_F, and advanced suite registration mechanisms."
---

# Test Case and Test Suite API

GoogleTest provides a robust API for defining, managing, and executing test cases and test suites (formerly called test cases but now standardized as test suites). This page details the macros, classes, and functions for creating and controlling tests, enabling you to write precise, scalable, and maintainable C++ test programs.

---

## Overview of Test Cases and Test Suites

- **Test Suite**: A collection of related tests usually sharing a common fixture. Test suites group tests logically and isolate initialization/teardown.
- **Test**: An individual executable test that verifies a particular aspect of code.

GoogleTest supports two primary ways to define tests:

- **TEST** - for tests without a fixture.
- **TEST_F** - for tests that use a test fixture class.

Additionally, advanced patterns include:

- **TEST_P** and **INSTANTIATE_TEST_SUITE_P** for value-parameterized tests.
- **TYPED_TEST_SUITE** and **TYPED_TEST** for typed tests.
- **TYPED_TEST_SUITE_P** and **TYPED_TEST_P** for type-parameterized tests.

---

## Macros for Defining Tests

### TEST

Defines an individual test within a test suite. This macro is used when no test fixture is required.

```cpp
TEST(TestSuiteName, TestName) {
  // test code
}
```

#### Rules and Best Practices

- Both `TestSuiteName` and `TestName` must be valid C++ identifiers with **no underscores** (`_`). Underscores can cause unexpected failures or name collisions due to GoogleTest's internal naming scheme. See the [FAQ on underscores in test names](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore) for details.
- Tests in different suites can share the same individual test name.

---

### TEST_F

Defines a test using a test fixture, which allows reuse of setup and teardown logic.

```cpp
TEST_F(TestFixtureName, TestName) {
  // test code
}
```

#### Notes

- `TestFixtureName` must be the name of a subclass of `testing::Test`.
- Tests in the same suite share the fixture, which manages setup/teardown per test.
- The test suite name is identical to the fixture name.

Example of fixture use:

```cpp
class WidgetTest : public ::testing::Test {
protected:
  void SetUp() override {
    widget_ = new Widget();
  }

  void TearDown() override {
    delete widget_;
  }

  Widget* widget_;
};

TEST_F(WidgetTest, InitializesCorrectly) {
  EXPECT_TRUE(widget_->IsValid());
}
```

---

### TEST_P and INSTANTIATE_TEST_SUITE_P: Value-Parameterized Tests

Value-parameterized tests enable running the same test logic across multiple input parameters without duplicating code.

#### Defining a Fixture

Your test fixture must inherit from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyParamTest : public testing::TestWithParam<int> {};
```

#### Defining Parameterized Tests

Use `TEST_P` instead of `TEST_F`:

```cpp
TEST_P(MyParamTest, HandlesValues) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}
```

Inside the test body, call `GetParam()` to access the current parameter.

#### Instantiating the Tests

Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues, MyParamTest, testing::Values(1, 2, 3));
```

This generates tests named like `PositiveValues/MyParamTest.HandlesValues/0` with successive parameter values.

#### Parameter Generators

GoogleTest provides several generators for specifying test input parameters:

| Generator          | Description                                                                                     |
|--------------------|------------------------------------------------------------------------------------------------|
| `Range(begin, end[, step])` | Generates values starting at `begin`, increments by `step` until but not including `end`. Defaults to `step=1`. |
| `Values(v1, v2, ..., vN)`    | Specifies explicit list of parameter values.                                             |
| `ValuesIn(container)`         | Generates values from a container or iterator range.                                      |
| `Bool()`                     | Generates `false, true`.                                                                   |
| `Combine(g1, g2, ..., gN)`   | Cartesian product of multiple generators, producing tuples of parameters.                 |
| `ConvertGenerator<T>(g)` or `ConvertGenerator(g, func)` | Converts values from generator `g` to `T` using `static_cast` or a custom converter.
|

You may customize test names for parameters by providing a `name_generator` callable as the fourth argument to `INSTANTIATE_TEST_SUITE_P`. This callable takes a `TestParamInfo` and returns a string suffix with only alphanumeric characters and underscores.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
  CustomNames, MyParamTest, testing::Values(0, 1, 2),
  [](const testing::TestParamInfo<int>& info) {
    return "Value" + std::to_string(info.param);
  });
```

Note: The parameter generator expressions are evaluated at GoogleTest initialization, not at instantiation site or test run.

#### Suppressing Warnings for Uninstantiated Test Suites

If you define a parameterized test suite but do not instantiate it, GoogleTest reports a failing test in the special suite `GoogleTestVerification`. You can silence this by adding:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyParamTest);
```

---

### Typed Tests

Typed tests enable running the same tests across a list of types, useful for testing template code or multiple implementations of an interface.

#### Defining a Typed Test Suite

Define a class template fixture:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
protected:
  T value_;
};
```

Associate a list of types:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

#### Defining Typed Tests

Use `TYPED_TEST` in place of `TEST_F`:

```cpp
TYPED_TEST(MyTypedTest, DoesWork) {
  TypeParam val = this->value_;
  // test code with val
}
```

Inside the tests, `TypeParam` refers to the current type.

#### Optional Name Generator

A third argument to `TYPED_TEST_SUITE` can specify a `NameGenerator` class with a static templated `GetName(int)` method to assign readable test names for each type.

---

### Type-Parameterized Tests

Type-parameterized tests allow defining test logic generically and instantiating it with types later, potentially multiple times across translation units.

#### Defining a Type-Parameterized Test Suite

Define the fixture template:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {};
```

Declare it parameterized with `_P` suffix:

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

#### Defining Tests

Use `TYPED_TEST_P` instead of `TYPED_TEST`:

```cpp
TYPED_TEST_P(MyTypeParamTest, TestA) {
  TypeParam val = 0;
  // test code
}
```

#### Registering Tests

Register all test patterns:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestA, TestB);
```

#### Instantiating

Instantiate the suite with types:

```cpp
using MyTypes = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```

Multiple instantiations can be created with unique prefixes.

---

## Classes and Functions

### `testing::Test`

Base class for all tests. It provides methods:

- `SetUp()`: Override to define per-test setup.
- `TearDown()`: Override to define per-test teardown.
- `SetUpTestSuite()`: Static method for per-test-suite setup.
- `TearDownTestSuite()`: Static for per-test-suite teardown.
- Static methods for checking failure status: `HasFatalFailure()`, `HasNonfatalFailure()`, `HasFailure()`, `IsSkipped()`.
- `RecordProperty(key, value)`: Record custom properties.

### `testing::TestInfo`

Represents information about a test instance:

- Accessors for test suite name, test name, parameter info, source file and line.
- Status flags for whether the test is disabled, selected by filter, or should run.
- Access to `TestResult` for detailed outcome.

### `testing::TestSuite`

Represents a group of tests:

- Properties for suite name, parameter type name, test counts (total, run, skipped, failed, disabled).
- Methods to get tests and manage execution.
- Holds `TestResult` for results of suite-level setup/teardown.

### `testing::TestResult`

Contains detailed execution results for a single test:

- Counts and info on failures, skips, and successes.
- Collection of `TestPartResult` objects representing individual assertions.
- Recorded test properties.
- Timing information.

### `testing::UnitTest`

Singleton providing global information about the entire test program:

- Aggregate counts for all tests and suites: passed, failed, skipped, disabled.
- Access to specific test suites.
- Current running test and suite info.
- APIs to add global test environments.
- Access to event listeners for hooking into the test execution.

### `testing::RegisterTest`

Dynamic registration of tests at runtime, for advanced use cases. This function takes test suite and test names, code location, and a factory to create instances of test fixtures.

Example:

```cpp
testing::RegisterTest(
  "MySuite", "MyTest", nullptr, nullptr, __FILE__, __LINE__,
  []() -> MyFixture* { return new MyFixtureSubclass; });
```

---

## Test Execution Lifecycle

1. Test suites are registered with their tests.
2. For each test:
   - Fixture object is created.
   - `SetUp()` is called.
   - Test body runs.
   - `TearDown()` is called.
   - Fixture object is destroyed.
3. Suite `SetUpTestSuite()` is called once before the first test, and `TearDownTestSuite()` after the last.
4. Global test environments (`testing::Environment`) `SetUp()` and `TearDown()` are called before and after all tests.

Failures are recorded but do not abort the entire test program unless `--gtest_fail_fast` is enabled.

---

## Working With Test Filters and Disabled Tests

- Tests and suites can be filtered at runtime via `--gtest_filter` or `GTEST_FILTER` environment variable using wildcard patterns.
- Prefix a test or suite name with `DISABLED_` to temporarily exclude it from execution while still compiling it.
- Use the `--gtest_also_run_disabled_tests` flag to run disabled tests.

---

## Using Test Properties

Within a test or suite setup/teardown, use `RecordProperty(key, value)` to attach metadata or custom information to tests, useful for reports.

Example:

```cpp
TEST_F(FooTest, MyTest) {
  RecordProperty("MaxWidgets", 5);
  EXPECT_EQ(widget_->Count(), 5);
}
```

This will be included in generated XML or JSON test reports.

---

## Getting Current Test and Suite Information

Within a running test or fixture, you can query the current test info:

```cpp
const testing::TestInfo* test_info = testing::UnitTest::GetInstance()->current_test_info();
if (test_info) {
  std::cout << "Currently running: " << test_info->test_suite_name() << "." << test_info->name() << std::endl;
}
```

This is useful for dynamic behavior based on test identity.

---

## Trouble Avoiding Duplicate Fixtures in One Suite

GoogleTest requires that all tests in the same suite use the same fixture class. If tests with different fixtures are declared under the same suite name, an error will be reported at runtime. To solve this, ensure:

- Tests sharing a suite name must share the same fixture class.
- Avoid mixing plain `TEST` and fixture-based `TEST_F` in the same suite.
- Consider renaming suites or fixtures to separate tests logically.

See related FAQ entries for more about this common pitfall.

---

## Examples

### Simple Test

```cpp
TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}
```

### Test with Fixture

```cpp
class StackTest : public testing::Test {
protected:
  std::stack<int> stack_;
  void SetUp() override {
    stack_.push(1);
  }
};

TEST_F(StackTest, TopIsOne) {
  EXPECT_EQ(stack_.top(), 1);
}
```

### Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest,
                         testing::Values(2, 4, 6, 8));
```

### Typed Test

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, MaxIsPositive) {
  EXPECT_GT(std::numeric_limits<TypeParam>::max(), 0);
}
```

---

## Troubleshooting & Common Pitfalls

- **Underscores in Suite or Test Names:** Avoid underscores in test suite and test names to prevent naming collisions and reserved identifier violations. Use natural casing or camel case instead.

- **Mixing Fixtures in One Suite:** All tests in a suite must share the same fixture class. Mixing `TEST` and `TEST_F` under the same suite name or using different fixtures in the same suite causes runtime errors.

- **Test Constructor Restrictions:** You cannot use fatal assertions inside constructors or destructors of fixtures because of C++ language restrictions. Use `SetUp()` and `TearDown()` for setups that can fail.

- **Parameterized Tests Without Instantiation:** If you declare a `TEST_P` suite but never instantiate it with `INSTANTIATE_TEST_SUITE_P`, GoogleTest will generate failing tests in `GoogleTestVerification`. To suppress, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

- **Death Tests Naming:** Name test suites containing death tests with suffix `*DeathTest` to ensure proper ordering and thread safety.

- **Global Environment Order:** Global test environments are set up and torn down in the order they are registered (setup) and reverse order (teardown). Register environments carefully to respect dependencies.

---

## Additional Resources

For more on writing tests, managing fixtures, assertions, and parameter types, consult:

- [GoogleTest Primer](../primer.md)
- [Parameterized and Typed Tests Guide](../advanced.md#value-parameterized-tests)
- [Typed Tests Guide](../advanced.md#typed-tests)
- [Death Tests Guide](../advanced.md#death-tests)
- [Assertions Reference](assertions.md)
- [FAQ & Common Issues](../faq.md)


---

## Summary Diagram: Test Registration and Execution Flow

```mermaid
flowchart TD

  subgraph Registration
    A[Test Macros (TEST, TEST_F, TEST_P, TYPED_TEST)] --> B[TestInfo Creation]
    B --> C[TestSuite Creation or Retrieval]
    C --> D[TestInfo & Suite Registration]
  end

  subgraph Execution
    E[RUN_ALL_TESTS] --> F[Filtering & Sharding]
    F --> G[SetUpTestSuite (per-suite setup)]
    G --> H[Create Fixture Instance Per Test]
    H --> I[Test::SetUp]
    I --> J[TestBody (test function runs)]
    J --> K[Test::TearDown]
    K --> L[Destroy Fixture Instance]
    L --> M{
      More Tests?
    }
    M -->|Yes| H
    M -->|No| N[TearDownTestSuite (per-suite teardown)]
  end

  F --> O[Global Environments SetUp and TearDown]
  O --> E

  classDef important fill:#f96,stroke:#333,stroke-width:2px;
  class A,E important;
```

---
