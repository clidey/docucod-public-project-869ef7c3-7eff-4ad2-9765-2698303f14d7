---
title: "Custom Assertions and Matchers"
description: "Guidance and API surface for defining user-specific assertions and matchers, enabling domain-specific or advanced expressive tests. Includes best practices for informative error reporting."
---

# Custom Assertions and Matchers

GoogleTest empowers you to enhance your tests with **custom assertions and matchers** tailored to your specific domain and testing needs. This page details how you can define expressive, user-specific assertions and matchers to produce tests that not only verify behavior but also communicate intent and errors clearly.

## Why Custom Assertions and Matchers?

While GoogleTest offers a vast suite of built-in matchers and assertions, real-world scenarios often call for checks that align tightly with your application's domain concepts. Crafting custom assertions:

- Enables expressive tests that read almost like natural language.
- Provides detailed and precise error messages when tests fail.
- Encourages reuse and consistency of validation logic across your test suite.

By systematically defining your own assertions and matchers, you make your tests more maintainable, robust, and communicative.

---

## Defining Custom Matchers

Custom matchers let you specify how values should be validated in tests.
They focus on whether a given value satisfies a condition, and if not, explain what went wrong.

### Using the `MATCHER` Macro

The most accessible way to write a custom matcher is via the `MATCHER` (and parameterized variants like `MATCHER_P`):

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

- `arg` represents the value being tested.
- The matcher returns `true` if `arg` matches; otherwise, `false`.
- The description string documents the matcher for error messages.

Usage example:

```cpp
EXPECT_CALL(mock, Foo(IsDivisibleBy7()));
EXPECT_THAT(some_expression, IsDivisibleBy7());
```

If the matcher fails, GoogleTest produces a clear, readable error message explaining the failure.

### Parameterized Matchers

To add flexible matchers that depend on user-supplied parameters:

```cpp
MATCHER_P(InClosedRange, range, "") {
  return arg >= range.first && arg <= range.second;
}
```

Usage:

```cpp
EXPECT_THAT(value, InClosedRange(std::make_pair(5, 10)));
```

Descriptions can incorporate parameter values for rich failure explanations.

### Writing Matcher Classes for Advanced Use Cases

For reusable matchers requiring more control or state, implement a matcher class with the prescribed interface. It must define:

- `bool MatchAndExplain(const T& value, std::ostream* listener) const`
- `void DescribeTo(std::ostream* os) const`
- `void DescribeNegationTo(std::ostream* os) const`

Example:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected)
      : expected_(expected) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* /* listener */) const {
    return (foo.bar() + foo.baz()) == expected_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_;
  }

 private:
  int expected_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected) {
  return ::testing::Matcher<const Foo&>(new BarPlusBazEqMatcher(expected));
}
```

Using this matcher increases diagnostic quality by explaining specifically why a match failed.

---

## Crafting Custom Assertions

While matchers evaluate conditions with informative messages, **assertions** check conditions and terminate or continue tests based on success or failure.

You can write helper functions that return `::testing::AssertionResult`, allowing fine-grained control over success/failure and custom messages.

Example:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess();
  } else {
    return testing::AssertionFailure() << n << " is not even";
  }
}

// Usage:
EXPECT_TRUE(IsEven(value));
```

This approach lets you provide rich failure explanations without resorting to cumbersome boolean expressions.

### Predicate-Format Assertions

To fully customize how failure messages are printed, use predicate-format assertions, allowing your predicate function to receive expressions as strings for precise diagnostics.

```cpp
testing::AssertionResult AssertBetween(const char* val_expr, const char* lower_expr,
                                       const char* upper_expr, int val, int lower, int upper) {
  if (val >= lower && val <= upper) return testing::AssertionSuccess();
  return testing::AssertionFailure() << val_expr << " (" << val << ") is not in range ["
                                   << lower_expr << ", " << upper_expr << "]";
}

EXPECT_PRED_FORMAT3(AssertBetween, value, 5, 10);
```

---

## Best Practices for Custom Assertions and Matchers

- **Keep matchers pure**: Avoid side-effects. Matchers may be called multiple times or not at all.
- **Use descriptive messages**: Leverage `DescribeTo()` and streaming in `MatchAndExplain()` to provide actionable failure insights.
- **Prefer matchers for conditions; assertions for control flow**: Use assertions to signal test flow changes; use matchers to declare conditions cleanly.
- **Parameterize your matchers**: Enable reusable, flexible conditions.
- **Use `ON_CALL` to set default behaviors and `EXPECT_CALL` for verification** when mocking.

---

## Tips for Informative Error Reporting

- Use streaming to output diagnostic details in `MatchAndExplain()`—this appears in failure messages.
- Provide negation descriptions clearly with `DescribeNegationTo()`.
- When defining parameterized matchers, include the parameters in description strings.
- Add actionable hints or intermediate values causing failures.
- Consider using `EXPECT_PRED_FORMAT*` macros for custom and complex assertions that need access to expressions.

---

## Common Pitfalls to Avoid

- Defining mock methods or matchers without considering constness, reference qualifiers, or overloads can yield compile errors or warnings.
- Do not mock private/protected methods outside of public sections to ensure `EXPECT_CALL` and `ON_CALL` visibility.
- Avoid overly strict expectations on mocks (`StrictMock`) unless necessary; prefer `NiceMock` or default mocks to reduce brittleness.
- Avoid making real classes virtual solely for mocking; prefer mocking interfaces.
- Avoid complex matchers with side effects.

---

## Example: Creating a Custom Matcher for a Complex Type

Suppose you have a class `Person` and want to check that the sum of their age and number of pets equals a certain value:

```cpp
class Person {
 public:
  int age() const;
  int num_pets() const;
};

MATCHER_P(AgePlusPetsEquals, expected, "") {
  return (arg.age() + arg.num_pets()) == expected;
}

// Usage:
EXPECT_THAT(john, AgePlusPetsEquals(42));
```

Failure messages will clearly state the condition expected.

---

## Additional References and Extensions

- See the [GoogleTest Primer](primer.md) for introduction to writing tests.
- Explore the [Mocking Reference](reference/mocking.md) and [Matchers API](googlemock/include/gmock/gmock-matchers.h) for advanced matchers and mocking techniques.
- Consult the [gMock Cookbook](docs/gmock_cook_book.md) for real-world matcher and action recipes.
- For writing custom matchers with detailed diagnostics, review the internal matcher interface in `gmock-matchers.h`.

---

By harnessing custom assertions and matchers effectively, you will write tests that are highly expressive, maintain robust validation logic, and provide immediate, informative feedback when failures occur—empowering rapid diagnosis and confidence in code correctness.