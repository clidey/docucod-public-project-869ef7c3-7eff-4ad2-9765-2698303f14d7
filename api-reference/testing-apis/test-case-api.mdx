---
title: "Test Cases and Fixtures"
description: "Describes how to define tests using TEST, TEST_F, and test fixtures, as well as advanced patterns with typed and parameterized test macros. Covers suite organization, fixture initialization/teardown, and strategies for scalable test architecture."
---

# Test Cases and Fixtures

This page delivers a comprehensive guide to defining and organizing tests in GoogleTest, focusing on the use of `TEST`, `TEST_F`, test fixtures, as well as advanced patterns with typed and parameterized tests. It equips you to effectively group, initialize, and teardown tests, providing scalable test architecture strategies.

---

## Writing Basic Tests with the `TEST` Macro

GoogleTest provides the `TEST` macro as the simplest way to define a test. Use it to create independent test functions without shared state.

```cpp
TEST(TestSuiteName, TestName) {
  // Your test code and assertions here
}
```

- The first argument is the **test suite name**, grouping related tests.
- The second argument is the **individual test name**.
- Both must be valid C++ identifiers without underscores.

### Example

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(3), 6);
}
```

These belong to the `FactorialTest` suite, letting GoogleTest organize test results logically.

---

## Using Test Fixtures with `TEST_F`

When your tests need to share common setup and cleanup code or reuse data, use test fixtures. Define a fixture class by inheriting from `testing::Test`, and then use the `TEST_F` macro to write tests using that fixture.

### Defining a Test Fixture

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Initialization common to all tests
    q1_.Enqueue(1);
    q2_.Enqueue(2);
  }

  void SetUp() override {
    // Code here runs before each test
  }

  void TearDown() override {
    // Code here runs after each test
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};
```

- `SetUp()` and `TearDown()` can be used for per-test setup and cleanup.
- Member variables hold shared data accessible in each test.

### Writing Tests with Fixtures

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

Each `TEST_F` creates a fresh instance of `QueueTest`.

---

## Shared Setup and Teardown for Test Suites

If your tests require expensive setup/teardown shared across all tests in a suite, use static methods `SetUpTestSuite()` and `TearDownTestSuite()` in your fixture:

```cpp
class FooTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Runs once before all tests in FooTest
    shared_resource_ = new Resource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  static Resource* shared_resource_;
};

Resource* FooTest::shared_resource_ = nullptr;
```

- These run before/after the entire suite.
- Must be `public` if using `TEST_P` or parameterized tests.

---

## Parameterized Tests with `TEST_P` and `INSTANTIATE_TEST_SUITE_P`

Use parameterized tests to run the same test logic repeatedly with different parameters.

### Defining Parameterized Tests

Define a fixture deriving from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}
```

### Instantiating Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to generate test instances with parameter sets.

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers, FooTest, testing::Values(2, 4, 6));
```

Resulting test names include the instantiation and parameter indices.

### Parameter Generators

GoogleTest provides generators like:

- `Range(begin, end [, step])`
- `Values(v1, v2, ..., vN)`
- `ValuesIn(container)`
- `Bool()` for boolean values
- `Combine(g1, g2, ..., gN)` to generate cartesian products

### Customizing Parameter Names

Add a callback functor to name tests meaningfully:

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedInst, FooTest, testing::Values(1, 2),
  [](const testing::TestParamInfo<FooTest::ParamType>& info) {
    return "Param_" + std::to_string(info.param);
  });
```

---

## Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`

Test the same logic over multiple types.

### Defining Typed Tests

Define a fixture class template:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```

Associate types with `TYPED_TEST_SUITE`:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Writing Typed Tests

Use the `TYPED_TEST` macro:

```cpp
TYPED_TEST(MyTypedTest, IsDefaultZero) {
  TypeParam zero{};
  EXPECT_EQ(this->value_, zero);
}
```

---

## Type-Parameterized Tests with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`

Define type-parameterized tests that can be instantiated multiple times later.

### Steps

1. Use `TYPED_TEST_SUITE_P` to declare the test suite.
2. Define tests with `TYPED_TEST_P`.
3. Register with `REGISTER_TYPED_TEST_SUITE_P`.
4. Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Example

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, TestSomething) {
  TypeParam val{};
  EXPECT_TRUE(SomeCheck(val));
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestSomething);

using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

---

## Defining Individual Tests that Use Fixtures and Parameters

- Use `TEST_F(TestFixture, TestName)` for tests using fixtures.
- Use `TEST_P(TestFixture, TestName)` for parameterized tests.
- Use `TYPED_TEST(TestFixture, TestName)` for typed tests.
- Use `TYPED_TEST_P(TestFixture, TestName)` for type-parameterized tests.

Each creates isolated test instances.

---

## Best Practices for Scalable Test Architecture

- Name test suites and tests consistently with C++ identifier rules.
- Use fixtures for shared setup; minimize redundant code.
- Prefer `ON_CALL` for default mock behaviors and `EXPECT_CALL` for verifications.
- Use parameterized and typed tests to reduce code duplication across inputs and types.
- Avoid fragile ordering by carefully using sequences only when necessary.
- Use `SetUpTestSuite`/`TearDownTestSuite` for expensive shared resources.
- Avoid mixing test fixture setup with test logic.

---

## Troubleshooting Common Issues

- Fatal assertions (`ASSERT_*`) should not be used in constructors or destructors.
- When using parameterized tests, ensure `INSTANTIATE_TEST_SUITE_P` is used to instantiate; otherwise tests fail silently.
- If encountering ambiguous overloads in mocks, help the compiler with disambiguation techniques such as `Const()` or typed matchers.
- Use `SCOPED_TRACE` to add context in failure messages for subroutine calls.

---

## References and Next Steps

- See the [Testing Reference](https://github.com/google/googletest/blob/main/docs/reference/testing.md) for detailed macros and classes used to define tests.
- Explore the [GoogleTest Primer](primer.md) for a deeper introduction to testing concepts.
- Visit the [Guides on Writing & Running Tests](guides/writing-and-running-tests) for best practices and workflows.
- For mocking, consult [Mocking Reference](docs/reference/mocking.md) and [gMock for Dummies](docs/gmock_for_dummies.md).

---

This page empowers you to structure tests confidently with foundational GoogleTest APIs, ensuring comprehensive, maintainable, and scalable unit tests for your C++ projects.
