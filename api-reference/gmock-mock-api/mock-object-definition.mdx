---
title: "Defining Mock Objects"
description: "Covers the MOCK_METHOD macros used to define mock classes and methods, including support for const, ref, noexcept, and special qualifiers. Illustrates configuring mock interfaces for classes and integrating with test code."
---

# Defining Mock Objects

This documentation provides a comprehensive guide to defining mock classes and methods using the `MOCK_METHOD` macros in GoogleMock. It highlights the supported qualifiers like `const`, `ref`, `noexcept`, and special calling conventions, and shows how to configure mock interfaces that integrate cleanly with test code.

---

## Overview

In GoogleMock, defining mock objects is streamlined through the `MOCK_METHOD` macro family. These macros allow you to declare mock methods inside your mock classes—classes designed to simulate interfaces or behaviors of real classes in tests.

### Basic Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```
- **ReturnType**: The function return type.
- **MethodName**: The name of the mock method.
- **Args**: The argument list enclosed in parentheses.
- **Specs (optional)**: A comma-separated list of method qualifiers, enclosed in parentheses (e.g., `const`, `override`).

The macro generates the method declaration and definition for you, allowing the mock to intercept calls and validate them against your test expectations.

### Essential Requirements

- `MOCK_METHOD` must be declared in the `public:` section of the mock class, regardless of the access level of the original method.
- If the original method uses qualifiers like `const` or `noexcept`, they must be specified in the `Specs` parameter.
- Parentheses are required around the argument list and qualifiers.

---

## Using `MOCK_METHOD`

### Defining Mock Methods

Suppose you have a base class to mock:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
};
```

You can define a mock like this:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};
```

- Note that for `GetSize`, which is `const` in the base class, the `(const, override)` qualifiers are present explicitly.
- The macro handles both method declaration and definitions internally.

### Handling Commas in Types

If your return type or argument types contain commas (such as templates), wrap them in parentheses to avoid parsing issues.

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());
MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
```

Alternatively, use a type alias:

```cpp
using BoolAndInt = std::pair<bool, int>;
MOCK_METHOD(BoolAndInt, GetPair, ());
using MapIntDouble = std::map<int, double>;
MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
```

### Mocking `const` Methods

When mocking a method declared as `const` in the base interface, add `const` in the specs:

```cpp
MOCK_METHOD(int, GetSize, (), (const, override));
```

This ensures the mock properly overrides the base `const` method.

### Qualifiers and Specifiers

`MOCK_METHOD` supports a fixed set of qualifiers that can be specified in the specs parameter:

| Qualifier                 | Purpose                                    |
|---------------------------|--------------------------------------------|
| `const`                   | Marks the mocked method as a const method. Required if base method is const. |
| `override`                | Marks the method as `override`. Recommended for virtual overrides. |
| `noexcept`                | Marks the method as `noexcept`. Required if base method is noexcept. |
| `Calltype(...)`           | Specifies calling convention, e.g., `Calltype(STDMETHODCALLTYPE)` for Windows. |
| `ref(&)` or `ref(&&)`     | Marks the method with the reference qualifier — needed if the base method has ref qualifiers. |

Example of ref-qualified method:

```cpp
MOCK_METHOD(int, RefQualifiedMethod, (), (const, ref(&), override));
```

### Mocking Methods with Calling Conventions

On Windows, methods with special calling conventions can be mocked with `Calltype`:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
MOCK_METHOD(int, Bar, (double x, double y), (const, Calltype(STDMETHODCALLTYPE)));
```

This ensures compatibility with interfaces using such conventions.

### Example: Complete Mock Class

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual bool Process(int elem, int count) noexcept = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int elem, int count), (noexcept, override));
};
```

---

## Legacy Macros

Older codebases may use `MOCK_METHODn` and related macros:

```cpp
MOCK_METHOD1(Foo, bool(int));
MOCK_CONST_METHOD1(Bar, int(int));
```

These have been superseded by the generic `MOCK_METHOD`, but are still supported.

Old macros differ mainly in:
- The number of arguments is encoded in the macro name (e.g., `MOCK_METHOD2`).
- Const methods use `MOCK_CONST_METHODn`.
- For templates, suffix `_T` or `_WITH_CALLTYPE` variants exist for special use-cases.

### Mapping Old to New

| Old Macro                                   | New Equivalent                            |
|---------------------------------------------|------------------------------------------|
| `MOCK_METHOD1(Foo, bool(int))`               | `MOCK_METHOD(bool, Foo, (int))`           |
| `MOCK_CONST_METHOD1(Bar, bool(int))`         | `MOCK_METHOD(bool, Bar, (int), (const))`  |
| `MOCK_METHOD1_T(Foo, bool(int))`              | `MOCK_METHOD(bool, Foo, (int))`           |
| `MOCK_CONST_METHOD1_T(Foo, bool(int))`        | `MOCK_METHOD(bool, Foo, (int), (const))`  |
| `MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))`     | `MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))`       |
| `MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))` |

Legacy macros can still be used, but migrating to `MOCK_METHOD` is recommended.

---

## Best Practices

- Always specify `override` on mock methods to catch mismatch with base class methods.
- Use `const` and `noexcept` in mock method specs exactly as in the base method.
- Wrap types containing commas within parentheses or define alias types for clean syntax.
- Declare mocks in the `public:` section to ensure accessibility by testing macros like `EXPECT_CALL` and `ON_CALL`.
- For overloaded functions, mock all variants or use `using BaseClass::methodName;` to avoid hiding base methods.

---

## Example: Mocking an Interface with Overloads

```cpp
class Foo {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int count, int x) = 0;
  virtual const std::string& GetName() const = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int count, int x), (override));
  MOCK_METHOD(const std::string&, GetName, (), (const, override));
};
```

If you do not mock all overloads, the compiler will warn you about base methods being hidden.

To fix it, add:

```cpp
using Foo::Add;
```

in `MockFoo`'s public section.

---

## Integrating with Test Code

Using mocks in tests follows this typical flow:

1. Include the mock header and `gmock/gmock.h`.
2. Instantiate mock objects.
3. Set expectations using `EXPECT_CALL()`.
4. Exercise the system under test that uses these mocks.
5. Upon test end or mock destruction, `EXPECT_CALL` expectations are verified.

Example:

```cpp
#include <gmock/gmock.h>
#include "mock_foo.h"

using ::testing::Return;

TEST(FooTest, UsesMock) {
  MockFoo foo;

  EXPECT_CALL(foo, GetSize())
    .WillOnce(Return(5));

  EXPECT_EQ(5, foo.GetSize());
}
```

This verifies your mock intercepts the calls and behaves as expected seamlessly.

---

## Troubleshooting

### Common Issues

- **Compilation errors from unprotected commas in types:** Use parentheses or type aliases.
- **Warnings about overriding virtual methods with const parameters:** Top-level const in parameters is ignored; remove those const qualifiers if possible.
- **Unmatched calls:** Verify that you set the correct expectations using correct matchers.
- **Uninteresting calls warning:** Use `NiceMock<>` to suppress, or explicitly add `EXPECT_CALL(...).Times(AnyNumber())` as a catch-all.

### Tips

- Use the `--gmock_verbose=info` flag to get detailed mock call traces.
- Always declare destructors of base interfaces as `virtual` to avoid undefined behavior.
- When mocking non-virtual methods, consider the high-perf dependency injection pattern.

---

## Related Documentation

- [Using Mocks in Tests](docs/gmock_for_dummies.md#using-mocks-in-tests)
- [Setting Expectations](docs/gmock_cook_book.md#setting-expectations)
- [Matchers Reference](docs/api-reference/gmock-mock-api/matchers-reference)
- [Mock Object Behaviors](docs/api-reference/gmock-mock-api/mock-object-behaviors-and-strictness)
- [Mocking Reference](docs/reference/mocking.md)

---

For the latest examples and usage patterns, consult the [gMock Cheat Sheet](docs/gmock_cheat_sheet.md).

---

*This documentation draws from GoogleTest and GoogleMock code and user guides to help you master defining mock objects effectively and idiomatically.*

