---
title: "Mock Class and Method Macros"
description: "Documents the core macros and utilities for declaring and implementing mock classes and methods. Covers `MOCK_METHOD` usage and variants, with illustrative mock class examples."
---

# Mock Class and Method Macros

This documentation details the core macros and utilities provided by GoogleMock for declaring and implementing mock classes and methods in C++. It focuses on the powerful and flexible `MOCK_METHOD` macro family that allows you to easily define mocked methods, including advanced features such as qualifiers, overloads, templates, and calling conventions. Practical examples illustrate common usage scenarios and best practices.

---

## Overview of Mock Class Macros

GoogleMock enables effortless mocking of C++ interfaces by providing macros to declare mock methods inside mock classes. These macros generate all necessary boilerplate to intercept calls, specify expected behavior, and verify interactions during tests.

### Defining Mock Classes with `MOCK_METHOD`

Use `MOCK_METHOD` to declare a mock method inside a mock class:

```cpp
class MockClass {
 public:
  MOCK_METHOD(ReturnType, MethodName, (Args...), (Specifiers));
};
```

- **ReturnType**: The return type of the method.
- **MethodName**: The name of the method to mock.
- **Args...**: Parenthesized list of argument types.
- **Specifiers**: Optional comma-separated list of qualifiers such as `const`, `override`, `noexcept`, and calling conventions.

All `MOCK_METHOD` macros _must_ be declared in the `public:` section of the mock class to enable proper access for setting expectations and default actions.

### Example: Basic Mock Class Declaration

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

This mock class can be used in tests to set expectations, default behavior, and to verify interactions with the `Turtle` interface.

---

## Handling Complex Return and Argument Types

### Commas in Return or Argument Types

If your return or argument types contain unprotected commas (e.g., template types like `std::pair<bool, int>`), `MOCK_METHOD` may fail to parse correctly.

#### Solution 1: Parenthesize Types

Wrap types containing commas in **extra parentheses** to group them properly:

```cpp
class MockFoo {
 public:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
};
```

#### Solution 2: Use Type Aliases

Define type aliases to avoid unprotected commas directly inside the macro:

```cpp
class MockFoo {
 public:
  using BoolAndInt = std::pair<bool, int>;
  using MapIntDouble = std::map<int, double>;

  MOCK_METHOD(BoolAndInt, GetPair, ());
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

This keeps your code clean and readable.

---

## Qualifiers and Specifiers

You can specify additional method qualifiers as an optional fourth argument to `MOCK_METHOD`. These include:

| Qualifier                  | Description                                               |
|----------------------------|-----------------------------------------------------------|
| `const`                    | Marks the method as `const`. Required to mock `const` methods. |
| `override`                 | Marks the method as `override`. Recommended to reflect virtual overrides. |
| `noexcept`                 | Marks the method as `noexcept`. Required if overriding a `noexcept` method. |
| `Calltype(...)`            | Sets calling convention, e.g., `Calltype(STDMETHODCALLTYPE)` on Windows. |
| `ref(&)` or `ref(&&)`      | Applies reference qualifiers for methods qualified with `&` or `&&`. |

Example with specifiers:

```cpp
MOCK_METHOD(int, GetSize, (), (const, override));
MOCK_METHOD(void, Process, (int x), (override, noexcept));
MOCK_METHOD(bool, Foo, (), (Calltype(STDMETHODCALLTYPE), override));
```

---

## Mocking Overloaded Methods

You can mock overloaded methods by declaring each overload using `MOCK_METHOD` with the exact signature and qualifiers.

```cpp
class Foo {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int times, int x) = 0;
  virtual int GetValue() const = 0;
  virtual int GetValue() = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(int, GetValue, (), (override));
};
```

**Note:** If you do not mock all overloaded versions, use `using BaseClass::MethodName;` to bring unmocked overloads into scope and avoid hiding warnings.

---

## Mocking Class Templates

Mocking class templates works identically to regular classes. Declare the template parameter(s) as usual and mock the methods:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

---

## Mocking Non-Virtual Methods (High-Perf Dependency Injection)

GoogleMock can't mock non-virtual methods directly. Instead, the typical pattern is to create a mock class unrelated to the real class but with the same method signatures.

Example:

```cpp
class ConcretePacketStream {
 public:
  void AppendPacket(Packet* new_packet);
  const Packet* GetPacket(size_t packet_number) const;
  size_t NumberOfPackets() const;
};

class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

You then use template code or compile-time dispatch to switch between real and mock implementations.

---

## Mocking Private or Protected Methods

Always declare mock methods `MOCK_METHOD` in the **public:** section of your mock class, regardless of original method visibility. C++ allows changing access levels in derived classes.

Example:

```cpp
class Foo {
 protected:
  virtual void Resume();
 private:
  virtual int GetTimeout();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Resume, (), (override));  // Public, though base protected
  MOCK_METHOD(int, GetTimeout, (), (override));  // Public, though base private
};
```

---

## Old-Style `MOCK_METHODn` Macros

Before 2018, GoogleMock used method-count-suffixed macros like `MOCK_METHOD1`, `MOCK_CONST_METHOD1`, etc. While still supported for legacy code, migrating to `MOCK_METHOD` is recommended.

| Old Macro                                   | New Equivalent                                |
|---------------------------------------------|-----------------------------------------------|
| `MOCK_METHOD1(Foo, bool(int))`               | `MOCK_METHOD(bool, Foo, (int))`                 |
| `MOCK_CONST_METHOD1(Foo, bool(int))`         | `MOCK_METHOD(bool, Foo, (int), (const))`         |
| `MOCK_METHOD1_T(Foo, bool(int))`             | `MOCK_METHOD(bool, Foo, (int))`                 |
| `MOCK_CONST_METHOD1_T(Foo, bool(int))`       | `MOCK_METHOD(bool, Foo, (int), (const))`         |
| `MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))` |

---

## Mock Strictness Wrappers

GoogleMock provides wrapper templates to control how uninteresting calls (calls to mock methods without matching expectations) are handled.

| Wrapper             | Behavior Description                                    | Example Usage                         |
|---------------------|---------------------------------------------------------|--------------------------------------|
| `NiceMock<T>`       | Suppresses warnings on uninteresting calls.             | `NiceMock<MockFoo> nice_foo;`        |
| `NaggyMock<T>`      | Prints warnings on uninteresting calls (default mock).   | `NaggyMock<MockFoo> naggy_foo;`      |
| `StrictMock<T>`     | Treats uninteresting calls as test failures.             | `StrictMock<MockFoo> strict_foo;`    |

These wrappers subclass the underlying mock class, retaining all functionality but changing behavior for uninteresting calls. They also forward constructors transparently.

---

## Common Best Practices and Tips

- Always place `MOCK_METHOD` declarations in the public section of the mock class.
- Wrap complex types with parentheses or create type aliases to handle commas in template parameters.
- If mocking overloaded methods, mock all overloads or use `using Base::Method;` to avoid hiding overloads.
- Prefer migrating legacy `MOCK_METHODn` macros to unified `MOCK_METHOD` syntax for clarity.
- Use `NiceMock` by default to reduce noise from uninteresting calls.
- Use `StrictMock` to enforce strict verification during debugging or when you want to catch all unexpected calls.

---

## Complete Example

```cpp
#include <gmock/gmock.h>
#include <map>
#include <string>

using ::testing::Return;

// Original interface with overloaded and templated methods.
class Foo {
 public:
  virtual ~Foo() {}
  virtual int Add(int x) = 0;
  virtual int Add(int times, int x) = 0;
  virtual std::pair<bool, int> GetPair() = 0;
  virtual bool CheckMap(std::map<int, double> m, bool flag) const = 0;
};

// Mock class
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));

  // Wrapping return type with extra parentheses due to comma
  MOCK_METHOD((std::pair<bool, int>), GetPair, (), (override));

  // Wrapping argument type with extra parentheses
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool), (const, override));
};

TEST(FooTest, TestAdd) {
  MockFoo mock;
  EXPECT_CALL(mock, Add(5)).WillOnce(Return(10));
  EXPECT_CALL(mock, Add(3, 7)).WillOnce(Return(21));

  EXPECT_EQ(10, mock.Add(5));
  EXPECT_EQ(21, mock.Add(3, 7));
}
```

---

## Troubleshooting Common Pitfalls

### Parsing Errors with Comma in Template Types

If your mock definition fails to compile, check if your return or argument types contain unprotected commas. Wrap those types in an additional pair of parentheses or create type aliases.

### Visibility Issues Mocking Private or Protected Methods

Remember that `MOCK_METHOD` declarations *must* be public even if mocking private or protected methods of the base class.

### Overloaded Method Ambiguities

If you get compilation errors with overloaded methods, explicitly define all overloads or use `using BaseClass::Method;` to bring in unmocked overloads.

### Strictness Behavior of NiceMock, NaggyMock, StrictMock

If you get unexpected warnings or failures from uninteresting calls, verify which wrapper you are using and choose appropriately to reduce noise or enforce strictness.

### Special Call Type Support on Windows

When mocking methods with non-default calling conventions, specify it via `(Calltype(...))` in the specifier list.

---

For more details on setting expectations, argument matchers, and mock behaviors, see the related sections in the GoogleMock documentation such as [Defining Expectations](../guides/mocking-techniques/defining-expectations-and-verifying-behavior.mdx) and [Mock Strictness and Behavior Modes](../api-reference/mocking-matching-actions/mock-behaviors.mdx).