---
title: "Writing Custom Matchers"
description: "Explains the APIs and templates for creating custom matchers for both test assertions and mock expectations. Provides insight on composition, documentation, and maintaining matcher libraries."
---

# Writing Custom Matchers

This guide details how to create your own custom matchers in GoogleTest and GoogleMock, enabling you to write expressive, reusable conditions for test assertions and mock expectations. You'll learn about the APIs and templates involved, how to compose matchers, document them effectively, and maintain a matchers library for scalable test development.

---

## Why Write Custom Matchers?

Built-in matchers cover many common testing needs, but sometimes you need to verify complex conditions or domain-specific invariants that cannot be expressed with existing matchers. Custom matchers let you encapsulate these checks with clear failure messages, improving both test readability and diagnostics.

--

## Types of Custom Matchers

GoogleTest supports several ways to create matchers:

- **MATCHER macros**: Quick and terse matcher definitions suitable for many cases.
- **Matcher classes implementing MatcherInterface**: For greater control, type specialization, and rich descriptions.
- **Polymorphic matchers**: Able to match multiple argument types via templates.

This page focuses on these interfaces as used in GoogleMock's mocking and GoogleTest assertion context.

---

## Defining a Matcher Using MATCHER Macros

The `MATCHER` family of macros provides a fast path to define a matcher with minimal code:

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

You can use this matcher directly:

```cpp
EXPECT_CALL(mock_foo, Bar(IsDivisibleBy7()));
EXPECT_THAT(some_value, IsDivisibleBy7());
```

### Parameterized Matchers

If your matcher needs parameters, use `MATCHER_P`, `MATCHER_P2`, up to `MATCHER_P10`:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}
```

Usage:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

### Custom Descriptions and Diagnostic Explanations

- The last argument to the `MATCHER*` macro is a string expression used as a custom matcher description.
- The special variable `negation` is `true` when describing negated matchers.
- Provide additional context to test failures by streaming messages to `*result_listener` in your matcher body:

```cpp
MATCHER_P(IsDivisibleBy7, "") {
  int remainder = arg % 7;
  if (remainder != 0 && result_listener != nullptr) {
    *result_listener << "remainder is " << remainder;
  }
  return remainder == 0;
}
```

---

## Implementing Matcher Classes Directly

MATCHER macros are convenient but may sometimes be insufficient for complex matchers or when you want clearer compiler diagnostics and more control.

### Matcher Interface

To implement a matcher class for argument type `T`, define:

- A class with `using is_gtest_matcher = void;`
- A `bool MatchAndExplain(const T& value, std::ostream* listener)` or preferably `MatchResultListener*` parameter
- `void DescribeTo(std::ostream* os)` and `void DescribeNegationTo(std::ostream* os)` methods

Example:

```cpp
class BarPlusBazEqMatcher {
 public:
  using is_gtest_matcher = void;

  explicit BarPlusBazEqMatcher(int expected_sum) : expected_sum_(expected_sum) {}

  bool MatchAndExplain(const Foo& foo, std::ostream* os) const {
    return foo.bar() + foo.baz() == expected_sum_;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "bar() + baz() equals " << expected_sum_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "bar() + baz() does not equal " << expected_sum_;
  }

 private:
  const int expected_sum_;
};

::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {
  return BarPlusBazEqMatcher(expected_sum);
}
```

Usage:

```cpp
EXPECT_THAT(foo, BarPlusBazEq(5));
```

### Polymorphic Matchers

Make the `MatchAndExplain` method a function template to allow matching multiple argument types:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const {
    return p != nullptr;
  }

  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

This lets `NotNull()` be used with raw and smart pointers of different types.

---

## Composing Matchers

Custom matchers can delegate to or compose existing matchers for modular, reusable code:

```cpp
MATCHER_P(NestedPropertyMatches, matcher, "") {
  return ExplainMatchResult(matcher, arg.nested().property(), result_listener);
}
```

Use `DescribeMatcher<ExpectedType>(matcher, negation)` to generate descriptions of sub-matchers.

---

## Documenting and Maintaining Matcher Libraries

- Choose descriptive matcher names that read naturally in failure messages.
- Provide rich, detailed descriptions and diagnostic output via `DescribeTo`, `DescribeNegationTo`, and streaming to `result_listener`.
- Make matchers polymorphic when applicable to maximize reuse.
- Organize your matchers logically by domain or type to facilitate discovery.

---

## Practical Tips & Best Practices

- Prefer `MATCHER` macros for quick matchers that are simple and self-contained.
- Use matcher classes for complex logic, type-specific matchers, or when better compile-time diagnostics are needed.
- Always provide informative failure messages for easier debugging.
- When matching container elements or object members, consider using existing container or member matchers, or composing with them.
- Avoid side effects inside matchers; they should be purely functional.

---

## Troubleshooting

- If your matcher fails to compile due to unclear types, explicitly specify template arguments or implement a matcher class to control types.
- If a matcher gives poor failure messages, enhance `DescribeTo` and `DescribeNegationTo`, and consider providing output on mismatches with `result_listener`.
- Avoid calling mock methods inside matchers, as matchers should be side-effect free.

---

## Related Documentation

For deeper understanding of matchers and mocking:

- [Matchers Reference](reference/matchers.md)
- [Mocking Reference](docs/reference/mocking.md)
- [gMock Cookbook â€” Writing New Matchers Quickly](docs/gmock_cook_book.md#NewMatchers)
- [Core Concepts & Terminology](overview/architecture-core-concepts/core-concepts-terminology.md)

---

## Summary

Writing custom matchers in GoogleTest and GoogleMock empowers you to create highly expressive, reusable, and precise test conditions. Start with simple `MATCHER` macros for straightforward checks and graduate to fully implemented matcher classes for complex scenarios. Emphasize clear descriptions and meaningful failure messages to maximize test clarity and maintainability.

---

<Info>
For examples and implementation patterns, see [gMock's built-in matchers implementation](https://github.com/google/googletest/blob/main/googlemock/include/gmock/gmock-matchers.h) and the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#WritingNewMatchersQuickly).
</Info>
