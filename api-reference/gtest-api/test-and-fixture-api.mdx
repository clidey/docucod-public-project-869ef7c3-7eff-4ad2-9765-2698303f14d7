---
title: "Test and Fixture API"
description: "Detailed documentation of the fundamental GoogleTest APIs for defining test cases, test suites, and fixtures. Learn how to structure tests using TEST, TEST_F, and related macros, manage setup/teardown, and leverage the main entry points for running tests. This page is essential for anyone starting out with GoogleTest or organizing complex test hierarchies."
---

# Test and Fixture API

Detailed documentation of the fundamental GoogleTest APIs for defining test cases, test suites, and fixtures. Learn how to structure tests using `TEST`, `TEST_F`, and related macros, manage setup/teardown, and leverage the main entry points for running tests. This page is essential for anyone starting out with GoogleTest or organizing complex test hierarchies.

---

## Overview of Test and Fixture APIs

GoogleTest provides a structured and intuitive way to organize and write your tests using macros and test fixtures. This allows you to write isolated, repeatable tests grouped logically into test suites, taking advantage of setup and teardown mechanisms for efficient and maintainable test code.

All your test code should include the following header to access these APIs:

```cpp
#include <gtest/gtest.h>
```

Whether you are writing simple test cases or complex hierarchies requiring shared setup, GoogleTest provides macros and classes designed to cover your needs.

---

## Defining Simple Tests with `TEST`

The fundamental building block is the `TEST` macro, which defines an individual test.

```cpp
TEST(TestSuiteName, TestName) {
  // test code and assertions
}
```

- `TestSuiteName`: Groups related tests; must be a valid C++ identifier without underscores.
- `TestName`: The specific test you are defining.

These form the full test name `TestSuiteName.TestName`, which you can reference when filtering or running tests.

### Behavior

- Each `TEST` defines a test that runs independently and can have any assertions.
- Multiple tests with the same `TestName` can exist in different test suites.
- Naming guidelines discourage underscores in names to avoid internal conflicts.

### Example

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(3), 6);
}
```

---

## Reusing Setup Using Test Fixtures with `TEST_F`

When multiple tests share the same setup or utilities, use a **test fixture**.

### Creating a Test Fixture Class

Define a class derived from `testing::Test`:

```cpp
class MyTestFixture : public testing::Test {
 protected:
  // Optional constructor for common initialization
  MyTestFixture() {
    // Initialization code
  }

  // Called immediately before each test
  void SetUp() override {
    // Setup code
  }

  // Called immediately after each test
  void TearDown() override {
    // Cleanup code
  }

  // Shared objects or utilities
};
```

- Setup and teardown logic are placed in `SetUp()`/`TearDown()`.
- Constructors and destructors may be used for setup but cannot use fatal assertions.

### Writing Tests with Fixtures

Use the `TEST_F` macro to reference the fixture class:

```cpp
TEST_F(MyTestFixture, TestCase1) {
  // Access fixture members
  EXPECT_TRUE(SomeFunction());
}
```

- The test suite name is implicitly the fixture class name.
- Each test creates a fresh instance of the fixture; state does not leak between tests.

### Per-Test-Suite Setup and Teardown

To share expensive resources across all tests in a suite, provide static member functions:

```cpp
class MyTestFixture : public testing::Test {
 public:
  static void SetUpTestSuite() {
    // Called once before any tests in this suite
  }

  static void TearDownTestSuite() {
    // Called once after all tests in the suite
  }

  void SetUp() override {
    // Called before each test
  }

  void TearDown() override {
    // Called after each test
  }
};
```

This allows expensive initialization (e.g., database connections) to be done once per test suite.

### Example

```cpp
class QueueTest : public testing::Test {
 protected:
  std::queue<int> q;

  void SetUp() override {
    // Setup queue before each test
    q.push(1);
  }
};

TEST_F(QueueTest, HasOneElement) {
  EXPECT_EQ(q.size(), 1);
}

TEST_F(QueueTest, DequeuesElement) {
  int n = q.front();
  q.pop();
  EXPECT_EQ(n, 1);
  EXPECT_TRUE(q.empty());
}
```

---

## Parameterized and Typed Tests Overview (Brief Mention)

While this page focuses on test and fixture APIs, GoogleTest later provides `TEST_P` and `TYPED_TEST` macros for more advanced test behaviors like parameterized and typed tests. For details, see the [Parameterized and Typed Test API](../parameterized-and-typed-tests.md).

---

## Main Entry Points for Running Tests

To run your tests, define a `main()` function that initializes GoogleTest and runs all tests:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- `testing::InitGoogleTest()` parses GoogleTest-specific command line flags.
- `RUN_ALL_TESTS()` runs all registered tests and returns 0 on success, 1 otherwise.

This main function can be customized if you want special pre/post-processing but is usually provided by linking with `gtest_main`.

---

## Best Practices and Common Pitfalls

- **No underscores in test suite or test names:** Underscores cause internal naming collisions in generated classes.
- **Use test fixtures instead of global variables:** To prevent test interdependence and side effects.
- **Setup and teardown:** Use the fixture's `SetUp()` and `TearDown()` for per-test setup, and `SetUpTestSuite()` and `TearDownTestSuite()` for expensive shared setup.
- **Assertions in SetUp():** You can use assertions but be mindful that fatal assertions abort the current test.
- **Every test runs in isolation:** Modifications in one test's fixture object do not affect others.

---

## Summary

GoogleTest's Test and Fixture API provides:

- Macros for defining basic tests (`TEST`) and fixture-based tests (`TEST_F`).
- Facilities for shared setup and teardown both per test and per test suite.
- Clear guidelines on naming and structuring tests.
- Main functions to drive test execution and command-line parsing.

These APIs form the foundation for creating well-structured, maintainable test suites in C++.

---

## Reference

For a deeper understanding and examples, see the following related documentation:

- [GoogleTest Primer](../primer.md) — Introduces basic concepts and writing your first tests.
- [Advanced GoogleTest Topics](../advanced.md) — Covers more complex test scenarios and APIs.
- [Assertions Reference](assertions-and-failures.md) — Details on assertions used within tests.
- [Parameterized and Typed Test API](parameterized-and-typed-tests.md) — Advanced test parameterization.

---

## Additional Examples

### Simple `TEST` Macro

```cpp
TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}
```

### `TEST_F` with Fixture

```cpp
class VectorTest : public testing::Test {
 protected:
  std::vector<int> v;

  void SetUp() override {
    v = {1, 2, 3};
  }
};

TEST_F(VectorTest, SizeIsCorrect) {
  EXPECT_EQ(v.size(), 3);
}

TEST_F(VectorTest, CanClearVector) {
  v.clear();
  EXPECT_TRUE(v.empty());
}
```

### Per-Test-Suite Setup and Teardown

```cpp
class DBTest : public testing::Test {
 protected:
  static DBConnection* conn;

  static void SetUpTestSuite() {
    conn = new DBConnection("my_database");
  }

  static void TearDownTestSuite() {
    delete conn;
    conn = nullptr;
  }
};

DBConnection* DBTest::conn = nullptr;

TEST_F(DBTest, QueryReturnsResults) {
  ASSERT_TRUE(conn->ExecuteQuery("SELECT * FROM table"));
}
```


---