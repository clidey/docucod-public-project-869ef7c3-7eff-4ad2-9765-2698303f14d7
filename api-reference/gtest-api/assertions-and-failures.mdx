---
title: "Assertions and Failures"
description: "Complete API reference for GoogleTest assertion macros, custom predicates, assertion results, and error handling. This includes core assertions for equality, inequality, exceptions, and floating point comparisons, as well as facilities for user-defined assertions and controlling fatal/non-fatal failure handling within tests."
---

# Assertions and Failures

Comprehensive reference for GoogleTest assertion macros, custom predicates, assertion results, and failure handling.

---

## Overview of Assertions

GoogleTest offers a rich set of assertion macros to validate expected outcomes within your tests. To use assertions, include the header:

```cpp
#include <gtest/gtest.h>
```

Assertions come in pairs:

- `EXPECT_` macros generate **non-fatal** failures, allowing the test to continue.
- `ASSERT_` macros generate **fatal** failures, aborting the current function.

You can append custom failure messages to any assertion using the streaming operator `<<`:

```cpp
EXPECT_TRUE(condition) << "Condition failed explanation.";
```

This transparency and flexibility motivates clear, informative tests that help pinpoint issues effectively.

---

## Explicit Success and Failure

Sometimes control-flow determines success or failure rather than a boolean condition. For such cases, GoogleTest provides:

- `SUCCEED()`: Generates a documented success (does not affect overall test success).
- `FAIL()`: Generates a fatal failure and returns from the current `void` function.
- `ADD_FAILURE()`: Generates a nonfatal failure and continues.
- `ADD_FAILURE_AT(file, line)`: Generates a nonfatal failure at a specified file and line number.

These macros enable fine control especially for error cases or complex decision logic.

---

## Boolean Assertions

GoogleTest supports assertions for general boolean expressions:

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Pass if condition is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Pass if condition is false.

Failures report the evaluated expression and actual boolean result for clarity.

---

## Binary Comparison Assertions

These assertions compare two values using relational operators. They execute their arguments exactly once to avoid side effects issues. They are compatible with native types, strings, and user-defined types with streaming support for error messages.

| Macro          | Meaning                         |
|----------------|--------------------------------|
| `EXPECT_EQ(a,b)` / `ASSERT_EQ(a,b)` | Verify `a == b`            |
| `EXPECT_NE(a,b)` / `ASSERT_NE(a,b)` | Verify `a != b`            |
| `EXPECT_LT(a,b)` / `ASSERT_LT(a,b)` | Verify `a < b`             |
| `EXPECT_LE(a,b)` / `ASSERT_LE(a,b)` | Verify `a <= b`            |
| `EXPECT_GT(a,b)` / `ASSERT_GT(a,b)` | Verify `a > b`             |
| `EXPECT_GE(a,b)` / `ASSERT_GE(a,b)` | Verify `a >= b`            |

### Special Notes on Pointers and Strings

- Pointer equality for `EXPECT_EQ` compares addresses, **not** contents. To compare C strings by content, use `EXPECT_STREQ` or related string macros.
- Use `nullptr` rather than `NULL` when comparing pointers in assertions.

---

## String Comparison Assertions

GoogleTest provides specific assertions for C strings (null-terminated character arrays), including wide strings. These verify content equality or inequality, optionally ignoring case.

| Macro                 | Description                                |
|-----------------------|--------------------------------------------|
| `EXPECT_STREQ(a,b)` / `ASSERT_STREQ(a,b)` | Pass if C strings `a` and `b` have same content. |
| `EXPECT_STRNE(a,b)` / `ASSERT_STRNE(a,b)` | Pass if C strings `a` and `b` differ.         |
| `EXPECT_STRCASEEQ(a,b)` / `ASSERT_STRCASEEQ(a,b)` | Like STREQ but ignore case.            |
| `EXPECT_STRCASENE(a,b)` / `ASSERT_STRCASENE(a,b)` | Like STRNE but ignore case.            |

Wide strings (`wchar_t*`) are supported similarly with UTF-8 message translation.

---

## Floating-Point Assertions

Due to rounding and representation issues, floating-point assertions compare values approximately using either Units in Last Place (ULPs) or absolute error bounds.

| Macro                        | Description                            |
|------------------------------|--------------------------------------|
| `EXPECT_FLOAT_EQ(a,b)` / `ASSERT_FLOAT_EQ(a,b)`     | Checks that two floats are approximately equal within 4 ULPs. |
| `EXPECT_DOUBLE_EQ(a,b)` / `ASSERT_DOUBLE_EQ(a,b)`   | Same for doubles.                     |
| `EXPECT_NEAR(a,b,abs_error)` / `ASSERT_NEAR(a,b,abs_error)` | Pass if `|a - b| <= abs_error`.        |

These macros help prevent flaky failures caused by floating point precision.

---

## Exception Assertions

If exceptions are enabled in your build, you can verify that code throws or does not throw exceptions:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(...)`: Verify statement throws `exception_type`.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(...)`: Verify statement throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(...)`: Verify statement does not throw.

Statements can be compound blocks (`{ ... }`).

---

## Predicate Assertions

For complex conditions, GoogleTest provides predicate assertions that improve the clarity of failure messages:

- `EXPECT_PREDn(pred, args...)` / `ASSERT_PREDn(pred, args...)`: Uses your boolean `pred` with `n` arguments.
- `EXPECT_PRED_FORMATn(pred_formatter, args...)` / `ASSERT_PRED_FORMATn(...)`: Uses `pred_formatter` returning `AssertionResult` to customize failure messages.

This allows streaming argument values automatically and custom failure detail.

### Example:

```cpp
bool MutuallyPrime(int m, int n) { ... }

EXPECT_PRED2(MutuallyPrime, a, b); // Fails if a and b share common divisors

// Predicate-formatter example
AssertionResult AssertMutuallyPrime(const char* expr1, const char* expr2, int m, int n) {
  if (MutuallyPrime(m, n)) return AssertionSuccess();
  return AssertionFailure() << expr1 << " and " << expr2 
                            << " are not mutually prime.";
}
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, x, y);
```

---

## Generalized Assertions Using Matchers

GoogleTest supports GoogleMock matchers in assertions via:

- `EXPECT_THAT(value, matcher)` / `ASSERT_THAT(value, matcher)`

Matchers enable expressive, English-like assertions such as `EXPECT_THAT(str, StartsWith("Hello"))`.

---

## HRESULT Assertions (Windows only)

Special assertions verify that expressions return successful or failed `HRESULT` codes:

- `EXPECT_HRESULT_SUCCEEDED(expression)` / `ASSERT_HRESULT_SUCCEEDED(...)`: Pass if expression is success.
- `EXPECT_HRESULT_FAILED(expression)` / `ASSERT_HRESULT_FAILED(...)`: Pass if expression is failure.

Failures show the returned HRESULT code and accompanying error message.

---

## Death Assertions

Death tests verify that your code terminates (e.g., due to a fatal assertion failure or process kill). GoogleTest performs death tests in child processes.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH(...)`: Verifies `statement` terminates with nonzero exit code and that `stderr` matches `matcher`.
- `EXPECT_DEATH_IF_SUPPORTED(...)` / `ASSERT_DEATH_IF_SUPPORTED(...)`: Only run if death tests supported.
- `EXPECT_DEBUG_DEATH(...)` / `ASSERT_DEBUG_DEATH(...)`: Runs in debug mode only.
- `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT(...)`: Verifies `statement` exits with status satisfying `predicate` and `stderr` matches `matcher`.

For example:

```cpp
EXPECT_DEATH({ DoCrash(); }, "Crash message regex");
EXPECT_EXIT(NormalExit(), ::testing::ExitedWithCode(0), "Success");
```

---

## Assertion Results and Failure Objects

GoogleTest uses `AssertionResult` objects to represent the outcome of predicate assertions, supporting chaining of messages for detailed explanations.

`TestPartResult` objects encapsulate individual assertion results including type (success, non-fatal failure, fatal failure, skip), location, summary, and full message.

You can query test results programmatically for pass/fail state, fatal vs non-fatal failures, and access recorded failure messages. This supports rich reporting and filtering.

---

## Best Practices and Common Pitfalls

- Use `EXPECT_` macros where possible to continue tests after failures and uncover multiple issues.
- Use `ASSERT_` macros when failure should halt test execution to prevent further errors or undefined states.
- Stream prudent, informative failure messages to assertions to clarify the nature of failures.
- Use predicate assertions or custom predicate-formatters to improve clarity on complex assertions.
- Prefer string-specific assertions for C strings over using `EXPECT_EQ` to avoid pointer equality issues.
- Careful with floating-point comparisonsâ€”prefer the dedicated floating-point assertions.
- In death tests, avoid operations with side effects that must be observable after death.
- In functions with fatal assertions, understand that they abort only the current function, so consider using `HasFatalFailure()` or `ASSERT_NO_FATAL_FAILURE` to propagate failures properly.
- Use `SUCCEED()` and `FAIL()` to explicitly document expected unconditional success or failure points.

---

## Examples

### Basic Boolean Assertion

```cpp
TEST(FactorialTest, HandlesZero) {
  EXPECT_TRUE(Factorial(0) == 1);
}
```

### Binary Comparison

```cpp
EXPECT_EQ(42, Answer());
ASSERT_NE(ptr, nullptr) << "Pointer must not be null";
```

### String Comparison

```cpp
EXPECT_STREQ("hello", str.c_str());
ASSERT_STRCASEEQ("abc", "ABC");
```

### Floating Point

```cpp
EXPECT_FLOAT_EQ(3.14f, ComputePi());
EXPECT_NEAR(val, expected, 0.001);
```

### Exception

```cpp
EXPECT_THROW(DoSomething(), std::runtime_error);
EXPECT_NO_THROW(DoSomethingSafe());
```

### Predicate Assertion

```cpp
bool IsPositive(int n) { return n > 0; }
EXPECT_PRED1(IsPositive, result);

// Predicate formatter
AssertionResult IsPositiveFmt(const char* expr, int n) {
  if (n > 0) return AssertionSuccess();
  return AssertionFailure() << expr << " is not positive";
}
EXPECT_PRED_FORMAT1(IsPositiveFmt, x);
```

### Death Test

```cpp
EXPECT_DEATH({ CrashFunction(); }, ".*segmentation fault.*");
EXPECT_EXIT(CleanExit(), ::testing::ExitedWithCode(0), "Success");
```

---

## Troubleshooting

- Ensure expressions in `ASSERT_*` macros are in `void` functions to avoid compiler errors.
- Avoid multiple death assertions on the same line.
- When comparing pointers, be mindful that `EXPECT_EQ` checks address equality. Use string-specific assertions for C-strings.
- To handle fatal failures inside helper functions, use `ASSERT_NO_FATAL_FAILURE()` or check `HasFatalFailure()` after calling.
- Use `GTEST_SKIP()` to skip tests at runtime instead of commenting them out.

---

## Additional Resources

- [Matchers Reference](matchers.md) â€” for using matchers with `EXPECT_THAT`.
- [Advanced GoogleTest Topics](../advanced.md#more-assertions) â€” in-depth info on predicates and floating point.
- [Writing Your First Unit Tests](../guides/getting-started/writing-your-first-tests) â€” practical guide.
- [Death Test API](reference/assertions.md#death) â€” usage of death assertions.
- [Custom Assertions and Matchers](../guides/advanced-testing-patterns/custom-assertions-and-matchers) â€” extend assertion behavior.

---

## See Also

- [`Test::HasFatalFailure()`](../reference/testing.md#Test-HasFatalFailure)
- [`SCOPED_TRACE()`](../reference/testing.md#SCOPED_TRACE)
- [`GTEST_SKIP()`](../reference/testing.md#GTEST_SKIP)
- [Exception Assertions](reference/assertions.md#exceptions)
- [Parameterized and Typed Tests](reference/testing.md#TEST_P)

---

This reference is an essential tool to help you write precise, reliable, and maintainable tests using GoogleTest's powerful assertion framework.