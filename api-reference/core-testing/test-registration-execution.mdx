---
title: "Test Registration & Execution"
description: "Describes how to define, register, and execute tests and test suites using GoogleTest's core macros and test runner. Covers test structure, setup/teardown patterns, and controlling test execution."
---

# Test Registration & Execution

This page details how to define, register, and execute tests and test suites using GoogleTest's core macros and test runner. It covers test structure, setup/teardown patterns, and controlling test execution.

---

## Writing Tests: Macros Overview

GoogleTest provides powerful macros to declare tests and organize them effectively.

### 1. Simple Tests with `TEST`

Define an individual test belonging to a test suite:

```cpp
TEST(TestSuiteName, TestName) {
  // test statements
}
```

- `TestSuiteName` and `TestName` must be valid C++ identifiers without underscores.
- Each `TEST` defines one test function run independently.
- Tests with the same `TestName` can exist in different test suites.


### 2. Tests with Fixtures Using `TEST_F`

Use when tests share common data/setup by defining a fixture class:

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override { /* per-test setup */ }
  void TearDown() override { /* per-test cleanup */ }
  // fixture members & helpers
};

TEST_F(MyFixture, TestName) {
  // test using fixture data
}
```

- `TEST_F` requires a previously defined fixture class.
- Each test gets a fresh fixture object with `SetUp()` and `TearDown()` called around it.
- Enables reusing common test logic to maintain test independence.


### 3. Value-Parameterized Tests with `TEST_P` and `INSTANTIATE_TEST_SUITE_P`

When you want to run the same test logic with different input values:

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // fixture with parameter support
};

TEST_P(MyParamTest, CheckSomething) {
  int param = GetParam();
  EXPECT_TRUE(DoCheck(param));
}

INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyParamTest, testing::Values(1, 2, 3));
```

- `TEST_P` defines a parameterized test pattern.
- `INSTANTIATE_TEST_SUITE_P` generates multiple tests from the pattern with different parameters.
- The `GetParam()` method accesses the current parameter.
- Supports synthesizing complex input data with parameter generator functions (`Values`, `Range`, `Combine`, etc.).


### 4. Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`

When repeating test logic over multiple types:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};

using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam v = this->value_;
  // test with type T
}
```

- `TYPED_TEST_SUITE` associates a fixture template with a type list.
- `TYPED_TEST` defines tests using the template parameter `TypeParam`.
- Tests are compiled and run once per type.


### 5. Type-Parameterized Tests with `TYPED_TEST_SUITE_P` and Registration

- Provides abstract test patterns that can be instantiated multiple times with different type lists.

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test { ... };

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, TestName) { ... }
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestName);

using Types1 = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(Instance1, MyTypeParamTest, Types1);
```

- Enables flexible, reusable type tests beyond a fixed list.


## Programmatic Test Registration

When macros do not suffice, tests can be registered dynamically at runtime:

```cpp
template <typename Factory>
TestInfo* RegisterTest(const char* test_suite_name, const char* test_name,
                       const char* type_param, const char* value_param,
                       const char* file, int line, Factory factory);
```

- Use a callable factory that creates test fixture objects.
- Allows dynamic tests based on runtime data.
- Must be called **before** `RUN_ALL_TESTS()`.

Example:

```cpp
class MyFixture : public testing::Test { ... };
class MyTest : public MyFixture {
 public:
  explicit MyTest(int data) : data_(data) {}
  void TestBody() override { /* test with data_ */ }
 private:
  int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
      "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr,
      std::to_string(v).c_str(), __FILE__, __LINE__,
      [=]() -> MyFixture* { return new MyTest(v); });
  }
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);

  std::vector<int> values = {1, 2, 3};
  RegisterMyTests(values);

  return RUN_ALL_TESTS();
}
```


## Running Tests with the Test Runner

### 1. Initialization

Before running tests, initialize GoogleTest to parse flags:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- `InitGoogleTest` processes command-line flags and sets up the environment.
- Must be called before `RUN_ALL_TESTS()`.


### 2. Running All Tests

`RUN_ALL_TESTS()` runs all registered tests and returns `0` on success, `1` on failure.

- It creates fresh fixture objects for each test.
- Runs setup (`SetUp`), test body, then teardown (`TearDown`).
- Skips or runs tests depending on filtering flags.


### 3. Test Filtering

Control which tests to run via `--gtest_filter` flag with glob patterns:

- Run all: `--gtest_filter=*`
- Run specific suite: `--gtest_filter=SuiteName.*`
- Exclude tests: `--gtest_filter=-SuiteName.ExcludedTest`


### 4. Disabled Tests

Prefix test or suite names with `DISABLED_` to skip them during runs.

- Run disabled tests explicitly with `--gtest_also_run_disabled_tests`.


### 5. Test Repetition, Shuffling, and Segmentation

- Repeat tests with `--gtest_repeat=N`.
- Shuffle test order with `--gtest_shuffle` for uncovering hidden dependencies.
- Shard tests across machines using `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX`.


## Shared Setup and Teardown

### 1. Test Fixture Setup/TearDown

- Implement `SetUp()` and `TearDown()` for per-test setup and cleanup.

### 2. Per-Test-Suite Setup/TearDown

Define static methods in a fixture class:

```cpp
class MyFixture : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    // expensive shared setup
  }
  static void TearDownTestSuite() {
    // shared cleanup
  }
  void SetUp() override {}
  void TearDown() override {}
};
```

- `SetUpTestSuite` is called once before the first test in the suite.
- `TearDownTestSuite` is called once after the last test in the suite.
- Helps avoid costly setup per test.


### 3. Global Setup and Teardown

By subclassing `::testing::Environment`, you can manage setup/teardown for the entire test program.

```cpp
class MyEnvironment : public testing::Environment {
 public:
  void SetUp() override { /* setup global resources */ }
  void TearDown() override { /* cleanup global resources */ }
};

testing::AddGlobalTestEnvironment(new MyEnvironment);
```

- Called before any tests run, and after all tests finish.


## Controlling Test Execution Flow

### 1. Skipping Tests

Use `GTEST_SKIP()` to skip a test at runtime with an optional message:

```cpp
TEST(MyTest, SkipsIf) {
  if (some_condition) {
    GTEST_SKIP() << "Skipping this test";
  }
  // test code
}
```

- Can also be used inside `SetUp` of fixtures or global environments to skip multiple tests.


### 2. Explicit Failures and Success

Use `FAIL()`, `ADD_FAILURE()`, or `SUCCEED()` to mark test results explicitly:

- `FAIL()` aborts current test with a fatal failure.
- `ADD_FAILURE()` marks a nonfatal failure.
- `SUCCEED()` marks an explicit success (rarely used).


### 3. Using `SCOPED_TRACE` for Enhanced Error Context

Add contextual information to failures by wrapping code regions with `SCOPED_TRACE`:

```cpp
SCOPED_TRACE("Iteration " + std::to_string(i));
EXPECT_EQ(foo, bar);
```

- Adds file, line, and the given message to every failure inside its lexical scope.
- Helps identify nested or call chain related failures.


## Obtaining Information About Currently Running Tests

Use GoogleTest reflection API:

```cpp
const testing::TestInfo* test_info = testing::UnitTest::GetInstance()->current_test_info();
if (test_info) {
  std::cout << "Running test: " << test_info->test_suite_name() << "." << test_info->name() << "\n";
}
```

This is useful to customize behavior or filenames based on test identity.


## Best Practices & Common Pitfalls

- Always call `InitGoogleTest` *before* `RUN_ALL_TESTS` to ensure proper flag handling.
- Test suite and test names must not contain underscores `_` to avoid naming conflicts.
- Use fixtures (`TEST_F`) for tests sharing setup to keep tests DRY and independent.
- Use parameterized tests (`TEST_P`) or typed tests for scalable coverage over data or types.
- For runtime test registration, ensure tests are registered before running tests.
- Avoid asserts in constructors/destructors; use `SetUp`/`TearDown` instead.


## Examples

### Simple Test

```cpp
TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}
```

### Fixture Test

```cpp
class StackTest : public testing::Test {
 protected:
  void SetUp() override { stack_.push(5); }
  std::stack<int> stack_;
};

TEST_F(StackTest, IsNotEmptyAfterPush) {
  EXPECT_FALSE(stack_.empty());
}
```

### Value-Parameterized Test

```cpp
class MyParamTest : public testing::TestWithParam<std::string> {};

TEST_P(MyParamTest, IsNotEmpty) {
  EXPECT_FALSE(GetParam().empty());
}

INSTANTIATE_TEST_SUITE_P(MyStrings, MyParamTest,
                         testing::Values("foo", "bar", "baz"));
```

### Typed Test

```cpp
template <typename T>
class NumericTest : public testing::Test {
 protected:
  T value_{};
};

using NumericTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, IsDefaultZero) {
  EXPECT_EQ(this->value_, TypeParam(0));
}
```

---

## Event Listener API

Optionally, to monitor test execution or customize output, define event listeners by subclassing `TestEventListener` or `EmptyTestEventListener` and attach them to `testing::UnitTest::GetInstance()->listeners()` before running tests.

Example of a minimal listener:

```cpp
class MinimalPrinter : public testing::EmptyTestEventListener {
  void OnTestStart(const testing::TestInfo& info) override {
    std::cout << "Starting: " << info.test_suite_name() << "." << info.name() << "\n";
  }

  void OnTestEnd(const testing::TestInfo& info) override {
    std::cout << "Ended: " << info.test_suite_name() << "." << info.name() << "\n";
  }
};

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  testing::UnitTest::GetInstance()->listeners().Append(new MinimalPrinter);
  return RUN_ALL_TESTS();
}
```


---

## Summary

This documentation covers the essentials to define, register, and execute tests with GoogleTest, focusing on core macros (`TEST`, `TEST_F`, `TEST_P`), dynamic test registration, fixtures with shared setup, test filtering and control, parameterized and typed tests, and usage best practices.

For further mastery, users should explore related advanced topics such as assertions, mocks, parameterization, and integrations found in other parts of the documentation.


---

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "docs/reference/testing.md", "range": "full"},{"path": "googletest/include/gtest/gtest.h", "range": "full"}]} />
