---
title: "Test Cases & Suites"
description: "Defines how to structure unit tests in GoogleTest using test case macros, test fixtures, and test suites. Explains how to register, run, and organize tests in a maintainable, discoverable way."
---

# Test Cases & Suites

GoogleTest organizes your unit tests into *test cases* and *test suites*, which group related tests for better maintainability, readability, and execution control. This page explains how to use the GoogleTest macros and classes to define, register, and organize tests efficiently.

---

## Understanding Test Cases and Test Suites

GoogleTest uses the terms *test case* and *test suite* almost interchangeably, though the modern preferred term is *test suite*. A test suite is a collection of individual tests that share a logical grouping, usually representing a class, module, or functionality in your codebase.

- **Test Case/Suite**: A named grouping of one or more tests.
- **Test**: An individual test verifying a specific behavior.

Tests in the same suite can share common code and setup through *test fixtures*. When you define tests, you specify the suite they belong to, and subsequently, GoogleTest manages their discovery and execution.

## Defining Individual Tests

GoogleTest provides macros to define tests:

### 1. Plain Tests (`TEST`)

Defines a test function in a named test suite.

```cpp
TEST(TestSuiteName, TestName) {
  // Test code and assertions here
  EXPECT_EQ(42, CalculateAnswer());
}
```

- Creates a new *test* named `TestName` within the suite `TestSuiteName`.
- Both `TestSuiteName` and `TestName` must be valid C++ identifiers with **no underscores** (`_`).
- Each test runs independently and is automatically registered.

### 2. Tests With Fixtures (`TEST_F`)

Defines a test that uses a test fixture class, allowing shared setup/teardown.

```cpp
class MyFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Common setup
  }
  void TearDown() override {
    // Common teardown
  }
  // Shared resources
};

TEST_F(MyFixture, DoesThis) {
  // Test code can use fixture members
  EXPECT_TRUE(CheckSomething());
}
```

- `MyFixture` must be a class derived from `::testing::Test`.
- Tests in this suite share the fixture but get a new instance for each test.

### Naming Constraints

Avoid underscores (`_`) in test suite and test names to prevent runtime errors due to macro expansion and internal name generation. Use camel case or Pascal case instead.

## Organizing Tests Using Fixtures

Test fixtures encapsulate common setup, teardown, and helper functions for a suite of related tests. Each test gets a fresh fixture instance.

- Define shared data members and SetUp/TearDown methods.
- Use `TEST_F` with the fixture to define tests using that common context.

Example:

```cpp
class StackTest : public ::testing::Test {
 protected:
  Stack<int> stack_;  // Reused in every test.

  void SetUp() override {
    stack_.Push(1);
    stack_.Push(2);
  }
};

TEST_F(StackTest, PopsLastElement) {
  int val = stack_.Top();
  stack_.Pop();
  EXPECT_EQ(2, val);
  EXPECT_EQ(1, stack_.Top());
}

TEST_F(StackTest, IsEmptyAfterPops) {
  stack_.Pop();
  stack_.Pop();
  EXPECT_TRUE(stack_.IsEmpty());
}
```

## Test Suites and Tests Lifecycle Hooks

### Per-Test Setup and Teardown

- `void SetUp()` — Called before each test runs.
- `void TearDown()` — Called after each test finishes.

Each test runs with a new fixture instance.

### Per-TestSuite Setup and Teardown

Define static methods in your fixture to allocate and clean up expensive shared resources:

```cpp
class FooTest : public ::testing::Test {
 public:
  static void SetUpTestSuite() {
    shared_resource_ = new Resource();
  }
  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

 protected:
  static Resource* shared_resource_;
};

Resource* FooTest::shared_resource_ = nullptr;
```

GoogleTest automatically calls `SetUpTestSuite()` once before the first test and `TearDownTestSuite()` once after the last test in the suite.

## Typed Tests and Type-Parameterized Tests

For testing code templates or interface implementations across types, GoogleTest offers:

- **Typed Tests:** Use `TYPED_TEST_SUITE` and `TYPED_TEST` macros to run identical tests over a fixed list of types. You must specify the types up front.

- **Type-Parameterized Tests:** Use `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, and `INSTANTIATE_TYPED_TEST_SUITE_P` macros to define generic tests for a fixture template and instantiate them with arbitrary type lists at different points in your codebase.

These features maximize test code reuse while maintaining clear, organized test suites by type.

### Typed Test Example

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  using ValueType = T;
  // ...
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val{};
  (void)val;
  SUCCEED();
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
 // ...
};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, TestName) {
  // Use TypeParam
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestName);

using Types1 = ::testing::Types<int, char>;
INSTANTIATE_TYPED_TEST_SUITE_P(Instantiation1, MyTypeParamTest, Types1);
```

## Dynamic Test Registration

While GoogleTest provides most functionality with macros, advanced users can register tests programmatically using `::testing::RegisterTest()`. This enables dynamic test creation.

```cpp
class MyFixture : public testing::Test {};

class MyTest : public MyFixture {
 public:
  explicit MyTest(int value) : value_(value) {}
  void TestBody() override {
    ASSERT_GT(value_, 0);
  }
 private:
  int value_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
        "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr,
        std::to_string(v).c_str(), __FILE__, __LINE__,
        [=]() -> MyFixture* { return new MyTest(v); });
  }
}
```

Call `RegisterMyTests` before `RUN_ALL_TESTS()`.

## Running Tests

Invoke `RUN_ALL_TESTS()` in your `main` function to run all registered tests:

```cpp
int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

`RUN_ALL_TESTS()` returns 0 if all tests pass, or 1 if any fail.

## Best Practices

- Always call `::testing::InitGoogleTest` before running tests to process command-line flags.
- Use fixtures (`TEST_F`) for related tests sharing setup.
- Prefer typed or type-parameterized tests for testing across types.
- Avoid underscores in test and suite names.
- Use suite-level `SetUpTestSuite()/TearDownTestSuite()` for expensive shared resources.
- Use `GTEST_SKIP()` to skip tests at runtime.
- Harness `SCOPED_TRACE()` to add trace messages aiding in debugging failures inside helper functions.

## Troubleshooting & Common Pitfalls

- Mixing `TEST` and `TEST_F` macros in the same test suite is not allowed and triggers runtime errors.
- Naming collisions can occur with underscores in test names.
- Test fixtures require default constructors accessible by GoogleTest.
- For value-parameterized tests (`TEST_P`), make sure to always instantiate with `INSTANTIATE_TEST_SUITE_P`.

<Accordion title="See Also">
- [Basic Tests (`TEST` Macro)](/docs/reference/testing.md#TEST)
- [Test Fixtures (`TEST_F` Macro)](/docs/reference/testing.md#TEST_F)
- [Typed Tests and Type-Parameterized Tests](/docs/advanced.md#typed-tests)
- [Value-Parameterized Tests](/docs/advanced.md#value-parameterized-tests)
- [Programmatic Test Registration](/docs/advanced.md#registering-tests-programmatically)
</Accordion>

## Summary

GoogleTest efficiently organizes tests into suites and cases with clear, extensible macros and classes. By defining test fixtures, typed tests, or type-parameterized tests, you gain reusable, maintainable, and expressive test groupings. Use `RUN_ALL_TESTS()` to run all registered tests and leverage the rich CLI flags and environment controls for filtering, sharding, and detailed reporting.

---