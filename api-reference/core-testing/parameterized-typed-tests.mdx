---
title: "Parameterized & Typed Tests"
description: "Documents how to use parameterized and typed test APIs, including test macros for running the same test logic over sets of values or types. Highlights registration, instantiation, and input data generation."
---

# Parameterized & Typed Tests

GoogleTest offers robust APIs for *parameterized* and *typed tests*, empowering you to run the same test logic over a variety of inputs or types with minimal repetition. These APIs enable comprehensive coverage with concise test code by automating test registration and execution across specified value sets or type lists.

---

## Overview

Parameterized and typed tests are essential when you want to:

- Validate a function or class against multiple values without duplicating code.
- Execute the same test logic for several types to verify template-based code or interface implementations.
- Organize tests logically with custom naming and grouping.

GoogleTest supports **value-parameterized tests**, **typed tests**, and **type-parameterized tests**, each serving distinct but related roles in test parameterization.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to reuse a test pattern with different *values* provided as parameters.

### Writing Value-Parameterized Tests

1. **Define a test fixture** that inherits from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Test fixture code
};
```

2. **Write test cases using the** `TEST_P` **macro:**

```cpp
TEST_P(FooTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(IsValid(param));
}
```

3. **Instantiate with parameter generators:**

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values(1, 2, 3));
```

The above will run the test `DoesSomething` with parameters `1`, `2`, and `3`.

### Supported Parameter Generators

GoogleTest provides flexible generators to express value sets:

| Generator                      | Behavior                                               |
|-------------------------------|--------------------------------------------------------|
| `Range(begin, end [, step])`  | Generates values starting at `begin` up to (but not including) `end`, incremented by `step` (default 1). |
| `Values(v1, v2, ..., vN)`     | Explicitly lists values.                               |
| `ValuesIn(container)`          | Generates values by iterating over an array, container, or iterator range. |
| `Bool()`                      | Generates boolean values `{false, true}`.              |
| `Combine(g1, g2, ..., gN)`    | Cartesian product of multiple generators, generating tuples combining all value combinations. |
| `ConvertGenerator<T>(g)`      | Converts generator `g`'s values to type `T` using `static_cast`. Allows explicit and custom conversions. |

### Accessing the Test Parameter

Inside your `TEST_P` test body, you access the current parameter via `GetParam()`:

```cpp
int param = GetParam();
```

### Instantiation Naming

- The first argument of `INSTANTIATE_TEST_SUITE_P` is a unique *prefix* added to the test suite's name to identify the instantiation.
- The indexed test names include suffixes like `/0`, `/1` automatically for each parameter.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(MyGroup, FooTest, testing::Values(10, 20));
```

Results in tests named:

- `MyGroup/FooTest.DoesSomething/0` for parameter `10`
- `MyGroup/FooTest.DoesSomething/1` for parameter `20`

### Custom Test Name Generation

You can supply a custom naming function for test parameters to produce descriptive or safe test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Notes

- Place all `TEST_P` and `INSTANTIATE_TEST_SUITE_P` calls at *global or namespace scope*.
- If a `TEST_P` is defined but not instantiated, GoogleTest flags a failure by default.
- To suppress the failure on uninstantiated tests (e.g., in libraries), use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);`.

---

## Typed Tests

Typed tests execute the same test logic over a known list of types.

### When to Use Typed Tests

- You want to apply a test suite to different types known at compile time.
- The list of types is fixed when writing tests.

### Writing Typed Tests

1. **Define the typed test fixture as a template derived from `testing::Test`:**

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_ = {};
  // ...
};
```

2. **Create a type alias for the list of types to test:**

```cpp
using MyTypes = testing::Types<int, double, std::string>;
```

3. **Associate the type list with the test suite:**

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. **Write tests using** `TYPED_TEST`: 

Inside these tests, `TypeParam` refers to the current type.

```cpp
TYPED_TEST(MyTypedTest, CanBeDefaultConstructed) {
  TypeParam val = this->value_;
  EXPECT_TRUE(IsValid(val));
}
```

---

## Type-Parameterized Tests

Type-parameterized tests are like typed tests but support *defining test patterns without knowing the list of types ahead of time*.

### Benefits

- Define test patterns once, instantiate multiple times with different type lists.
- Support interface verification by multiple implementations without duplicating code.

### Writing Type-Parameterized Tests

1. **Define the fixture template as with typed tests:**

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
 // ...
};
```

2. **Declare a type-parameterized test suite:**

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Write tests using** `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypeParamTest, HasPropertyA) {
  TypeParam val{};
  EXPECT_TRUE(HasProperty(val));
}
```

4. **Register the tests:**

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, HasPropertyA, HasPropertyB);
```

5. **Instantiate the suite with a list of types:**

```cpp
using MyTypes = testing::Types<char, int, unsigned>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```

---

## Example: Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6));
```

---

## Example: Typed Test

```cpp
template <typename T>
class StackTest : public testing::Test {
 public:
  Stack<T> stack;
};

using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack.empty());
}
```

---

## Example: Type-Parameterized Test

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container;
};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanInsertElement) {
  this->container.insert(this->container.end(), TypeParam());
  EXPECT_FALSE(this->container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanInsertElement);

using MyContainers = testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MySequenceContainers, ContainerTest, MyContainers);
```

---

## Best Practices

- Avoid underscores in test suite and test names to prevent macro-generated class name collisions.
- When using typed tests, ensure types are fully defined and have default constructors if needed.
- Use `ConvertGenerator` for explicit or custom parameter type conversions.
- Define `PrintTo` functions or `AbslStringify` for custom types to enhance test output readability.
- For large parameter sets, consider combining generators with `Combine`.

## Common Pitfalls

- Forgetting to instantiate a parameterized test results in no test execution and a warning or error.
- Using pointers as parameters requires manual lifetime management.
- Custom naming functions must produce unique, non-empty, and identifier-safe strings.

---

## Troubleshooting

- If tests defined with `TEST_P` do not run, verify that `INSTANTIATE_TEST_SUITE_P` is present.
- To silence false positives about uninstantiated tests, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Begin your `main` function by calling `testing::InitGoogleTest(&argc, argv);` before running tests.

---

## Summary

GoogleTest's parameterized and typed test facilities maximize test coverage while minimizing boilerplate. They accommodate numerous testing scenarios, including data-driven testing and type-based interface conformance checks, while providing flexible parameter generation and custom naming.

Use these APIs to build scalable, maintainable test suites that robustly validate your C++ code.

---

## References

- [Value-Parameterized Tests (Advanced Docs)](../advanced.md#value-parameterized-tests)
- [Typed Tests (Advanced Docs)](../advanced.md#typed-tests)
- [Type-Parameterized Tests (Advanced Docs)](../advanced.md#type-parameterized-tests)
- [Testing Reference: TEST_P and INSTANTIATE_TEST_SUITE_P](../reference/testing.md#TEST_P)
- [Testing Reference: TYPED_TEST_SUITE and TYPED_TEST](../reference/testing.md#TYPED_TEST_SUITE)
- [Testing Reference: TYPED_TEST_SUITE_P and Type-Parameterized Tests](../reference/testing.md#TYPED_TEST_SUITE_P)
- [FAQ](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)

---

## Code Examples from Source

The following example illustrates registration and instantiation of value-parameterized and typed tests:

```cpp
// Value-Parameterized Test Fixture
class ValueParamTest : public testing::TestWithParam<MyType> {};

TEST_P(ValueParamTest, TestA) { /* test code using GetParam() */ }
TEST_P(ValueParamTest, TestB) { /* test code using GetParam() */ }

// Instantiation with values
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, ValueParamTest,
    testing::Values(
        MyType("one line"), MyType("two\nlines"), MyType("a very long line...")));

// Typed Tests
template <typename T>
class TypedTest : public testing::Test {};

using MyTypes = testing::Types<VeryLongTypeName, int*, MyArray<bool, 42>>;
TYPED_TEST_SUITE(TypedTest, MyTypes);

TYPED_TEST(TypedTest, TestA) { /* test code using TypeParam */ }
TYPED_TEST(TypedTest, TestB) { /* test code using TypeParam */ }

// Type-Parameterized Test Fixture
template <typename T>
class TypeParamTest : public testing::Test {};

TYPED_TEST_SUITE_P(TypeParamTest);

TYPED_TEST_P(TypeParamTest, TestA) { /* test code */ }
TYPED_TEST_P(TypeParamTest, TestB) { /* test code */ }

REGISTER_TYPED_TEST_SUITE_P(TypeParamTest, TestA, TestB);

INSTANTIATE_TYPED_TEST_SUITE_P(My, TypeParamTest, MyTypes);
```
