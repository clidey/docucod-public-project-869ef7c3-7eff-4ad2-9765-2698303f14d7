---
title: "Test Parameterization"
description: "Covers techniques for value-parameterized and type-parameterized tests, allowing systematic coverage of different input values or types with the same test logic."
---

# Test Parameterization

GoogleTest empowers you to systematically test your code across a variety of input values and types without duplicating test logic. This page covers the techniques of *value-parameterized tests* and *type-parameterized tests*, enabling broad coverage and flexible verification of your code base through reusable test patterns.

---

## Introduction to Test Parameterization

Testing multiple data inputs or types often requires running the same logical test repeatedly with different parameters. Writing separate tests for each input quickly becomes tedious and error-prone.

Test parameterization offers a powerful way to define test logic once, then automatically apply it across many values or types, ensuring thorough coverage and enabling cleaner test code.

## Value-Parameterized Tests

### What They Are

Value-parameterized tests allow the same test logic to run multiple times, each with a different data value as input. These are ideal for testing behavior over a range of inputs, configuration flags, or implementations differing only by construction parameters.

### How to Write Them

1. **Define a test fixture class** derived from `::testing::TestWithParam<T>`, where `T` represents the type of your parameter.

   ```cpp
   class FooTest : public ::testing::TestWithParam<int> {
     // Your fixture code here.
   };
   ```

2. **Write your tests with `TEST_P`**, using `GetParam()` inside to access the parameter value:

   ```cpp
   TEST_P(FooTest, DoesBlah) {
     int param = GetParam();
     EXPECT_TRUE(SomeFunctionUnderTest(param));
   }
   ```

3. **Instantiate your test suite with parameters** using `INSTANTIATE_TEST_SUITE_P` and built-in parameter generators like `Values()`, `Range()`, or `Combine()`:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       NumericValues,
       FooTest,
       testing::Values(1, 2, 3, 4));
   ```

### Useful Parameter Generators

| Generator                          | Description                                                       |
|----------------------------------|-------------------------------------------------------------------|
| `Values(v1, v2, ..., vN)`         | Supplies explicit list of parameters.                             |
| `ValuesIn(container)`              | Draws parameters from an STL container or C array.                |
| `Range(start, end [, step])`      | Generates sequence of values `[start, start + step, ... < end]`.  |
| `Bool()`                         | Provides boolean values `{false, true}`.                          |
| `Combine(g1, g2, ..., gN)`        | Cartesian product of multiple parameter sets, yielding tuples.   |

### Naming Test Instances

By default, your instantiated tests will show default numeric suffixes like `/0`, `/1`, etc. For clearer output, you can provide a custom name generator function returning descriptive test names based on the parameters.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames,
    FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Param" + std::to_string(info.param);
    });
```

### When to Use Value-Parameterized Tests

- To check behavior for a range of input values.
- When construction or setup varies per parameter.
- For data-driven testing scenarios.

---

## Typed Tests

### What They Are

Typed tests allow you to write a common test suite template once and run the tests for a fixed list of types, repeating all the same test cases for each type. This is suitable when the testing logic only varies by the data type â€” for example, validating container behavior across different container types.

### How to Write Them

1. **Define a type-parameterized test fixture class template**, deriving from `::testing::Test`:

   ```cpp
   template <typename T>
   class MyTypedTest : public ::testing::Test {
    public:
     T value_;
     // Additional members here
   };
   ```

2. **Define a list of types** you'd like to test:

   ```cpp
   using MyTypes = ::testing::Types<int, double, std::string>;
   ```

3. **Bind the type list to the test suite** using `TYPED_TEST_SUITE`:

   ```cpp
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

4. **Write typed tests using `TYPED_TEST`**, referring to the type by the special name `TypeParam`:

   ```cpp
   TYPED_TEST(MyTypedTest, DefaultValueIsValid) {
     TypeParam value = this->value_;
     EXPECT_TRUE(IsValid(value));
   }
   ```

### Naming Customization

`TYPED_TEST_SUITE` optionally accepts a third argument providing a class with a template static function to customize the test suite name suffixes by type.

Example:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>()) return "Int";
    if (std::is_same<T, double>()) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### When to Use Typed Tests

- When verifying behavior over different types sharing an interface or expected properties.
- When test instances can be created uniformly with the same constructor pattern per type.
- When you want to clearly identify failures by type in test output.

---

## Type-Parameterized Tests

### What They Are

Type-parameterized tests are an advanced form of typed tests where you define *abstract* test patterns whose types are not fixed at the point of definition. Other parts of your code or other translation units can then *instantiate* these test patterns with their own choice of types.

This allows defining reusable test suites verifying interface/concept compliance that can be instantiated multiple times and in different places.

### How to Write Them

1. **Define a fixture class template derived from `::testing::Test`**:

   ```cpp
   template <typename T>
   class MyTypeParamTest : public ::testing::Test {
     // Test fixture
   };
   ```

2. **Declare your test suite as type-parameterized using `TYPED_TEST_SUITE_P`**:

   ```cpp
   TYPED_TEST_SUITE_P(MyTypeParamTest);
   ```

3. **Define type-parameterized test cases with `TYPED_TEST_P`**:

   ```cpp
   TYPED_TEST_P(MyTypeParamTest, TestTraitA) {
     EXPECT_TRUE(TraitCheck<TypeParam>::value);
   }
   ```

4. **Register your tests before instantiation** using `REGISTER_TYPED_TEST_SUITE_P`:

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestTraitA, TestTraitB);
   ```

5. **Instantiate the suite with types and a prefix** anywhere in your program with `INSTANTIATE_TYPED_TEST_SUITE_P`:

   ```cpp
   using ImplTypes = ::testing::Types<MyImpl1, MyImpl2>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyImplTest, MyTypeParamTest, ImplTypes);
   ```

### When to Use Type-Parameterized Tests

- When you want to define tests without knowing the types upfront.
- When multiple components or plugins instantiate the same abstract test suite with different types.
- When developing generic interfaces with multiple implementations requiring compliance verification.

---

## Practical Tips and Best Practices

- **Avoid underscores** in test suite and test names, especially in typed or parameterized tests, to prevent name clashes and reserved identifier issues. See [Naming Rules](../faq.md#Why-should-test-suite-names-and-test-names-not-contain-underscore) for details.
- **Choose between value-parameterized and typed tests** based on needs. Typed tests suit uniform construction and type-based scenarios; value-parameterized tests are better if test input logic or construction varies with parameters.
- **Write descriptive names** for your parameter sets or type names for clarity in test reports.
- **Use `SetUpTestSuite()` and `TearDownTestSuite()`** for expensive shared setup/teardown when multiple tests share the same fixture.
- **Define custom name generators** for clearer, more meaningful test output.
- **Keep tests independent and simple**; parameterized tests should not introduce hidden dependencies between test runs.

---

## Common Pitfalls and Troubleshooting

### Parameter Initialization

Ensure your fixture correctly initializes resources or state that depends on the parameter. Access parameters in `SetUp()` or `TEST_P/TYPED_TEST` bodies to avoid surprises.

### Missing Instantiations

Failing to instantiate parameterized or typed test suites with macros like `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` can cause tests to not run and appear missing.

Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you deliberately want to define parameterized tests without instantiation.

### Compilation Errors

Parameterized tests can emit complex template errors. Ensure your fixture classes and test macros conform to requirements (correct base classes, public test suite setup, no underscores in names).

### Linking in Multiple Translation Units

For type-parameterized tests, declaring and registering test suites in headers allows multiple translation units to instantiate them independently without linker conflicts.

---

## Summary Example: Defining and Instantiating a Type-Parameterized Test Suite

```cpp
#include <gtest/gtest.h>

// Step 1: Define fixture template.
template <typename T>
class ContainerTest : public ::testing::Test {
  // Fixture code here.
};

// Step 2: Declare type-parameterized test suite.
TYPED_TEST_SUITE_P(ContainerTest);

// Step 3: Define tests.
TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
  // Test body.
}

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}

// Step 4: Register tests.
REGISTER_TYPED_TEST_SUITE_P(ContainerTest,
                            CanBeDefaultConstructed,
                            InitialSizeIsZero);

// Step 5: Instantiate with desired types.
using MyContainers = ::testing::Types<std::vector<int>, std::set<char>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```

---

## Additional Resources

- [GoogleTest Advanced Topics: Typed and Parameterized Tests](../advanced.md#typed-tests)
- [Testing Reference for Macros: TEST_P, TYPED_TEST](reference/testing.md#TEST_P)
- [Test Parameterization Guide](../guides/writing-effective-tests/test-parameterization)
- [FAQ on Choosing between Typed and Value-Parameterized Tests](../faq.md#I-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements)

---

By mastering test parameterization, you maximize your test coverage with minimal code duplication and maintain more maintainable, scalable test suites, ensuring your softwareâ€™s robustness across varying inputs and types.


---