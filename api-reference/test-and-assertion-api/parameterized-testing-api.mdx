---
title: "Parameterized and Typed Test API"
description: "Explore APIs that support parameterized and type-parameterized testing. Illustrates how to reuse test logic with varying inputs and types, enabling broader code coverage through concise and flexible test structures."
---

# Parameterized and Typed Test API

Explore APIs that support parameterized and type-parameterized testing in GoogleTest. These APIs enable you to reuse test logic with varying inputs and types, empowering broader code coverage through concise, flexible test structures.

---

## Parameterized Testing API

GoogleTest provides powerful macros and facilities to define parameterized tests, allowing the same test logic to be executed repeatedly with different input values.

### Defining Parameterized Tests

1. **Define a Test Fixture Class**

   Your fixture class should inherit from `testing::TestWithParam<T>`, where `T` is the parameter type. This class combines testing::Test and the `WithParamInterface<T>` providing access to the test parameter.

   ```cpp
   class FooTest : public testing::TestWithParam<int> {
     // Test fixture members...
   };
   ```

2. **Write Parameterized Tests Using `TEST_P`**

   Use the `TEST_P` macro instead of `TEST` or `TEST_F` to define a test pattern that gets parameterized:

   ```cpp
   TEST_P(FooTest, DoesSomething) {
     int param = GetParam();  // Gets current test parameter
     EXPECT_TRUE(DoSomething(param));
   }
   ```

3. **Instantiate Test Suites with `INSTANTIATE_TEST_SUITE_P`**

   Instantiate with a generator of test parameters, like `Values()`, `ValuesIn()`, or `Range()`:

   ```cpp
   INSTANTIATE_TEST_SUITE_P(MyGroup, FooTest, testing::Values(1, 2, 3));
   ```

   This creates concrete tests for each parameter value, named as `<InstantiationName>/<TestSuiteName>.<TestName>/<Index>`.

### Parameter Generators

- `Range(begin, end [, step])`: generates a sequence of values from `begin` (inclusive) up to `end` (exclusive) in steps.
- `Values(v1, v2, ..., vN)`: generates each explicitly specified value.
- `ValuesIn(container)`: generates values from an array, STL container, or iterator range.
- `Bool()`: generates the sequence `{false, true}`.
- `Combine(g1, g2, ..., gN)`: generates Cartesian product tuples combining multiple parameter generators.
- `ConvertGenerator<T>(gen)` or `ConvertGenerator(gen, functor)`: casts or converts generated values to a different type.

### Naming Test Instances

- You can provide an optional name generator (function or functor accepting `testing::TestParamInfo<Param>` and returning a `std::string`) as the last argument to `INSTANTIATE_TEST_SUITE_P` to customize test name suffixes.
- Use `PrintToStringParamName` for default name generation except for `std::string` or C-style strings.

### Controlling Uninstantiated Parameterized Tests

By default, every `TEST_P` requires a matching `INSTANTIATE_TEST_SUITE_P`. Use:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);
```

to mark suites that may have no instantiations without failing.

## Typed Test API

Typed tests execute the same test logic across multiple types. This helps verify type-agnostic code correctness.

### Writing Typed Tests

1. **Define a Fixture Class Template**

   The fixture is defined with a template parameter, deriving from `testing::Test`.

   ```cpp
   template <typename T>
   class MyTypedTest : public testing::Test {
    public:
     T value_;
   };
   ```

2. **Associate a List of Types with the Fixture Using `TYPED_TEST_SUITE`**

   Create a type list using `testing::Types<...>`, then associate it:

   ```cpp
   using MyTypes = testing::Types<int, double, std::string>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Define Typed Tests with `TYPED_TEST`**

   Access the current type with the special name `TypeParam`:

   ```cpp
   TYPED_TEST(MyTypedTest, DoesSomething) {
     TypeParam val = this->value_;
     // test code using val...
   }
   ```

### Custom Type Names

You can provide an optional third argument to `TYPED_TEST_SUITE` as a class with a static template method `GetName(int)` to generate readable test suffixes:

```cpp
class MyNameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    else if constexpr (std::is_same_v<T, double>) return "Double";
    else return "UnknownType";
  }
};
TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyNameGenerator);
```

## Type-Parameterized Test API

Type-parameterized tests allow defining abstract test patterns parameterized by types, which can be instantiated later multiple times with different type lists. This is useful when the list of types is not known upfront.

### Defining Type-Parameterized Tests

1. **Define a Fixture Template**

   Like typed tests, a fixture class template derives from `testing::Test`.

2. **Declare Test Suite as Type-Parameterized**

   Use `TYPED_TEST_SUITE_P` instead of `TYPED_TEST_SUITE`.

3. **Define Tests with `TYPED_TEST_P`**

   Define tests similarly to typed tests:

   ```cpp
   TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
     TypeParam val = 0;  // use TypeParam
     ...
   }
   ```

4. **Register Tests with `REGISTER_TYPED_TEST_SUITE_P`**

   Before instantiation, register all test names:

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething, AnotherTest);
   ```

5. **Instantiate Suites with `INSTANTIATE_TYPED_TEST_SUITE_P`**

   Instantiate with type lists:

   ```cpp
   using MyTypeList = testing::Types<int, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypeList);
   ```

### Benefits and Use Cases

- Defines a reusable test template independent of types.
- Enables multiple instantiations in the same or different source files.
- Ideal for verifying interface or concept conformance across implementations.

## Summary

GoogleTest's parameterized and typed test APIs dramatically reduce boilerplate, enhance test coverage, and enforce code correctness across data and types. They enable effective reuse patterns in complex test suites.

---

## Practical Example: Parameterized Test with `Values`

```cpp
class FactorialTest : public testing::TestWithParam<int> {};

int Factorial(int n) {
  return n <= 1 ? 1 : n * Factorial(n - 1);
}

TEST_P(FactorialTest, ComputesCorrectFactorial) {
  int n = GetParam();
  int expected = factorial_expected_for(n);  // your expected
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(ValidInputs, FactorialTest, testing::Values(0, 1, 5, 10));
```

## Practical Example: Typed Test for Containers

```cpp
template <typename T>
class ContainerTest : public testing::Test {
 public:
  T container_;
};

using MyContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(ContainerTest, MyContainerTypes);

TYPED_TEST(ContainerTest, IsEmptyInitially) {
  EXPECT_TRUE(this->container_.empty());
}

TYPED_TEST(ContainerTest, CanInsert) {
  this->container_.insert(this->container_.end(), 1);
  EXPECT_FALSE(this->container_.empty());
}
```

## Practical Example: Type-Parameterized Test

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {};

TYPED_TEST_SUITE_P(NumericLimitsTest);

TYPED_TEST_P(NumericLimitsTest, IsSigned) {
  EXPECT_TRUE(std::numeric_limits<TypeParam>::is_signed);
}

REGISTER_TYPED_TEST_SUITE_P(NumericLimitsTest, IsSigned);

using TypesToTest = testing::Types<int, long, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyTypes, NumericLimitsTest, TypesToTest);
```
