---
title: "Mock Method Definition"
description: "Explains the core APIs and macros for defining mock methods in user classes, specifying function signatures, qualifiers, and behaviors. Demonstrates usage of MOCK_METHOD and customization of mock objects for flexible and safe test scaffolding."
---

# Mock Method Definition

This page details the core macros and APIs provided by GoogleMock (gMock) for defining mock methods within user-defined classes. It explains the usage and syntax of the `MOCK_METHOD` macro, demonstrating how to declare mock methods that mirror the signature and behavior of real class methods, including their argument lists and qualifiers. Understanding this is essential to creating effective mock classes that support flexible and safe testing.

---

## Overview of MOCK_METHOD

`MOCK_METHOD` is the fundamental macro used in GoogleMock to declare mock methods inside mock classes. It generates all necessary plumbing to intercept calls, set expectations, and specify behaviors for mocked methods.

### Basic Syntax

```cpp
MOCK_METHOD(return_type, method_name, (args...), (specs...));
```

- `return_type`: The return type of the method being mocked.
- `method_name`: The exact name of the method.
- `(args...)`: A parenthesized list of argument types the method accepts.
- `(specs...)` (optional): A list of method qualifiers like `const`, `override`, `noexcept`, or calling conventions.

### Example

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
};
```

This mock declares three mocked methods mirroring the signature of a real `Turtle` interface.

### Where to Place `MOCK_METHOD`

All `MOCK_METHOD` declarations must be placed in the `public:` section of the mock class, even if the method in the real class is protected or private. This visibility ensures that gMock's macros like `ON_CALL` and `EXPECT_CALL` can properly access and reference those methods from tests.

---

## Handling Complex Method Signatures

### Dealing with Unprotected Commas

If the return type or argument types contain commas (like templated types), these must be wrapped in parentheses or replaced with type aliases to avoid parsing errors by the macro:

```cpp
class MockFoo {
 public:
  // Incorrect - will not compile because of unprotected commas:
  // MOCK_METHOD(std::pair<bool, int>, GetPair, ());
  
  // Correct - wrap with parentheses:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());

  // Or use type aliases:
  using BoolIntPair = std::pair<bool, int>;
  MOCK_METHOD(BoolIntPair, GetPair, ());
};
```

### Mocking Overloaded Methods

When mocking overloaded methods, all overloads must be mocked explicitly. If some overloads are omitted, the compiler will warn about hiding other overloads. You can bring unmocked overloads into scope with the `using` keyword:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring other overloads into scope
  MOCK_METHOD(int, Add, (Element x), (override));
};
```

### Mocking Const and Reference Qualifiers

Add qualifiers like `(const)`, `(override)`, `(noexcept)`, `(ref(&))` as a comma-separated list inside the fourth macro parameter. For example:

```cpp
MOCK_METHOD(int, GetValue, (), (const, override));
MOCK_METHOD(void, Process, (Data& d), (override, ref(&)));
```

### Specifying Calling Conventions

On platforms like Windows, where calling conventions matter, use `Calltype(...)` in the specs list:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE), override));
```

---

## Advanced Tips and Best Practices

### Mocking Private and Protected Methods

Always place `MOCK_METHOD` in the `public:` section regardless of original access specifiers. This is a C++ feature allowing subclasses to elevate visibility.

### Mocking Non-Virtual Methods

Although gMock primarily mocks virtual methods, it supports mocking non-virtual methods via unrelated mock classes that replicate the signatures. Dependency injection on template parameters enables swapping implementations in tests.

### Avoid Over-Specifying Expectations

Tests should specify only necessary constraints. Avoid setting too many `EXPECT_CALL`s or overly strict cardinalities to keep tests maintainable and resilient to internal changes.

### Using NiceMock, NaggyMock, and StrictMock

These wrappers modify a mock's behavior for uninteresting calls:
- **NiceMock**: suppresses warnings on unexpected calls.
- **NaggyMock**: the default; warns on uninteresting calls.
- **StrictMock**: treats uninteresting calls as errors.

Choose appropriately based on your testing needs.

### Controlling Return Value Behavior

By default, mock methods return default-constructed values for their types. Customize these with `ON_CALL` to set default behaviors or use `WillOnce` / `WillRepeatedly` with `EXPECT_CALL` for fine-grained control.

Example:

```cpp
ON_CALL(mock, GetValue()).WillByDefault(Return(42));
EXPECT_CALL(mock, GetValue()).WillOnce(Return(100));
```

### Retiring Expectations

To avoid undesired repeated matching and errors with multiple `WillOnce` clauses, use `.RetiresOnSaturation()` to deactivate an expectation once fulfilled.

### Organizing Expectations with Sequences

Use `InSequence` objects or `.InSequence()` clauses on expectations to enforce ordering of calls, which helps express temporal constraints clearly.

Example:

```cpp
Sequence s;
EXPECT_CALL(mock, Initialize()).InSequence(s);
EXPECT_CALL(mock, Run()).InSequence(s);
EXPECT_CALL(mock, Finish()).InSequence(s);
```

---

## Typical Workflow

1. Define a mock class by mocking all virtual methods you want to fake with `MOCK_METHOD`.
2. Instantiate mock objects in your tests.
3. Use `ON_CALL` to define default method behavior.
4. Set expectations with `EXPECT_CALL` specifying call counts, matchers, and actions.
5. Run your code that interacts with mocks.
6. Test failures automatically report unmet expectations or unexpected calls.
7. Optionally use `Mock::VerifyAndClearExpectations` to explicitly check mocks before destruction.

---

## Common Pitfalls

- Forgetting to put `MOCK_METHOD` declarations in `public:` causes linkage or access errors.
- Omitting parentheses or proper aliasing around types with commas in signatures causes compilation errors.
- Setting expectations after the mock method has already been called leads to undefined behavior.
- Forgetting to specify `RetiresOnSaturation()` with multiple `WillOnce` clauses causes upper-bound errors.
- Using overloaded methods without disambiguating them by matchers or `using` declarations causes ambiguity.

---

## Example: Comprehensive Mock Class

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual bool Transform(Gadget* g) = 0;
  virtual void Resume() = 0;
  virtual int GetTimeout() const = 0;
  virtual ~Foo() {}
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(bool, Transform, (Gadget* g), (override));
  MOCK_METHOD(void, Resume, (), (override));
  MOCK_METHOD(int, GetTimeout, (), (const, override));
};
```

In your tests, you can set expectations:

```cpp
MockFoo mock_foo;
ON_CALL(mock_foo, GetTimeout()).WillByDefault(Return(100));
EXPECT_CALL(mock_foo, Transform).Times(AtLeast(1));
EXPECT_CALL(mock_foo, Resume()).Times(0); // Should never be called

// Exercise code that uses mock_foo
```

---

## Further Reading

- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) — Beginner friendly intro with examples.
- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Detailed scenarios and recipes.
- [Mocking and Matchers API Reference](./defining-expectations.md) — Get into expectations and matchers.
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) — Quick syntax reference.

---

This page fits within the `Mocking and Matchers` section of the API reference and serves as the foundation for declaring mocks, enabling users to build precise, expressive, and maintainable test doubles with gMock.