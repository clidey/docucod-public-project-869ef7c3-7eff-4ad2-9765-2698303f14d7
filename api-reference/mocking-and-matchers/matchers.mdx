---
title: "Matchers and Validation"
description: "Provides a complete catalog of built-in matchers, along with guidance on composing complex matchers and registering custom ones. Discusses value, range, and type matching to maximize test expressiveness."
---

# Matchers and Validation Reference

## Overview

Matchers in GoogleMock provide a powerful, expressive language to specify expected argument values when setting expectations on mock methods. This documentation page offers a complete catalog of built-in matchers, explains how to compose complex matchers, and guides you on registering your own custom matchers. It frames value, range, and type matching patterns that enable maximal expressiveness in your test assertions.

Matchers allow you to specify detailed and flexible criteria, resembling natural English, to match function arguments during mock method invocations. They help you write robust tests that clearly convey intent and produce informative failure messages.

## Contents

1. Built-in Matchers Catalog
2. Composing Complex Matchers
3. Custom Matcher Creation
4. Value Matching
5. Range Matching
6. Type Matching

---

## 1. Built-in Matchers Catalog

GoogleMock ships with a rich set of built-in matchers covering common scenarios. Here are key categories:

### Wildcard Matchers
- `_`, `A<T>()`, `An<T>()`
  - Match any value of type `T`, allowing you to ignore an argument's exact value.

### Equality Matchers
- `Eq(value)`
  - Matches values that are equal to `value`.
- `Ne(value)`
  - Matches values not equal to `value`.

### Relational Matchers
- `Lt(value)` — less than
- `Le(value)` — less or equal
- `Gt(value)` — greater than
- `Ge(value)` — greater or equal

### String Matchers
- `StrEq(str)`, `StrNe(str)` — compare C strings or string-like types for (in)equality
- `StrCaseEq(str)`, `StrCaseNe(str)` — case-insensitive comparisons
- `HasSubstr(substring)` — matches strings containing the substring
- `StartsWith(prefix)`, `EndsWith(suffix)` — match string prefixes or suffixes
- `MatchesRegex(regex)`, `ContainsRegex(regex)` — match strings against regular expressions

### Pointer Matchers
- `IsNull()`, `NotNull()` — match null or non-null pointers
- `Pointee(matcher)` — match the value pointed to by a pointer
- `Ref(variable)` — match references that bind to `variable`

### Container Matchers
- `ElementsAre(...)` — match container elements in order
- `UnorderedElementsAre(...)` — match container elements regardless of order
- `Contains(element_matcher)` — confirm presence of element matching criteria
- `Each(element_matcher)` — all elements satisfy matcher
- `SizeIs(size_matcher)` — match the container's size

### Composite Matchers
- `AllOf(m1, m2, ...)` — match if ALL sub-matchers match
- `AnyOf(m1, m2, ...)` — match if ANY sub-matcher matches
- `Not(matcher)` — negates the matcher

### Specialized Matchers
- `Pairs(first_matcher, second_matcher)` — for `std::pair`(key,value) elements
- `Key(matcher)` — matches the key part of a pair
- `Property(&Class::Method, matcher)` — matches an object by a getter result
- `Field(&Class::field, matcher)` — matches an object’s member field
- `WhenDynamicCastTo<T>(matcher)` — matches an object after dynamic casting to `T`
- `Optional(value_matcher)` — matches `std::optional` values
- `VariantWith<T>(matcher)` — matches selected type content in `std::variant`

---

## 2. Composing Complex Matchers

Matchers can be composed recursively, allowing you to build expressive constraints from simpler pieces.

For example, you can combine matchers with:

- **Logical AND**: `AllOf(Gt(5), Lt(10))` matches values between 5 and 10.
- **Logical OR**: `AnyOf(Eq(0), Eq(42))` matches 0 or 42.
- **Negation**: `Not(Eq(5))` matches all values except 5.

Matchers may be nested inside container matchers for rich structural validation:

```cpp
EXPECT_CALL(mock, Process(ElementsAre(Gt(0), Lt(0), _))); // Vector elements constraints
```

You can also restrict expectations on multiple arguments as a tuple via `.With()`:

```cpp
EXPECT_CALL(mock, Func(_, _)).With(Lt());  // The first argument < second arg
```

### Tips for Complex Matcher Composition

- **Reuse matchers:** Assign complex matcher expressions to variables to avoid duplication:
  
```cpp
auto in_range = AllOf(Gt(5), Le(15));
EXPECT_CALL(mock, Foo(in_range));
EXPECT_CALL(mock, Bar(in_range));
```

- **Use `MatcherCast` and `SafeMatcherCast`** to convert polymorphic matchers or adjust types explicitly.
- **Explainability:** Use matchers that provide `MatchAndExplain()` for richer failure diagnostics.

---

## 3. Creating Custom Matchers

While GoogleMock’s built-in matchers cover most needs, defining custom matchers can greatly improve readability and specificity in your tests.

### Quick Custom Matcher with `MATCHER` Macro
You can define a basic polymorphic matcher easily:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

// Usage:
EXPECT_CALL(mock, Foo(IsEven()));
```

- The macro provides the value via `arg`.
- The matcher returns `true` if matched, `false` otherwise.
- Optionally stream detailed failure info to `result_listener`.

### Parameterized Matchers (`MATCHER_P`, `MATCHER_P2`, ...)

For matchers with parameters:

```cpp
MATCHER_P(InRange, bound, "") {
  return arg >= 0 && arg <= bound;
}

EXPECT_THAT(value, InRange(100));
```

- The description string can be empty `""`, or customized using parameters and negation status.

### Explicit Matcher Classes

For performance or more control, implement the `MatcherInterface<T>` interface:

```cpp
class DivisibleByMatcher {
 public:
  using is_gtest_matcher = void;
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}
  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os) *os << "remainder " << (n % divisor_);
    return false;
  }
  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }
  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }
 private:
  int divisor_;
};

Matcher<int> DivisibleBy(int divisor) {
  return DivisibleByMatcher(divisor);
}
```

This approach allows streaming detailed explanations and negation handling.

---

## 4. Value Matching

Matchers can test exact values, references, pointer addresses, and more.

### Examples

```cpp
EXPECT_CALL(mock, Foo(Eq(42)));   // Exactly 42
EXPECT_CALL(mock, Foo(Ref(x)));   // Matches argument that references variable x
EXPECT_CALL(mock, Foo(IsNull())); // Argument is null pointer
EXPECT_CALL(mock, Foo(NotNull())); // Argument is non-null pointer
```

### Best Practices

- Use `Eq()` for exact value matching.
- Use `Ref()` when you want to match by reference identity.
- Avoid mixing pointer equality with string equality: use string matchers for content comparison.

---

## 5. Range Matching

GoogleMock provides relational matchers to specify ranges:

| Matcher | Description                    |
|---------|-------------------------------|
| `Lt(v)` | Less than `v`                 |
| `Le(v)` | Less than or equal to `v`     |
| `Gt(v)` | Greater than `v`              |
| `Ge(v)` | Greater than or equal to `v`  |

### Example

```cpp
EXPECT_CALL(mock, Foo(AllOf(Ge(5), Le(10))));  // Between 5 and 10 inclusive
```

### Advanced Range Matching

Combine with `AllOf()` and `AnyOf()` to define complex numeric ranges easily.

---

## 6. Type Matching

Matchers support matching argument types indirectly and safely through polymorphism.

### Any Type Matcher

- Use `_`, `A<T>()`, or `An<T>()` to match any value of type `T`, regardless of its value.

### Dynamic Casting Matcher

If RTTI is enabled, use `WhenDynamicCastTo<T>(matcher)` to match an object after a `dynamic_cast` to `T`. For example:

```cpp
EXPECT_CALL(mock, Foo(WhenDynamicCastTo<Derived*>(Pointee(Eq(42)))));
```

This matches a pointer which, when cast to `Derived*`, points to a value equal to 42.

### Advantages

- Enables safe downcasting-based matching
- Safeguards test correctness when different derived types are involved

---

## Practical Tips and Best Practices

- Always specify only the necessary argument constraints to keep tests maintainable.
- Use `SafeMatcherCast` or `MatcherCast` to handle type compatibility explicitly.
- Combine matchers to form expressive logical conditions: `AllOf`, `AnyOf`, `Not`.
- Use container matchers to validate complex collections easily.
- Define custom matchers when reusable or complex logic is needed.
- Match pointer target values with `Pointee()` rather than pointer values unless intentional.

---

## Troubleshooting Common Matcher Issues

- **Unmatched Overloads:** When mocking overloaded methods, provide explicit matcher types or use wrappers like `TypedEq<T>()` to resolve ambiguities.
- **Lifetime Issues:** Ensure referenced variables used in `Ref()` or matcher parameters outlive the expectations.
- **Move-only Types:** Matchers work with move-only types if properly handled in mock method declarations.
- **Implicit Conversions:** Use `SafeMatcherCast` to guarantee safe conversions and avoid surprises.

For detailed usage, consult related guides like the [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md) and the [Matchers Reference](matchers.md).

---

## Additional Resources

- [GoogleMock Mocking Reference](../reference/mocking.md)
- [Expectations and Actions](../reference/actions.md)
- [gMock Cookbook for practical recipes](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md)
- [Writing New Matchers Quickly](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md#newmatchers)
- [Matchers Reference](matchers.md)
- [Using Matchers with ASSERT_THAT and EXPECT_THAT](../reference/assertions.md#EXPECT_THAT)

---

This page empowers you to leverage GoogleMock’s full matcher capabilities to specify precise and readable mock expectations that transform your tests into crystal-clear, resilient specifications.