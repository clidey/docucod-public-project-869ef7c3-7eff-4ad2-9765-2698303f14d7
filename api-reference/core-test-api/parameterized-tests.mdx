---
title: "Parameterized & Typed Tests"
description: "Documents APIs for value-parameterized and type-parameterized testing, enabling the same tests to run with multiple input values and types. Includes instantiation, registration, and best practices."
---

# Parameterized & Typed Tests

GoogleTest offers powerful APIs for writing tests that run repeatedly over multiple input values and types using **value-parameterized tests** and **type-parameterized tests**. This approach reduces code duplication and ensures your code works correctly across a variety of scenarios.

This documentation guides you through the essentials of parameterized and typed testing, explaining how to define, instantiate, and register tests that take parameters by value or by type. It also highlights best practices to ensure clear, maintainable, and effective test cases.

---

## Overview

Both value-parameterized and type-parameterized tests enable writing flexible test suites where the same test logic runs over different inputs. The core difference lies in what varies:

- **Value-Parameterized Tests** vary test inputs by values passed to the test (e.g., strings, numbers, tuples). 
- **Type-Parameterized Tests** vary the test by types, ideal for verifying templates or class interfaces work properly across multiple type instantiations.

This page covers the key GoogleTest macros and classes involved, how to instantiate these tests, and how to customize test naming for clearer output.

---

## Value-Parameterized Tests API

### Defining a Value-Parameterized Test

1. Define a test fixture class derived from `::testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<TypeYouWantToTest> {
  // Implement fixture members if needed.
};
```

2. Use `TEST_P()` to define a test method inside the fixture. Access the current parameter with `GetParam()`.

```cpp
TEST_P(FooTest, DoesSomething) {
  auto param = GetParam();
  EXPECT_TRUE(SomeFunction(param));
}
```

### Instantiating the Test Suite

Instantiate the parameterized test suite using `INSTANTIATE_TEST_SUITE_P`, providing:

- A unique prefix name to identify the instantiation.
- The test suite (fixture) name.
- A parameter generator object.

Example generating string parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(MyGroup, FooTest, testing::Values("apple", "banana", "cherry"));
```

This creates separate tests like:

- `MyGroup/FooTest.DoesSomething/0` with parameter "apple"
- `MyGroup/FooTest.DoesSomething/1` with parameter "banana"
- `MyGroup/FooTest.DoesSomething/2` with parameter "cherry"

### Parameter Generators

GoogleTest offers built-in parameter generators capable of producing sequences for your tests:

| Generator             | Description                                         |
|-----------------------|-----------------------------------------------------|
| `Range(start, end)`   | Yields sequential values from `start` to `end - 1`.
| `Values(v1, ..., vN)` | Uses explicitly listed values.
| `ValuesIn(container)` | Uses values from array, container, or iterator range.
| `Bool()`              | Produces `false` and `true`.
| `Combine(...)`        | Produces Cartesian products of multiple parameter sets.

Example using combinations:
```cpp
INSTANTIATE_TEST_SUITE_P(
  ComboTest, SomeTest,
  testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Customizing Test Names

By default, GoogleTest generates test names using parameter values, but you may want custom readable names especially if parameters are complex. Pass a name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(
  MyGroup, FooTest, testing::Values("A", "B"),
  [](const testing::TestParamInfo<FooTest::ParamType>& info) {
    return "Param_" + info.param;
  });
```

**Important:** Generated test names must only use alphanumeric characters and underscores, and cannot contain underscores at start or end or be empty (see [FAQ](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)).

### Best Practices & Notes for Value-Parameterized Tests

- Your parameter type `T` must be copyable and support streaming to `ostream` for default naming.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` to silence warnings if a test fixture defines parameterized tests but is not instantiated.
- Instantiations can occur in different translation units.
- Remember the `TEST_P` test bodies rely on `GetParam()` for parameters.

---

## Typed Tests API

### Typed Tests

When you want to run the same test logic across a fixed list of types, use Typed Tests.

Steps:

1. Define a template fixture class parameterized on a type and derived from `::testing::Test`:

```cpp
template <typename T>
class FooTypedTest : public ::testing::Test {
 public:
  // Fixture code here
};
```

2. Define a type list using `::testing::Types<...>`:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
```

3. Associate the list with your test suite using `TYPED_TEST_SUITE`:

```cpp
TYPED_TEST_SUITE(FooTypedTest, MyTypes);
```

4. Use `TYPED_TEST` macro to write your typed test. Refer to the type parameter as `TypeParam`:

```cpp
TYPED_TEST(FooTypedTest, SupportsOperations) {
  // Example usage
  TypeParam value = 42;
  EXPECT_TRUE(SomeOperation(value));
}
```

### Typed Test Naming Customization

You can provide a custom name generator by supplying a class with a static template `GetName(int)` method as the optional third argument of `TYPED_TEST_SUITE`:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    return "Unknown";
  }
};
TYPED_TEST_SUITE(FooTypedTest, MyTypes, MyTypeNames);
```

This generates test suite names like `FooTypedTest/Int`, `FooTypedTest/Double` when tests run.

### Best Practices & Notes for Typed Tests

- Typed tests require you to know all types at compile time.
- Use them when the test logic/template depends on type overloading or other type-based behavior.
- The test code must be valid for all types in the list.

---

## Type-Parameterized Tests

Type-parameterized tests let you define tests without specifying the type list upfront. Instead, you can declare a type-parameterized test suite and instantiate it multiple times with different type lists in different translation units.

### Defining Type-Parameterized Tests

1. Define a template test fixture:

```cpp
template <typename T>
class MyTypesTest : public ::testing::Test {
  // ...
};
```

2. Declare the test suite as type-parameterized with `TYPED_TEST_SUITE_P`:

```cpp
TYPED_TEST_SUITE_P(MyTypesTest);
```

3. Define typed tests inside with `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypesTest, WorksForAllTypes) {
  TypeParam value{};
  EXPECT_TRUE(SomeCheck(value));
}
```

4. Register all tests you defined using `REGISTER_TYPED_TEST_SUITE_P`, listing test names:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypesTest, WorksForAllTypes);
```

### Instantiating a Type-Parameterized Test Suite

Use `INSTANTIATE_TYPED_TEST_SUITE_P` to instantiate the registered test suite with specific types:

```cpp
using MyTypes1 = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, MyTypesTest, MyTypes1);
```

Tests will be named `MyPrefix/MyTypesTest.WorksForAllTypes/<type_index>`.

You may instantiate the same test suite with different type sets multiple times.

### Custom Name Generation

Pass an optional fourth argument to provide a custom name generator class with the same interface as for typed tests.

```cpp
INSTANTIATE_TYPED_TEST_SUITE_P(
    Custom, MyTypesTest, MyTypes1, MyCustomNameGen);
```

---

## Using Parameter Generators

GoogleTest provides versatile parameter generators useful for both value-parameterized tests and type-parameterized tests:

- `Values(...)`
- `ValuesIn(container)`
- `Range(start, end[, step])`
- `Bool()` generates Boolean values
- `Combine(...)` for Cartesian products
- `ConvertGenerator(...)` for casting or transforming parameters

These generators support a wide spectrum of testing scenarios.

---

## Managing Test Fixtures

- The parameterized test fixture must derive from both `testing::Test` and `testing::WithParamInterface<T>` for value-parameterized tests (shortcut: use `TestWithParam<T>`).
- For typed tests, derive a class template from `testing::Test`.
- You can define `SetUpTestSuite` and `TearDownTestSuite` as `public static` methods for shared state setup/teardown.
- Inside typed tests, refer to the current type as `TypeParam`.
- Inside value-parameterized tests, access current parameter with `GetParam()`.

---

## Common Pitfalls & Troubleshooting

- **Name constraints:** Test suite and test names must avoid leading/trailing underscores and be underscore-free to prevent runtime errors.
- **Uninstantiated parameterized tests:** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest)` if you define but don't instantiate parameterized tests within a build.
- **Type conversions:** Use `ConvertGenerator` when parameters require explicit conversions to parameter types.
- **Linking issues:** Ensure consistent use of typed/value-parameterized test macros and proper instantiation, as missing instantiations cause runtime failures.

See the [FAQ](../faq.md#my-compiler-complains-no-matching-function-to-call-when-i-use-assert_pred-) for additional guidance on template and assertion usage.

---

## Practical Examples

### Value-Parameterized Test Example

```cpp
// Fixture for string parameter
class StringTest : public ::testing::TestWithParam<std::string> {};

TEST_P(StringTest, IsNotEmpty) {
  EXPECT_FALSE(GetParam().empty());
}

// Instantiate with string values
INSTANTIATE_TEST_SUITE_P(Strings, StringTest, testing::Values("foo", "bar", "baz"));
```

### Typed Test Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  static constexpr T zero() { return T{0}; }
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, ZeroIsZero) {
  EXPECT_EQ(this->zero(), TypeParam(0));
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class InterfaceTest : public ::testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(InterfaceTest);

TYPED_TEST_P(InterfaceTest, SupportsOperation) {
  TypeParam obj;
  EXPECT_TRUE(obj.Operation());
}

REGISTER_TYPED_TEST_SUITE_P(InterfaceTest, SupportsOperation);

using ImplementationTypes = ::testing::Types<Foo, Bar>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpls, InterfaceTest, ImplementationTypes);
```

---

## Additional References

- [GoogleTest Primer](../primer.md) for foundational knowledge on writing tests
- [Value-Parameterized Tests Guide](../guides/core-workflows/value-and-type-param-tests.md) for detailed workflows
- [Testing Reference - Parameterized Tests](../reference/testing.md#TYPED_TEST_SUITE) for API details
- [FAQ on Using Parameterized Tests](../faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests)

---

## Summary

Embrace the power of GoogleTest's parameterized and typed testing APIs to write scalable and expressive tests across varying inputs and types. Proper test fixture design, parameter generation, and instantiation are key to successful test suites with minimal duplication and maximum coverage. Custom naming options aid in test clarity, while recommended best practices help avoid common pitfalls.

---