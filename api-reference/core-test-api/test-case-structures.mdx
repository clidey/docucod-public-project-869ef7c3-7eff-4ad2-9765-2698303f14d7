---
title: "Test Cases and Fixtures"
description: "Details how to define test cases, organize tests, and use fixtures in GoogleTest. Outlines the TEST and TEST_F macros, the structure of test files, and best practices for grouping and parameterizing tests."
---

# Test Cases and Fixtures

This documentation details how to define test cases, organize tests, and use fixtures in GoogleTest. It outlines the `TEST` and `TEST_F` macros, the structure expected for test files, and best practices for grouping and parameterizing tests. Understanding these concepts enables you to write clear, maintainable, and efficient C++ tests with GoogleTest.

---

## 1. Overview of Test Case Structures

GoogleTest organizes tests into *test cases* and *test suites*, each comprising one or more tests. This page explains:

- How to define an individual test using the `TEST` macro.
- How to use a *test fixture* with `TEST_F` to set up shared context.
- Best practices for test organization and parameterization.

> In GoogleTest, the term "test case" sometimes refers to a group of related tests. Newer GoogleTest versions also use "test suite" interchangeably. Both represent a collection of tests sharing a common name prefix.

### Key Macros in Test Case Definition

| Macro  | Purpose                                              |
|--------|-----------------------------------------------------|
| `TEST` | Defines a basic test without shared fixture.         |
| `TEST_F`| Defines a test that uses a test fixture (shared context). |


---

## 2. Defining Basic Tests with `TEST`

Use the `TEST` macro to create simple tests that do not require sharing common setup or teardown code.

### Syntax

```cpp
TEST(TestCaseName, TestName) {
  // test code here
}
```

- `TestCaseName` groups related tests.
- `TestName` uniquely identifies the test within the group.

### Example

```cpp
TEST(ArithmeticTests, Addition) {
  EXPECT_EQ(2 + 2, 4);
}
```

### Best Practices

- Each test should verify one behavior or condition.
- Name tests clearly to reflect their intent.
- Avoid duplicating setup code across tests; use fixtures for shared setup.

---

## 3. Grouping Tests with Test Fixtures and `TEST_F`

For tests needing shared context (common data, setup, or teardown), GoogleTest provides *test fixtures*.

### What is a Test Fixture?

A test fixture is a class derived from `::testing::Test` which encapsulates the common setup and teardown logic for a set of related tests.

### How to Define a Test Fixture

```cpp
class MyTestFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Initialize shared resources.
  }

  void TearDown() override {
    // Cleanup.
  }

  // Shared data members
  int shared_value;
};
```

### Using `TEST_F` to create tests with a Fixture

```cpp
TEST_F(MyTestFixture, TestBehavior) {
  shared_value = 42;
  EXPECT_EQ(shared_value, 42);
}
```

- All tests defined with `TEST_F` use the fixture class as their context.
- The test methods have access to fixture members.

### Advantages

- Eliminates duplicated setup/teardown code across tests.
- Provides a clean environment for each test, with setup run before and teardown after.
- Enables rich stateful testing scenarios.

---

## 4. Parameterized Tests

GoogleTest allows specifying parameterized tests to run the same logic with different inputs.

While this page focuses on `TEST` and `TEST_F`, parameterized tests build on fixtures, adding flexibility to cover multiple scenarios efficiently.

Learn more in the [`Parameterized and Type-Parameterized Tests`](../guides/core-testing-patterns/parameterized-and-type-parameterized-tests) documentation.

---

## 5. Organizing Test Files

### File Naming and Placement

- Place tests close to the code they verify.
- Common pattern: tests for a type or module reside in `{module}_test.cc` or `{module}_unittest.cc`.

### One Test Case per File or Multiple

- Balance convenience and maintainability.
- Many small test cases: easier navigation.
- Group closely related tests: reduces boilerplate.

### Naming Test Case and Tests

- Use descriptive, readable names.
- Test case names usually reflect the class or component under test.
- Test names describe the specific behavior or condition.

Example:

```cpp
TEST_F(StackTest, PushIncreasesSize) {
  stack_.Push(5);
  EXPECT_EQ(stack_.Size(), 1);
}
```

---

## 6. Best Practices for Grouping and Parameterizing Tests

- **Write focused tests:** each test should check a single logical condition.
- **Avoid redundant test code:** use fixtures with `TEST_F` for common data and setup.
- **Use parameterized tests for data-driven testing:** reduces duplication and improves coverage.
- **Use descriptive test and test case names:** helps quickly identify intent and test purpose.
- **Keep test dependencies minimal:** each test should be independently runnable without relying on global state or other tests.

---

## 7. Practical Examples

### Simple Test Example

```cpp
TEST(MathTest, Multiplication) {
  EXPECT_EQ(3 * 5, 15);
}
```

### Test Fixture Example

```cpp
class StringTest : public ::testing::Test {
 protected:
  void SetUp() override {
    s_ = "hello";
  }

  std::string s_;
};

TEST_F(StringTest, HasCorrectLength) {
  EXPECT_EQ(s_.length(), 5);
}

TEST_F(StringTest, CanConcatenate) {
  s_ += " world";
  EXPECT_EQ(s_, "hello world");
}
```

### Using a Fixture to Share a Resource

If several tests require a complex or expensive setup (e.g., opening a database connection), using a fixture avoids repeating setup code and ensures cleanup occurs automatically.

---

## 8. Common Pitfalls and Troubleshooting

- **Test functions must not throw exceptions:** GoogleTest expects tests to catch exceptions or fail gracefully.
- **Expectations must be set before exercising the code under test:** Setting expectations after calls have been made leads to undefined behavior.
- **Avoid sharing mutable global state between tests:** This can produce flaky or nondeterministic test results.
- **Make sure your test fixture destructor is virtual if you subclass it.**

Refer to the [Troubleshooting Setup & Installation](../getting-started/environment-setup/troubleshooting-setup) and [Best Practices for Reliable and Maintainable Tests](../guides/real-world-practices/best-practices) for more guidance.

---

## 9. Advanced Topics

- **Value- and Type-Parameterized Tests:** Extend `TEST_F` with templates to handle multiple data inputs.
- **Death Tests:** Special tests verifying that code terminates or asserts as expected.
- **Test Lifecycle and Order:** Control order and dependencies between tests with sequences and fixtures.

Explore [the Concepts section on The xUnit Model and Test Lifecycle](../concepts/framework-architecture/xunit-model) for deep insights.

---

## 10. Summary

This document covered how to write simple tests with `TEST`, structure tests using the `TEST_F` macro with fixtures for shared setup and teardown, organize test files for maintainability, and best practices to ensure test reliability and clarity.

Use fixtures to reduce duplication, group logically related tests, and leverage parameterized tests to improve coverage efficiently.

---

## 11. Additional Resources

- [Writing & Running Your First Test](../getting-started/first-run-validation/your-first-test)
- [GoogleTest Primer](../overview/welcome-introduction/what-is-googletest)
- [Parameterized Tests Documentation](../guides/core-testing-patterns/parameterized-and-type-parameterized-tests)
- [Best Practices for Tests](../guides/real-world-practices/best-practices)
- [Mocking Introduction for Tests](../guides/getting-started/mocking-intro)

For detailed API reference about expectations and mocking, see the [Mocking Framework API](../api-reference/mocking-framework-api/defining-mocks).

---

<AccordionGroup title="Quick Reference">
<Accordion title="Defining a Basic Test">
```cpp
TEST(TestCaseName, TestName) {
  // test code
}
```
</Accordion>
<Accordion title="Using a Test Fixture">
```cpp
class MyFixture : public ::testing::Test {
 protected:
  void SetUp() override { /* setup code */ }
  void TearDown() override { /* cleanup code */ }
  DataType shared_data_;
};

TEST_F(MyFixture, TestName) {
  // test code with access to shared_data_
}
```
</Accordion>
<Accordion title="Parameterless EXPECT_CALL">

If method is not overloaded, you can expect calls without specifying parameters:

```cpp
EXPECT_CALL(mock_obj, MethodName).Times(2);
```

Note: This is disallowed for overloaded methods.
</Accordion>
<Accordion title="Overriding Setup with Fixtures">

Use fixtures to share setup & teardown across tests for cleaner code and reliable tests.
</Accordion>
</AccordionGroup>

---