---
title: "Mock Creation & Usage"
description: "Documentation for defining mock classes, using the MOCK_METHOD macro, and the main workflow for mocking dependencies. Provides practical examples on substituting real implementations with mocks for unit isolation and controlling the test environment."
---

# Mock Creation & Usage

This documentation explains how to define mock classes, use the `MOCK_METHOD` macro, and apply the main workflow for mocking dependencies in GoogleMock. Its focus is to empower you to replace real implementations with mocks during unit tests, isolate components, and precisely control your test environment.

---

## Defining Mock Classes

### Overview

Mock classes simulate real interfaces or abstract classes by allowing you to specify expected interactions at runtime. The core of mock class creation is deriving from the interface and using `MOCK_METHOD` macros to define mocked methods.

### Using the `MOCK_METHOD` Macro

The `MOCK_METHOD` macro simplifies mock method definitions. Its syntax is:

```cpp
MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (Qualifiers));
```

- **ReturnType**: The return type of the method you're mocking.
- **MethodName**: The name of the method.
- **ArgTypes...**: Parenthesized list of argument types.
- **Qualifiers** (optional): A comma-separated list within parentheses that can include `const`, `override`, `noexcept`, calling conventions (e.g., `Calltype(STDMETHODCALLTYPE)`), or reference qualifiers like `ref(&)`.

Example:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};
```

#### Dealing with commas

When argument or return types themselves contain commas (e.g., templated types like `std::pair<bool, int>`), you must either wrap those types in an extra pair of parentheses or use type aliases to avoid macro parsing errors:

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());
// or
using BoolAndInt = std::pair<bool, int>;
MOCK_METHOD(BoolAndInt, GetPair, ());
```

### Access Level

Mock methods defined using `MOCK_METHOD` must be declared in the `public` section of your mock class regardless of the original access level (public/protected/private) in the base interface. This allows `ON_CALL` and `EXPECT_CALL` macros to access these methods.

### Overloaded Methods

To mock overloaded methods, define a mock method for each overload. If you do not mock all overloads, bring unmocked versions into scope using `using BaseClass::MethodName;` to avoid hiding warnings.

### Templates and Move-Only Types

Templates are mocked just like normal classes by templating the mocking class and defining mocked methods with `MOCK_METHOD`.

Modern GoogleMock supports mocking methods that take or return move-only types (e.g., `std::unique_ptr`). Use `MOCK_METHOD` normally and provide lambdas or `WillOnce` / `WillRepeatedly` with custom actions to generate or consume move-only values.

---

## Workflows for Using Mocks

To effectively use mocks in your tests, follow this typical workflow:

1. **Import GoogleMock symbols:**
   ```cpp
   using ::testing::Return;
   using ::testing::_;  // The wildcard matcher
   ```
2. **Create mock objects:**
   ```cpp
   MockFoo mock_foo;
   ```
3. **Set default actions with `ON_CALL`:**
   Use `ON_CALL` to specify default behavior when the method is called without setting explicit expectations.

   ```cpp
   ON_CALL(mock_foo, GetSize()).WillByDefault(Return(42));
   ```

4. **Set expectations with `EXPECT_CALL`:**
   Declare how the mock object is expected to be used.

   ```cpp
   EXPECT_CALL(mock_foo, Describe("test"))
       .Times(3)
       .WillRepeatedly(Return("mocked description"));
   ```

5. **Exercise code using the mock:**
   Call code under test that depends on the mock interface.

6. **Verify expectations automatically:**
   When your mock object goes out of scope, GoogleMock automatically verifies all expectations. You can also force verification explicitly:

   ```cpp
   ASSERT_TRUE(Mock::VerifyAndClearExpectations(&mock_foo));
   ```

### Practical Example

```cpp
using ::testing::Return;
using ::testing::_;

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
};

TEST(BarTest, Example) {
  MockFoo foo;

  ON_CALL(foo, GetSize()).WillByDefault(Return(1));

  EXPECT_CALL(foo, Describe(5))
      .Times(3)
      .WillRepeatedly(Return("Category 5"));

  // Code under test uses foo
  EXPECT_EQ("Category 5", MyProdFunction(&foo));
}
```

### Best Practices

- Use `ON_CALL` for default behavior where you do not want to verify call counts.
- Use `EXPECT_CALL` sparingly for calls you *must* verify.
- Set expectations **before** exercising the code Under Test.
- Use `NiceMock` or `StrictMock` to control behavior on uninteresting calls.
- Avoid mocking private or protected methods unless necessary.

---

## Controlling Mock Strictness

GoogleMock lets you control how strictly uninteresting calls (calls to mock methods with no expectations) are handled.

### Mock Types

- **NaggyMock** (default mock behavior currently): warns on uninteresting calls.
- **NiceMock**: suppresses uninteresting call warnings.
- **StrictMock**: treats uninteresting calls as errors.

You use these by wrapping your mock class with the template:

```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;
using ::testing::NaggyMock;

NiceMock<MockFoo> nice_mock;  // No warnings on uninteresting calls
StrictMock<MockFoo> strict_mock;  // Errors on uninteresting calls
NaggyMock<MockFoo> naggy_mock;  // Warnings on uninteresting calls (default)
```

### Usage Notes

- These wrappers inherit constructors from your mock class and can be used in place of the original mock.
- They only affect *uninteresting* calls; *unexpected* calls (calls violating expectations) always cause errors.
- Wrapping multiple modifiers is not supported (e.g. `NiceMock<StrictMock<MockFoo>>` is unsupported).
- They only affect mock methods defined with `MOCK_METHOD` directly in the mock class.

### Example:

```cpp
using ::testing::NiceMock;

NiceMock<MockFoo> mock(42, "arg");  // Calls MockFoo(42, "arg")
EXPECT_CALL(mock, DoSomething());
// No warnings if other methods are called without expectation
```

---

## Practical Tips and Common Pitfalls

- **Virtual destructors:** Ensure your interface base class has a virtual destructor to avoid undefined behavior and memory leaks.
- **Order of expectations:** Later `EXPECT_CALL`s override earlier ones; new expectations take precedence.
- **Sequence control:** Use `InSequence` or `Sequence` objects to enforce call ordering.
- **Dealing with overloaded methods:** Use `Const()` or explicit type casts in matchers to disambiguate overloads.
- **Suppressing uninteresting calls warnings:** Use `NiceMock` or explicit `.Times(AnyNumber())` catch-all expectations.
- **Avoid setting expectations after mock is used:** Doing so leads to undefined behavior.

---

## Example: Creating a Mock Class Step-by-Step

Using interface `Turtle` as example:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

Use `MockTurtle` in your tests:

```cpp
TEST(PainterTest, DrawCircle) {
  MockTurtle mock;

  EXPECT_CALL(mock, PenDown()).Times(AtLeast(1));

  Painter p(&mock);
  p.DrawCircle(0, 0, 10);
}
```

---

## Advanced Example: Delegating to a Real or Fake Object

Sometimes you want to have a mock delegate calls to an existing implementation for default behavior while still verifying calls.

Example (delegating to a fake):

```cpp
class FakeFoo : public Foo {
 public:
  int DoThis(int n) { return n * 2; }
  void DoThat() { /* real implementation */ }
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, DoThis, (int n), (override));
  MOCK_METHOD(void, DoThat, (), (override));

  void DelegateToFake() {
    ON_CALL(*this, DoThis).WillByDefault(
        [this](int n) { return fake_.DoThis(n); });
    ON_CALL(*this, DoThat).WillByDefault(
        [this]() { fake_.DoThat(); });
  }

 private:
  FakeFoo fake_;
};
```

In your test:

```cpp
MockFoo mock;
mock.DelegateToFake();
EXPECT_CALL(mock, DoThis(5));
int result = mock.DoThis(5);  // Calls FakeFoo::DoThis(5)
```

---

## Summary

This page focused exclusively on the creation and use of mocks:

- Defining mock classes using `MOCK_METHOD`
- Setting default behavior with `ON_CALL`
- Specifying expected calls with `EXPECT_CALL`
- Controlling uninteresting calls via `NiceMock`, `StrictMock`, and `NaggyMock`
- Best practices, including ordering, access modifiers, and dealing with overloads

For further reading and deeper mastery, consult:

- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)
- [Using Mocks for Dependency Isolation](https://google.github.io/googletest/guides/core-workflows/using-mocks.html)

---