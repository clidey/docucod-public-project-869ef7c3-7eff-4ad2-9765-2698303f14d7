---
title: "Matchers: Built-in and Custom"
description: "Provides reference material and practical recipes for using built-in matchers, combining matchers, and implementing custom matchers. Examples illustrate use in both assertions and mock expectations to ensure flexible and precise verification."
---

# Matchers: Built-in and Custom

This page provides a comprehensive reference and practical guidance on using matchers in GoogleMock (gMock). Matchers are fundamental for expressing expectations on the arguments passed to mock functions and enable precise, flexible verification of function calls in your tests. This documentation covers the rich set of built-in matchers, techniques for combining matchers, and how to implement custom matchers to extend gMock's capabilities.

---

## Overview of Matchers

Matchers define the criteria that mock function arguments must satisfy for an expectation to match. They come in polymorphic and monomorphic variants, allowing flexibility depending on the argument types expected. You use matchers primarily inside `EXPECT_CALL` and `ON_CALL` statements to specify which function calls are expected or what their behaviors should be.

### Wildcard Matchers
- `_`
  - Matches **any** argument of any type unconditionally.
  - Useful for skipping argument validation.
- `A<T>()` / `An<T>()`
  - Matches any argument of the specified type `T`.

### Nullity Matches
- `IsNull()`
  - Matches any raw or smart pointer that is `nullptr`.
- `NotNull()`
  - Matches any raw or smart pointer that is **not** `nullptr`.

### Reference Matcher
- `Ref(variable)`
  - Matches any argument that **references** the specified variable.
  - Useful to ensure the exact object (not a copy) is passed.

### Equality and Comparison Matchers
- `Eq()`
  - Matches if the two tuple elements are equal.
- `Ne()`
  - Matches if the two tuple elements are not equal.
- `Lt()`, `Le()`, `Gt()`, `Ge()`
  - Match less than, less or equal, greater than, and greater or equal respectively.

### Floating Point Matchers
- `FloatEq()`, `DoubleEq()`
  - Matches floating-point numbers approximately equal up to 4 ULPs.
- `FloatNear()`, `DoubleNear()`
  - Matches floating-point numbers within a user-specified absolute error.
- NaN-sensitive variants treat NaN values as equal when specified.

### Container Matchers
- `ElementsAre(...)`
  - Matches containers whose elements exactly match the specified sequence of matchers or values.
- `UnorderedElementsAre(...)`
  - Matches containers where elements match the specified sequence but order is not significant.
- `ElementsAreArray(...)`, `UnorderedElementsAreArray(...)`
  - Match containers against arrays or other sequence ranges.
- `Contains(matcher)`
  - Matches containers containing at least one element satisfying the matcher.
- `Each(matcher)`
  - Matches containers where **all** elements satisfy the matcher.
- `SizeIs(matcher)`
  - Matches containers whose size matches the provided matcher.

### Tuple and Pair Matchers
- `Pair(first_matcher, second_matcher)`
  - Matches `std::pair` objects whose `first` and `second` satisfy the given matchers.
- `Key(matcher)`
  - Matches an element whose key (e.g. first in a pair) satisfies the matcher.
- `Pointwise(tuple_matcher, rhs_container)`
  - Matches containers where each element and corresponding element in `rhs_container` satisfy the `tuple_matcher`.
- `UnorderedPointwise(tuple_matcher, rhs_container)`
  - A version of `Pointwise` ignoring order.

### String Matchers
- `StrEq(string)` / `StrNe(string)`
  - Matches strings exactly equal or not equal.
- `StrCaseEq(string)` / `StrCaseNe(string)`
  - Case-insensitive string equality/inequality.
- `HasSubstr(substring)`
  - Matches strings containing the given substring.
- `StartsWith(prefix)` / `EndsWith(suffix)`
  - Matches strings starting or ending with the given substring.

### Pointer and Optional Matchers
- `Pointee(matcher)`
  - Matches pointers whose pointee matches the given matcher.
  - Works with raw and smart pointers.
- `Pointer(matcher)`
  - Matches pointers matching the given matcher.
- `Address(matcher)`
  - Matches object whose address matches the given matcher.
- `Optional(matcher)`
  - Matches `std::optional` or similar engaged value whose content matches the matcher.

### Matchers on Fields and Properties
- `Field(pointer_to_field, matcher)`
  - Matches an object whose specified member variable matches the matcher.
- `Property(pointer_to_getter, matcher)`
  - Matches an object whose property's getter method return value matches the matcher.

### Compound and Conditional Matchers
- `AllOf(m1, m2, ...)`
  - Matches if **all** matchers match (logical AND).
- `AnyOf(m1, m2, ...)`
  - Matches if **any** matcher matches (logical OR).
- `Not(matcher)`
  - Matches if the matcher does **not** match (logical negation).
- `Conditional(condition, matcher_true, matcher_false)`
  - Chooses between two matchers based on a boolean condition.

### Numeric and Distance Matchers
- `DistanceFrom(target, distance_measure, matcher)`
  - Matches values whose distance (according to `distance_measure`) from a target satisfies the matcher.
- `DistanceFrom(target, matcher)`
  - Uses default distance as absolute difference.

### Predicates and Custom Matchers
- `Truly(predicate)`
  - Turns any unary predicate (function or functor returning bool) into a matcher.
- `Matches(matcher)`
  - Converts a matcher into a unary predicate for use in predicate contexts.

---

## Using Matchers in gMock

### In `EXPECT_CALL` and `ON_CALL`
Matchers directly map to argument validation in `EXPECT_CALL` and `ON_CALL`. For example:

```cpp
EXPECT_CALL(mock_object, Method(Eq(5), Ge(10), _));
ON_CALL(mock_object, AnotherMethod(NotNull())).WillByDefault(Return(true));
```

Matchers allow precise condition checks on arguments without resorting to manually writing verification code.

### Mult-Argument Matching using `With()` Clause

You can use the `.With()` clause in `EXPECT_CALL` or `ON_CALL` to specify matchers that validate the function's arguments as a whole tuple. For example:

```cpp
EXPECT_CALL(mock_obj, SetPosition(_, _))
    .With(Lt());  // Matches when first arg < second arg
```

Sometimes you want to select specific argument positions for compound matching, which you can do with `Args<>()` combinator.

### Matching Reference to Variables

Use `Ref(variable)` to ensure that an argument is the same object as `variable`:

```cpp
int x = 5;
EXPECT_CALL(mock, Foo(Ref(x)));
```

### Matching Containers

The `ElementsAre()`, `UnorderedElementsAre()`, `Contains()`, and `Each()` matchers provide complex container matching, supporting both ordered and unordered comparison, subsets, and wildcards.

### Using Nested Matchers

Matchers can be nested to construct expressive conditions. For example, to expect a container of pairs where the first element is greater than 5 and the second element is a string starting with "foo":

```cpp
EXPECT_THAT(container, ElementsAre(Pair(Gt(5), StartsWith("foo"))));
```

### Combining Matchers

You can combine matchers using `AllOf()` and `AnyOf()` combinators to express composite conditions with logical AND and OR:

```cpp
EXPECT_CALL(mock, Method(AllOf(Ge(0), Le(10))));
```

### Writing Custom Matchers with `MATCHER` and `MATCHER_P`

For specialized matching scenarios, you can define custom matchers succinctly using `MATCHER` macros.

#### Basic example:

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}
```

Usage:
```cpp
EXPECT_CALL(mock, Process(IsEven()));
EXPECT_THAT(value, Not(IsEven()));
```

#### Adding descriptive failure messages:

```cpp
MATCHER(IsEven, negation ? "isn't even" : "is even") {
  if ((arg % 2) == 0) return true;
  *result_listener << "remainder is " << (arg % 2);
  return false;
}
```

#### Parameterized matchers:

Use `MATCHER_P`, `MATCHER_P2`, ..., `MATCHER_P10` macros to define matchers that accept parameters.

Example:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  return (arg % divisor) == 0;
}
...
EXPECT_THAT(value, IsDivisibleBy(7));
```

Their failure messages can include parameter values for clarity.

### Writing Polymorphic Matchers

By templating the `MatchAndExplain` method, matchers can match values of various types, e.g.:

```cpp
class NotNullMatcher {
 public:
  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const { return p != nullptr; }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};
```

You then expose a factory function:

```cpp
PolymorphicMatcher<NotNullMatcher> NotNull() { return MakePolymorphicMatcher(NotNullMatcher()); }
```

### Composing Matchers

More complex matchers often contain sub-matchers and override descriptions accordingly.

Use provided factory functions such as `DistanceFrom()`, `Key()`, `Pair()`, and others to combine and create matchers suited to your domain-specific needs.

---

## Practical Tips and Best Practices

- **Matchers must be pure**: They must be free of side effects and deterministic because they can be invoked multiple times.
- **Use `SafeMatcherCast<T>(m)`** when you want to cast a matcher’s type if the types involved are not exactly the same but safely convertible. For example, casting a `Matcher<long>` to a `Matcher<int>` when appropriate.
- **Prefer expressive matchers** over complex lambdas for clarity and better diagnostics.
- **Avoid over-specifying** expectations; use general matchers like `_` or `AnyNumber()` when argument values are irrelevant to test correctness.
- **Combine matchers for clarity**: Use `AllOf()`, `AnyOf()`, and tuple matchers to reduce boilerplate and capture precise semantics.
- **For container arguments, use `ElementsAre()` and `UnorderedElementsAre()`** to verify the contents effectively.
- **Use `Field()` and `Property()`** to verify relevant object members without over-constraining tests.

---

## Matcher Examples

### Basic matcher usage in expectation:

```cpp
EXPECT_CALL(mock_obj, DoSomething(Ge(1), Eq("foo"), _));
```

### With custom matcher:

```cpp
MATCHER(IsPositive, "checks if positive") { return arg > 0; }
EXPECT_CALL(mock_obj, ProcessValue(IsPositive()));
```

### Parameterized matcher:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") { return (arg % divisor) == 0; }
EXPECT_CALL(mock_obj, ProcessValue(IsDivisibleBy(3)));
```

### Matching container contents:

```cpp
EXPECT_CALL(mock, ReceiveValues(ElementsAre(1, Ge(5), _)));
EXPECT_CALL(mock, ReceiveValues(UnorderedElementsAre(3, 1, 2)));
```

### Matching members:

```cpp
EXPECT_CALL(mock, HandleEvent(Field(&Event::type, Eq(EventType::kClick))));
```

### Matching pointers:

```cpp
EXPECT_CALL(mock, ProcessData(Pointee(Ge(100))));
```

### Combining multiple matchers:

```cpp
EXPECT_THAT(value, AllOf(Ge(10), Le(20), Not(Eq(15))));
```

---

## Troubleshooting Matchers

- If a matcher fails unexpectedly, run tests with the `--gmock_verbose=info` flag to get detailed insights on which expectations matched or failed, including argument values and stack traces.
- Use descriptive matchers to pinpoint mismatch causes rather than relying on basic `Eq` or `Ne` alone.
- Avoid matcher side effects; unintended state modification in matchers can cause flaky or misleading test results.

---

## References and Further Reading

- [Using Assertions Effectively](../../guides/real-world-usage-and-best-practices/using-assertions-effectively.md) — to understand how `EXPECT_THAT` works with matchers.
- [Setting Expectations and Verifications](../mocking-framework-apis/setting-expectations.md) — where matchers are used in the context of mocking.
- [Writing New Matchers Quickly](../../docs/gmock_cook_book.md#NewMatchers) — for extensive recipes and examples for defining custom matchers.
- [Matchers: Built-in and Custom](../api-reference/mocking-framework-apis/using-matchers.md) — the canonical API reference for matchers.
- [Actions, Cardinalities, and Mock Control](../mocking-framework-apis/actions-and-cardinalities.md) — related concepts impacting expectations.

---

## Summary

This documentation empowers you with the knowledge to validate function calls effectively by using gMock matchers. A diverse and extensible matcher set is crucial for precise testing, and custom matchers allow you to tailor validation to your domain needs. Use these matchers to express clear and maintainable test contracts and combine them to capture complex expectations succinctly.

---
