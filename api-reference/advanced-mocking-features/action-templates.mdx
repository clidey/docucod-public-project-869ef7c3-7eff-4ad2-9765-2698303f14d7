---
title: "Action Templates and Parameterized Actions"
description: "Document mechanisms for defining parameterized or variadic actions with ACTION_TEMPLATE, and explain how to create highly reusable custom actions for complex test scenarios."
---

# Action Templates and Parameterized Actions

GoogleMock offers powerful mechanisms to create custom actions that can be parameterized or templated, enabling flexible and reusable behavior definitions directly within your mock expectations. This page explains how to define such parameterized and variadic actions through `ACTION_TEMPLATE` and related macros, empowering you to construct highly reusable custom actions for complex testing scenarios.

---

## Why Use Parameterized and Variadic Actions?

In many testing situations, you need a mock function to perform a behavior that depends on one or more parameters that customize the action's operation. For example, an action that adds a fixed number to an argument or returns a new instance of a class built with varying constructor parameters. Defining such custom actions using parameterized or template-based approaches lets you write concise, composable, and maintainable tests.

Unlike simple actions that are hardcoded when created, parameterized actions offer:

- **Flexibility**: Customize actions by passing runtime parameters.
- **Reusability**: Write once, invoke with many variations.
- **Type Safety**: Utilize C++'s type system to enforce correctness.


## Defining Parameterized Actions with `ACTION_P` and Friends

GoogleMock provides a family of macros to define actions with parameters:

- `ACTION(name) { /* ... */ }` defines a zero-parameter action.
- `ACTION_P(name, param) { /* ... */ }` defines an action with one parameter.
- `ACTION_P2(name, p1, p2)`, up to `ACTION_P10` enable defining actions with multiple parameters.

### Example: A Simple Parameterized Action
```cpp
// Defines an action that adds a fixed number to the first argument.
ACTION_P(Add, n) {
  return arg0 + n;
}

// Usage:
EXPECT_CALL(mock, Foo(5))
    .WillOnce(Add(3));  // Will return 8 when called with 5
```

### Using Argument and Parameter Types
Inside the action body, you can reference the types of the mock function's arguments and the parameters by using `arg0_type`, `arg1_type` for arguments and `n_type` for the parameter `n`. This feature helps enforce type correctness and use of conversions safely.

```cpp
ACTION_P(Add, n) {
  arg0_type value = arg0;  // mock function's 1st argument type
  n_type offset = n;      // action's parameter type
  return value + offset;
}
```


## Introducing `ACTION_TEMPLATE` for More Powerful Actions

When you need actions with explicit template parameters—not deduced from values—or want to pass multiple template arguments, GoogleMock offers the `ACTION_TEMPLATE` macro.

### Syntax
```cpp
ACTION_TEMPLATE(ActionName,
                HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),
                AND_n_VALUE_PARAMS(p1, ..., p_n)) {
  // Action implementation here
}
```

- **`HAS_m_TEMPLATE_PARAMS`**: Specifies `m` template parameters, their kinds (e.g., `typename`, `int`), and names.
- **`AND_n_VALUE_PARAMS`**: Specifies `n` value parameters for the action.

You invoke the resulting action in tests by specifying template parameters explicitly:
```cpp
ActionName<t1, t2, ...>(v1, v2, ...)
```

### Example: Copying an Argument with Explicit Types
```cpp
// Copies the k-th argument of the mock function to *output, converting to type T.
ACTION_TEMPLATE(DuplicateArg,
                HAS_2_TEMPLATE_PARAMS(int, k, typename, T),
                AND_1_VALUE_PARAMS(output)) {
  *output = T(std::get<k>(args));
}

// Usage:
int n;
EXPECT_CALL(mock, Foo(_, _))
    .WillOnce(DuplicateArg<1, unsigned char>(&n));
```

This approach lets you explicitly control template and runtime parameters for defining complex behaviors.


## Working with Variadic Actions

GoogleMock supports defining actions that handle up to 10 parameters using `ACTION_Pk` macros and variadic templates internally. This makes it feasible to write rich mock behaviors that:

- Accept multiple configuration parameters
- Use explicit types for parameters, including integral template parameters
- Are composable and reusable


## Best Practices for Custom Actions

- **Prefer `ACTION_P` and friends for simple parameterized actions:** Use these macros for most use cases to keep syntax simple.
- **Use `ACTION_TEMPLATE` for explicit template parameters:** When you need more control over template parameters that cannot be deduced, or when combining multiple template and value parameters.
- **Avoid over-specifying in expectations:** Only parameterize actions when needed to test the behavior under different conditions.
- **Write type-safe code:** Use `argN_type` and parameter types to prevent subtle bugs.


## Example: A Complex Action with Multiple Parameters
```cpp
// Returns the sum of several values, with explicit template params
ACTION_TEMPLATE(ReturnSum,
                HAS_1_TEMPLATE_PARAMS(typename, Number),
                AND_3_VALUE_PARAMS(v1, v2, v3)) {
  return static_cast<Number>(v1) + v2 + v3;
}

// Usage:
EXPECT_CALL(mock, Compute())
    .WillOnce(ReturnSum<int>(10, 20, 30));  // returns 60
```


## Chaining and Combining Actions

GoogleMock allows combining multiple actions into one with `DoAll()`, which performs multiple actions sequentially and returns the result of the last one. Custom parameterized actions integrate seamlessly with such compositions.


## Troubleshooting and Tips

- Remember to define actions at namespace scope; ACTION macros cannot be used inside functions or classes.
- Template and value parameter counts have upper bounds (10 each).
- Using `RetiresOnSaturation()` when using multiple expectations avoids sticky failures.
- For complex behaviors not supported by built-in actions, prefer lambdas or functors as they integrate well.


## Summary

You now have the tools to create robust, flexible, and reusable custom actions that are parameterized or template-based, enabling you to model even the most complex behaviors in mocks simply and cleanly.

---

## Related Documentation

- [Actions Reference](../reference/actions.md): Comprehensive list of available built-in actions.
- [EXPECT_CALL & ON_CALL](../api-reference/core-mocking-apis/expectations-on-call.md): How to use actions to define behavior.
- [Mocking Reference](../reference/mocking.md): Core concepts around mock method definitions and expectations.
- [gMock Cookbook](../gmock_cook_book.md): Practical recipes and advanced patterns on mocks.

---

### Code Example Snippet
```cpp
// A parameterized action that returns the sum of an argument plus a constant.
ACTION_P(AddN, n) {
  return arg0 + n;
}

// Usage in test:
EXPECT_CALL(mock, Foo(10))
    .WillOnce(AddN(5));  // Returns 15 on call

// A template action duplicating the k-th argument after converting to T.
ACTION_TEMPLATE(DuplicateArg,
                HAS_2_TEMPLATE_PARAMS(int, k, typename, T),
                AND_1_VALUE_PARAMS(output)) {
  *output = T(std::get<k>(args));
}

int copied;
EXPECT_CALL(mock, Foo(_, _))
    .WillOnce(DuplicateArg<1, unsigned char>(&copied));
```


## Frequently Asked Questions

<AccordionGroup title="Parameterizing Actions FAQs">
<Accordion title="Can I use ACTION macros inside functions or classes?">
No. ACTION macros must be defined at namespace scope because templates cannot be defined inside local scopes. Define helper functors or lambdas inside functions if needed.
</Accordion>
<Accordion title="What is the maximum number of parameters an ACTION_P macro supports?">
ACTION and ACTION_P family macros support up to 10 parameters. For more, consider composing actions or using custom functors.
</Accordion>
<Accordion title="When should I use ACTION_TEMPLATE instead of ACTION_P?">
Use ACTION_TEMPLATE when you need explicit template parameters that cannot be deduced from value parameters, or when multiple template parameters are needed.
</Accordion>
</AccordionGroup>


---