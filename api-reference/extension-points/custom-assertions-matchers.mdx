---
title: "Custom Assertions & Matchers"
description: "How to define and register custom assertions and matchers for your project's specific needs. Includes extension APIs, interfaces to implement, and best practices for robust integration."
---

# Custom Assertions & Matchers

## Overview

Custom assertions and matchers empower you to extend GoogleTest and GoogleMock beyond their built-in capabilities by defining your own validation logic tailored to your project’s domain. This page guides you through the process of creating and registering these extensions, enabling you to write tests that are clear, expressive, and robust.

You will learn how to:
- Define quick custom matchers using provided macros for simple cases.
- Implement advanced, reusable matcher classes for complex validation scenarios.
- Incorporate parameterized matchers that accept arguments and produce informative messages.
- Best practices for designing matchers that integrate seamlessly with GoogleTest’s reporting.

By mastering custom assertions and matchers, you ensure your tests precisely express intended behaviors and edge cases, enhancing both test effectiveness and maintainability.

---

## Why Create Custom Assertions and Matchers?

Built-in assertions and matchers cover a wide spectrum of common use cases, such as equality checks, relational comparisons, container validation, and string operations. However, real-world projects often encounter unique data structures and domain-specific conditions that require specialized validation.

Customizing assertions and matchers allows you to embed those domain rules directly into your test expressions. This improves clarity by replacing verbose or repetitive code with declarative checks and generates failure messages that precisely describe what went wrong, helping faster diagnosis.

---

## Quick Introduction to MATCHER Macros

GoogleMock provides an easy way to define simple custom matchers using the `MATCHER` macros. These macros generate matcher classes with support for detailed failure messages and work polymorphically with any compatible argument type.

### Basic Syntax

A simple matcher can be defined as:

```cpp
MATCHER(NameOfMatcher, "Description string") {
  // 'arg' is the value to match.
  // Return true if match succeeds, false otherwise.
  return (arg meets some condition);
}
```

Here, `NameOfMatcher` becomes the matcher name you can use in your tests.

**Example:** Matcher to check if a number is divisible by 7

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

// Usage in tests:
EXPECT_CALL(mock_object, SomeMethod(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

If the description string is empty, GoogleMock automatically generates a readable message based on the matcher name.

### Adding More Informative Failure Messages

You can stream extra information to a hidden `result_listener` to augment failure messages:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

Now, if the match fails, your message will include the actual remainder, giving more insight into the failure.

---

## Parameterized Matchers

For matchers requiring parameters, GoogleMock offers a family of macros: `MATCHER_P`, `MATCHER_P2`, ..., up to `MATCHER_P10`, allowing you to pass one or more arguments when creating the matcher instance.

### Syntax

```cpp
MATCHER_P(NameOfMatcher, param, "Description") {
  return (arg satisfies condition involving param);
}
```

### Example: Matcher to check absolute value

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}

// Usage
EXPECT_THAT(x, HasAbsoluteValue(10));
```

Descriptions automatically include the parameter value, improving diagnostic output.

---

## Writing Matcher Classes for Advanced Use

Beyond macros, you can implement matcher classes directly to gain full control and reusability, especially for:
- Polymorphic matchers handling multiple types
- Complex matching logic involving multiple steps or internal state
- Composite matchers that take other matchers as arguments

### Matcher Class Interface Requirements

Your matcher class must:

- Declare a type alias `using is_gtest_matcher = void;`
- Implement a templated `bool MatchAndExplain(const T& value, std::ostream* listener) const;`
  - This function determines if `value` matches your condition
  - If `listener` is non-null, provide explanation for success or failure
- Implement `void DescribeTo(std::ostream* os) const;` to describe the matcher
- Implement `void DescribeNegationTo(std::ostream* os) const;` to describe the negation

### Example: Custom Matcher Class

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    int rem = n % 7;
    if (rem == 0) return true;
    if (os) *os << "the remainder is " << rem;
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by 7";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by 7";
  }
};

::testing::Matcher<int> DivisibleBy7() {
  return ::testing::Matcher<int>(new DivisibleBy7Matcher());
}

// Usage
EXPECT_THAT(value, DivisibleBy7());
```

---

## Composite Matchers

Matchers can accept other matchers as parameters to build complex validation logic. You typically store sub-matchers inside your matcher class and delegate validation and description to them.

**Example:** Matcher that checks if a string has a length matching a given matcher

```cpp
class LengthMatcher {
 public:
  explicit LengthMatcher(::testing::Matcher<size_t> length_matcher)
      : length_matcher_(length_matcher) {}

  template <typename T>
  bool MatchAndExplain(const T& str, std::ostream* os) const {
    size_t len = str.size();
    if (!length_matcher_.Matches(len) && os) {
      *os << "which has length " << len;
    }
    return length_matcher_.Matches(len);
  }

  void DescribeTo(std::ostream* os) const {
    *os << "has length that ";
    length_matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "does not have length that ";
    length_matcher_.DescribeNegationTo(os);
  }

 private:
  ::testing::Matcher<size_t> length_matcher_;
};

::testing::Matcher<std::string> HasLength(::testing::Matcher<size_t> m) {
  return ::testing::Matcher<std::string>(new LengthMatcher(m));
}

// Usage
EXPECT_THAT(my_string, HasLength(::testing::Gt(5)));
```

---

## Using Custom Assertions

In addition to matchers, GoogleTest allows you to write custom assertions — predicates that produce detailed pass/fail messages. For many cases, a matcher coupled with `EXPECT_THAT` is clearer and more reusable, but assertions shine when you must perform complex setup or teardown.

### Custom Assertion Function Signature

```cpp
testing::AssertionResult MyAssertion(const Type& value);
```

Return `testing::AssertionSuccess()` on success or
`testing::AssertionFailure() << "failure message";` on failure.

### Example

```cpp
testing::AssertionResult IsValidEmail(const std::string& email) {
  if (email.find('@') != std::string::npos) {
    return testing::AssertionSuccess();
  } else {
    return testing::AssertionFailure() << "does not contain '@'";
  }
}

// Usage
EXPECT_TRUE(IsValidEmail(some_email));
// or with GTest's message streaming
EXPECT_TRUE(IsValidEmail(some_email)) << "Email check failed.";
```

### Better: Use EXPECT_THAT with A Custom Matcher

A matcher integrates tightly to GoogleTest’s failure reporting:

```cpp
MATCHER(IsValidEmail, "checks if string looks like an email") {
  return arg.find('@') != std::string::npos;
}

EXPECT_THAT(email, IsValidEmail());
```

This approach enhances diagnostics and test readability.

---

## Best Practices

- **Keep matchers pure:** They should have no side effects and be deterministic regardless of invocation frequency.
- **Write clear failure messages:** Use `result_listener` or explicit description methods to aid diagnosis.
- **Use parameterized matchers judiciously:** Parameter values should be part of the failure message.
- **Prefer matchers over raw assertion functions:** Matchers compose better with GoogleTest’s expressive syntax.
- **Define reusable matchers:** Keep matchers modular; for complex logic, split into smaller matchers.
- **Use existing building blocks:** Leverage `AllOf`, `AnyOf`, `Not`, and container matchers to combine simpler matchers.
- **Avoid over-specification:** Only match what’s truly relevant to each test to prevent brittle tests.

---

## Troubleshooting

- **Matcher not invoked as expected:** Verify the matcher accepts the argument type compatible with the tested function's parameter.
- **Failing with obscure errors:** Use verbose failure messages by streaming details in `MatchAndExplain`.
- **Compilation errors:** Wrap types with parentheses or use type aliases as needed.
- **Too much noisy output:** Avoid excessive logging in matchers; keep explanations focused.
- **Side effects in matcher:** Ensure your matcher cannot inadvertently call mock functions or alter state.

---

## Additional Resources

- [GoogleTest Assertions Reference](../../core-apis/assertions-reference)
- [gMock Cookbook on Matchers](../../gmock_cook_book#NewMatchers)
- [Matchers Reference](../using-matchers)
- [Writing Your First Test Guide](../../gtest-guides/getting-started/write_first_test)

---

## Code Example Summary

```cpp
// Simple matcher using MATCHER macro.
MATCHER(IsPositive, "Checks if a number is positive") {
  return arg > 0;
}

// Parameterized matcher using MATCHER_P.
MATCHER_P(IsDivisibleBy, divisor, "Checks divisibility") {
  return arg % divisor == 0;
}

// Advanced matcher class example.
class StartsWithMatcher {
 public:
  explicit StartsWithMatcher(const std::string& prefix) : prefix_(prefix) {}

  template <typename T>
  bool MatchAndExplain(const T& s, std::ostream* os) const {
    if (s.find(prefix_) == 0) return true;
    if (os) *os << "does not start with " << prefix_;
    return false;
  }

  void DescribeTo(std::ostream* os) const { *os << "starts with " << prefix_; }
  void DescribeNegationTo(std::ostream* os) const { *os << "does not start with " << prefix_; }

 private:
  std::string prefix_;
};

::testing::Matcher<std::string> StartsWith(const std::string& prefix) {
  return ::testing::Matcher<std::string>(new StartsWithMatcher(prefix));
}

// Usage
EXPECT_THAT(my_string, StartsWith("Hello"));
```

---

## Summary

Custom assertions and matchers let you tailor GoogleTest and GoogleMock to test domain-specific invariants clearly and reliably. From concise macro-based matchers for simple checks to comprehensive matcher classes for rich validation, this page equips you with tools and best practices to build expressive and maintainable test predicates.
