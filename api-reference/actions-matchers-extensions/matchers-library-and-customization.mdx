---
title: "Matchers Library and Custom Matchers"
description: "Detailed guide to using the built-in matcher library for expressive assertions and expectations (e.g., equality, comparisons, container, and regex matching). Explains how to write your own custom matchers for domain-specific validation, leveraging GoogleTest/GoogleMock's matcher extensibility."
---

# Matchers Library and Custom Matchers

GoogleMock’s matcher library empowers you to write expressive assertions and expectations. This guide details how to leverage the built-in matcher library for common assertions like equality, comparisons, container membership, and regex matching. Furthermore, it explains how to extend the framework with your own custom matchers, enabling validation of domain-specific invariants with clear, precise semantics.

---

## Overview

Matchers are predicates used to specify constraints on function arguments during mocking and assertions. Rather than writing `EXPECT_CALL(foo, Method(5))` to check exact argument equality, matchers provide a flexible way to describe argument expectations succinctly and readably.

They can match values literally, compare with ranges, inspect container contents, or evaluate custom predicates. GoogleMock ships with a comprehensive set of built-in matchers, and you can customize them or write your own to handle specialized conditions.

Using matchers enhances your tests’ readability, maintainability, and diagnostic clarity when test failures occur.


## Built-in Matcher Categories

### 1. Comparison Matchers

Matchers that compare values using standard operators:

- `Eq(value)` or simply `value` — expects equality.
- `Ne(value)` — expects inequality.
- `Gt(value)`, `Ge(value)` — greater than, greater or equal.
- `Lt(value)`, `Le(value)` — less than, less or equal.

**Example:**

```cpp
EXPECT_CALL(mock, Func(Ge(10)));  // Expects argument >= 10
EXPECT_THAT(value, Lt(5));        // Assertion that value < 5
```

### 2. Wildcard and Identity Matchers

- `_` — matches any value of the correct argument type.
- `A<T>()` / `An<T>()` — match any value of type `T`.
- `IsNull()` / `NotNull()` — for pointer types, matches `nullptr` or not.
- `Ref(variable)` — matches an argument that references the same variable.

### 3. Container Matchers

Help validate contents of STL-style containers and arrays:

- `ElementsAre(...)` — matches container elements in order with given matchers.
- `UnorderedElementsAre(...)` — matches elements regardless of order.
- `Contains(matcher)` — expects at least one element matching `matcher`.
- `Each(matcher)` — all elements satisfy `matcher`.
- `SizeIs(matcher)` — matches container size or `begin()`/`end()` distance.
- `IsSubsetOf()`, `IsSupersetOf()` — match container subset/superset relationships.

**Example:**

```cpp
EXPECT_THAT(vec, ElementsAre(1, Gt(10), _));
EXPECT_THAT(set, UnorderedElementsAre(5, 1, 3));
EXPECT_THAT(map, Contains(Key(42)));
```

### 4. String Matchers

For matching strings including raw C strings and std::string:

- `StrEq(s)` / `StrNe(s)` — exact case-sensitive equality/inequality.
- `StrCaseEq(s)` / `StrCaseNe(s)` — equality/inequality ignoring case.
- `StartsWith(prefix)`, `EndsWith(suffix)` — match string prefixes/suffixes.
- `HasSubstr(substring)` — matches if substring is contained.
- `MatchesRegex(regex)`, `ContainsRegex(regex)` — regex matching.

**Example:**

```cpp
EXPECT_THAT(str, StartsWith("Hello"));
EXPECT_THAT(str, MatchesRegex("a.*z"));
```

### 5. Tuple and Pair Matchers

- `Pair(first_matcher, second_matcher)` — matches `std::pair` or similar structures.
- `FieldsAre(m1, m2, m3, ...)` — matches tuple or aggregate fields individually.
- `Key(matcher)` — matches key in a key-value pair.

Useful for containers of pairs or complex data structures.

### 6. Predicate Matchers

- `Truly(predicate)` — accepts any unary predicate callable.
- Custom matchers (see below).


## Using Matchers in Tests

Matchers are typically used with:

- `EXPECT_CALL(mock_object, Method(matcher1, matcher2, ...))` — to specify mock method argument expectations.
- `EXPECT_THAT(value, matcher)` or `ASSERT_THAT(value, matcher)` — for runtime assertions.

They replace explicit argument values in `EXPECT_CALL` for clear semantic intent, e.g.: 

```cpp
EXPECT_CALL(mock_turtle, Forward(Ge(100)));  // Checks argument >= 100
EXPECT_THAT(container, Contains(Key(42)));   // Asserts container has key 42
```


## Writing Custom Matchers

Built-in matchers cover most cases, but domain-specific conditions require custom matchers. GoogleMock offers multiple ways to write them, from lightweight macros to full class-based implementations.

### 1. Using MATCHER Macros

These macros offer concise definitions of matchers with automatic description generation.

**Simple example:**

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }

// Usage:
EXPECT_CALL(mock, Func(IsEven()));
EXPECT_THAT(value, IsEven());
```

To improve diagnostics, stream explanations to `*result_listener`:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if (arg % 7 == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

**Parameterized matcher:**

```cpp
MATCHER_P(InClosedRange, bound, "") { return 0 <= arg && arg <= bound; }
EXPECT_THAT(x, InClosedRange(10));
```

### 2. Implementing Matcher Interface

For advanced control over typing and behavior, implement a matcher class:

```cpp
class DivisibleByMatcher {
 public:
  using is_gtest_matcher = void;
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os) *os << "remainder: " << (n % divisor_);
    return false;
  }

  void DescribeTo(std::ostream* os) const { *os << "is divisible by " << divisor_; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is not divisible by " << divisor_; }

 private:
  int divisor_;
};

testing::Matcher<int> DivisibleBy(int divisor) {
  return testing::MakeMatcher(new DivisibleByMatcher(divisor));
}
```

### 3. Polymorphic Matchers

Allow matchers usable over multiple types by making `MatchAndExplain` a template:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(T* p, std::ostream*) const { return p != nullptr; }

  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return testing::MakePolymorphicMatcher(NotNullMatcher());
}
```

### 4. Combining Matchers

You can compose matchers with logical combinators:

- `AllOf(m1, m2, ...)` — matches if all matchers match.
- `AnyOf(m1, m2, ...)` — matches if any matcher matches.
- `Not(matcher)` — negates a matcher.


## Practical Tips & Best Practices

- Prefer using built-in matchers for common scenarios to keep tests simple and efficient.
- Use `_` matcher for arguments that are not relevant to your verification to avoid overspecification.
- Leverage `RetiresOnSaturation()` to deactivate expectations once used, especially when multiple similar expectations may apply.
- When mocking methods with multiple overloads, disambiguate using `Const()` or specific matchers to avoid ambiguity.
- Use `SafeMatcherCast<T>(matcher)` to convert matchers to argument types safely.
- Write custom matchers when you need to express complex domain rules or predicates.
- Stream detailed explanations to `*result_listener` in custom matchers to improve failure messages.

## Common Pitfalls

- Setting expectations after exercising mocks leads to undefined behavior.
- Overly strict expectations on arguments or call count can make tests fragile.
- Ignoring uninteresting calls without `NiceMock` or catch-all expectations leads to warnings.

## Example: Defining and Using a Custom Matcher

Suppose you want to verify that a number is divisible by a configurable divisor.

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  if (arg % divisor == 0) return true;
  *result_listener << "with remainder " << (arg % divisor);
  return false;
}

// Using it with EXPECT_CALL
EXPECT_CALL(mock, ProcessValue(IsDivisibleBy(5)));

// Using with ASSERT_THAT
ASSERT_THAT(computed_value, IsDivisibleBy(5));
```

This matcher provides natural language failure messages, showing the specific remainder when failing.

---

For advanced users, see the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for detailed recipes on writing custom matchers, and the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) for the full built-in matcher list.


## Troubleshooting

- If a matcher behaves unexpectedly, ensure it is pure and has no side effects.
- When custom matchers don’t produce clear failure messages, add streaming to `*result_listener`.
- Compiler errors related to matcher types often indicate a need for `SafeMatcherCast` or better type disambiguation.


## Related Documentation

- [EXPECT_CALL](../mocking-framework/expectations-and-default-actions.md) for integrating matchers into mock method expectations
- [Assertion Macros and EXPECT_THAT](../testing-framework/assertions-reference.md#EXPECT_THAT) for using matchers in assertions
- [Writing New Matchers Quickly](../gmock_cook_book.md#NewMatchers) from the Cookbook for advanced custom matcher patterns

---

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "googlemock/include/gmock/gmock-matchers.h", "range": "1-1000"},{"path": "docs/gmock_cook_book.md", "range": "1-300"}]} />
