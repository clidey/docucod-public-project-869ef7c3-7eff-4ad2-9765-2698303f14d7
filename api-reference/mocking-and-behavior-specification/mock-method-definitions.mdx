---
title: "Mock Method Definitions"
description: "Reference for macro-based mechanisms and helper templates for defining mock methods with custom signatures. Illustrates the use of MOCK_METHOD and its integration with class hierarchies to simulate dependencies and verify interactions."
---

# Mock Method Definitions

This reference documents the macro-based mechanisms and helper templates provided by GoogleTest for defining mock methods with custom signatures. It highlights the usage of the `MOCK_METHOD` macro within mock classes, demonstrating how it integrates seamlessly with class hierarchies to simulate dependencies and verify interactions between components.

---

## Overview of MOCK_METHOD

At the heart of defining mock methods in GoogleTest is the `MOCK_METHOD` macro. This macro generates mock methods inside your mock classes, allowing you to specify precise behaviors, expectations, and verification of calls.

### Basic Syntax

```cpp
MOCK_METHOD(return_type, method_name, (argument_types...), (optional_specifiers));
```

- `return_type`: The return type of the mocked method.
- `method_name`: The name of the method to mock.
- `(argument_types...)`: A parenthesized list of argument types.
- `(optional_specifiers)`: Parenthesized list of optional qualifiers like `const`, `override`, `noexcept`, and others.

### Example

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(void, SetValue, (int val), (override));
};
```

### Important Notes

- The macro must be placed in the `public:` section of the mock class regardless of the base class method's access level (public, protected, or private). This ensures visibility to `ON_CALL` and `EXPECT_CALL` macros.

- If your return type or argument types include commas (e.g., `std::pair<int, int>`), you must enclose the type in parentheses to avoid parsing errors:

```cpp
MOCK_METHOD((std::pair<int, int>), GetPair, ());
```

or you can use a type alias:

```cpp
using Pair = std::pair<int, int>;
MOCK_METHOD(Pair, GetPair, ());
```

- For methods with qualifiers such as `const`, `override`, or `noexcept`, include these in the optional specifiers parameter in a comma-separated format:

```cpp
MOCK_METHOD(void, Func, (), (const, override, noexcept));
```

- The macro supports marking calling conventions and reference qualifiers using `Calltype()` and `ref()` specifiers:

```cpp
MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)));
MOCK_METHOD(void, Foo, (), (ref(&)));
```

---

## Integration with Class Hierarchies and Use Cases

`MOCK_METHOD` is designed to be used to mock both virtual and non-virtual methods, enabling diverse test scenarios:

### Mocking Virtual Methods in Inherited Classes

To mock virtual methods in interfaces or base classes, define a derived mock class and replace each virtual method with a `MOCK_METHOD` in the `public:` scope:

```cpp
class Base {
 public:
  virtual ~Base() {}
  virtual int DoWork(int x) = 0;
};

class MockDerived : public Base {
 public:
  MOCK_METHOD(int, DoWork, (int x), (override));
};
```

This allows setting expectations and behaviors for `DoWork` in tests.

### Mocking Overloaded Methods

For overloaded methods, each overload can be mocked individually (pay attention to qualifiers like `const`), for example:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Get, (), (override));
  MOCK_METHOD(int, Get, (int index), (override));
  MOCK_METHOD(int, Get, (int index), (const, override));
};
```

To avoid hiding base class overloads, use `using` declarations if you do not mock all overloads.

### Mocking Class Templates

You can mock methods in template classes by using `MOCK_METHOD` inside the template specialization:

```cpp
template <typename T>
class MockStack : public Stack<T> {
 public:
  MOCK_METHOD(int, Size, (), (const, override));
  MOCK_METHOD(void, Push, (const T& val), (override));
};
```

### Mocking Non-Virtual Methods

While direct mocking of non-virtual methods is not supported, you can define unrelated mocks with methods that have the same signature for use in template-based or compile-time dependency injection.

---

## Best Practices and Common Pitfalls

- **Always place `MOCK_METHOD` in the `public:` section** to ensure accessibility from test code using `EXPECT_CALL` or `ON_CALL`.

- **Enclose complex types with commas in parentheses or use type aliases** to prevent macro parsing errors.

- **Specify the appropriate qualifiers** (`const`, `override`, `noexcept`, calling convention, and reference qualifiers) to correctly override the base class methods.

- **Avoid mocking destructors directly with `MOCK_METHOD`**. Instead, mock it by adding a mock method like `Die()` and calling it in the destructor, then set expectations on `Die()`.

- **Use `using` declarations to expose base class overloads if they are not mocked to avoid hiding warnings**.

- **For performance improvement during compilation**, consider moving the constructor and destructor definitions of the mock class into a separate source file.

---

## Example Walkthrough: Defining a Mock Class

Given an interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};
```

To create a mock:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

This mock class lets tests specify behavior and expectations on all turtle methods easily.

---

## Integration with gMock Interaction Controls

The methods generated by `MOCK_METHOD` work seamlessly with other GoogleMock facilities:

- `EXPECT_CALL` to set call expectations with argument matchers.
- `ON_CALL` to define default behaviors.
- Support for sequences, cardinalities, and call ordering.
- Compatibility with NiceMock, StrictMock, and NaggyMock wrappers to customize mock behaviors on uninteresting calls.

---

## Troubleshooting Your Mock Method Definitions

- **Compilation Errors Due to Commas:** Wrap return types or argument types containing commas in parentheses or use a type alias.

- **Overload Ambiguity:** Use fully qualified parameter lists or `using` declarations to clarify overload selection.

- **Incorrect Access Levels:** Always define `MOCK_METHOD` in the public section even if base methods are protected or private.

- **Missing Qualifiers:** Failing to include `const`, `override`, or other qualifiers exactly as in the base class method results in override mismatches.

- **Destructor Mocking:** `MOCK_METHOD` does not support destructors; mock destructors via a separate method like `Die()`.

---

## References and Additional Resources

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) - detailed recipes on using mocks.
- [Mocking Reference](../mocking.md) - comprehensive reference for macros, classes, and expectations.
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) - quick reference for mocking syntax.
- [Creating and Using Mocks Guide](../creating-and-using-mocks.md) - tutorial on mock creation and usage.

---

By mastering `MOCK_METHOD` and its correct use within mock classes, you empower your tests to precisely simulate dependencies, control interactions, and verify expected behavior with confidence and clarity.
