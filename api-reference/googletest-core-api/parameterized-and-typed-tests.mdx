---
title: "Parameterized & Typed Tests"
description: "Documents mechanisms for value- and type-parameterized tests, macros for test generation, and utilities for running suites with multiple input values or types to maximize code coverage and reduce test duplication."
---

# Parameterized & Typed Tests

GoogleTest provides powerful mechanisms for maximizing test coverage and minimizing duplicated code by supporting *value-parameterized*, *typed*, and *type-parameterized* tests. This page explores these mechanisms, their usage patterns, macros, and utilities that enable you to run comprehensive test suites over various input values or types seamlessly.

---

## 1. Introduction to Parameterized & Typed Tests

If you want to verify that your code behaves correctly across multiple inputs or types without writing repetitive test functions, parameterized and typed tests are your best tools. They enable *data-driven* and *type-driven* testing efficiently:

- **Value-Parameterized Tests** let you run the same test logic with different input values.
- **Typed Tests** run the same test code over a specified list of types known at compile time.
- **Type-Parameterized Tests** allow defining abstract test patterns that can later be instantiated with various lists of types.

By leveraging these features, you achieve extensive test coverage while keeping your test code clean and maintainable.

## 2. Value-Parameterized Tests: Testing with Varying Input Values

### What Are Value-Parameterized Tests?
Value-parameterized tests let you run a single test case multiple times with different data inputs, which is invaluable when testing functions or components against a range of scenarios.

### How to Define Value-Parameterized Tests

1. **Define a Test Fixture Class** 
   - Derive from both `testing::Test` and `testing::WithParamInterface<T>` (or simply `testing::TestWithParam<T>`).
   - `T` here is the type of the parameter values.

2. **Use the `TEST_P` Macro** 
   - Define your test patterns using the parameterized fixture.
   - Access the parameter with `GetParam()` inside the test body.

3. **Instantiate the Test Suite**
   - Use `INSTANTIATE_TEST_SUITE_P` with a unique instantiation name.
   - Provide a parameter generator like `Values`, `ValuesIn`, `Range`, or combine generators with `Combine`.

### Example:
```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(Process(param));
}

INSTANTIATE_TEST_SUITE_P(
    VariousInputs, FooTest,
    testing::Values(1, 2, 3, 4));
```

Now GoogleTest runs `FooTest.HandlesVariousInputs` four times with parameters 1, 2, 3, and 4.

### Supported Parameter Generators
- `Range(start, end [, step])` — Yields values from `start` up to but not including `end`.
- `Values(v1, v2, ..., vN)` — Yields specified explicit values.
- `ValuesIn(container or iterator range)` — Yields values from a container or iterator range.
- `Bool()` — Yields `false` and `true`.
- `Combine(g1, g2, ..., gN)` — Yields the Cartesian product as tuples of multiple generators.

### Custom Test Name Suffixes
You can supply a *name generator* function or functor as an optional last argument to `INSTANTIATE_TEST_SUITE_P` that generates descriptive test case suffixes based on parameters, improving readability in test reports.

---

## 3. Typed Tests: Testing Across Multiple Types

### Overview
Typed tests let you write a test suite once and run the same set of tests for several different types. This is ideal when you want to verify that multiple implementations conform to the same interface or concept.

### How to Write Typed Tests

1. **Define a Fixture Class Template**
   - Template your test fixture class on a type parameter `T`.
   - Inherit from `testing::Test`.

2. **Declare The List of Types**
   - Using `testing::Types<T...>`, define the type list.
   - Use `TYPED_TEST_SUITE` to associate the fixture with the type list.

3. **Define Typed Tests Using `TYPED_TEST`**
   - Use `TypeParam` inside the test to refer to the current type.

### Example:

```cpp
template<typename T>
class FooTest : public testing::Test {
 public:
  T value_;
};

using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);

TYPED_TEST(FooTest, DoesBasicOperations) {
  TypeParam val = this->value_;
  EXPECT_TRUE(DoSomething(val));
}
```

GoogleTest compiles and runs the tests three times: for `int`, `double`, and `char`.

### Optional Name Generator
`TYPED_TEST_SUITE` accepts a third argument, a class providing a static `GetName(int)` template method that customizes the test name for each type.

---

## 4. Type-Parameterized Tests: Defining Abstract Typed Test Patterns

Type-parameterized tests extend typed tests by allowing the test suite definition without knowing the list of types up-front. You can later instantiate the suite multiple times with different type lists, potentially from different translation units.

### Defining Type-Parameterized Tests

1. Define a fixture class template.
2. Declare the suite as type-parameterized with `TYPED_TEST_SUITE_P`.
3. Define the individual tests using `TYPED_TEST_P`.
4. Register the tests with `REGISTER_TYPED_TEST_SUITE_P`.

### Instantiation
Use `INSTANTIATE_TYPED_TEST_SUITE_P` with a unique prefix and the list of types to instantiate the suite.

### Example:
```cpp
template<typename T>
class FooTest : public testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, Works) {
  TypeParam val{};
  EXPECT_TRUE(DoSomething(val));
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, Works);

using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

---

## 5. Instantiating and Running Parameterized and Typed Tests

| Macro | Purpose |
|-------|---------|
| `INSTANTIATE_TEST_SUITE_P` | Instantiate value-parameterized test suites with a parameter generator and optional name generator |
| `TYPED_TEST_SUITE` | Declare typed test suites by associating a fixture template and a list of types |
| `INSTANTIATE_TYPED_TEST_SUITE_P` | Instantiate type-parameterized test suites with a prefix and list of types |

### Important Notes
- The instantiation macros must be used at global or namespace scope.
- For value-parameterized tests, generators are lazily evaluated at `InitGoogleTest()`, so any initialization code needed for parameter generation should happen prior.
- Test names generated automatically use numeric suffixes, but you can supply custom name generators for better test reporting clarity.

---

## 6. Best Practices and Common Pitfalls

- **Avoid Underscores in Test Names:** GoogleTest reserves underscore (_) characters for special purposes; avoid using them in test suite or test names to prevent naming collisions or build errors.
- **Prefer `TEST_P` Over Manual Loops:** Use GoogleTest parameterized test infrastructure instead of looping test logic inside a single test.
- **Ensure Proper Instantiation:** Uninstantiated parameterized test suites cause failures; use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress if intended.
- **Remember Parameter Lifetimes:** Generators that produce references (e.g., `std::string_view` backed by temporary strings) can create dangling references if not carefully managed.
- **Use Custom Name Generators:** When using complex parameter types (like strings), provide custom parameter names for clearer test output.

---

## 7. Practical Tips & Utilities

- **Combining Multiple Parameters:** Use `testing::Combine()` to create tests which verify all possible parameter combinations.

- **Converting Generator Types:** Use `ConvertGenerator()` to adapt generator output to types explicitly required by your tests, accommodating explicit conversions and complex parameter types.

- **Using `GetParam()` and `TypeParam`:** Within parametrized tests, use `GetParam()` to access the current parameter value and `TypeParam` to reference the current type respectively.

- **Custom Printing Support:** Implement `PrintTo()` or `AbslStringify()` for your parameter types to ensure clear output in test reports.

- **Test Filtering and Names:** Parameterized test instances appear as `<InstantiationName>/<TestSuite>.<TestName>/<Index>`. Use `--gtest_filter` with these names to run specific cases.

---

## 8. Summary

Parameterized and typed tests empower you to cover wide input ranges and multiple types without redundant code. By following GoogleTest's macros and patterns (`TEST_P`, `TYPED_TEST`, `TYPED_TEST_P`, and their instantiations), you write tests that scale naturally to complex scenarios, improving RTL robustness and developer productivity.

---

For additional practical code samples and advanced techniques, refer to the [Advanced GoogleTest Topics](advanced.md#value-parameterized-tests) and the [Testing Reference's parameterized and typed test sections](reference/testing.md#TEST_P).

---

## Code Examples

### Value-Parameterized Test Example
```cpp
class StringLengthTest : public testing::TestWithParam<std::string> {};

TEST_P(StringLengthTest, IsNonEmpty) {
  const std::string& str = GetParam();
  EXPECT_FALSE(str.empty());
}

INSTANTIATE_TEST_SUITE_P(MyInstantiation, StringLengthTest,
                         testing::Values("apple", "banana", "cherry"));
```

### Typed Test Example
```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {
 protected:
  T value_ = T();
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsZeroInitially) {
  EXPECT_EQ(this->value_, TypeParam(0));
}
```

### Type-Parameterized Test Example
```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyOnInit) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyOnInit);

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainers, ContainerTest, ContainerTypes);
```

---

## Troubleshooting Tips

- **Uninstantiated TEST_P Suites:** If your parameterized tests are not instantiating, your suite will cause a failure. Ensure each `TEST_P` has a corresponding `INSTANTIATE_TEST_SUITE_P` or mark it with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
 
- **Incorrect Parameter Lifetimes:** Beware of using parameter generators returning references or pointers to temporary data. Use explicit conversion or ensure the lifetime extends past test execution.

- **Name Collisions Due to Underscores:** Avoid underscores in test or suite names to prevent name mangling and ambiguous symbols causing build errors.

- **Fatal Assertions in Non-Void Functions:** Fatal assertions (`ASSERT_*`) are not usable in functions returning non-void. Refactor these into `void` or use nonfatal assertions like `EXPECT_*`.

---  

## References and Further Reading

- [GoogleTest Primer](primer.md)
- [Testing Reference](reference/testing.md#value-parameterized-tests)
- [Advanced GoogleTest Topics](advanced.md#value-parameterized-tests)
- [Assertions Reference](reference/assertions.md)
- [Writing Your First C++ Test](guides/core-testing-workflows/writing-basic-tests)

---

## See Also

- [Core Concepts and Terminology](overview/architecture-and-key-concepts/core-terminology)
- [How to Manage and Organize Test Suites](guides/core-testing-workflows/managing-test-suites)
- [Effective Mocking with GoogleMock](guides/advanced-features-and-patterns/effective-mocking.md)


