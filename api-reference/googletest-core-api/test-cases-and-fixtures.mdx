---
title: "Test Cases & Fixtures"
description: "Describes how to define test cases, test suites, and fixtures, including class hierarchies and the structure for organizing and running tests. Covers patterns for resource sharing and setup/teardown to ensure reliable and isolated testing."
---

# Test Cases & Fixtures

GoogleTest structures tests around the concepts of test cases, test suites, and fixtures to provide a flexible and reliable framework for organizing, executing, and isolating your tests. This page covers how to define test cases and suites using `TEST` and `TEST_F` macros, how to build fixtures to share setup and teardown code, and best practices for managing resources to ensure tests remain independent, reliable, and maintainable.

---

## Understanding Test Cases and Test Suites

In GoogleTest, **test cases** have evolved into the terminology of **test suites**, which group together related tests logically. Each test suite contains multiple tests (or test methods) and allows sharing setup and teardown logic through **test fixtures**.

- A **test suite** is a collection of related tests focused on a particular functionality or class.
- A **test** (individual test) is represented by a function inside a test suite that verifies a specific behavior.

Tests within a suite should be independent - they must not rely on each other or shared mutable state - to ensure that a failure in one test does not cascade or mask issues in others.

## Defining Simple Tests: `TEST` Macro

The simplest tests use the `TEST` macro, which defines a test within a named test suite:

```cpp
TEST(TestSuiteName, TestName) {
  // Test body - your assertions and test logic here
  EXPECT_EQ(SomeFunction(), expected_value);
}
```

- `TestSuiteName` groups related tests.
- `TestName` identifies the specific test.

Each `TEST` creates a separate instance and does not share common setup or teardown logic with other tests.

## Using Fixtures: Sharing Setup and Teardown with `TEST_F`

When multiple tests require the same environment setup or shared resources, use **test fixtures** by defining a class that inherits from `testing::Test`. Use the `TEST_F` macro to write tests that use this fixture.

### Defining a Fixture

```cpp
class MyTestFixture : public testing::Test {
 protected:
  // Optional constructor for setup
  MyTestFixture() {
    // Code here runs before *each* test
  }

  // Optional destructor or TearDown function
  ~MyTestFixture() override {
    // Cleanup code here
  }

  void SetUp() override {
    // Code here runs immediately before each test
  }

  void TearDown() override {
    // Code here runs immediately after each test
  }

  // Shared objects for tests
  SomeClass shared_object_;
};
```

### Writing Tests Using the Fixture

```cpp
TEST_F(MyTestFixture, TestA) {
  // Use shared_object_ or other members
  EXPECT_TRUE(shared_object_.IsReady());
}

TEST_F(MyTestFixture, TestB) {
  // Tests run independently with their own fresh fixture instance
  shared_object_.SetValue(3);
  EXPECT_EQ(shared_object_.GetValue(), 3);
}
```

Each test using the fixture will have its own fresh instance, ensuring independence and reliability.

## Lifecycle of a Fixture-based Test

1. GoogleTest creates an instance of the fixture class.
2. The constructor runs.
3. `SetUp()` is called.
4. The test body (`TEST_F` function) executes.
5. `TearDown()` is called.
6. The destructor runs.
7. The fixture instance is deleted.

This isolation guarantees tests do not affect each other by sharing state unintentionally.

## Setting Up Shared Resources with `SetUpTestSuite` and `TearDownTestSuite`

To share expensive setup and teardown between all tests in a suite, define static methods:

```cpp
class MyTestFixture : public testing::Test {
 public:
  static void SetUpTestSuite() {
    // Code here runs once before the first test in this suite
  }

  static void TearDownTestSuite() {
    // Code here runs once after the last test in this suite
  }
  ...
};
```

Use these for shared resources that don’t need to be recreated for each individual test.

## Organizing Tests into Suites and Naming Conventions

- Choose test suite names that represent the class or module under test.
- Test names should describe the behavior or condition being tested.
- Avoid underscores in test names to maintain consistency.

Example:

```cpp
TEST_F(DatabaseConnectionTest, OpensConnectionSuccessfully) {
  ...
}
```

## Using Parameterized Fixtures

GoogleTest supports parameterized and typed tests, which let you run the same tests with different input values or types. For these advanced use cases, refer to the [Parameterized & Typed Tests](../api-reference/googletest-core-api/parameterized-and-typed-tests.md) documentation.

## Key Patterns and Best Practices

- Always keep tests isolated by using fixtures or independent test bodies.
- Use `SetUp()` and `TearDown()` to handle per-test preparation and cleanup.
- Resort to `SetUpTestSuite()` and `TearDownTestSuite()` for expensive shared setup.
- Name tests clearly to improve readability and maintainability.
- Avoid relying on shared mutable state across tests.
- Use assertions like `EXPECT_*` and `ASSERT_*` effectively to catch failures without cascading errors.

## Practical Example: Testing a Simple Queue

```cpp
#include <gtest/gtest.h>

class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    queue_.Enqueue(1);
    queue_.Enqueue(2);
  }

  Queue<int> queue_;
};

TEST_F(QueueTest, IsNotEmptyAfterSetup) {
  EXPECT_FALSE(queue_.IsEmpty());
}

TEST_F(QueueTest, DequeueWorks) {
  int* item = queue_.Dequeue();
  ASSERT_NE(item, nullptr);
  EXPECT_EQ(*item, 1);
  delete item;

  item = queue_.Dequeue();
  ASSERT_NE(item, nullptr);
  EXPECT_EQ(*item, 2);
  delete item;

  EXPECT_TRUE(queue_.IsEmpty());
}
```

This example shows a fixture that prepares a test queue and two tests that use it independently.

## Troubleshooting Common Issues

<AccordionGroup title="Common Challenges with Test Cases & Fixtures">
<Accordion title="Tests Failing Due to Shared State">
Shared state across tests can cause flaky or unpredictable failures. Always rely on fresh fixture instances or properly reset state in `TearDown()`. Avoid global or static mutable variables in tests unless managed carefully.
</Accordion>
<Accordion title="Mistaking Constructor for Setup">
Remember that constructors run before `SetUp()`, but exceptions in constructors cause hard failures. Use `SetUp()` to initialize resources that can fail.
</Accordion>
<Accordion title="Tearing Down Resources Improperly">
If test resources are leaked or not cleaned up, check your `TearDown()` implementation. Ensure all allocated memory or files are released.
</Accordion>
<Accordion title="Test Execution Order Reliance">
Tests should not depend on the order of execution. GoogleTest runs tests independently and in arbitrary order.
</Accordion>
</AccordionGroup>

## Summary

Test cases, test suites, and fixtures form the backbone of GoogleTest’s structure for organizing and running C++ tests. By defining tests as `TEST` or within fixtures using `TEST_F`, users gain flexibility to share setup and isolate test runs for reliability. Fixtures empower users to manage resources for multiple tests, ensuring accurate behavior verification with minimum duplication.

For advanced test structuring, including parameterized and typed tests, refer to the related API documentation.

---

<Info>
For a comprehensive understanding, review [Writing Your First C++ Test](../guides/core-testing-workflows/writing-basic-tests.md), [Managing and Organizing Test Suites](../guides/core-testing-workflows/managing-test-suites.md), and [Parameterized & Typed Tests](../api-reference/googletest-core-api/parameterized-and-typed-tests.md).
</Info>

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "docs/reference/testing.md", "range": "1-600"}]} />