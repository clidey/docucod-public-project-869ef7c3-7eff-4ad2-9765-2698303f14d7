---
title: "Parameterized and Typed Tests"
description: "Step-by-step guide and API reference for creating parameterized and type-parameterized tests. Enables efficient test coverage for functions and classes that accept multiple data types or input sets."
---

# Parameterized and Typed Tests

Efficient test coverage is key to robust C++ software, especially when your code must correctly handle multiple input types or sets of data. GoogleTest empowers you with *parameterized* and *type-parameterized* tests, enabling you to write flexible, reusable test logic that runs over different data or types without duplicating code.

This page guides you step-by-step on creating and using parameterized and typed tests, complete with API references and practical examples.

---

## 1. Parameterized (Value-Parameterized) Tests

Value-parameterized tests let you run the same test logic multiple times with different input values.

### Why Use Parameterized Tests?
- Test varying inputs without writing repetitive tests.
- Validate code behavior across different scenarios systematically.

### Getting Started

1. **Define a parameterized test fixture:**
   Derive your fixture class from `testing::TestWithParam<T>`, where `T` is your parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Setup test members here if needed.
};
```

2. **Write test patterns:**
   Use `TEST_P` macro with your fixture to define tests accessing the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(MyFunction(param));
}
```

3. **Instantiate your tests:**
   Use `INSTANTIATE_TEST_SUITE_P` with a name, test suite name, and a parameter generator.

```cpp
INSTANTIATE_TEST_SUITE_P(ExampleValues, FooTest, testing::Values(1, 2, 3));
```

### Common Parameter Generators
| Generator            | Description                                                  |
|----------------------|--------------------------------------------------------------|
| `Range(start, end[, step])` | Generates values from start up to but not including end (step default 1).  |
| `Values(v1, v2, ..., vN)` | Generates the given explicit values.                        |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Generates values from a container or iterator range.        |
| `Bool()`              | Generates `{false, true}`.                                   |
| `Combine(g1, g2, ..., gN)` | Produces all combinations as `std::tuple` from the parameter generators.

### Example: Parameterized Test for a String Function

```cpp
class StringLengthTest : public ::testing::TestWithParam<std::string> {};

TEST_P(StringLengthTest, LengthIsCorrect) {
  EXPECT_EQ(GetParam().size(), MyStringLengthFunction(GetParam()));
}

INSTANTIATE_TEST_SUITE_P(
    SomeStrings, StringLengthTest,
    testing::Values("", "a", "hello"));
```

### Customizing Test Names
The optional fourth parameter of `INSTANTIATE_TEST_SUITE_P` is a name generator:
- It is a callable accepting a `testing::TestParamInfo<T>` and returning a `std::string`.
- Generated suffixes must be non-empty, unique, and contain only alphanumeric characters or underscores.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedStrings, StringLengthTest,
    testing::Values("foo", "bar"),
    [](const testing::TestParamInfo<std::string>& info) {
      std::string name = info.param;
      std::replace(name.begin(), name.end(), ' ', '_');
      return name;
    });
```

### Special Macros
- `TEST_P`: Define parameterized tests.
- `INSTANTIATE_TEST_SUITE_P`: Instantiate and generate tests from parameters.
- `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest)`: Suppresses errors if a parameterized test suite is not instantiated.

---

## 2. Typed Tests

Typed tests allow you to run the same test logic over a predefined list of types.

### Use Cases
- Validate template classes or functions against multiple types.
- Ensure consistent API behavior across types.

### Defining Typed Tests

1. **Define a fixture class template:**

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
  // You can use static members here shared across all tests of the type.
};
```

2. **Specify the type list and associate it with the test suite:**

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write typed test cases using `TYPED_TEST`:**

```cpp
TYPED_TEST(MyTypedTest, SupportsZeroInitialization) {
  TypeParam zero = static_cast<TypeParam>(0);
  EXPECT_EQ(zero, this->value_);
}
```

### Example

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T default_value_ = T();
};

using NumericTypes = ::testing::Types<int, double, long>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultValueIsZero) {
  EXPECT_EQ(this->default_value_, static_cast<TypeParam>(0));
}
```

---

## 3. Type-Parameterized Tests

These are similar to typed tests but more flexible, allowing test patterns to be registered first and instantiated with types later.

### Workflow Overview

1. Define a template fixture.
2. Declare a type-parameterized test suite with `TYPED_TEST_SUITE_P`.
3. Define tests with `TYPED_TEST_P`.
4. Register tests using `REGISTER_TYPED_TEST_SUITE_P`.
5. Instantiate with types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {
  // Fixture code
};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyInitially) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

TYPED_TEST_P(ContainerTest, SizeIncreasesOnInsert) {
  TypeParam container;
  container.insert(container.end(), 'a');
  EXPECT_EQ(container.size(), 1);
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyInitially, SizeIncreasesOnInsert);

using SequenceContainers = ::testing::Types<std::vector<char>, std::list<char>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MySequences, ContainerTest, SequenceContainers);
```

---

## 4. Advanced Parameter Generators and Conversions

GoogleTest offers advanced functionality for building complex parameter sets.

### Combine
Generate all combinations (Cartesian product) of parameter generators.

```cpp
INSTANTIATE_TEST_SUITE_P(
    ComboTest, MyTestSuite,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### ConvertGenerator
Cast or transform generated parameters before passing them to the test.

```cpp
INSTANTIATE_TEST_SUITE_P(
    ConvertedTest, MyTestSuite,
    testing::ConvertGenerator<MyParamType>(
        testing::Combine(testing::Values(1, 2), testing::Bool()),
        [](std::tuple<int, bool> t) {
          return MyParamType{std::get<0>(t), std::get<1>(t)};
        }));
```

### Tips on Use
- Use `ConvertGenerator` when the generator's output type differs from your fixture parameter type.
- Avoid dangling references when converting with lambdas â€” explicitly specify the generated type if needed.

---

## 5. API Summary

| Macro/Function                         | Description                                 |
|--------------------------------------|---------------------------------------------|
| `TEST_P(Fixture, TestName)`           | Defines a parameterized test for a fixture.|
| `INSTANTIATE_TEST_SUITE_P(prefix, Fixture, param_gen[, name_gen])` | Instantiates parameterized tests with generated params and optional custom names.
|
| `TYPED_TEST_SUITE(Fixture, Types)`      | Defines a typed test suite with given types.|
| `TYPED_TEST(Fixture, TestName)`          | Defines a typed test case.
|
| `TYPED_TEST_SUITE_P(Fixture)`            | Declares a type-parameterized test suite.
| `TYPED_TEST_P(Fixture, TestName)`          | Defines a type-parameterized test case.
| `REGISTER_TYPED_TEST_SUITE_P(Fixture, Tests...)` | Registers the typed test cases to the suite.
| `INSTANTIATE_TYPED_TEST_SUITE_P(prefix, Fixture, Types)` | Instantiates the type-parameterized test suite.

---

## 6. Practical Tips and Pitfalls

- **Test Names**: Avoid underscores in test and test suite names; they can cause filtering confusion.
- **Instantiation Timing**: Generators are evaluated at `InitGoogleTest()`, not at instantiation call site.
- **Uninstantiated Tests**: By default, failure occurs if a parameterized test suite is not instantiated. Suppress with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- **Custom Test Names**: Use custom name generators to create human-readable, unique test identifiers.
- **Shared State**: Each parameterized test runs in a fresh fixture instance ensuring test isolation.
- **Iteration Access**: Use `GetParam()` inside a `TEST_P` to access the current parameter.

---

For detailed API and examples, see the following references.

---

## References and Further Reading

- [GoogleTest Primer](primer.md)
- [Value-Parameterized Tests](advanced.md#value-parameterized-tests)
- [Typed and Type-Parameterized Tests](advanced.md#typed-tests)
- [Testing Reference - Parameterized and Typed Tests](reference/testing.md#TEST_P)
- [Parameterized Test Examples](googletest/test/googletest-param-test-test.cc)

---

This powerful testing capability will boost your productivity and test coverage, letting you write concise and expressive tests suited for complex types and wide-ranging inputs.

---

### Diagram: Value-Parameterized Testing Workflow

```mermaid
flowchart TD
  Start([User Defines TEST_P]) --> DefineFixture[Define Fixture derived from TestWithParam<T>]
  DefineFixture --> WriteTestCases[Write TEST_P Test Cases Using GetParam()]
  WriteTestCases --> Instantiate[Instantiate Using INSTANTIATE_TEST_SUITE_P]
  Instantiate --> Generators[Select Parameter Generators (Values, Range, etc.)]
  Generators --> InitGoogleTest[Generator Evaluated during InitGoogleTest()]
  InitGoogleTest --> RegisterTests[Framework Registers Expanded Tests]
  RegisterTests --> RUN_ALL_TESTS[Run All Tests]
  RUN_ALL_TESTS --> Report[Results Reported]
```
