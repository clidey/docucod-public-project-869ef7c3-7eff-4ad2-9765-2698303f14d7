---
title: "Using Built-in Matchers"
description: "Reference the suite of built-in matchers offered for comparing values, validating containers, and composing match expressions. This page guides users towards effective test assertions and highlights key matcher categories for common C++ data and behaviors."
---

# Using Built-in Matchers

GoogleTest provides a rich suite of built-in matchers that help you assert properties of values and function arguments in expressive and readable ways. This page is a comprehensive reference to these matchers, grouped by their typical usage categories. Using these matchers with `EXPECT_THAT` or in mock expectations enables precise, informative assertions that improve both the clarity and resilience of your tests.

---

## Quick Introduction

Matchers are predicates over values. For example, if your test wants to verify that a function returns a positive number, instead of writing:

```cpp
EXPECT_GT(value, 0);
```

You can also write:

```cpp
using ::testing::Gt;
EXPECT_THAT(value, Gt(0));
```

Matchers can be combined together and used in many different contexts, such as:

- Specifying argument expectations on mock methods with `EXPECT_CALL`.
- Verifying return values and intermediate results with `EXPECT_THAT` or `ASSERT_THAT`.

They make test assertions read more naturally and provide clearer failure messages.

---

## Wildcard Matchers

| Matcher | Description |
| :--- | :--- |
| `_` | Matches any value of the correct type. Useful as a wildcard in argument matching. |
| `A<type>()` or `An<type>()` | Matches any value of a specified type. For example, `A<int>()` matches any `int` value. |

---

## Generic Comparison Matchers

These matchers compare arguments to fixed values using common operators.

| Matcher | Meaning |
| :--- | :--- |
| `Eq(value)` or simply `value` | Matches if argument == value.
| `Ne(value)` | Matches if argument != value.
| `Ge(value)` | Matches if argument >= value.
| `Gt(value)` | Matches if argument > value.
| `Le(value)` | Matches if argument <= value.
| `Lt(value)` | Matches if argument < value.
| `IsTrue()` | Matches if argument evaluates to true in a boolean context.
| `IsFalse()` | Matches if argument evaluates to false in a boolean context.
| `IsNull()` | Matches if argument is a null pointer (raw or smart).
| `NotNull()` | Matches if argument is a non-null pointer (raw or smart).
| `Ref(variable)` | Matches if argument is a reference to the specified variable.
| `Optional(m)` | Matches an `optional<>` containing a value matching `m`.
| `VariantWith<T>(m)` | Matches a `variant<>` holding alternative of type `T` with a value matching `m`.
| `DistanceFrom(target, m)` | Matches if the absolute distance between argument and target matches `m`.
| `DistanceFrom(target, get_distance, m)` | Matches if the distance computed by `get_distance(argument, target)` matches `m`.
| `TypedEq<type>(value)` | Matches if argument is of type `type` and equals `value`. Useful for resolving overload ambiguity.

### Usage Notes:
- Use `Ref()` when you want to match a function argument that is a reference to a particular variable.
- Matching `optional<>` types requires the `Optional()` matcher; to check for `nullopt` equality use `Eq(nullopt)`.
- The `DistanceFrom` matcher is useful for testing proximity within a tolerance.

---

## Floating-Point Matchers

Floating-point comparisons are notoriously tricky due to rounding errors. These matchers use ULP-based or absolute error bounds for comparisons:

| Matcher | Description |
| :--- | :--- |
| `DoubleEq(a_double)` | Matches `double` approximately equal to `a_double` (two NaNs are not equal).
| `FloatEq(a_float)` | Matches `float` approximately equal to `a_float`.
| `NanSensitiveDoubleEq(a_double)` | Matches `double` approximately equal to `a_double`, treating two NaNs as equal.
| `NanSensitiveFloatEq(a_float)` | Matches `float` approximately equal to `a_float`, treating two NaNs as equal.
| `IsNan()` | Matches any floating-point value that is NaN.
| `DoubleNear(a_double, max_abs_error)` | Matches `double` within absolute error `max_abs_error` of `a_double`.
| `FloatNear(a_float, max_abs_error)` | Matches `float` within absolute error `max_abs_error`.
| `NanSensitiveDoubleNear(a_double, max_abs_error)` | Nan-sensitive version of DoubleNear.
| `NanSensitiveFloatNear(a_float, max_abs_error)` | Nan-sensitive version of FloatNear.

Use the nan-sensitive variants when your test logic treats two NaNs as equal.

---

## String Matchers

String matchers support matching C strings, `std::string`, wide strings, and their variants. They facilitate substring, prefix/suffix, regex, and case-insensitive matching.

| Matcher | Description |
| :--- | :--- |
| `StrEq(string)` | Matches string exactly equal to `string`.
| `StrNe(string)` | Matches string not equal to `string`.
| `StrCaseEq(string)` | Matches string equal to `string`, ignoring case.
| `StrCaseNe(string)` | Matches string not equal to `string`, ignoring case.
| `HasSubstr(string)` | Matches string containing `string` as a substring.
| `StartsWith(prefix)` | Matches string starting with `prefix`.
| `EndsWith(suffix)` | Matches string ending with `suffix`.
| `IsEmpty()` | Matches empty string.
| `ContainsRegex(string)` | Matches string containing a substring matching the given regular expression.
| `MatchesRegex(string)` | Matches string that fully matches the given regular expression.
| `WhenBase64Unescaped(m)` | Matches a base64-encoded string whose base64-unescaped value matches matcher `m`.

### Notes:
- You can use wide-string overloads if your environment supports `std::wstring`.
- `ContainsRegex()` and `MatchesRegex()` support RE2 or POSIX extended regex syntax depending on the build.

---

## Exception Matchers

These allow you to assert properties of exceptions thrown by callable objects.

| Matcher | Description |
| :--- | :--- |
| `Throws<E>()` | Matches a callable that throws an exception of type `E`.
| `Throws<E>(m)` | Matches a callable that throws an exception of type `E` matching `m`.
| `ThrowsMessage<E>(m)` | Matches a callable throwing `E` with a message matching `m`.

Example:
```cpp
auto argument = [] { throw std::runtime_error("error msg"); };
EXPECT_THAT(argument, Throws<std::runtime_error>());
EXPECT_THAT(argument, Throws<std::runtime_error>(Property(&std::runtime_error::what, Eq("error msg"))));
EXPECT_THAT(argument, ThrowsMessage<std::runtime_error>(HasSubstr("msg")));
```

---

## Container Matchers

Matchers designed for STL-style containers support flexible and expressive assertions about container contents, order, size, and properties.

| Matcher | Description |
| :--- | :--- |
| `BeginEndDistanceIs(m)` | Matches containers where the distance between `begin()` and `end()` matches `m`. Useful for container size without a `size()` method.
| `ContainerEq(container)` | Matches containers equal to the given container, describing mismatches with specific elements.
| `Contains(e)` | Matches containers containing at least one element matching `e`.
| `Contains(e).Times(n)` | Matches containers containing exactly `n` elements matching `e`.
| `Each(e)` | Matches containers where every element matches `e`.
| `ElementsAre(e0, e1, ..., en)` | Matches containers with elements matching those listed in order.
| `ElementsAreArray(...)` | Like `ElementsAre` but takes an array or range of expected elements or matchers.
| `IsEmpty()` | Matches empty containers.
| `IsSubsetOf(...)` | Matches containers that are subsets of given matchers.
| `IsSupersetOf(...)` | Matches containers that are supersets of given matchers.
| `Pointwise(m, container)` | Matches containers element-wise using matcher `m` on pairs from two containers.
| `SizeIs(m)` | Matches containers with size matching `m`.
| `UnorderedElementsAre(e0, e1, ..., en)` | Matches containers having all specified elements, ignoring order.
| `UnorderedElementsAreArray(...)` | Like `UnorderedElementsAre` but with a range.
| `UnorderedPointwise(m, container)` | Like `Pointwise` but ignoring element order.
| `WhenSorted(m)` | Matches containers that match `m` when sorted by `<`.
| `WhenSortedBy(comparator, m)` | Matches containers that match `m` when sorted using the provided comparator.

### Usage Notes:
- `ElementsAre...()` requires matching in the specified order; use `UnorderedElementsAre...()` if order doesn't matter.
- You can nest these matchers for multi-dimensional container matching.
- To match containers passed as pointers, use `Pointee()`.
- `Pair()` and `Key()` help match associative containers like maps.

---

## Member Matchers

These matchers extract and test object members or properties during matching.

| Matcher | Description |
| :--- | :--- |
| `Field(&Class::field, m)` | Matches an object whose `field` matches matcher `m`. Works with pointers as well.
| `Field(field_name, &Class::field, m)` | Better error messages with explicit field name.
| `Property(&Class::property, m)` | Matches an object where the zero-arg const method `property()` returns a value matching `m`.
| `Property(property_name, &Class::property, m)` | Property matcher with explicit name.
| `Key(e)` | Matches `std::pair` whose `first` field matches `e`. Useful in map-like containers.
| `Pair(m1, m2)` | Matches `std::pair` with `first` matching `m1` and `second` matching `m2`.
| `FieldsAre(m...)` | Matches tuple-like or aggregate objects with matchers applied per field.

### Notes:
- `Property()` should be used only on member functions you own due to fragility of pointer to member functions.
- Combine these with `AllOf()` or other composite matchers for complex member validations.

---

## Matching the Result of a Callable

- `ResultOf(f, m)` matches values where `f(value)` matches matcher `m`. `f` can be a function pointer, functor, or lambda.
- Optionally, a description can be provided for better error messages.

---

## Pointer Matchers

| Matcher | Description |
| :--- | :--- |
| `Address(m)` | Matches if `std::addressof(value)` satisfies matcher `m`.
| `Pointee(m)` | Matches a pointer (raw or smart) pointing to a value that matches `m`. Null pointers never match.
| `Pointer(m)` | Matches a pointer itself, regardless of pointee type, using matcher `m` on the raw pointer.
| `WhenDynamicCastTo<T>(m)` | Matches pointer or reference cast to `T` via `dynamic_cast` matching `m`. Null on cast failure.

---

## Multi-argument Matchers

Often used with `.With()` in `EXPECT_CALL` to match multiple arguments as a tuple:

| Matcher | Description |
| :--- | :--- |
| `Eq()`, `Ge()`, `Gt()`, `Le()`, `Lt()`, `Ne()` | Match 2-tuples where the first field relates to the second field accordingly.
| `AllArgs(m)` | Alias for matcher `m` applied to all arguments.
| `Args<N1,N2,...>(m)` | Matches a tuple of selected argument indices.

---

## Composite Matchers

You can combine matchers logically:

| Matcher | Description |
| :--- | :--- |
| `AllOf(m1, m2, ..., mn)` | Matches if all sub-matchers match.
| `AllOfArray(container)` | Like `AllOf` but from a range.
| `AnyOf(m1, m2, ..., mn)` | Matches if any sub-matcher matches.
| `AnyOfArray(container)` | Like `AnyOf` but from a range.
| `Not(m)` | Matches if `m` does not match.
| `Conditional(condition, m1, m2)` | Matches `m1` if `condition` is true, `m2` otherwise.

Combine for powerful logical assertions.

---

## Adapter Matchers

| Matcher | Description |
| :--- | :--- |
| `MatcherCast<T>(m)` | Casts matcher `m` to `Matcher<T>`. Unsafe if types mismatch.
| `SafeMatcherCast<T>(m)` | Casts with compile-time checks for safety.
| `Truly(predicate)` | Matches values where the predicate returns true.

---

## Using Matchers as Predicates

Matchers can be used as unary predicates in algorithms via `Matches(m)`, where `m` is a matcher:

```cpp
std::vector<int> v = {1,2,3,4,5};
int count = std::count_if(v.begin(), v.end(), Matches(Ge(3)));
EXPECT_EQ(count, 3);
```

---

## Defining Custom Matchers

Use the `MATCHER` macros for quick custom matchers:

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }
```

More advanced matchers can implement the MatcherInterface directly.

---

## Examples

### Simple Positive Check

```cpp
EXPECT_THAT(value, Gt(0));
EXPECT_THAT(ptr, NotNull());
EXPECT_THAT(str, StartsWith("Test"));
```

### Container Content Check

```cpp
EXPECT_THAT(v, ElementsAre(1, Gt(2), 5));
EXPECT_THAT(map, Contains(Pair("key", 42)));
EXPECT_THAT(set, IsSupersetOf({1, 2}));
```

### Complex Multi-argument Matcher with With Clause

```cpp
EXPECT_CALL(mock, Func(_, _))
    .With(Args<0, 1>(Lt())); // first arg < second arg
```

### Using Custom Matcher

```cpp
MATCHER(IsDivisibleBy3, "") { return arg % 3 == 0; }
EXPECT_CALL(mock, Compute(IsDivisibleBy3()));
```

---

## Tips and Best Practices

- When matching pointers, use `NotNull()` or `IsNull()` rather than raw checks.
- Use `ElementsAre` or `UnorderedElementsAre` to write clear container content expectations.
- Combine matchers with `AllOf`, `AnyOf`, and `Not` for complex assertions.
- Prefer `EXPECT_THAT` with matchers over legacy `EXPECT_EQ` for expressive failures.
- Control mock call argument matching with `.With()` and multi-argument matchers.
- Use `SafeMatcherCast` when matching arguments with type conversions.

---

## Troubleshooting

- If matchers don't compile, verify argument types and use `TypedEq<T>()` to resolve overload ambiguity.
- Beware of null pointers when using `Pointee(m)`; null always fails.
- For floating-point assertions, avoid `EXPECT_EQ` directly; use floating-point matchers instead.
- When `EXPECT_THAT` silently passes or fails, check for implicit conversions that may match unexpectedly.

---

## Related Documentation

- [Assertions Reference](../reference/assertions.md) — learn how to use `EXPECT_THAT` with matching.
- [Matchers Reference](../reference/matchers.md) — official listing and details of all matchers.
- [gMock Cookbook](../gmock_cook_book.md) — recipes and best practices for mocking with matchers.
- [Defining Mock Methods and Classes](../api-reference/core-mocking-api/mock-methods-and-classes.md).
- [Setting Call Expectations and Cardinalities](../api-reference/core-mocking-api/call-expectations-and-cardinalities.md).

---

Mastering built-in matchers empowers you to write robust, readable, and maintainable tests. Begin by using simple matchers to validate argument values or container contents, then progressively incorporate composite and member matchers to capture complex conditions precisely.

---