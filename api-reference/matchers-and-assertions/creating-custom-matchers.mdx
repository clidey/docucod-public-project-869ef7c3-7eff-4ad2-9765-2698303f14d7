---
title: "Creating Custom Matchers"
description: "Learn to implement your own matchers for domain-specific verification needs. This page covers custom matcher construction principles, integration strategy, and common pitfalls when extending the matcher ecosystem in your tests."
---

# Creating Custom Matchers

When working with GoogleMock (gMock), you may encounter situations where the built-in matchers do not express the specific constraints or properties you want to verify. **Creating custom matchers** allows you to extend GoogleMock’s capabilities to fit your domain-specific needs with precision and clarity.

This page guides you through the concepts, best practices, and practical steps for defining your own matchers in gMock, empowering you to write tests that are both expressive and maintainable.

---

## Why Create Custom Matchers?

Built-in matchers cover a broad range of common use cases, but sometimes:

- You need to match properties or behaviors unique to your application domain.
- The logic you want to verify involves combining multiple aspects or fields of an object.
- You want richer, more descriptive failure messages to improve test diagnostics.

By writing custom matchers, you gain control over *what* is matched and *how* it is described.

---

## Core Principles of Custom Matcher Implementation

When creating custom matchers, focus on **user intent and value** rather than internal implementation details. Your matcher should clearly answer these questions for test writers:

- What property or condition does it check?
- When does a match succeed or fail?
- How will the failure message help diagnose the problem?

### Essential Matcher Interface

A matcher in gMock must implement these operations:

- **Match and Explain:** Determines whether a given actual value satisfies the matcher, optionally providing additional explanation.
- **Describe:** Offers a human-readable description of the matcher's condition.
- **Describe Negation:** Describes the logical negation of the matcher condition.

### Recommended Strategies

- Use the [MATCHER](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers) and related macros (`MATCHER_P`, `MATCHER_P2`, ..., `MATCHER_P10`) for concise matcher creation.
- When advanced control is needed, implement the matcher interface classes directly.
- Parameterize matchers to generalize behavior.
- Provide meaningful descriptions that adapt to negation for clear test output.

---

## Writing a Basic Custom Matcher

Use the `MATCHER` macro to define a simple matcher that is concise and easy to maintain.

### Example: Checking if an Integer Is Divisible by 7

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}
```

Use it like this:

```cpp
EXPECT_CALL(mock_object, ProcessValue(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

If the match fails, the failure message will read:

```text
Value of: value
Expected: is divisible by 7
  Actual: 27
```

### Enhancing the Failure Message

Add an explanation to help users understand why the match failed.

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

Resulting message on failure:

```text
Value of: value
Expected: is divisible by 7
  Actual: 27 (the remainder is 6)
```

---

## Writing Parameterized Custom Matchers

If your matcher requires parameters, use `MATCHER_P`, `MATCHER_P2`, ..., up to `MATCHER_P10`.

### Example: Matcher for Absolute Value

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}
```

Usage:

```cpp
EXPECT_THAT(my_object.GetValue(), HasAbsoluteValue(10));
```

### Custom Descriptions with Parameters

You can provide a description string that uses parameters and negation to improve messages:

```cpp
MATCHER_P2(InClosedRange, low, hi,
           std::string(negation ? "isn't" : "is") + " in range [" +
           testing::PrintToString(low) + ", " + testing::PrintToString(hi) + "]") {
  return low <= arg && arg <= hi;
}
```

Failures show descriptions like:

```
Expected: is in range [4, 6]

or

Expected: isn't in range [2, 4]
```

---

## Advanced Custom Matchers Implementation

For full control over matcher behavior, define a matcher class implementing the following methods:

- `bool MatchAndExplain(const TType& value, std::ostream* listener) const;` — core matching logic with optional textual explanation.
- `void DescribeTo(std::ostream* os) const;` — description of the match condition.
- `void DescribeNegationTo(std::ostream* os) const;` — description of negation condition.

### Example: DivisibleBy Matcher Class

```cpp
class DivisibleByMatcher {
 public:
  using is_gtest_matcher = void;  // Marker for gMock

  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  template <typename T>
  bool MatchAndExplain(const T& n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os) *os << "which is " << (n % divisor_) << " modulo " << divisor_;
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }

 private:
  int divisor_;
};

::testing::Matcher<int> DivisibleBy(int n) {
  return ::testing::MakePolymorphicMatcher(DivisibleByMatcher(n));
}
```

This can be used polymorphically:

```cpp
EXPECT_THAT(21, DivisibleBy(7));
EXPECT_THAT(22, ::testing::Not(DivisibleBy(7)));
```

---

## Integrating Custom Matchers in Tests

Once defined, use custom matchers wherever GoogleMock expects matchers:

- In `EXPECT_CALL` and `ON_CALL` to specify argument expectations.
- In `EXPECT_THAT` assertions for expressive condition checking.

Example: 

```cpp
EXPECT_CALL(mock, ProcessValue(HasAbsoluteValue(10)));
EXPECT_THAT(result, DivisibleBy(3));
```

---

## Best Practices & Tips

- **Use Matchers to Communicate Intent:** Name your matchers clearly and write expressive descriptions.
- **Keep Matchers Pure:** Avoid side effects inside matchers; they may be called multiple times.
- **Leverage Polymorphic Matchers:** Write matchers that work across multiple types if possible.
- **Add Detailed Explanations:** Use `result_listener` to provide helpful explanation on failures.
- **Combine Matchers:** Use built-in combinators like `AllOf()`, `AnyOf()`, `Not()` with your custom matchers for powerful expressions.
- **Use Parameterized Macros:** They simplify creation, reduce boilerplate, and produce better error messages.
- **Document Clearly:** Include comments and examples for your custom matchers to aid future maintainers.

---

## Common Pitfalls

- **Ignoring Matching Context:** The matched value’s type is deduced by usage context; ensure your matcher is compatible.
- **Not Handling Negations Correctly:** Provide comprehensive descriptions for both positive and negative cases.
- **Side Effects and Non-Purity:** Matchers are expected to be idempotent and free of side effects.
- **Unintended Costs in Descriptions:** Keep description operations lightweight to avoid slowing down test runs.

---

## Further Reading and Resources

- [MATCHER Macro Recipes in gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#NewMatchers)
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html#matchers)
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html)

For examples and deeper dives into matcher internals, see the [gMock Matcher Tests](https://github.com/google/googletest/tree/main/googlemock/test) and the source code header `gmock-matchers.h`.

---

Explore this page alongside documentation on [Using Built-in Matchers](../using-built-in-matchers.md) and [Defining Mock Methods and Classes](../mock-methods-and-classes.md) to master test expressiveness.


---

## Summary
Creating custom matchers in GoogleMock allows you to capture domain-specific testing conditions with expressive syntax and detailed failure diagnostics. Using macros like `MATCHER` and `MATCHER_P`, you can swiftly define matchers that integrate seamlessly with existing test flows. For advanced control, implementing the matcher interface classes directly provides powerful extensibility.

This page covered the motivation for custom matchers, simple and parameterized matcher creation, interface implementation, integration techniques, best practices, and gotchas, with references to deeper resources.

---