---
title: "Custom and User-Defined Assertions"
description: "Shows how to create new assertions and matchers tailored to specific domains and requirements, with guidance on extension points and interoperability."
---

# Custom and User-Defined Assertions

This documentation guides you through creating **custom assertions and matchers** in GoogleTest and GoogleMock tailored to your domain-specific testing needs. Building on the foundation of built-in assertions and matchers, you will learn how to extend their capabilities by writing expressive, maintainable, and reusable custom assertions.

---

## Why Create Custom Assertions and Matchers?

GoogleTest offers a rich set of built-in assertions for common testing scenarios, but sometimes these are insufficient when:

- Your code involves domain-specific validation logic.
- You want clearer, more descriptive failure messages.
- You need to reuse complex verification logic across many tests.
- You want to integrate seamlessly with GoogleMock expectations.

Custom assertions and matchers help you write tests that communicate intent more clearly, improve debuggability, and reduce boilerplate.

---

## Overview of Custom Assertions

Assertions in GoogleTest are macros that check conditions and report test failures. While you can use built-in assertions like `EXPECT_TRUE`, `EXPECT_EQ`, and `ASSERT_THROW`, you can extend the framework by writing:

- **Custom assertion macros**
- **Custom matchers** (which integrate with `EXPECT_THAT`)

The recommended approach is to write custom matchers that work naturally with `EXPECT_THAT` and can be combined with other matchers.

---

## Writing Custom Assertion Macros

At its simplest, a custom assertion macro wraps a Boolean condition check and emits appropriate failure messages.

### Simple Custom Assertion Macro Example

```cpp
#define EXPECT_IS_EVEN(val) \
  EXPECT_PRED_FORMAT1(CheckIsEven, val)

::testing::AssertionResult CheckIsEven(const char* expr, int val) {
  if (val % 2 == 0) {
    return ::testing::AssertionSuccess();
  } else {
    return ::testing::AssertionFailure() << expr << " is not even, got " << val;
  }
}
```

Usage:

```cpp
EXPECT_IS_EVEN(x);
```

This outputs clear failure information, including the expression and the actual value.

### Advantages of Using Predicate-Format Assertions

They allow more informative failure messages than a simple true/false.

---

## Writing New Matchers Quickly

GoogleMock's matcher framework is highly extensible. A matcher can be:

- **Monomorphic** — matches a single type
- **Polymorphic** — matches multiple types, adapting automatically

### Using MATCHER Macros

GoogleMock provides `MATCHER`, `MATCHER_P`, `MATCHER_P2`, ... macros to quickly create custom matchers.

#### Basic MATCHER Example

```cpp
MATCHER(IsDivisibleBy7, "Checks if a number is divisible by 7") {
  return (arg % 7) == 0;
}
```

Usage:

```cpp
EXPECT_THAT(number, IsDivisibleBy7());
```

If the assertion fails, GoogleMock prints a message like:

```
Value of: number
Expected: is divisible by 7
  Actual: 23
```

#### Adding Custom Failure Messages

You can provide detailed feedback by streaming to the listener:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "has remainder " << (arg % 7);
  return false;
}
```

#### Parameterized Matcher Example

```cpp
MATCHER_P(InRange, range, "Checks if a value is within the specified range") {
  return arg >= range.first && arg <= range.second;
}
```

Usage:

```cpp
EXPECT_THAT(value, InRange(std::make_pair(5, 10)));
```

This generates failure messages that include the range parameters.

---

## Writing Custom Matcher Classes

For complex matching behavior beyond `MATCHER` macros, implement a matcher class.

### Minimal Matcher Interface Requirements

Your class must:

- Declare `using is_gtest_matcher = void;`
- Implement:
  - `bool MatchAndExplain(value_type arg, std::ostream* listener) const;`
  - `void DescribeTo(std::ostream* os) const;`
  - `void DescribeNegationTo(std::ostream* os) const;`

### Example Matcher Class

```cpp
class EvenMatcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    if ((n % 2) == 0) return true;
    if (os) *os << "which is not even";
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is an even number";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not an even number";
  }
};

::testing::Matcher<int> IsEven() {
  return ::testing::Matcher<int>(new ::testing::MatcherInterfaceImpl<EvenMatcher>(EvenMatcher()));
}
```

Usage:

```cpp
EXPECT_THAT(x, IsEven());
```

This approach offers maximal flexibility and type safety.

---

## Writing Polymorphic Matchers

To support matching multiple types, implement `MatchAndExplain` as a template:

```cpp
class NotNullMatcher {
 public:
  using is_gtest_matcher = void;

  template <typename T>
  bool MatchAndExplain(const T* p, std::ostream* /* os */) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }
};

PolymorphicMatcher<NotNullMatcher> NotNull() {
  return MakePolymorphicMatcher(NotNullMatcher());
}
```

You can then use `NotNull()` to match any pointer type.

---

## Composite Matchers

You can define matchers that take other matchers as parameters and explain their results.

For example, `AllOf(m1, m2)` matches values satisfying both `m1` and `m2`.

You can create custom composite matchers by storing sub-matchers and invoking their checks and descriptions appropriately.

---

## Testing with Custom Assertions and Matchers

Use your new custom assertions and matchers in tests as follows:

```cpp
EXPECT_THAT(value, IsEven());
EXPECT_THAT(container, ElementsAre(IsDivisibleBy7(), _));
```

When a matcher fails, GoogleTest prints detailed and descriptive messages to aid debugging.

---

## Common Pitfalls and Best Practices

- **Matchers should be pure functions.** Avoid side effects in your matcher implementation to prevent flaky tests.
- **Describe failure clearly.** Use `DescriptionTo` and streaming to provide helpful failure messages.
- **Use `EXPECT_PRED_FORMAT` macros** for assertions that need custom failure messages.
- **Reuse matchers** by assigning them to variables if they are complex.
- **Use polymorphic matchers** whenever possible to maximize compatibility.

---

## Troubleshooting

| Issue | Solution |
|---|---|
| No detailed failure message | Implement streaming to `result_listener` in custom matcher.
| Unexpected matcher matching behavior | Check matcher purity and argument types.
| Compilation errors with complex matchers | Use `MATCHER_P` macros or implement matcher classes with explicit typing.

---

## Related Documentation

- [Matchers Reference](reference/matchers.md) — Detailed built-in matchers and usage.
- [gMock Cookbook](docs/gmock_cook_book.md) — Recipes including custom matchers and actions.
- [Assertions Reference](docs/reference/assertions.md) — Built-in assertion macros.
- [Mocking Reference](docs/reference/mocking.md) — Using mocks with `EXPECT_CALL` and matchers.


---

## Summary

Custom assertions and matchers empower you to validate your code with domain-specific, expressive checks and improved failure diagnostics. Starting from simple predicate assertion macros to advanced polymorphic matcher classes, GoogleTest and GoogleMock provide flexible extension points to meet complex testing needs.

---