---
title: "Matchers: Argument and Value Matching"
description: "Reference for built-in and custom matchers—tools for flexible argument verification in expectations and assertions. Documents matcher syntax, composition, and advanced matching techniques."
---

# Matchers: Argument and Value Matching

Matchers are the essential tools that make GoogleMock flexible and powerful by allowing you to specify how to verify arguments in mock methods and expectations. They enable you to express complex conditions on the values passed to your mock functions, ensuring precise control over your tests.

---

## What is a Matcher?

A **matcher** is a predicate or condition that is applied to *a single function argument* to check whether the argument meets the specified requirements. Matchers are used in:

- `EXPECT_CALL(mock_object, method(matchers...))` to specify expectations.
- `ON_CALL(mock_object, method(matchers...))` to specify default behaviors.
- `EXPECT_THAT(value, matcher)` or `ASSERT_THAT(value, matcher)` to assert properties about values directly.

Matchers compare the actual input with expected values or properties without requiring you to write verbose custom checks.

## Basic Usage

You use matchers inside mock method calls to specify what arguments you expect or allow. For example:

```cpp
EXPECT_CALL(foo, Bar(42, "hello"));
```

This expects `foo.Bar` to be called with exactly `42` and "hello" as arguments.

Sometimes you want to be more flexible, so you use built-in matchers:

```cpp
using ::testing::_;  // Matches any value
EXPECT_CALL(foo, Bar(_, "hello"));  // First argument can be anything
```

### The Wildcard Matcher `_`

`_` matches any argument of the correct type, providing the most flexibility.

### Specifying Explicit Matchers

You can use a variety of matchers to define detailed conditions, e.g., `Eq(value)`, `Gt(value)`, `Lt(value)`, `HasSubstr(str)`, and many more.

## Composition and Parameterization

Matchers can be combined to express complex logic:

- **Logical combinators:** `AllOf(m1, m2, ...)` requires all matchers to match.
- **Logical OR:** `AnyOf(m1, m2, ...)` requires any of the matchers to match.
- **Negation:** `Not(m)` matches when `m` does not.

You can also use parameterized matchers:

```cpp
MATCHER_P(IsDivisibleBy, n, "") { return (arg % n) == 0; }
EXPECT_CALL(foo, Bar(IsDivisibleBy(7)));
```

## Categories of Built-in Matchers

GoogleMock provides a comprehensive set of built-in matchers, categorized as follows:

### Generic Comparison Matchers

| Matcher          | Matches if...                                          |
|------------------|--------------------------------------------------------|
| `Eq(value)` or `value` | argument == value                                      |
| `Ne(value)`       | argument != value                                      |
| `Gt(value)`       | argument > value                                       |
| `Ge(value)`       | argument >= value                                      |
| `Lt(value)`       | argument < value                                       |
| `Le(value)`       | argument <= value                                      |
| `IsTrue()`        | argument is convertible to `true`                     |
| `IsFalse()`       | argument is convertible to `false`                    |
| `Ref(variable)`   | argument is a reference to `variable`                 |
| `DistanceFrom(target, m)` | argument’s distance from target matches matcher `m`          |

### Pointer Matchers

| Matcher                    | Matches if...                                  |
|----------------------------|----------------------------------------------|
| `IsNull()`                 | argument is a null raw or smart pointer      |
| `NotNull()`                | argument is a non-null raw or smart pointer  |
| `Pointee(m)`               | argument points to a value matching matcher `m`  |
| `Pointer(m)`               | argument (pointer or smart pointer) matches matcher `m`  |
| `Address(m)`               | address of argument matches matcher `m`      |
| `WhenDynamicCastTo<T>(m)` | `dynamic_cast<T>(argument)` matches matcher `m`  |

### Container Matchers

You can match STL-style containers flexibly:

| Matcher                    | Description                              |
|----------------------------|------------------------------------------|
| `ElementsAre(e0, e1, ...)` | container elements match exactly in order |
| `UnorderedElementsAre(e0, e1, ...)` | elements match ignoring order          |
| `ElementsAreArray(...)`    | match from array or container of expected elements |
| `UnorderedElementsAreArray(...)` | unordered match from array/container          |
| `Contains(e)`              | container contains element matching `e`   |
| `Each(e)`                  | all elements match `e`                      |
| `SizeIs(m)`                | container size matches matcher `m`          |
| `IsEmpty()`                | container is empty                          |
| `IsSubsetOf(...)`          | container is subset of expected elements   |
| `IsSupersetOf(...)`        | container is superset of expected elements |
| `WhenSorted(m)`            | container matches `m` after sorting        |
| `WhenSortedBy(comparator, m)` | container matches `m` after sorting with comparator |
| `Pointwise(m, container)`  | per-element paired match with another container |
| `UnorderedPointwise(m, container)` | same as Pointwise ignoring order         |

### String Matchers

Useful for flexible string comparison:

| Matcher                 | Description                               |
|-------------------------|-------------------------------------------|
| `StrEq(s)`              | string equal to `s`                       |
| `StrNe(s)`              | string not equal to `s`                   |
| `StrCaseEq(s)`          | string equal to `s` ignoring case        |
| `StrCaseNe(s)`          | string not equal to `s` ignoring case    |
| `HasSubstr(s)`          | string contains substring `s`             |
| `StartsWith(prefix)`    | string starts with `prefix`                |
| `EndsWith(suffix)`      | string ends with `suffix`                  |
| `MatchesRegex(regex)`   | string exactly matches regex               |
| `ContainsRegex(regex)`  | string contains matching substring regex  |
| `IsEmpty()`             | string is empty                            |
| `WhenBase64Unescaped(m)`| matches base64-encoded string whose unescaped form matches matcher `m` |

### Exception Matchers

Used to verify thrown exceptions in callables:

| Matcher                    | Description                              |
|----------------------------|------------------------------------------|
| `Throws<E>()`             | callable throws exception of type `E`    |
| `Throws<E>(m)`            | callable throws exception `E` matching `m` |
| `ThrowsMessage<E>(m)`     | callable throws exception `E` with message matching `m` |

## Using Matchers for Multi-Argument Matching

Match expressions to arguments are per-argument. But sometimes matching the combination of arguments matters. Use:

- `.With(m)` in `EXPECT_CALL` or `ON_CALL` to apply a matcher to the argument tuple as a whole.
- `AllArgs(m)` synonym for `m` when matching entire tuple.
- `Args<N1, N2, ..., Nk>(m)` matcher to match selected arguments as a tuple.

Multi-argument matchers must accept `std::tuple` of argument types.

Example:

```cpp
EXPECT_CALL(foo, Bar(_, _))
    .With(Lt());  // first argument less than second
```

## Defining Custom Matchers

GoogleMock makes defining your own matchers easy:

- Use the `MATCHER(name, description) { ... }` macro for simple matchers.
- Use `MATCHER_P`, `MATCHER_P2`, etc. macros to define parameterized matchers.
- Implement a matcher class with `MatchAndExplain`, `DescribeTo`, and `DescribeNegationTo` methods for advanced behaviors.

Custom matchers allow you to express domain-specific logic clearly and elegantly.

Example of a simple matcher:

```cpp
MATCHER(IsDivisibleBy7, "") {
  return (arg % 7) == 0;
}

EXPECT_CALL(mock, Func(IsDivisibleBy7()));
```

## Practical Tips & Best Practices

- Use `_` for wildcards when argument values are not important.
- Combine matchers to express compound conditions clearly.
- Use `Ref(variable)` to match arguments that must be the exact variable (by reference).
- For containers, prefer expressive container matchers to manual looping.
- When matching string arguments, consider case- and substring-sensitive matchers.
- Use `.With()` for complex predicates across multiple arguments.
- Avoid over-specifying tests; matchers allow you to relax expectations without losing precision.
- Remember that matchers must be pure functions without side effects.

## Troubleshooting Common Matcher Issues

- **Compiler errors on ambiguous call**: explicitly qualify overloads or specify parameter types using `TypedEq<T>(value)`.
- **Unexpected matcher behavior**: check that you're not unintentionally matching pointers by address instead of by value. Use string matchers for C strings.
- **Uninteresting calls warnings**: if you don't care about a call, avoid `EXPECT_CALL` and use `ON_CALL` to specify defaults.

## Working with Move-Only Types

Matchers support move-only types (like `std::unique_ptr`) but some built-in actions or matchers might not compile. Use lambdas or functors for actions involving move-only types.

## Matchers and Assertions

Use `EXPECT_THAT(value, matcher)` or `ASSERT_THAT(value, matcher)` macros to assert conditions in tests. Failures provide descriptive messages including the matched-value and matcher description.

Example:

```cpp
EXPECT_THAT(my_string, StartsWith("Hello"));
EXPECT_THAT(vector<int>{1, 2, 3}, ElementsAre(1, 2, 3));
```

## Summary

Matchers form the heart of GoogleMock's argument verification mechanism. They enable flexible, readable, and maintainable specifications for mock behavior and validation. By combining built-in and custom matchers, you can precisely articulate the behavior your code under test should perform.

---

### Code Example: Using Matchers in EXPECT_CALL

```cpp
using ::testing::_;  // Wildcard matcher
using ::testing::Gt; // Greater than
using ::testing::HasSubstr;

class MockFoo {
public:
  MOCK_METHOD(void, Bar, (int x, const std::string& y), ());
};

MockFoo mock;

EXPECT_CALL(mock, Bar(Gt(5), HasSubstr("test")));

mock.Bar(10, "this is a test");  // Matches expectation
mock.Bar(3, "this is a test");   // Fails expectation
```

### Code Example: Custom Matcher Definition

```cpp
MATCHER_P(IsWithinRange, range, "Checks if argument is within +/- range") {
  return arg >= -range && arg <= range;
}

EXPECT_CALL(mock, Bar(IsWithinRange(10)));
```

---

For deeper guidance, explore the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) and [Matchers Reference](../api-reference/advanced-behaviors/argument-matchers.html) for many more matchers and examples.

---

## Related Documentation

- [Mocking Reference](../api-reference/core-apis/mocking-and-methods.html) — overview of mock methods and expectations
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — recipes and examples for mocking and matchers
- [Assertions Reference](../api-reference/core-apis/assertions.md) — using assertions with matchers
- [Matchers Reference](matchers.md) — comprehensive reference of pre-defined matchers

---