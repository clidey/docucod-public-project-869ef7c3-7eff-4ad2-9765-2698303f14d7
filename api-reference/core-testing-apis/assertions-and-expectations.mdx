---
title: "Assertions and Expectations"
description: "Comprehensive guide to the available assertion macros, including ASSERT_* and EXPECT_*, to check conditions, compare values, and report results within tests. Explains the difference between fatal and non-fatal failures, with illustrative code samples."
---

# Assertions and Expectations

This page offers a comprehensive guide to the assertion macros available in GoogleTest, focusing on the `ASSERT_*` and `EXPECT_*` families. These macros allow you to verify conditions, compare values, and report outcomes in your tests clearly and effectively. Understanding the difference between fatal and non-fatal failures, along with practical code examples, will empower you to write robust and maintainable tests.

---

## Understanding Assertions in GoogleTest

Assertions are the fundamental mechanism to validate code behavior during tests. Each assertion checks a condition and reports success or failure accordingly.

- **`EXPECT_*` macros** generate *non-fatal* failures: these failures report errors but allow the rest of the test function to continue executing.
- **`ASSERT_*` macros** generate *fatal* failures: these failures immediately abort the current function, halting further execution within the test case.

This distinction is crucial for managing test flow and isolating failure impact.

<Callout title="Tip">
Use `EXPECT_*` when subsequent checks are still meaningful after a failure, and use `ASSERT_*` when failing the check should immediately stop the current test to avoid misleading results.
</Callout>

### Streaming Custom Failure Messages

Every assertion macro supports streaming user-defined messages using the `<<` operator. This allows adding clear, contextual explanations for why an assertion might fail.

```cpp
EXPECT_TRUE(is_valid) << "Value is not valid as expected";
```

Use this facility to improve test diagnostics and debuggability.

---

## Categories of Assertions

GoogleTest assertions cover a wide variety of test needs, grouped by purpose.

### 1. Explicit Success and Failure

- `SUCCEED()` — generates explicit success (mostly for documentation; does not force test pass).
- `FAIL()` — generates fatal failure, aborting the current test function.
- `ADD_FAILURE()` / `ADD_FAILURE_AT(file, line)` — generate non-fatal failures manually at your discretion.

```cpp
if (unexpectedCondition) {
  FAIL() << "Unexpected condition encountered";
}
```

### 2. Boolean Conditions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)` — checks that condition is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)` — checks that condition is false.

### 3. Binary Comparison

Compare two values using C++ operators, with helpful output on failure.

| Assertion      | Checks                              | Usage Notes                              |
|:--------------|:----------------------------------|:---------------------------------------|
| `EXPECT_EQ` / `ASSERT_EQ` | `val1 == val2`                    | Use `EXPECT_STREQ` for C strings       |
| `EXPECT_NE` / `ASSERT_NE` | `val1 != val2`                    | Use `EXPECT_STRNE` for C strings       |
| `EXPECT_LT` / `ASSERT_LT` | `val1 < val2`                     |                                        |
| `EXPECT_LE` / `ASSERT_LE` | `val1 <= val2`                    |                                        |
| `EXPECT_GT` / `ASSERT_GT` | `val1 > val2`                     |                                        |
| `EXPECT_GE` / `ASSERT_GE` | `val1 >= val2`                    |                                        |

**Example:**

```cpp
EXPECT_EQ(result, 42) << "Result should be 42";
```

### 4. String Comparison

Specialized macros to compare C-style strings, including case-insensitive variants.

| Assertion           | Description                       |
|:--------------------|:--------------------------------|
| `EXPECT_STREQ`      | Compares two C strings for equality  |
| `EXPECT_STRNE`      | Checks two C strings are different    |
| `EXPECT_STRCASEEQ`  | Case-insensitive equality             |
| `EXPECT_STRCASENE`  | Case-insensitive inequality           |

### 5. Floating-Point Comparison

Due to rounding errors, floating-point comparisons require fuzzy equality.

| Assertion         | Description                                                      |
|:------------------|:----------------------------------------------------------------|
| `EXPECT_FLOAT_EQ` | Checks two `float`s differ by at most 4 ULPs                    |
| `EXPECT_DOUBLE_EQ`| Checks two `double`s differ by at most 4 ULPs                   |
| `EXPECT_NEAR`     | Checks absolute difference between values within a given error |

### 6. Exception Assertions

Verify that code throws or does not throw exceptions.

| Assertion             | Description                        |
|----------------------|----------------------------------|
| `EXPECT_THROW`        | Expects statement to throw specified exception type |
| `EXPECT_ANY_THROW`    | Expects statement to throw any exception           |
| `EXPECT_NO_THROW`     | Expects statement to NOT throw any exception       |

*Code blocks can be used inside assertion macros for compound statements.*

### 7. Predicate Assertions

Enable complex predicates returning `bool` with better failure messages.

- `EXPECT_PRED1(pred, val1)` ... up to `EXPECT_PRED5(pred, val1, ..., val5)`
- `EXPECT_PRED_FORMAT*` allow custom failure message formatting.

```cpp
bool IsPrime(int n);
EXPECT_PRED1(IsPrime, value);
```

### 8. HRESULT Assertions (Windows only)

Assertions designed to verify `HRESULT` values for success or failure.

| Assertion                | Description                            |
| ----------------------- |--------------------------------------|
| `EXPECT_HRESULT_SUCCEEDED` | Checks HRESULT indicates success     |
| `EXPECT_HRESULT_FAILED`    | Checks HRESULT indicates failure     |

### 9. Death Assertions

Verify code terminates the process as expected.

| Assertion           | Description                                             |
|---------------------|---------------------------------------------------------|
| `EXPECT_DEATH`      | Expects code to terminate with matching stderr output   |
| `EXPECT_DEBUG_DEATH`| Same as `EXPECT_DEATH` in debug mode; otherwise executes code normally |
| `EXPECT_EXIT`       | Verifies code exits with specified status and output   |

*Death test code runs in a child process and supports regex matching on output.*

---

## Fatal vs Non-Fatal Failures: Choosing the Right Assertion

### Scenario:
You want to verify a pointer is not `nullptr` before dereferencing.

| Choice                     | Outcome                                         |
| -------------------------- | ------------------------------------------------|
| Use `EXPECT_NE(ptr, nullptr)`    | Test logs failure but continues, possibly crashing on dereference later|
| Use `ASSERT_NE(ptr, nullptr)`    | Test fails immediately, preventing invalid access|

### Guidance:
- Use `ASSERT_*` macros when subsequent test code depends critically on the assertion.
- Use `EXPECT_*` macros when continued test execution is safe and useful.

---

## Practical Examples

### 1. Basic Boolean Assertion

```cpp
TEST(MathTest, IsEven) {
  int n = 4;
  EXPECT_TRUE((n % 2) == 0) << "Number should be even";
}
```

### 2. Comparing Strings

```cpp
TEST(StringTest, CompareCStrings) {
  const char* s1 = "hello";
  const char* s2 = "hello";
  EXPECT_STREQ(s1, s2);
}
```

### 3. Checking Floating-point Approximation

```cpp
TEST(MathTest, FloatApprox) {
  float pi = 3.14159f;
  EXPECT_FLOAT_EQ(pi, 3.1416f);
}
```

### 4. Exception Testing

```cpp
TEST(ExceptionTest, ThrowsOnBadInput) {
  EXPECT_THROW(FunctionUnderTest(-1), std::invalid_argument);
}
```

### 5. Using Predicate Assertions

```cpp
bool IsPositive(int x) { return x > 0; }
TEST(PredicateTest, IsPositiveCheck) {
  int value = 5;
  EXPECT_PRED1(IsPositive, value);
}
```

### 6. Death Test Example

```cpp
TEST(DeathTest, CrashOnInvalidInput) {
  EXPECT_DEATH(DoDangerousThing(-1), "Invalid input");
}
```

---

## Best Practices

- Prefer `EXPECT_*` to keep test failures non-fatal unless immediate abort is essential.
- Always provide meaningful failure messages via streaming to assertions.
- Use the specialized assertions for C strings, floating point, and exceptions to ensure accurate verification.
- Apply death tests (`EXPECT_DEATH`) only when testing code that causes process termination.
- Use predicate and predicate format assertions to improve clarity and debug-ability for complex conditions.

---

## Troubleshooting Common Issues

### Problem: Assertion never fires
- Ensure assertions are not behind conditional statements that never evaluate true.
- Remember that `ASSERT_*` abort the test immediately on failure, so any code after them may not execute.

### Problem: Multiple failure messages for same assertion
- GoogleTest prints failure messages at time of assertion and when the test ends for unsatisfied expectations.
- This is by design and helps track when and why failures occurred.

### Problem: Comparing C strings with `EXPECT_EQ`
- `EXPECT_EQ` compares pointer equality for C strings, not string contents.
- Use `EXPECT_STREQ` and related macros instead.

### Problem: Floating point comparison fails despite expected approximate equality
- Use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` instead of `EXPECT_EQ` for floating point types.

---

## Related Documentation

- [Matchers Reference](../matchers.md) — for advanced assertions of conditions.
- [Assertions Reference](docs/reference/assertions.md) — comprehensive listing of all assertions.
- [Death Tests and Fatal Errors](../guides/everyday-workflows/dealing-with-death-tests.md) — more on process-terminating tests.
- [Writing Your First Test](../getting-started/first-steps-usage/writing-your-first-test.md) — for test structure basics.

---

By mastering assertions and expectations, you unlock the full power of GoogleTest's verification capabilities, allowing you to write precise, informative, and robust tests that help maintain high software quality.
