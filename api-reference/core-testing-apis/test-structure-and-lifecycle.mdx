---
title: "Test Structure & Lifecycle"
description: "Step-by-step guide to defining and organizing tests using GoogleTest macros, including test case lifecycle management. Explains essential constructs such as TEST, TEST_F, fixture setup/teardown, and main() management."
---

# Test Structure & Lifecycle

Step-by-step guide to defining and organizing tests using GoogleTest macros, including test case lifecycle management. Explains essential constructs such as `TEST`, `TEST_F`, fixture setup/teardown, and `main()` management.

---

## Introduction

This guide walks you through the foundational elements of structuring tests in GoogleTest. Whether you're writing simple unit tests or more complex test suites that share common test fixtures, understanding the test lifecycle and macro usage ensures your tests are clean, maintainable, and effective.

You will learn:

- How to define tests with `TEST` and `TEST_F`
- How to manage test setup and teardown using fixtures
- Test case lifecycle events
- Best practices around defining and running tests
- How to properly write or customize your program's `main()` function to execute tests

---

## Basic Test Definitions

### Using `TEST`

The `TEST` macro defines a simple, independent test. It requires two identifiers: the test suite name and the test name. Each `TEST` creates a standalone test function.

**Syntax:**

```cpp
TEST(TestSuiteName, TestName) {
  // test code
}
```

**Key Points:**
- Both names must be valid C++ identifiers and should *not* contain underscores.
- The test suite groups related tests.
- Tests in different suites can have identical test names without conflict.

**Example:**

```cpp
TEST(MathTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(MathTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(4), 24);
}
```

This creates two tests, `MathTest.HandlesZeroInput` and `MathTest.HandlesPositiveInput`.

---

### Using `TEST_F` with Test Fixtures

When multiple tests require shared setup or state, use `TEST_F` with a test fixture class.

A *test fixture* is a class derived from `testing::Test` which encapsulates common setup and teardown operations and member variables.

**Creating a Fixture:**

```cpp
class FooTest : public testing::Test {
 protected:
  FooTest() {
    // optional constructor setup
  }

  void SetUp() override {
    // Called before each test
  }

  void TearDown() override {
    // Called after each test
  }

  // Shared objects
  SomeClass obj_;
};
```

**Defining Tests Using Fixture:**

```cpp
TEST_F(FooTest, TestCase1) {
  EXPECT_TRUE(obj_.DoSomething());
}

TEST_F(FooTest, TestCase2) {
  EXPECT_EQ(obj_.GetValue(), 42);
}
```

**Lifecycle Notes:**
- For each test, a fresh fixture object is created.
- The constructor runs, then `SetUp()`, then the test body, then `TearDown()`, then the destructor.
- Changes in one test don’t affect others because of this isolation.

---

## Test Case Lifecycle Management

GoogleTest orchestrates test execution by invoking lifecycle methods at predefined points.

### Per-Test Lifecycle

- **Constructor:** Objects initialized here; prefer it for simple member initialization.
- **`SetUp()`:** Override for complex setup that might fail and must report errors via assertions.
- **Test Body:** The code inside `TEST` or `TEST_F` macro.
- **`TearDown()`:** Cleanup steps; avoid exceptions here as it can lead to undefined behavior.
- **Destructor:** Cleanup but avoid failure assertions.

### Per-Test-Suite Setup and Teardown

Sometimes you need to share resources across *all* tests in a suite to avoid costly duplication.

- Define static methods `SetUpTestSuite()` and `TearDownTestSuite()` in your fixture class.
- These are called once before the first test and once after the last test, respectively.

**Example:**

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    db_connection_ = new DatabaseConnection(...);
  }

  static void TearDownTestSuite() {
    delete db_connection_;
    db_connection_ = nullptr;
  }

  void SetUp() override {
    // Per-test setup
  }

  static DatabaseConnection* db_connection_;
};

DatabaseConnection* DatabaseTest::db_connection_ = nullptr;
```

---

## Tips and Best Practices

- **Avoid underscores (`_`) in test suite and test names:** Underscores can cause name clashes internally and unexpected failures. See the [FAQ on underscores](../faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore).
- **Use `ASSERT_*` when test continuation doesn't make sense after failure; otherwise use `EXPECT_*`.**
- **Prefer constructor for initialization that can’t fail, and `SetUp()` if assertions are needed.**
- **Ensure your fixture class has a default constructor so GoogleTest can instantiate it.**
- **Never ignore the return value of `RUN_ALL_TESTS()`.** It indicates overall success/failure of your tests.

---

## Writing Your Custom `main()` Function

GoogleTest provides a default `main` function in the `gtest_main` library. However, if you want custom behavior before or after tests run, you can write your own.

**Essential steps:**

1. Call `testing::InitGoogleTest(&argc, argv)` to initialize
2. Call `RUN_ALL_TESTS()` to execute tests
3. Return the result of `RUN_ALL_TESTS()` from `main`

**Example:**

```cpp
#include <gtest/gtest.h>

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This setup respects command-line flags, initializes test contexts, and properly aggregates results.

On some embedded platforms (ESP8266, ESP32, Arduino), GoogleTest offers special `setup()` and `loop()` hooks as the test framework's entry points.

---

## Summary

The GoogleTest test structure combines simple and fixture-based tests that are dynamically registered and run in isolated environments. Each test’s lifecycle—from construction to teardown—ensures isolation and consistency, while static suite-level setup allows resource sharing.

By mastering `TEST` and `TEST_F`, and understanding lifecycle hooks, you create organized and reliable test suites tailored to your development needs.

---

## References and Further Reading

- [GoogleTest Primer](../primer.md): For getting started with tests.
- [Testing Reference](../reference/testing.md): Complete API details for test macros and classes.
- [GoogleTest FAQ](../faq.md): Common questions and best practices.
- [Advanced GoogleTest Topics](../advanced.md): Learn about parameterized tests, event listeners, and more.

---

## Example Code Snippet

```cpp
// Simple test without fixture
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

// Test fixture for repeated setup
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```
