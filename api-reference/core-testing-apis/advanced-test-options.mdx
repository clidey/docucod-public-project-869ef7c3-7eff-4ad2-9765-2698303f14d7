---
title: "Parameterized and Typed Tests"
description: "Reference for value-parameterized and type-parameterized tests, including setup, test instantiation, and execution. Shows how these features enable broad input and type coverage with minimal code duplication."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write scalable and maintainable tests over a wide range of inputs and types by using parameterized and typed tests. This page serves as a detailed reference for defining, instantiating, and executing value-parameterized tests and typed tests, helping you achieve broad test coverage with minimal duplication.

---

## Overview of Parameterized Tests

*Value-parameterized tests* let you run the same test logic repeatedly with different input values. This pattern is especially powerful for testing functions or classes over a variety of data, configurations, or implementations without writing redundant tests.

### Defining Value-Parameterized Tests

1. **Create a test fixture class** that derives from `::testing::TestWithParam<T>`, where `T` is the parameter type (any copyable type).
2. **Write test cases with `TEST_P`**, referencing the current parameter inside each test via `GetParam()`.
3. **Instantiate the test suite with parameters** using `INSTANTIATE_TEST_SUITE_P`, providing a name, the test suite class, and a parameter generator such as `Values()`, `ValuesIn()`, or `Range()`.

<div className="callout note">
**Tip:** If your parameter type is a raw pointer, you are responsible for managing its lifetime.
</div>

### Parameter Generators

GoogleTest offers various parameter generators for instantiating test parameters:

- `Values(...)` - enumerates explicit values
- `ValuesIn(begin_iter, end_iter)` or `ValuesIn(container)` - from iterable containers
- `Range(begin, end[, step])` - numeric ranges
- `Bool()` - `true` and `false`
- `Combine(...)` - for tuple parameters, combining multiple generators

### Naming and Filtering

- The first argument to `INSTANTIATE_TEST_SUITE_P` is a unique **instantiation prefix** to distinguish different parameter sets.
- Generated test names include this prefix and numbered suffixes corresponding to parameter indices.
- Use filters such as `--gtest_filter` to select specific instantiated tests to run.

### Abstract Parameterized Tests

You can define parameterized tests in headers and source files to create reusable abstract tests, and instantiate them in multiple places for flexibility and modularity.

---

## Typed Tests

When you need to apply the **same tests to multiple types** (e.g., various container types, integral types), *typed tests* help you write test logic once and run it for several data types.

### Defining Typed Tests

1. Define a test fixture class template derived from `::testing::Test`:

```c++
template <typename T>
class MyTypedTest : public ::testing::Test {
  // Your test fixture code, typed by T
};
```

2. Declare the type list using `using MyTypes = ::testing::Types<T1, T2, ...>`.

3. Associate the test fixture with the types using `TYPED_TEST_SUITE(MyTypedTest, MyTypes);`.

4. Write tests with `TYPED_TEST` that use the special identifier `TypeParam` to refer to the type parameter:

```c++
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam value = ...;
  // Test logic
}
```

---

## Type-Parameterized Tests

Type-parameterized tests generalize typed tests by allowing you to define the test logic *once* and register test cases *separately*, enabling multiple instantiations with different type lists.

### Defining Type-Parameterized Tests

1. Create a template fixture class.
2. Use `TYPED_TEST_SUITE_P` to declare a type-parameterized suite.
3. Write tests with `TYPED_TEST_P`.
4. Register tests with `REGISTER_TYPED_TEST_SUITE_P`.
5. Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P` and your type list.

---

## Practical User Workflow

### Step 1: Define Your Parameterized or Typed Fixture

- For value parameterized: inherit from `TestWithParam<T>`.
- For typed tests: create a fixture template.

### Step 2: Write Tests Using `TEST_P` or `TYPED_TEST`

Use `GetParam()` or `TypeParam` inside tests to access parameters or types.

### Step 3: Instantiate Your Tests

- Use `INSTANTIATE_TEST_SUITE_P` for parameters.
- Use `TYPED_TEST_SUITE` or `INSTANTIATE_TYPED_TEST_SUITE_P` for types.

### Step 4: Run and Filter Tests

Leverage `--gtest_filter` to run specific parameter or type instantiations.

---

## Best Practices and Tips

- **Keep parameter types simple and copyable.** Complex ownership requires care.
- **Provide informative test names** with custom parameter name generators for clarity.
- **Avoid overly large parameter sets** to keep test runs manageable.
- **Combine parameters strategically** using `Combine()` for tests needing multiple parameters.
- **Remember that each test instantiation runs independently**, ensuring isolation.

---

## Common Pitfalls & Troubleshooting

- **Missing or incorrect instantiation causes tests to be unregistered** and appear as failures.
- **Parameter type lifetime issues** with pointers or references can cause crashes or leaks.
- **Naming clashes in typed tests** if test names overlap across instantiations.
- **Forgetting to declare `SetUpTestSuite` publicly in fixtures used with `TEST_P`** will cause compilation errors.
- **Unsynchronized shared resources** in parameterized tests can cause flaky behavior.

Use the above tips and always check test validation outputs for hints.

---

## Example: Combining Value-Parameterized and Typed Tests

```c++
// Typed test fixture template
template <typename T>
class MyVectorTest : public testing::Test {};

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
TYPED_TEST_SUITE(MyVectorTest, MyTypes);

TYPED_TEST(MyVectorTest, InitEmpty) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

// Value-parameterized tests with integers
class IntParamTest : public testing::TestWithParam<int> {};

TEST_P(IntParamTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveInts, IntParamTest, testing::Values(1, 2, 3, 4));
```

---

## References & More Information

- [GoogleTest Primer](primer.md) — fundamental concepts
- [Writing and Structuring Tests](guides/core-testing-workflows/writing-and-structuring-tests) — test organization
- [Assertions and Expectations](api-reference/core-testing-apis/assertions) — expanding on test validation
- [Advanced GoogleTest Topics](docs/advanced.md) — in-depth coverage of parameterized and typed test patterns

---

## Related Sample Code

- [sample7_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample7_unittest.cc) — value-parameterized tests example
- [sample6_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample6_unittest.cc) — typed tests example
- [sample8_unittest.cc](https://github.com/google/googletest/blob/main/googletest/samples/sample8_unittest.cc) — multi-parameter and combined parameterized tests

---

## Summary

Parameterized and typed tests offer powerful ways to efficiently run the same test logic across diverse inputs and types, dramatically reducing boilerplate and improving coverage. Familiarity with their setup — defining fixtures, writing test cases, and instantiating tests — enables scalable, maintainable test suites that evolve gracefully.

Prepare your test fixtures thoughtfully, use GoogleTest's parameter generators and type lists, and leverage filtering to focus your testing efforts for maximum impact.