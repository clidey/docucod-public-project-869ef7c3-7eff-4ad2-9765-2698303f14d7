---
title: "Parameterized & Typed Tests"
description: "Covers mechanisms for writing value-parameterized and type-parameterized tests using TEST_P and TYPED_TEST macros. Explains test instantiation, parameter generators, and patterns for maximizing code reuse across test cases."
---

# Parameterized & Typed Tests

GoogleTest provides powerful mechanisms to write tests that are automatically executed with different inputs or for different types. This dramatically reduces duplication and increases test coverage with minimal effort. This page covers the key features of value-parameterized and type-parameterized tests, including how to write them, instantiate test suites, and maximize code reuse.

---

## Value-Parameterized Tests (TEST_P)

Value-parameterized tests allow you to write a test once and run it multiple times with different parameter values. This is ideal for data-driven testing, interfaces with multiple implementations, or testing different input configurations.

### How It Works

1. **Define a Fixture Class:**
   Your value-parameterized test fixture should derive from `testing::TestWithParam<T>`, where `T` is the parameter type.

   ```cpp
   class FooTest : public testing::TestWithParam<int> {
     // Your fixture setup and helper methods.
   };
   ```

2. **Write Parameterized Tests with `TEST_P`:**
   Use `TEST_P` instead of `TEST` or `TEST_F` to define the test. Within the test body, access the current parameter via `GetParam()`.

   ```cpp
   TEST_P(FooTest, HandlesValues) {
     int param = GetParam();
     EXPECT_TRUE(SomeFunction(param));
   }
   ```

3. **Instantiate the Test Suite:**
   Use `INSTANTIATE_TEST_SUITE_P` to instantiate the tests with specific parameter values or ranges using GoogleTest's parameter generators.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       SampleValues,
       FooTest,
       testing::Values(1, 2, 3, 42));
   ```

### Parameter Generators

GoogleTest offers a rich set of parameter generator functions, including:

- `Values(v1, v2, ..., vN)`: Instantiates tests with explicit values.
- `ValuesIn(container)`: Instantiates tests using all values in a container or array.
- `Range(begin, end [, step])`: Generates sequential values from `begin` up to (but not including) `end` with an optional step (default 1).
- `Bool()`: Generates `{false, true}`.
- `Combine(g1, g2, ..., gN)`: Cartesian product of multiple generators, producing all combinations as tuples.

Example combining parameters:
```cpp
INSTANTIATE_TEST_SUITE_P(
    BoolAndRange,
    MyTest,
    testing::Combine(testing::Bool(), testing::Range(1, 3)));
```

### Custom Test Names

By default, test names include indices. To make names more meaningful, provide a custom name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P`. This function takes a `TestParamInfo<T>` and returns a valid test name suffix (alphanumeric and underscores only).

```cpp
INSTANTIATE_TEST_SUITE_P(
    FriendlyNames,
    FooTest,
    testing::Values("red", "green", "blue"),
    [](const testing::TestParamInfo<std::string>& info) {
      std::string name = info.param;
      std::replace_if(name.begin(), name.end(),
                      [](char c) { return !std::isalnum(c); }, '_');
      return name;
    });
```

### Notes

- The fixture class must declare `SetUpTestSuite()`/`TearDownTestSuite()` as `public` if used with `TEST_P`.
- Parameter generators are evaluated after `InitGoogleTest()` is called, allowing runtime parameter determination.
- Tests without instantiation (i.e., defined but not instantiated) fail by default, unless tagged with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## Typed Tests (TYPED_TEST)

Typed tests allow you to run the same test logic for a list of types known at compile-time. This is ideal for testing multiple implementations of an interface or type-concept conformance.

### How It Works

1. **Define a Fixture Class Template:**
   Define a class template derived from `testing::Test` parameterized by a type.

   ```cpp
   template <typename T>
   class StackTest : public testing::Test {
     // Shared logic, typedefs, static members
   };
   ```

2. **Associate a Type List:**
   Use `testing::Types<Types...>` to specify the list of types.

   ```cpp
   using MyTypes = testing::Types<int, double, std::string>;
   TYPED_TEST_SUITE(StackTest, MyTypes);
   ```

3. **Write Tests Using `TYPED_TEST`:**
   Use `TYPED_TEST` to define tests. Inside the tests, refer to the type via `TypeParam`.

   ```cpp
   TYPED_TEST(StackTest, CanPushAndPop) {
     TypeParam value = ...;
     Stack<TypeParam> stack;
     stack.Push(value);
     EXPECT_EQ(stack.Pop(), value);
   }
   ```

4. **Test Execution:**
   The test suite runs once for each type in the list.

### Optional Custom Name Generator

You can specify a custom class with a static templated `GetName(int)` method to generate readable test suffixes per type.

```cpp
class MyNameGen {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Other";
  }
};

typedef testing::Types<int, double> MyTypes;
TYPED_TEST_SUITE(StackTest, MyTypes, MyNameGen);
```

---

## Type-Parameterized Tests (TYPED_TEST_P)

Type-parameterized tests are similar to typed tests but handle type lists that are not known at the time of test logic definition, enabling test libraries or interfaces to define test patterns that can be instantiated with different types in multiple translation units.

### How It Works

1. **Define Test Suite Template and Declare Usage:**
   ```cpp
   template <typename T>
   class FooTest : public testing::Test {
     // ...
   };
   
   TYPED_TEST_SUITE_P(FooTest);
   ```

2. **Define Typed Tests:**
   Use `TYPED_TEST_P` to define tests, similarly using `TypeParam`.

   ```cpp
   TYPED_TEST_P(FooTest, DoesThis) {
     TypeParam val = ...;
     EXPECT_TRUE(SomeTest(val));
   }
   ```

3. **Register Tests:**
   You must register all typed test names before instantiating.

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesThis, DoesThat);
   ```

4. **Instantiate with Types:**
   You can instantiate the suite with a type list and a unique prefix.

   ```cpp
   using MyTypes = testing::Types<int, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(MyPrefix, FooTest, MyTypes);
   ```

This allows flexible, reusable test patterns across projects without hardcoding type lists in tests.

---

## Best Practices & Tips

- **Avoid underscores `_` in test suite and test names** because GoogleTest uses underscores internally in generated class names. Underscores in names may lead to collisions or undefined behavior.
- **Parameter Types:** Make sure the parameter type `T` used in `TestWithParam<T>` is copyable and its output to an ostream is defined or `PrintToString` is specialized.
- **Custom Names:** Provide custom parameter name generators for better test naming, especially with string or complex types.
- **Value Lifetime:** Be careful when using `ValuesIn` or conversions that involve references or pointers to ensure data stays valid during test instantiation.
- **Use Typed Tests for type-list based repetitive testing.** Use value-parameterized tests when testing with variable input values.
- **Uninstantiated Parameterized Tests:** If tests are defined but not instantiated on purpose (library or plugin), mark them with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## Example

```cpp
// Define a test fixture for value-parameterized tests
class MyParamTest : public testing::TestWithParam<int> {};

// Define a parameterized test
TEST_P(MyParamTest, IsEven) {
  int number = GetParam();
  EXPECT_EQ(number % 2, 0);
}

// Instantiate tests with various parameters
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyParamTest, testing::Values(2, 4, 6, 8));

// Define a typed test fixture
template <typename T>
class StackTest : public testing::Test {};

// Register types
using MyTypes = testing::Types<int, double>;

// Associate types with the test suite
TYPED_TEST_SUITE(StackTest, MyTypes);

// Define a typed test
TYPED_TEST(StackTest, DefaultConstructor) {
  TypeParam val{};
  EXPECT_TRUE(IsDefaultConstructible(val));
}

// Define a type-parameterized test
template <typename T>
class FooTest : public testing::Test {};
TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, DoesSomething) {
  TypeParam val{};
  EXPECT_EQ(DoSomething(val), expected);
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesSomething);
using OtherTypes = testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, FooTest, OtherTypes);
```

---

## Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Tests Not Running">
Check that your parameterized tests have been instantiated using `INSTANTIATE_TEST_SUITE_P`. Remember that tests defined with `TEST_P` / `TYPED_TEST` but without instantiation will trigger failures unless marked with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
</Accordion>
<Accordion title="Invalid Test Names / Compilation Errors">
Avoid underscores in test suite and test names to prevent naming collisions. Also check that your custom name generators produce only alphanumeric and underscore characters.
</Accordion>
<Accordion title="Parameter Type Issues">
Make sure your parameter type is copyable and streamable or provide a `PrintToString` overload for custom types.
</Accordion>
</AccordionGroup>

---

## References

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [Testing Reference - TEST_P and related macros](reference/testing.md#TEST_P)
- [FAQ on Underscores in Names](docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore)

---

For continued learning, you should explore the guides on [Writing Your First Tests](../../guides/getting-started/writing-your-first-tests.md) and [Advanced Test Structures](../../guides/core-testing-workflows/advanced-test-structures.md) to master the use of parameterized and typed tests in real-world scenarios.

---