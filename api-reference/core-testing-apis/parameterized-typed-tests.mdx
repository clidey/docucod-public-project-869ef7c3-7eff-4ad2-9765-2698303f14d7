---
title: "Parameterized and Typed Tests"
description: "Guides users through creating value-parameterized and type-parameterized tests for maximum test coverage with minimal redundancy. Explains data generators, test instantiation, and advanced combinatorics, with code snippets for the most common use cases."
---

# Parameterized and Typed Tests

GoogleTest enhances your testing strategy by allowing you to write tests that automatically run across a range of values and types. This approach maximizes coverage while minimizing repetitive code, empowering you to build more robust tests with less effort. This guide walks you through crafting value-parameterized and type-parameterized tests, explains the use of data generators for parameters, how to instantiate these tests, and demonstrates advanced combinatorics techniques with practical code snippets.

---

## What Are Parameterized and Typed Tests?

- **Value-Parameterized Tests (Value-Parameterized Tests)** let you run the same test logic over different input values.
- **Typed Tests** allow you to write tests that work over a fixed list of types.
- **Type-Parameterized Tests** enable defining test patterns that can be instantiated later with different type lists, offering flexibility for interface and concept testing.

Using these tests helps you avoid duplication, maintain consistency, and cover diverse scenarios efficiently.

---

## Value-Parameterized Tests

Value-parameterized tests run the same test logic multiple times, each with a different input value you provide.

### Getting Started

1. **Create a Test Fixture** that inherits from `::testing::TestWithParam<T>`, where `T` is the parameter type.
2. **Define Tests** using `TEST_P` macros that access the parameter with the `GetParam()` method.
3. **Instantiate the Test Suite** using `INSTANTIATE_TEST_SUITE_P`, supplying a unique instantiation name, the test suite, and a parameter generator.

### Example

```cpp
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues, FooTest, ::testing::Values(2, 4, 6, 8));
```

This example creates four instances of `FooTest.IsEven`, each running with a value from the list.

### Parameter Generators

Parameters for instantiations can come from several built-in generators, including:

| Generator | Description |
| --------- | ----------- |
| `Range(start, end[, step])` | Produces a sequence of values from `start` to `end` (excluding `end`), stepping by `step` (defaults to 1). |
| `Values(v1, v2, ..., vN)` | Uses the explicitly listed values. |
| `ValuesIn(container)` | Uses elements from a container or iterator range. |
| `Bool()` | Yields `{false, true}` for testing Boolean scenarios. |
| `Combine(g1, g2, ..., gN)` | Creates the Cartesian product of multiple generators, yielding tuples of all combinations. |
| `ConvertGenerator<T>(g)` | Converts generated values to an intermediate type `T`, needed when the test parameter type is not directly constructible from the generated values.

### Combining Multiple Parameters

Using `Combine()`, you can generate all combinations of parameters from multiple sequences.

```cpp
using ::testing::Combine;
using ::testing::Values;

class PairTest : public TestWithParam<std::tuple<int, char>> {};

TEST_P(PairTest, WorksForAllPairs) {
  int i; char c;
  std::tie(i, c) = GetParam();
  // Your test logic
}

INSTANTIATE_TEST_SUITE_P(AllPairs, PairTest, Combine(Values(1, 2), Values('a', 'b')));
```

This creates tests for all pairs `(1,'a')`, `(1,'b')`, `(2,'a')`, `(2,'b')`.

### Custom Parameter Naming

You can supply a custom function or functor to generate human-readable test names for each parameter instance. Names must be alphanumeric or underscores.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

The tests will be named accordingly, e.g., `CustomNames/FooTest.Value1`.

### Best Practices and Notes

- Place the `INSTANTIATE_TEST_SUITE_P` macros in global or namespace scope, not inside functions.
- If you have value-parameterized tests not meant to be instantiated, suppress warnings using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);`.
- Manage lifetimes carefully when using pointers as parameters.

---

## Typed Tests

Typed tests are great when the test logic is the same across multiple types known in advance.

### Workflow

1. **Define a Fixture Template** parameterized by a type and inheriting from `testing::Test`.
2. **Associate a List of Types** with the fixture using `TYPED_TEST_SUITE(FixtureName, Types);`.
3. **Write Typed Tests** using `TYPED_TEST(FixtureName, TestName)`, referencing the test type as `TypeParam`.

### Example

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T value_{};
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, MyTypes);

TYPED_TEST(NumericTest, IsZeroOnInit) {
  EXPECT_EQ(this->value_, TypeParam(0));
}
```

This runs the same test logic over `int`, `float`, and `double`.

### Custom Type Names

Optionally provide a `NameGenerator` class with a `static std::string GetName(int)`
that uniquely names types for test runner output.

### Notes

- You must know the type list at compile time.
- To directly specify a single type, write `TYPED_TEST_SUITE(FixtureName, int);`.

---

## Type-Parameterized Tests

Type-parameterized tests give you the flexibility to define test logic without fixing the types until instantiation.

### How It Works

1. Define the template test fixture, inheriting from `testing::Test`.
2. Use `TYPED_TEST_SUITE_P(FixtureName);` to declare the type-parameterized test suite.
3. Define tests using `TYPED_TEST_P(FixtureName, TestName)`.
4. Register tests with `REGISTER_TYPED_TEST_SUITE_P(FixtureName, TestName1, TestName2, ...);`.
5. Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P(InstanceName, FixtureName, Types);`.

### Example

```cpp
template <typename T>
class FooTest : public testing::Test {};

TYPED_TEST_SUITE_P(FooTest);

TYPED_TEST_P(FooTest, TestBehavior) {
  TypeParam value{};
  // test logic using value
}

REGISTER_TYPED_TEST_SUITE_P(FooTest, TestBehavior);

using TypesToTest = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, FooTest, TypesToTest);
```

You can instantiate the pattern multiple times in different files or in the same file with different type lists.

### Notes

- This is ideal when building libraries or interface compliance tests.
- You must register tests before instantiating.
- Instantiations add prefixes to test suite names to keep them distinct.

---

## Practical Tips and Common Pitfalls

- Use `SCOPED_TRACE()` to add context to complex assertions and trace failures.
- Fatal failures in helper functions propagate only up to the helper; use `ASSERT_NO_FATAL_FAILURE()` to verify subroutine failures.
- To customize test parameter naming, implement a custom naming function accepting `TestParamInfo<T>`.
- To test internal (private or static) parts of your code with parameterized or typed tests, consider using `FRIEND_TEST` or refactor internals into testable classes.
- Always instantiate your parameterized and typed tests; otherwise, GoogleTest may mark them as uninstantiated.

---

## Illustrated User Flow for Parameterized Tests

```mermaid
flowchart TD
  A[Define Test Fixture with Parameter] --> B[Write TEST_P with GetParam()]
  B --> C[Select Parameter Generator (Range, Values, etc.)]
  C --> D[Instantiate with INSTANTIATE_TEST_SUITE_P]
  D --> E[Run Tests for Each Parameter]
  E --> F{Results}
  F -->|Pass| G[Success]
  F -->|Fail| H[Debug Using Trace & Error Messages]
```

---

## Frequently Used Macros and Functions

| Macro / Function                  | Purpose                                                |
|---------------------------------|--------------------------------------------------------|
| `TEST_P(Fixture, TestName)`      | Define a value-parameterized test using a fixture.     |
| `INSTANTIATE_TEST_SUITE_P`       | Instantiate a value-parameterized test suite.          |
| `TYPED_TEST_SUITE(Fixture, Types)` | Define typed tests with specified types.               |
| `TYPED_TEST(Fixture, TestName)` | Write a typed test.                                     |
| `TYPED_TEST_SUITE_P(Fixture)`    | Declare a type-parameterized test suite.                |
| `TYPED_TEST_P(Fixture, TestName)`| Write a test in a type-parameterized suite.             |
| `REGISTER_TYPED_TEST_SUITE_P`    | Register tests in a type-parameterized suite.           |
| `INSTANTIATE_TYPED_TEST_SUITE_P`| Instantiate a type-parameterized test suite.            |

---

## Troubleshooting

- **Tests not running:** Make sure you have instantiated parameterized tests with `INSTANTIATE_TEST_SUITE_P` or your typed tests with `INSTANTIATE_TYPED_TEST_SUITE_P`.
- **Duplicate or invalid test names:** Ensure custom test name generators return unique, valid names (alphanumeric and underscore).
- **Unsupported parameter types:** Use `ConvertGenerator` to convert generated values to the fixture's parameter type.
- **Assertion failures lack context:** Utilize `SCOPED_TRACE()` to improve traceability of failures across test parameter iterations.

---

## Further Reading and Related Documentation

- Learn more about [Value-Parameterized Tests](../advanced.md#value-parameterized-tests).
- Explore [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for deeper understanding.
- See the [Testing Reference](docs/reference/testing.md) for API details.
- Try out [sample test files](https://github.com/google/googletest/tree/main/googletest/samples/) for hands-on examples.

---

For a richer practical experience, refer to the Advanced GoogleTest Topics guide and sample test implementations in the official [GoogleTest GitHub Repository](https://github.com/google/googletest).