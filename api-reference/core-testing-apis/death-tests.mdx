---
title: "Death Tests and Exception Testing"
description: "Guide to APIs for writing death tests that assert abnormal termination and error scenarios. Covers EXPECT_DEATH, ASSERT_DEATH, and related macros, along with strategies for validating error conditions in code."
---

# Death Tests and Exception Testing

Mastering death tests is crucial for verifying code paths that cause a program to terminate abnormally due to fatal errors or invalid conditions. This guide focuses specifically on GoogleTest's death test and exception testing APIs, explaining key macros, predicates, behaviors, and strategies for asserting abnormal termination and error output with precision.

---

## Understanding Death Tests

Death tests enable you to assert that certain code statements cause your program to terminate unexpectedly — such as through calls to `exit()`, aborts, fatal assertions, or signals. Since such termination interrupts normal program control flow, death tests run the code under test in child processes to isolate failures safely.

> Death tests verify three key outcomes:
> 1. The statement causes process termination.
> 2. The exit status (or signal) meets an expected condition.
> 3. The output to `stderr` matches an expected pattern.

Death tests do **not** catch exceptions — those are verified separately using exception assertions.

---

## Death Test Macros

GoogleTest provides several macros tailored to death testing, designed to accommodate different usage needs and failure handling patterns.

### Basic Death Assertions

- `ASSERT_DEATH(statement, matcher)`: Fails the current function immediately if `statement` does not terminate as expected.  Use inside tests when failure should abort the test.
- `EXPECT_DEATH(statement, matcher)`: Records a failure but continues execution if `statement` does not terminate as expected.

Both macros run `statement` in a separate child process and verify the process dies with a nonzero exit status **and** prints to `stderr` a message matching `matcher` (either a string interpreted as a regex or a matcher for `const std::string&`).

**Example:**

```cpp
EXPECT_DEATH(DoSomethingDangerous(), "Invalid port number");
ASSERT_DEATH(server.Shutdown(), "Fatal error occurred");
```

### Exit Assertions with Predicate

For finer control over the exit status, use:

- `ASSERT_EXIT(statement, predicate, matcher)`
- `EXPECT_EXIT(statement, predicate, matcher)`

Here, `predicate` is a function or functor accepting an `int` exit status and returning `bool`. This allows checking for specific exit codes or kill signals.

GoogleTest provides convenient predicate classes:

```cpp
::testing::ExitedWithCode(expected_exit_code);  // Matches normal exit with code.
#if !defined(GTEST_OS_WINDOWS) && !defined(GTEST_OS_FUCHSIA)
::testing::KilledBySignal(signal_number);        // Matches termination by signal.
#endif
```

**Example:**

```cpp
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "Killed");
```

### Conditional Death Macros

- `EXPECT_DEATH_IF_SUPPORTED` and `ASSERT_DEATH_IF_SUPPORTED` behave the same as their counterparts if death tests are available on the platform; otherwise, they generate warnings without failing.

- `EXPECT_DEBUG_DEATH` and `ASSERT_DEBUG_DEATH` assert death **only in debug mode** and execute normally in optimized builds. Useful to test `LOG(DFATAL)` and debug-only assertions.

---

## Writing Effective Death Tests

### Using Compound Statements

Death test macros accept any valid C++ statement. Compound statements (blocks) are often useful:

```cpp
ASSERT_DEATH({
  InitializeDangerousSubsystem();
  ExecuteFatalAction();
}, "Fatal error on initialization");
```

### Verifying Error Output with Regex

The `matcher` parameter can be either a string interpreted as a regex or a matcher object. GoogleTest supports different regex implementations depending on the platform:

| Platform          | Regex Syntax Supported                          |
|-------------------|-----------------------------------------------|
| POSIX-compliant *nix | POSIX Extended Regex with common features     |
| Windows, Mac      | GoogleTest's simplified subset (no unions, groups, etc.) |

Common supported constructs include character classes (`\d`, `\w`), anchors (`^`, `$`), quantifiers (`?`, `*`, `+`), and literals. Complex PCRE features like unions (`|`) or grouping are **not** supported in the simplified implementation.

**Tip:** Be mindful to stay within the supported regex subset to avoid runtime errors.

### Handling Multi-threading: Death Test Styles

Forking a process in multi-threaded contexts is unsafe, so GoogleTest defines two death test styles:

- `fast` style: Forks and executes the test code immediately in the child process **after forking**. Fast, but unsafe in multi-threaded tests.
- `threadsafe` style: Re-executes the test binary with a flag instructing it to run only the current death test. Safer in multi-threaded environments but slower due to process re-exec.

You can select the style globally or per test using:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

**Important:** Test suites containing death tests should be named to end with `DeathTest` to help ordering and reduce threading issues.

---

## Caveats and Best Practices

- **Avoid `return` statements or exceptions inside death test code.** Doing so causes the death test to fail.

- **Side effects inside death test statements are not visible to the parent process.** Variables modified or memory freed will not affect the parent’s memory.

- **If your death test involves mocks, consider allowing mock leaks** to avoid false failures from mock leak detectors during abnormal process termination.

- **Only one death test assertion per line** to avoid compilation errors.

- **Warn if running with multiple threads pre-existing before death test start.** GoogleTest issues a warning since forking multi-threaded processes is risky.

---

## Exception Testing and Death Tests

GoogleTest treats exceptions differently from death tests:

- **Death tests** expect _process termination_.
- **Exception assertions** verify that code _throws_ or _does not throw_ exceptions.

GoogleTest provides exception macros:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`

Exceptions escaping death tests are treated as failures. It’s possible to verify that exceptions are handled or propagated correctly using these assertions.

### Special Debug Death Tests

`EXPECT_DEBUG_DEATH` and `ASSERT_DEBUG_DEATH` assert failures only when compiled in debug mode. In release mode, the statements run without asserting death, allowing side effects to be validated.

**Example:**

```cpp
int DieInDebugOr12(int* sideeffect) {
  if (sideeffect) *sideeffect = 12;
  LOG(DFATAL) << "death";
  return 12;
}

TEST(TestSuite, DieOrReturn12) {
  int sideeffect = 0;
  EXPECT_DEBUG_DEATH(DieInDebugOr12(&sideeffect), "death");
#ifdef NDEBUG
  EXPECT_EQ(12, sideeffect);
#else
  EXPECT_EQ(0, sideeffect);
#endif
}
```

---

## Troubleshooting Death Tests

- If a death test **times out or hangs**, ensure that no unexpected threads are running before it starts.
- Ensure your test binary is invoked with a path including at least one separator for `threadsafe` tests to re-execute properly.
- Use `GTEST_FLAG_SET(death_test_style, "threadsafe")` for tests in multi-threaded environments.
- Confirm that your regex matcher syntax aligns with the supported regex subset.
- Avoid `return` statements inside death test statements.
- Use the `EXPECT_DEATH_IF_SUPPORTED` macros when maintaining code for multiple platforms.

---

## Detailed Examples

### Basic Death Test

```cpp
TEST(FooDeathTest, DiesOnBadInput) {
  EXPECT_DEATH(
    foo.DoSomethingInvalid(),
    "Invalid input provided"
  );
}
```

### Testing Specific Exit Codes

```cpp
TEST(FooDeathTest, ExitsWithZeroOnSuccess) {
  EXPECT_EXIT(
    foo.ExitWithZero(),
    testing::ExitedWithCode(0),
    "Success"
  );
}
```

### Death Test with Compound Statement

```cpp
TEST(FooDeathTest, DiesInSequence) {
  ASSERT_DEATH({
    Initialize();
    RunFatalStep();
  }, "fatal error");
}
```

### Debug Death Test

```cpp
TEST(FooDeathTest, DebugOnlyDeath) {
  int sideeffect = 0;
  EXPECT_DEBUG_DEATH(
    { sideeffect = 42; abort(); },
    "abort"
  );
#ifdef NDEBUG
  EXPECT_EQ(sideeffect, 42);
#else
  EXPECT_EQ(sideeffect, 0);
#endif
}
```

---

## Internals & How Death Tests Work

1. When a death test macro executes, it first warns if multiple threads are active.
2. The parent process fork/clones or creates a subprocess based on the style.
3. The child process runs the death test statement, and:
   - Should exit with a code or signal.
   - Writes error output to `stderr`.
4. The parent process waits and collects:
   - Child's exit status.
   - `stderr` output.
5. The parent applies the matcher to the output and predicates to exit code.
6. If expectations are met, the death test passes; otherwise it fails with detailed diagnostics.

This architecture ensures the main test runner process remains stable and insulated from the abnormal termination tested.

---

## Recommended Reading

- [ASSERT_DEATH and EXPECT_DEATH Macros](reference/assertions.md#death)
- [Death Tests and Threads](advanced.md#death-tests)
- [Exception Assertions](reference/assertions.md#exceptions)
- [Writing Your First Test](getting-started/writing-first-test.md)
- [Parameterized and Typed Tests](api-reference/core-testing-apis/parameterized-tests.md)
- [Mocking Best Practices](guides/mocking-advanced-techniques/mocking-best-practices.md)

---

## Summary

Death tests in GoogleTest are a powerful way to verify that your code terminates correctly on fatal errors or invalid states. Using `ASSERT_DEATH`, `EXPECT_DEATH`, `ASSERT_EXIT`, and `EXPECT_EXIT`, combined with exit status predicates and regex matchers, you can assert both termination and error output precisely. Understanding death test styles, handling exceptions separately, and following best practices around multithreading and side effects will ensure your death tests are reliable, maintainable, and safe to run.

---

<Task>
Write your death tests carefully, encapsulate critical failure points with clear matchers, and monitor threading contexts to avoid flaky test failures caused by inappropriate use of forks. Use `EXPECT_DEBUG_DEATH` smartly to differentiate debug and release behaviors.
</Task>
