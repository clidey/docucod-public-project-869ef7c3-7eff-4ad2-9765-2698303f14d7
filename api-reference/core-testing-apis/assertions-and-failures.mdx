---
title: "Assertions and Failure Handling"
description: "A complete guide to the assertion macros offered by GoogleTest for verifying test outcomes, including equality, exceptions, boolean predicates, and custom conditions. Explains the difference between fatal and non-fatal failures and offers detailed reference on assertion result types and messaging."
---

# Assertions and Failure Handling

A complete guide to the assertion macros offered by GoogleTest for verifying test outcomes, including equality checks, exception verification, boolean predicates, and custom condition validations. This document explains the differences between fatal and non-fatal failures, details assertion result types, and provides comprehensive references to support rigorous and expressive C++ testing.

---

## 1. Overview of Assertions in GoogleTest

Assertions are the backbone of GoogleTest, checking conditions during tests and reporting results. They come in two flavors:

- **Fatal Assertions (ASSERT_*)**: On failure, these abort the current function immediately, ensuring subsequent code in that function isn't run.
- **Non-Fatal Assertions (EXPECT_*)**: On failure, these log the failure but allow the function to continue running, enabling multiple assertions per test.

All assertion macros accept standard streaming for custom failure messages using the `<<` operator to make test failures easier to diagnose.

### Assertion Result Types

Internally, assertions yield one of these outcomes:

| Type               | Description                                 | Effect                         |
|--------------------|---------------------------------------------|------------------------------|
| `kSuccess`         | The assertion succeeded.                     | Test continues normally.      |
| `kNonFatalFailure` | The assertion failed but the test continues.| Test continues, logs failure. |
| `kFatalFailure`    | The assertion failed and test aborts.       | Current function returns.     |
| `kSkip`            | Test or assertion skipped.                   | Test marked skipped.          |


## 2. Using Assertion Macros

### 2.1 Explicit Success and Failure

- `SUCCEED()`
  - Marks an explicit success, useful chiefly for documenting successful steps. Does not affect overall test pass/fail.

- `FAIL()`
  - Generates a fatal failure and returns immediately; only valid in void-returning functions.

- `ADD_FAILURE()`
  - Generates a non-fatal failure; allows execution to continue.

- `ADD_FAILURE_AT(file, line)`
  - Like `ADD_FAILURE()`, but reports failure at the specified file and line number.

```cpp
switch(expression) {
  case 1:
    ...some checks...
  case 2:
    ...other checks...
  default:
    FAIL() << "Should not reach here.";
}
```

### 2.2 Basic Assertion Macros

Assertions verify conditions or compare values. Each macro has an `EXPECT_` and `ASSERT_` version.

#### Boolean Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)` - Verifies condition is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)` - Verifies condition is false.

#### Equality and Comparison Assertions

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)` — Verifies `val1 == val2`.
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)` — Verifies `val1 != val2`.
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)` — Verifies `val1 < val2`.
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)` — Verifies `val1 <= val2`.
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)` — Verifies `val1 > val2`.
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)` — Verifies `val1 >= val2`.

**Important Notes:**
- When comparing pointers, `EXPECT_EQ` checks pointer equality, not content equality.
- To compare C-strings by content, use string-specific assertions (below).
- Arguments are evaluated exactly once.

#### String Assertions (for C-strings)

To compare C-style strings by their contents (including `nullptr` safety), use:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)` — Verifies strings are equal.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)` — Verifies strings are not equal.
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)` — Case-insensitive equality.
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)` — Case-insensitive inequality.

Example:

```cpp
EXPECT_STREQ("hello", some_c_string);
ASSERT_STRCASEEQ("Hello", some_c_string);
```

#### Floating-Point Assertions

Due to rounding, direct equality is impractical for floating-point comparisons.

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)` — 4 ULP tolerance for `float`.
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)` — 4 ULP tolerance for `double`.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)` — Tolerance based on absolute difference.

Example:

```cpp
EXPECT_NEAR(computed_value, expected_value, 0.0001);
```

### 2.3 Exception Assertions

Requires exceptions enabled in your build.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)` — Verifies that the statement throws an exception of the specified type.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)` — Verifies that the statement throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)` — Verifies that the statement does not throw.

```cpp
EXPECT_THROW(DoSomething(), std::runtime_error);
EXPECT_NO_THROW(CleanUp());
```

### 2.4 Predicate Assertions

For complex verification where you want expressive error messages:

- `EXPECT_PREDn(pred, val1, ..., valN)` / `ASSERT_PREDn(pred, val1, ..., valN)` — verifies that the predicate returns true. `pred` should be a functor or function returning a bool.

- `EXPECT_PRED_FORMATn(pred_formatter, val1, ..., valN)` / `ASSERT_PRED_FORMATn(pred_formatter, val1, ..., valN)` — use predicate-formatter functions for richer custom failure messages, returning `testing::AssertionResult`.

Example:

```cpp
bool IsPrime(int n);
EXPECT_PRED1(IsPrime, 7);

// Predicate formatter example
AssertionResult IsPositive(const char* expr, int val) {
  if (val > 0) return AssertionSuccess();
  return AssertionFailure() << expr << " evaluates to " << val << ", which is not positive.";
}
EXPECT_PRED_FORMAT1(IsPositive, x);
```

### 2.5 Matcher-Enhanced Assertions

To assert on complex conditions or with readable output, use matchers from GoogleMock:

- `EXPECT_THAT(value, matcher)` / `ASSERT_THAT(value, matcher)` — verifies that `value` matches the `matcher`. See [Matchers Reference](matchers.md).

Example:

```cpp
EXPECT_THAT(str, StartsWith("Hello"));
ASSERT_THAT(number, AllOf(Gt(5), Lt(10)));
```

## 3. Key Differences: Fatal vs Non-Fatal Failures

- Fatal failures (`ASSERT_*`, `FAIL()`) cause immediate return from the current function.
- Non-fatal failures (`EXPECT_*`, `ADD_FAILURE()`) log the failure but continue executing the function.

Use fatal assertions when continuing after failure would cause undefined behavior or crashes.

## 4. Crafting Failure Messages

Most assertions support streaming custom messages with `<<`. This is essential for adding context when debugging.

```cpp
EXPECT_EQ(x, y) << "Mismatch at index " << i << ", values: " << x << ", " << y;
```

If you need multi-line or detailed messages, stream them for full clarity.

## 5. Utility Assertions for Specialized Cases

### Skipping Tests

- `GTEST_SKIP()` allows skipping a test at runtime with an optional message.

### Explicit Checks

- `ASSERT_NO_FATAL_FAILURE(statement)` / `EXPECT_NO_FATAL_FAILURE(statement)` — verify that `statement` does not generate new fatal failures.

### HRESULT Assertions (Windows only)

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)` — verify success HRESULT.
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)` — verify failure HRESULT.

## 6. Advanced Assertion Result Types and Streaming

### AssertionResult

Functions can return an `AssertionResult` to provide detailed success/failure results with custom messages.

Example:

```cpp
AssertionResult IsPositive(int n) {
  if (n > 0) return AssertionSuccess() << n << " is positive.";
  return AssertionFailure() << n << " is not positive.";
}
EXPECT_TRUE(IsPositive(x));
```

### Streaming User Types

GoogleTest supports streaming user-defined types for assertion failure messages by overloading the `<<` operator.

## 7. Best Practices and Troubleshooting

- Always prefer `EXPECT_*` over `ASSERT_*` when multiple failures should be reported.
- Use `ASSERT_` when failure invalidates subsequent test code in the function.
- Prefer C-string assertions (`EXPECT_STREQ`) over pointer equality.
- When testing floating-point values, use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` to avoid spurious failures.
- Use predicate assertions with `AssertionResult` or predicate-formatters for complex custom checks.
- Stream additional information to assertions for richer failure diagnostics.
- Use `SCOPED_TRACE` or `ScopedTrace` in subroutines to add context in multi-level test failures.
- Avoid `ASSERT_*` in constructors and destructors; use `SetUp()` and `TearDown()` instead.

## 8. Examples

### Basic Equality Check

```cpp
TEST(MathTest, Add) {
  int result = Add(2, 3);
  EXPECT_EQ(result, 5) << "Addition failed";
}
```

### String Comparison

```cpp
TEST(StringTest, Equals) {
  const char* actual = GetName();
  EXPECT_STREQ("John", actual) << "Names do not match";
}
```

### Floating-Point Comparison

```cpp
TEST(FloatTest, NearComparison) {
  EXPECT_NEAR(CalculatePi(), 3.1415, 0.0001);
}
```

### Exception Verification

```cpp
TEST(ExceptionTest, Throws) {
  EXPECT_THROW(RiskyOperation(), std::runtime_error);
}
```

### Advanced Predicate Assertion

```cpp
bool IsSorted(const std::vector<int>& v) {
  return std::is_sorted(v.begin(), v.end());
}
TEST(VectorTest, Sorted) {
  std::vector<int> v = {1, 2, 3};
  EXPECT_PRED1(IsSorted, v);
}
```

### Using Matchers

```cpp
#include <gmock/gmock.h>
using ::testing::HasSubstr;

TEST(StringTest, ContainsSubstr) {
  std::string s = "hello world";
  EXPECT_THAT(s, HasSubstr("world"));
}
```

## 9. Common Pitfalls

- Using `ASSERT_*` macros in non-void functions incorrectly. Remember fatal assertions require void-returning functions.
- Comparing C strings with `EXPECT_EQ` instead of `EXPECT_STREQ`.
- Forgetting to stream meaningful messages for easier debugging.
- Using `ASSERT_*` in constructors or destructors.
- Ignoring that `EXPECT_*` allow test execution to continue even after failures, which may produce confusing results if unchecked.

## 10. Troubleshooting

If your test assertions do not behave as expected:

- Ensure assertions are placed in appropriate void-returning contexts.
- Use predicate assertions with custom messages to clarify failures.
- Check for platform-specific constraints on exception assertions.
- Use `SCOPED_TRACE` to add context to failures in helper or nested functions.

---

## Useful Links

- [GoogleTest Assertion Macros Reference](docs/reference/assertions.md)
- [Matchers Reference](docs/reference/matchers.md)
- [Advanced GoogleTest Topics](docs/advanced.md#more-assertions)
- [Death Tests](docs/advanced.md#death-tests)
- [Value-Parameterized Tests](docs/testing.md#TEST_P)
- [Writing Your First Test Guide](guides/getting-started/writing-first-test)
- [Mocking and GoogleMock Overview](overview/core-concepts/mocking)

---

## Summary

This chapter unveils the rich, expressive assertion infrastructure of GoogleTest, enabling you to verify conditions, compare values, check exceptions, and define custom validations with clear diagnostics. By understanding the distinction between fatal and non-fatal failures and using the powerful assertion macros and predicate-formatter functions, you gain full control over how tests report successes and failures. Complementing this, GoogleMock matchers provide natural language-like assertions enhancing readability and diagnostic clarity.

Readers are encouraged to explore advanced guides on predicates, matchers, death tests, and assertion placement to master robust test writing.

---