---
title: "Test and Fixture Declarations"
description: "Explore the macros and classes used to declare standalone tests and test suites, including test fixtures for code reuse and setup/teardown logic. Learn how to use TEST, TEST_F, and fixtures to build structured unit tests."
---

# Test and Fixture Declarations

Explore the macros and classes used to declare standalone tests and test suites, including test fixtures for code reuse and setup/teardown logic. Learn how to use `TEST`, `TEST_F`, and fixtures to build structured unit tests.

---

## Overview

GoogleTest structures your tests in terms of test suites and test cases, where each test case represents a unit of testing logic that verifies some aspect of your code. This document focuses on how to declare these tests and re-use testing code efficiently through fixtures.

At the foundation, two primary macros allow you to define tests:

- `TEST()`: Declares a simple, standalone test without shared setup/teardown.
- `TEST_F()`: Declares a test that uses a test fixture class to share setup, teardown, and data.

Additionally, you can create your own fixture classes that inherit from `testing::Test` to bundle common test logic and resource management.

Understanding how to declare and use test fixtures is essential for writing clear, maintainable, and scalable C++ tests with GoogleTest.

---

## Declaring Simple Tests with `TEST`

Use the `TEST()` macro to define an individual test that doesnâ€™t share state with other tests. Each `TEST` is a function that runs a sequence of statements and assertions.

### Syntax

```cpp
TEST(TestSuiteName, TestName) {
  // Test logic and assertions
}
```

- **TestSuiteName** groups logically related tests.
- **TestName** identifies an individual test within the suite.

Both must be valid C++ identifiers without underscores to avoid naming conflicts.

### How GoogleTest Executes `TEST`s

GoogleTest creates a new test object for each `TEST`, runs the code inside, and cleans up immediately after. Tests are independent and run in an undefined order.

### Example

```cpp
// Function to be tested
int Factorial(int n);

// Tests factorial of 0.
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

// Tests factorial of positive numbers.
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

In this example, two tests belong to the `FactorialTest` suite.

---

## Using Test Fixtures with `TEST_F`

When multiple tests share common data or need the same setup/teardown, define a **test fixture** class.

### Creating a Test Fixture Class

1. Derive a class from `testing::Test`.
2. Declare shared variables as class members.
3. Override `SetUp()` and/or `TearDown()` to initialize or clean up before and after each test.
4. (Optionally) Define static methods `SetUpTestSuite()` and `TearDownTestSuite()` for setup/teardown once per suite.

### Defining Tests Using Fixtures

Use the macro `TEST_F(FixtureClassName, TestName)` where the first argument is your fixture class.

### Important Notes

- You must define the fixture class **before** using it in `TEST_F()`.
- The fixture class must have a default constructor.
- Each `TEST_F` creates a **new** fresh instance of the fixture class for each test run to maintain test isolation.

### Example

```cpp
// A simple Queue class template
template <typename E>
class Queue {
 public:
  Queue() {}
  void Enqueue(const E& element) {
    data_.push_back(element);
  }
  E* Dequeue() {
    if (data_.empty()) return nullptr;
    E* result = new E(data_.front());
    data_.pop_front();
    return result;
  }
  size_t size() const { return data_.size(); }

 private:
  std::list<E> data_;
};

// Test fixture for Queue<int>
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Setup different queues
    // q0_ is empty
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  // If needed:
  // void SetUp() override {}
  // void TearDown() override {}

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};

// Tests that q0_ is initially empty
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

// Tests the dequeue functionality
TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

Each `TEST_F` creates a fresh `QueueTest` instance automatically.

---

## Test Fixture Setup and Teardown

GoogleTest calls lifecycle functions to prepare and clean the test environment.

| Method                | When It's Called                | Purpose                                      |
|-----------------------|-------------------------------|----------------------------------------------|
| `SetUpTestSuite()`     | Before the first test in suite| Prepare shared resources **once per suite**  |
| `TearDownTestSuite()`  | After last test in suite       | Clean up shared resources **once per suite** |
| `SetUp()`             | Before each individual test    | Prepare fresh resources per test              |
| `TearDown()`          | After each individual test     | Clean up after each test                      |

### Guidelines

- Use `SetUpTestSuite()` for expensive shared setup.
- Use `SetUp()` for per-test initialization.
- Fixture constructor & destructor can also be used but with caveats:
  - Avoid assertions in constructor/destructor.
  - Use `SetUp()`/`TearDown()` when framework calls are needed.

### Example for Shared Setup

```cpp
class FooTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    shared_resource_ = new SomeResource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  void SetUp() override { /* per-test setup */ }
  void TearDown() override { /* per-test teardown */ }

  static SomeResource* shared_resource_;
};

SomeResource* FooTest::shared_resource_ = nullptr;
```

---

## Writing Tests Programmatically With `RegisterTest`

When macros `TEST` or `TEST_F` are insufficient, dynamically register tests via `RegisterTest()`.

### Signature

```cpp
template <typename Factory>
TestInfo* testing::RegisterTest(const char* test_suite_name, const char* test_name,
                                const char* type_param, const char* value_param,
                                const char* file, int line, Factory factory);
```

- `test_suite_name`, `test_name`: Test suite and test identifiers.
- `type_param`, `value_param`: For templated or parameterized tests, otherwise `nullptr`.
- `file`, `line`: Location of test registration.
- `factory`: Callable creating a new instance of the test fixture.

### When to Use

- Dynamic test generation based on runtime data.
- Creating tests in loops or with complex runtime logic.

### Important

- Must be called before `RUN_ALL_TESTS()`.
- Tests registered this way behave like those declared with macros.

### Example

```cpp
class MyFixture : public testing::Test {
  void SetUp() override {}
  void TearDown() override {}
};

class MyTest : public MyFixture {
 public:
  explicit MyTest(int data) : data_(data) {}
  void TestBody() override {
    EXPECT_GT(data_, 0);
  }
 private:
  int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
        "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr, std::to_string(v).c_str(),
        __FILE__, __LINE__,
        [=]() -> MyFixture* { return new MyTest(v); });
  }
}
```

---

## Common Pitfalls and Best Practices

- Avoid mixing `TEST` and `TEST_F` within the same test suite; all tests in a suite must use the same fixture.
- Avoid underscores `_` in test suite and test names to prevent name conflicts.
- Use `ASSERT_*` when failing the test should stop further execution inside the test; use `EXPECT_*` to continue and accumulate errors.
- Remember GoogleTest creates a fresh fixture object per test, so avoid relying on state persisting across tests in the same fixture.
- Use `SCOPED_TRACE` to add context to failures inside helper functions or loops.

---

## Summary

GoogleTest offers flexible macros to declare tests and re-use code efficiently:

- Use `TEST()` for simple standalone tests.
- Use `TEST_F()` with test fixtures for shared setup/teardown.
- Create fixtures by subclassing `testing::Test`, overriding lifecycle methods.
- For dynamic or complex test generation, use `RegisterTest()`.

Mastering these declarations lets you write maintainable and scalable tests aligned to your C++ code architecture.

---

## Additional Resources

- [GoogleTest Primer](primer.md) - Introduction and core concepts.
- [Assertions and Failure Handling](reference/assertions.md) - Details on assertions.
- [Test Fixtures & Code Reuse Guide](guides/core-test-design/test-fixtures-sharing-code.md) - Best practices with fixtures.
- [Parameterized and Typed Tests](reference/testing.md#parameterized-tests) - Extending tests with parameters.
- [Advanced GoogleTest Topics](docs/advanced.md) - In-depth info on assertions and fixtures.

---

_For full macro and class declarations, see the [Testing Reference](reference/testing.md#TEST), [Primer](primer.md), and the GoogleTest header files._


