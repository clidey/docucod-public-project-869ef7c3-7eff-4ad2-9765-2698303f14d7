---
title: "Assertions API"
description: "Comprehensive reference for all supported assertion macros and utilities. Explore how to make your tests expressive and robust by leveraging equality, inequality, exception, and user-defined checks, including fatal versus non-fatal failures."
---

# Assertions API

Comprehensive reference for all supported assertion macros and utilities in GoogleTest. This documentation will help you make your tests expressive and robust by leveraging various assertion types including equality, inequality, exception, and user-defined checks. It also covers the differentiation between fatal and non-fatal failures to help you control test flow effectively.

---

## Overview of Assertions

GoogleTest provides an extensive set of assertion macros that fall into paired forms:
- **`EXPECT_` macros:** Generate non-fatal failures, allowing the test to continue
- **`ASSERT_` macros:** Generate fatal failures and abort the current test function

Each assertion supports streaming custom failure messages to provide context upon failure.

Use assertions to verify conditions, comparisons, exceptions, and predicates in your tests, guiding test success or failure clearly.

---

## Explicit Success and Failure

Sometimes you want to explicitly mark success or failure regardless of conditions.

### SUCCEED

`SUCCEED()` generates a success signal but does not alter the overall test outcome.

Example:
```cpp
SUCCEED(); // Marks point of success, useful for documentation
```

### FAIL

`FAIL()` generates a fatal failure, aborting the current test function.

Example:
```cpp
if (unexpected_case) {
  FAIL() << "Reached an impossible state";
}
```

### ADD_FAILURE

`ADD_FAILURE()` generates a nonfatal failure and continues running the current function.

Example:
```cpp
if (some_condition) {
  ADD_FAILURE() << "A warning about this condition";
}
```

---

## Boolean Condition Assertions

Verify boolean expressions easily.

- **`EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`**: Verify a condition is true
- **`EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`**: Verify a condition is false

Example:
```cpp
EXPECT_TRUE(value > 0) << "Value must be positive";
ASSERT_FALSE(pointer == nullptr) << "Pointer must not be null";
```

---

## Binary Comparison Assertions

Compare two values with various operators. These generate detailed error messages showing expected and actual values.

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`: Verifies equality (`==`)
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`: Verifies inequality (`!=`)
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`: Verifies less than (`<`)
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`: Verifies less or equal (`<=`)
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`: Verifies greater than (`>`)
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`: Verifies greater or equal (`>=`)

**Note:**
- For C strings, use string-specific assertions such as `EXPECT_STREQ`.
- When comparing pointers with `NULL`, use `nullptr` instead.

Example:
```cpp
EXPECT_EQ(result, 42) << "Unexpected result value";
ASSERT_LT(size, max_size) << "Size exceeded maximum";
```

---

## String Comparison Assertions (For C-strings)

Specialized for C-string comparisons:

- `EXPECT_STREQ(str1, str2)`: Compare for equality by content
- `EXPECT_STRNE(str1, str2)`: Verify strings differ by content
- `EXPECT_STRCASEEQ(str1, str2)`: Compare ignoring case
- `EXPECT_STRCASENE(str1, str2)`: Verify difference ignoring case

Example:
```cpp
EXPECT_STREQ(message, "Success") << "Messages do not match";
```

---

## Floating-Point Comparison Assertions

Due to precision issues, floating-point values require approximate comparisons:

- `EXPECT_FLOAT_EQ(val1, val2)`: Approximate equality of floats
- `EXPECT_DOUBLE_EQ(val1, val2)`: Approximate equality of doubles
- `EXPECT_NEAR(val1, val2, abs_error)`: Absolute difference within tolerance

Example:
```cpp
EXPECT_NEAR(3.1415, pi_value, 0.0001) << "Pi approximation off";
```

---

## Exception Assertions

Verify code throws or does not throw exceptions.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW`: Expects a specific exception
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW`: Expects any exception
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW`: Expects no exceptions

Example:
```cpp
EXPECT_THROW(DangerousOperation(), std::runtime_error);
EXPECT_NO_THROW(SafeOperation());
```

---

## Predicate Assertions

Allow verifying predicates or arbitrary boolean functions with detailed failure messages.

- `EXPECT_PREDn(pred, val1, val2, ...)`: Validates predicate with `n` arguments
- `EXPECT_PRED_FORMATn(formatter, val1, val2, ...)`: Uses custom predicate-formatter function for enhanced output

Example:
```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, value);
```

---

## Matching with Matchers Using `EXPECT_THAT`

For flexible assertions on complex values, GoogleTest integrates with GoogleMock's matcher framework.

- `EXPECT_THAT(value, matcher)` / `ASSERT_THAT`: Test if `value` satisfies the given matcher

Example:
```cpp
EXPECT_THAT(name, StartsWith("John"));
EXPECT_THAT(numbers, ElementsAre(1, 2, 3));
```

Matchers provide expressive ways to verify complex structures and conditions.

---

## Windows HRESULT Assertions

Convenient assertions for verifying Windows `HRESULT` values.

- `EXPECT_HRESULT_SUCCEEDED(expression)` / `ASSERT_HRESULT_SUCCEEDED`: Checks for success
- `EXPECT_HRESULT_FAILED(expression)` / `ASSERT_HRESULT_FAILED`: Checks for failure

Example:
```cpp
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
```

---

## Death Assertions

Verify that code terminates the process as expected.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH`: Verify death with matching output
- Variants include `EXPECT_DEBUG_DEATH`, `EXPECT_DEATH_IF_SUPPORTED`, and `EXPECT_EXIT`

Example:
```cpp
EXPECT_DEATH(CheckPointer(nullptr), "null pointer detected");
```

---

## Practical Examples

### Basic Equality Check

```cpp
TEST(FooTest, EqualCheck) {
  int result = ComputeValue();
  EXPECT_EQ(result, 10) << "Result did not match expected value";
}
```

### Floating-Point Near Comparison

```cpp
TEST(MathTest, PiApproximation) {
  const double pi = 3.1415926535;
  EXPECT_NEAR(CalculatePi(), pi, 1e-9);
}
```

### Exception Checking

```cpp
TEST(ThrowingTest, ThrowsOnInvalid) {
  EXPECT_THROW(FunctionThatThrows(-1), std::invalid_argument);
}
```

### Using a Matcher

```cpp
TEST(NameTest, StartsCorrectly) {
  std::string name = GetUserName();
  EXPECT_THAT(name, StartsWith("Test"));
}
```

### Custom Predicate Assertion

```cpp
bool IsPositive(int x) { return x > 0; }

TEST(PredicateTest, PositiveValues) {
  EXPECT_PRED1(IsPositive, GetValue());
}
```

---

## Best Practices

- Use **`EXPECT_`** assertions when the test can continue after a failure.
- Use **`ASSERT_`** assertions when failure should stop the current test immediately.
- Prefer `EXPECT_THAT` with matchers for expressive and flexible conditions.
- Use floating-point assertions (`EXPECT_FLOAT_EQ`, `EXPECT_NEAR`) rather than `EXPECT_EQ` to avoid precision pitfalls.
- Provide descriptive failure messages with `<<` for easy debugging.
- For exception testing, ensure exceptions are enabled in your build.

---

## Troubleshooting Common Pitfalls

- Comparing C strings with `EXPECT_EQ` checks pointer equality, not content; use `EXPECT_STREQ` instead.
- When floating-point comparisons fail unexpectedly, use `EXPECT_NEAR` or related floating-point macros instead of `EXPECT_EQ`.
- Avoid side effects in predicates passed to predicate assertions.
- Use `ASSERT_` if subsequent code depends on an assertion's success.

---

## References and Related Documentation

- [GoogleTest Primer](../getting-started/first-test-and-validation/quickstart-primer)
- [Matchers Reference](../reference/matchers.md)
- [GoogleMock for Dummies](../docs/gmock_for_dummies.md)
- [GoogleMock Cookbook](../docs/gmock_cook_book.md)
- [Writing & Running Tests](../core-testing-apis/writing-and-running-tests.mdx)

<br/>

---

Feel empowered with Google's robust assertion suite, enabling precise, readable, and maintainable tests.

