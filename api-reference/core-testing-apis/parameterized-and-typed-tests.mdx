---
title: "Parameterized and Typed Tests"
description: "Explains how to define and instantiate parameterized and type-parameterized tests to maximize coverage across multiple input values and data types. Includes practical examples for advanced test scenarios."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write concise, reusable tests that cover a range of input values and data types without duplicating code. This page explains how to define and instantiate **value-parameterized tests** and **type-parameterized tests**, enabling you to maximize test coverage effectively and elegantly. You'll find clear explanations, step-by-step guidance, concrete examples, and best practices for advanced testing scenarios.

---

## Table of Contents

- [Introduction to Parameterized Tests](#introduction-to-parameterized-tests)
- [Value-Parameterized Tests](#value-parameterized-tests)
  - [Defining a Value-Parameterized Test Fixture](#defining-a-value-parameterized-test-fixture)
  - [Writing Parameterized Test Cases with `TEST_P`](#writing-parameterized-test-cases-with-test_p)
  - [Instantiating Parameterized Tests with `INSTANTIATE_TEST_SUITE_P`](#instantiating-parameterized-tests-with-instantiate_test_suite_p)
  - [Common Parameter Generators](#common-parameter-generators)
  - [Custom Parameter Naming](#custom-parameter-naming)
  - [Abstract Tests and Library Usage](#abstract-tests-and-library-usage)
  - [Best Practices and Troubleshooting](#best-practices-and-troubleshooting)
- [Typed Tests and Type-Parameterized Tests](#typed-tests-and-type-parameterized-tests)
  - [Defining Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`](#defining-typed-tests-with-typed_test_suite-and-typed_test)
  - [Type-Parameterized Tests with `_P` Variants](#type-parameterized-tests-with-_p-variants)
  - [Registering and Instantiating Type-Parameterized Tests](#registering-and-instantiating-type-parameterized-tests)
  - [Custom Type Naming](#custom-type-naming)
- [Summary](#summary)

---

## Introduction to Parameterized Tests

Automated tests with repetitive logic but varying inputs can quickly become unmanageable if duplicated. Parameterized tests break through this challenge by allowing you to write a single test logic and run it against multiple inputs or types.

- **Value-Parameterized Tests** allow you to test your code across multiple *values*.
- **Typed and Type-Parameterized Tests** enable testing across multiple *types*.

This not only keeps your test code DRY but also increases confidence that your code behaves consistently across conditions.

---

## Value-Parameterized Tests

### Defining a Value-Parameterized Test Fixture

To start, write a fixture class derived from [`testing::TestWithParam<T>`](../reference/testing.md#TestWithParam) where `T` is the parameter type. `T` can be any copyable type.

```cpp
class MyValueParamTest : public ::testing::TestWithParam<int> {
  // Optional: define fixture setup here
};
```

If you already have a fixture class (e.g., `BaseTest`), you can separately inherit from `::testing::WithParamInterface<T>`:

```cpp
class BaseTest : public ::testing::Test { /*...*/ };

class DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {
  // ...
};
```

### Writing Parameterized Test Cases with `TEST_P`

Define your test logic using the `TEST_P` macro. Within the test, call `GetParam()` to access the current parameter:

```cpp
TEST_P(MyValueParamTest, HandlesPositiveNumbers) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}
```

You can define as many `TEST_P` tests as you like on that fixture.

### Instantiating Parameterized Tests with `INSTANTIATE_TEST_SUITE_P`

After defining the parameterized test suite, you need to instantiate it with specific parameter values.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveIntegers,  // Instantiation name prefix
    MyValueParamTest, // Test suite name
    testing::Values(1, 2, 3, 4));
```

This will generate tests with names like:
- `PositiveIntegers/MyValueParamTest.HandlesPositiveNumbers/0` for parameter `1`
- `PositiveIntegers/MyValueParamTest.HandlesPositiveNumbers/1` for parameter `2`

The instantiation happens at namespace or global scope, and the parameter generator is not evaluated until GoogleTest initialization.

### Common Parameter Generators

GoogleTest provides several handy parameter generators in the `::testing` namespace:

| Generator                           | Description                                                      |
|-----------------------------------|------------------------------------------------------------------|
| `Range(begin, end [, step])`       | Produces values from `begin` (inclusive) to `end` (exclusive)   |
| `Values(v1, v2, ..., vN)`          | Produces the supplied list of values                             |
| `ValuesIn(container)`               | Produces values from an STL container or C-array                |
| `Bool()`                          | Produces `false` and `true`                                      |
| `Combine(g1, g2, ..., gN)`         | Produces Cartesian product tuples from multiple generators      |

Example using `Range`:

```cpp
INSTANTIATE_TEST_SUITE_P(RangeTests, MyValueParamTest, testing::Range(1, 5, 2));
```

### Custom Parameter Naming

The last optional argument to `INSTANTIATE_TEST_SUITE_P` can be a custom function or functor to generate readable test parameter suffixes. It receives a `TestParamInfo` object.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyValueParamTest, 
    testing::Values(10, 20),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

This produces test names like `CustomNames/MyValueParamTest.HandlesPositiveNumbers/Val10`.

Note: Names must be unique and only contain alphanumeric characters or underscores.

### Abstract Tests and Library Usage

You can define parameterized test fixtures and test cases in a library, then instantiate them in multiple translation units. This is achieved by defining the fixture and `TEST_P` in a header/source pairing and instantiating via `INSTANTIATE_TEST_SUITE_P` in other places, maximizing reuse.

---

## Typed Tests and Type-Parameterized Tests

These tests focus on running the *same test logic* over multiple C++ types rather than values.

### Defining Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`

1. Define a class template fixture derived from `::testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value = T();
};
```

2. Associate a list of types with the fixture using `::testing::Types<...>` and the macro `TYPED_TEST_SUITE`:

```cpp
using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write typed tests using `TYPED_TEST`. Inside, the current type is accessed via `TypeParam`. Non-static members require `this->`.

```cpp
TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam val = this->value;
  // Test that val equals the expected default
}
```

### Type-Parameterized Tests with `_P` Variants

When the list of types is not known upfront or test logic is in a library, define a type-parameterized test suite that can be instantiated later:

- Use `TYPED_TEST_SUITE_P` to declare the test suite template.
- Use `TYPED_TEST_P` to define test cases.
- Register tests with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {
  ...
};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
  TypeParam val;
  ...
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething);
```

### Registering and Instantiating Type-Parameterized Tests

Later, instantiate the type-parameterized tests with types:

```cpp
using TypesList = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, TypesList);
```

You can instantiate multiple times with different type lists and prefixes.

### Custom Type Naming

`TYPED_TEST_SUITE` and `INSTANTIATE_TYPED_TEST_SUITE_P` optionally take a third/fourth argument to customize type names in test suite names, via a class exposing a templated static `GetName(int)` method.

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
  }
};

TYPED_TEST_SUITE(MyTypedTest, ::testing::Types<int, double>, TypeNames);
```

Named tests will include these custom suffixes, improving clarity in reports.

---

## Summary

Parameterized and type-parameterized tests in GoogleTest allow you to write flexible, compact, and powerful test suites that cover a broad range of inputs and types. By defining fixtures inheriting from `TestWithParam<T>` or templates deriving from `::testing::Test`, and then using `TEST_P`, `TYPED_TEST`, or their variants with macro-based instantiations, you ensure comprehensive test coverage with reduced code duplication.

Your journey now continues with leveraging these features in test libraries, writing custom parameter and type naming functions, and exploring advanced generator combinations via `Combine()`, `ConvertGenerator()`, and `Bool()`.

Explore related guides such as the [Writing Effective Tests: Parameterized and Typed Tests](../guides/writing-effective-tests/parameterized-typed-tests.md) for a narrative introduction, and the [Testing Reference](../reference/testing.md) for full API details.

---

### Code Example: Simple Parameterized Test

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Code Example: Typed Test

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T zero = T();
};

using MyNumericTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(NumericTest, MyNumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(this->zero, TypeParam{});
}
```

---

### Troubleshooting Tips

- Always instantiate your value-parameterized tests with `INSTANTIATE_TEST_SUITE_P` to prevent failing test warnings.
- Parameter names generated by default may be unreadable for complex types; consider custom naming functions.
- For type-parameterized tests, register all typed tests before instantiation using `REGISTER_TYPED_TEST_SUITE_P`.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when deliberately not instantiating a test suite (e.g., in abstract libraries).

---

### Visualizing the Parameterized Test Flow

```mermaid
flowchart TD
  A[Define Test Fixture Derived From TestWithParam<T>] --> B[Write TEST_P Test Cases Using GetParam()]
  B --> C[Instantiate Tests Using INSTANTIATE_TEST_SUITE_P with Parameter Generator]
  C --> D[GoogleTest Expands Each Parameter Into Unique Test Instances]
  D --> E[Run Tests With Each Parameter]
  E --> F{Test Result}
  F -->|Pass| G[Success]
  F -->|Fail| H[Failure with Parameter Details]
```

---

### Related Documentation

- [Testing Reference - Parameterized Tests and Typed Tests](../reference/testing.md#TEST_P)
- [Advanced Guide - Parameterized and Typed Tests](../guides/writing-effective-tests/parameterized-typed-tests.md)
- [Test Organization and Patterns](../guides/writing-effective-tests/test-patterns.md)

---

By mastering parameterized and typed tests, you bring efficiency and clarity to your testing framework, ensuring reliable code through systematic validation across input spaces and data types.


<Source url="https://github.com/google/googletest" paths='[{"path": "googletest/include/gtest/gtest-param-test.h", "range": "1-345"}, {"path": "googletest/include/gtest/gtest-typed-test.h", "range": "1-231"}, {"path": "googletest/test/googletest-param-test-test.cc", "range": "1-406"}, {"path": "googletest/test/gtest-typed-test_test.cc", "range": "1-400"}]' />