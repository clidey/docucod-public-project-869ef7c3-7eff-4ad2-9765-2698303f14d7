---
title: "Parameterized and Typed Tests"
description: "Explains how to set up tests that run across different values or types. Details on the APIs for value-parameterized and type-parameterized tests, covering generators, registration, and instantiation."
---

# Parameterized and Typed Tests

GoogleTest offers powerful mechanisms to write flexible, reusable tests that run across different values or type sets. This page guides you through setting up **value-parameterized tests** and **type-parameterized tests**—two essential capabilities for scaling your test coverage without duplicating code.

---

## Value-Parameterized Tests

Value-parameterized tests let you run the same test logic with multiple input values, enabling comprehensive validation against varied data sets or configurations with minimal boilerplate.

### Creating a Value-Parameterized Test

1. **Define a Test Fixture**: Derive your fixture from `testing::TestWithParam<T>` (or equivalently from both `testing::Test` and `testing::WithParamInterface<T>`), where `T` is the type of your test parameter.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture code here
};
```

2. **Write Tests Using `TEST_P`**: Define individual parameterized tests with `TEST_P`. Inside your test body, access the parameter using `GetParam()`.

```cpp
TEST_P(FooTest, DoesBehavior) {
  int param = GetParam();
  EXPECT_TRUE(SomeFunction(param));
}
```

3. **Instantiate the Test Suite**: Use `INSTANTIATE_TEST_SUITE_P` to specify the parameter values that cause GoogleTest to expand and run the test multiple times.

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveValues,
    FooTest,
    testing::Values(1, 2, 3));
```

- GoogleTest provides generators to create parameter sequences:
  - `Values(...)` - explicit value lists
  - `ValuesIn(container)` - use from container/array
  - `Range(start, end, [step])` - sequences within a range
  - `Bool()` - generate `true` and `false` flags
  - `Combine(...)` - Cartesian product of multiple generators

4. **Optional: Custom Test Names**

You can supply a function or functor to generate human-friendly test names based on the parameter.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedInstantiation,
    FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

### Use Cases

- Testing a function or class against multiple input values without copy-pasting
- Verifying that different configuration flags produce correct behaviors
- Automating tests over collections of data, such as enums, strings, or tuples

### Practical Tips

- Ensure your parameter type `T` is copyable.
- Manage lifetime for raw pointer parameters carefully.
- Place instantiation macros at namespace/global scope (not inside functions).
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if you declare tests but have no instantiation.

### Example

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

---

## Typed Tests

Typed tests allow you to write a test once and run it across multiple types. This is powerful when testing generic code or interface implementations across varying template types.

### Writing Typed Tests

1. **Define a Fixture Template**

Create a class template derived from `testing::Test` parameterized by a type.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  // Optional type aliases, static members
  using ValueType = T;
  T value_ = T{};
};
```

2. **Declare a Type List**

Use `testing::Types<T1, T2, ...>` to specify the list of types to test.

```cpp
using MyTypes = ::testing::Types<int, double, char>;
```

3. **Associate Types With Test Suite**

Use `TYPED_TEST_SUITE` to connect your fixture template with the type list.

```cpp
TYPED_TEST_SUITE(FooTest, MyTypes);
```

4. **Define Tests with `TYPED_TEST`**

Use `TYPED_TEST` to define tests inside the templated fixture. The special identifier `TypeParam` represents the current test type.

```cpp
TYPED_TEST(FooTest, HasDefaultValue) {
  TypeParam default_value{};
  EXPECT_EQ(this->value_, default_value);
}
```

### Use Cases

- Verifying multiple container types (e.g., `std::vector<int>`, `std::list<int>`) conform to interface requirements
- Testing template classes over integral, floating-point, or user-defined types
- Reusing test logic for multiple underlying type instantiations

### Customizing Names

You can provide a **type name generator** class with a static template method:

```cpp
class TypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if (std::is_same<T, int>::value) return "Int";
    if (std::is_same<T, double>::value) return "Double";
    return "Other";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, TypeNames);
```

This customizes test suite names in test output.

### Example

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  T value_ = T{};
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(FooTest, MyTypes);

TYPED_TEST(FooTest, ValueIsDefaultConstructed) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```

---

## Type-Parameterized Tests

Type-parameterized tests are an extension of typed tests: you define a test pattern without binding it to types.

Later, possibly in different source files, you instantiate that pattern with specific type lists.

### Writing Type-Parameterized Tests

1. **Define a Fixture Template** just like typed tests.

```cpp
template <typename T>
class FooTest : public testing::Test {
  // ...
};
```

2. **Declare the Test Suite as Type-Parameterized**

Use `TYPED_TEST_SUITE_P(FooTest);`

3. **Write Tests with `TYPED_TEST_P`**

```cpp
TYPED_TEST_P(FooTest, DoesSomething) {
  TypeParam val{};
  EXPECT_TRUE(DoWork(val));
}
```

4. **Register the Tests**

Use `REGISTER_TYPED_TEST_SUITE_P` to list your tests.

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesSomething);
```

5. **Instantiate the Suite**

Finally, bind the suite to actual types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = ::testing::Types<int, float>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, FooTest, MyTypes);
```

---

## Parameterized Test Generators

GoogleTest provides several generators to supply parameters:

- **Range:** Sequential values 
  ```cpp
  testing::Range(0, 10, 2);  // 0, 2, 4, 6, 8
  ```
- **Values:** Explicit values
  ```cpp
  testing::Values(1, 2, 3);
  ```
- **ValuesIn:** Fetch from array or container
  ```cpp
  std::vector<std::string> names = {"Alice", "Bob"};
  testing::ValuesIn(names);
  ```
- **Bool:** Produces `false` and `true`
- **Combine:** Produces product of multiple generators
  ```cpp
  testing::Combine(testing::Bool(), testing::Values(1, 2));
  ```
- **ConvertGenerator:** Convert generated values with a function


---

## Best Practices and Common Pitfalls

- Keep your test parameter types simple and copyable.
- Custom test name functions should generate unique, valid names only containing alphanumeric characters or underscores.
- Avoid calling `INSTANTIATE_TEST_SUITE_P` inside functions or classes.
- Always match value-parameterized fixtures (`TestWithParam<T>`) with `TEST_P` and typed test templates with `TYPED_TEST`.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to avoid failures when a parameterized test is declared but not instantiated.

---

## Troubleshooting

- **No tests run**: Ensure you instantiated your parameterized test suites properly with `INSTANTIATE_TEST_SUITE_P`.
- **Duplicate test names**: Custom parameter name generators must produce unique names.
- **Compilation errors**: Confirm your parameter type matches usages of `GetParam()`.
- **Tests not parameterized as expected**: Parameter generators are evaluated only during `InitGoogleTest()`, so mutable values changed after will not be reflected.

---

For detailed API usage, parameter generator options, and examples, consult the [Testing Reference - Parameterized and Typed Tests](reference/testing.md#parameterized-and-typed-tests), and the [Advanced Topics](advanced.md#value-parameterized-tests).


---

<Callout title="Related Documentation" type="info">
- [GoogleTest Primer](primer.md) — foundational concepts about tests and fixtures.
- [Testing Reference: Parameterized and Typed Tests](reference/testing.md#parameterized-and-typed-tests) — detailed API documentation.
- [Advanced Topics: Value-Parameterized and Typed Tests](advanced.md#value-parameterized-tests) — extended best practices and patterns.
- [GoogleTest GitHub Repository](https://github.com/google/googletest) — source and examples.
</Callout>
