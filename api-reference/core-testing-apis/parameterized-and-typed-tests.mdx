---
title: "Parameterized and Typed Tests"
description: "API documentation for writing parameterized and typed tests—allowing developers to efficiently test their code with varying input values and types. Includes macros, test declarations, generators, and instantiation patterns."
---

# Parameterized and Typed Tests

API documentation for writing parameterized and typed tests—allowing developers to efficiently test their code with varying input values and types. Includes macros, test declarations, generators, and instantiation patterns.

---

## Overview

GoogleTest empowers you to write tests that execute the same logic across multiple values or types without duplicating code. This is crucial when you want to verify that your code behaves correctly under a variety of conditions or type scenarios.

This page focuses exclusively on the API elements and mechanisms GoogleTest exposes for authoring:

- **Value-Parameterized Tests**: Reusing test patterns with values that vary across executions.
- **Typed Tests**: Repeating the same test for multiple C++ types.
- **Type-Parameterized Tests**: Abstract test patterns instantiated later with specific types.

By mastering these, you leverage GoogleTest's ability to scale test coverage efficiently.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to write a test once and run it multiple times with different input values. This is perfect for validating your code against a range of inputs or configurations.

### Workflow

1. **Define a Test Fixture Class** 

Derive a fixture from `testing::TestWithParam<T>`, where `T` is the type of the varying parameter value.

```cpp
class MyTest : public ::testing::TestWithParam<int> {
  // Optional fixture members here.
};
```

2. **Write Your Tests Using `TEST_P` Macro**

Define tests that use the parameter via `GetParam()`. The `_P` signifies these are parameterized.

```cpp
TEST_P(MyTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

3. **Instantiate Test Suites with Parameters**

Use the `INSTANTIATE_TEST_SUITE_P` macro to supply different values or generators that produce values.

```cpp
INSTANTIATE_TEST_SUITE_P(EvenValues, MyTest, ::testing::Values(2, 4, 6, 8));
```

Multiple generators are available to construct flexible parameter lists:

| Generator               | Description                                                     |
|-------------------------|-----------------------------------------------------------------|
| `Range(begin, end [,step])` | Generates a sequence `{begin, begin+step, ...}` excluding `end`. Defaults `step=1`. |
| `Values(v1, v2, ..., vN)` | Yields explicit values `{v1, v2, ..., vN}`.                       |
| `ValuesIn(container)`       | Pulls values from containers or arrays.                         |
| `Bool()`                   | Yields `{false, true}`, useful for flag testing.                |
| `Combine(g1, ..., gN)`     | Produces Cartesian product of multiple generators’ outputs.     |

#### Example: Using Combine to Test Multiple Flags

```cpp
class FlagTest : public testing::TestWithParam<std::tuple<bool, bool>> {};

TEST_P(FlagTest, CheckFlags) {
  auto [flag1, flag2] = GetParam();
  EXPECT_TRUE(flag1 || flag2);
}

INSTANTIATE_TEST_SUITE_P(
    BoolCombos, FlagTest,
    testing::Combine(testing::Bool(), testing::Bool()));
```

### Custom Naming of Parameterized Tests

To generate meaningful test names for parameterized instances, GoogleTest offers an optional last argument for `INSTANTIATE_TEST_SUITE_P` that is a callable producing a suffix string from the test parameter:

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedInstances, MyTest, testing::Values(1, 2, 3),
  [](const testing::TestParamInfo<MyTest::ParamType>& info) {
    return "Value_" + std::to_string(info.param);
  });
```

This improves test output readability and filtering.

### Handling Explicit and Complex Converts

If your parameter type isn't directly convertible from the generator's type, wrap the generator with `ConvertGenerator` to cast or transform generated values before they are passed:

```cpp
class MyParam {
public:
  explicit MyParam(std::tuple<int, bool> t);
};

INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTest,
    testing::ConvertGenerator<std::tuple<int, bool>>(
        testing::Combine(testing::Values(0, 1), testing::Bool())));
```

Alternatively, use a lambda to convert:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTest,
    testing::ConvertGenerator(
        testing::Combine(testing::Values(1, 2), testing::Bool()),
        [](std::tuple<int, bool> t) {
          return MyParam{std::get<0>(t), std::get<1>(t)};
        }));
```

### Allowing Uninstantiated Parameterized Tests

If you only define parameterized tests via `TEST_P` but instantiate them dynamically or not at all, prevent warnings using:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTest);
```

---

## Typed Tests

Typed tests enable you to execute the same test logic for different types, ideal for testing template code across multiple type arguments.

### Key Steps

1. **Define a Fixture Class Template**

Create a class template derived from `testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
  // Useful typedef example
  using ValueType = T;
};
```

2. **Associate Type List with the Fixture**

Use `TYPED_TEST_SUITE` to specify which types to test.

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Define Tests with `TYPED_TEST`**

Write tests with the macro `TYPED_TEST` that runs the test body for each type.

Inside the test, refer to the type as `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam obj{};
  EXPECT_EQ(obj, obj);
}
```

### Optional Custom Type Names

You can specify a third argument to `TYPED_TEST_SUITE` to customize test suite names per type by implementing a static templated `GetName(int)` method.

```cpp
class TypeNameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, float>) return "Float";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, TypeNameGenerator);
```

---

## Type-Parameterized Tests

Type-parameterized tests allow defining abstract test logic independent of the types to be tested, instantiating them with different type lists later, multiple times if needed.

### Workflow

1. **Define a Fixture Template and Declare Pattern**

```cpp
template <typename T>
class MyParamTest : public testing::Test {
  // Test internals
};

TYPED_TEST_SUITE_P(MyParamTest);
```

2. **Define Tests Using `TYPED_TEST_P`**

```cpp
TYPED_TEST_P(MyParamTest, TestOne) {
  TypeParam value{};
  EXPECT_TRUE(SomePredicate(value));
}

TYPED_TEST_P(MyParamTest, TestTwo) {
  TypeParam value{};
  EXPECT_EQ(value, value);
}
```

3. **Register Test Names**

Before instantiating, register tests with their names:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyParamTest, TestOne, TestTwo);
```

4. **Instantiate the Test Suite with Types**

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyParamTest, MyTypes);
```

Like typed tests, the instantiation will run the test cases for each type.

---

## Macros Summary

| Macro                       | Purpose                                                         |
|-----------------------------|-----------------------------------------------------------------|
| `TEST(TestSuite, TestName)`   | Define a regular test                                             |
| `TEST_F(Fixture, TestName)`   | Define a test using a fixture                                     |
| `TEST_P(Fixture, TestName)`   | Define a value-parameterized test using fixture                   |
| `INSTANTIATE_TEST_SUITE_P`   | Instantiate a value-parameterized test suite with parameters     |
| `TYPED_TEST_SUITE(Fixture, Types)` | Associate a fixed list of types with a typed test fixture    |
| `TYPED_TEST(Fixture, TestName)`     | Define a typed test for all types in the associated type list     |
| `TYPED_TEST_SUITE_P(Fixture)`        | Declare a type-parameterized test suite                          |
| `TYPED_TEST_P(Fixture, TestName)`    | Define a test in a type-parameterized test suite                 |
| `REGISTER_TYPED_TEST_SUITE_P` | Register tests of a type-parameterized test suite                |
| `INSTANTIATE_TYPED_TEST_SUITE_P` | Instantiate a type-parameterized test suite with types           |
| `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` | Suppress warnings for uninstantiated value-parameterized tests |

---

## Practical Tips & Best Practices

- **Test Naming**: Avoid underscores (`_`) in test suite and test names to prevent issues with GoogleTest's naming conventions.

- **Instantiation Timing**: Place `INSTANTIATE_TEST_SUITE_P` at global or namespace scope, never within functions, to ensure proper test discovery.

- **Custom Test Names**: For value-parameterized tests, provide custom name generators when testing with types or values whose default `PrintToString` representation would be unclear (e.g., strings).

- **Managing Test Suite Setup**: If `SetUpTestSuite()` or `TearDownTestSuite()` are defined, keep them `public` to avoid issues especially in parameterized tests.

- **Abstract Tests**: Use type-parameterized tests or abstract value-parameterized tests to build reusable test suites that other projects or components can instantiate with their own parameters or types.

- **Prevent Fake Failures**: Always instantiate your parameterized test suites. Otherwise, GoogleTest reports failures about tests being defined but not instantiated.

- **Complex Parameter Types**: Use `ConvertGenerator` for parameters requiring explicit conversions from the generated types.

---

## Example: Value-Parameterized Tests

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {};

TEST_P(MyValueTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers, MyValueTest,
    testing::Values(1, 2, 3, 4));
```

This code will run the `IsPositive` test four times with parameters 1, 2, 3, and 4.

---

## Example: Typed Tests

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsSigned) {
  EXPECT_TRUE(std::numeric_limits<TypeParam>::is_signed);
}
```

This runs `IsSigned` test for all listed types.

---

## Example: Type-Parameterized Tests

```cpp
template <typename T>
class HasEqualOperatorTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(HasEqualOperatorTest);

TYPED_TEST_P(HasEqualOperatorTest, CanCompareEqual) {
  TypeParam a, b;
  EXPECT_TRUE(a == b);
}

REGISTER_TYPED_TEST_SUITE_P(HasEqualOperatorTest, CanCompareEqual);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, HasEqualOperatorTest, MyTypes);
```

---

## Common Pitfalls & Troubleshooting

- **Forgetting to Instantiate**: If you define `TEST_P` tests without a corresponding `INSTANTIATE_TEST_SUITE_P`, GoogleTest reports failures in `GoogleTestVerification`. Fix by instantiating or explicitly allowing uninstantiated tests.

- **Parameter Generator Types**: Generated types might not exactly match your fixture parameter type. Use `ConvertGenerator` to resolve conversion mismatches explicitly.

- **Invalid Test Names in Parameter Generator**: Parameter names generated must only contain ASCII alphanumeric characters and underscores. Avoid spaces, dashes, or other special characters.

- **Scope of `INSTANTIATE_TEST_SUITE_P`**: Must be declared at the global or namespace level, never inside a function.

- **Access to Private Members**: To test private members, use `FRIEND_TEST` macros or friend declarations in your classes.

---

## Related Macros and Classes

- **`GetParam()`**: Access the current parameter value within a `TEST_P` test body.
- **`TypeParam`**: Refers to the current type in a typed or type-parameterized test.
- **Parameter Generators**: Functions like `Values()`, `Range()`, `Combine()`, `Bool()` to generate test parameters.
- **`testing::TestWithParam<T>`**: Convenience base class for value-parameterized fixtures.

---

For in-depth coverage, explore [GoogleTest Primer](primer.md) and the [Testing Reference](reference/testing.md) which include annotated examples and usage scenarios.

You can also consult the sections on [Value-Parameterized Tests](advanced.md#value-parameterized-tests), [Typed Tests](advanced.md#typed-tests), and [Type-Parameterized Tests](advanced.md#type-parameterized-tests) in the Advanced Guide.

---

## Summary Diagram of Test Flows

```mermaid
flowchart TD
  A[Define Fixture (TestWithParam<T>)] --> B[Define TEST_P with GetParam()]
  B --> C[Instantiate with INSTANTIATE_TEST_SUITE_P using Value Generators]
  C --> D[GoogleTest Runs Tests Per Parameter]
  E[Define Typed Fixture Template<T>: Test] --> F[Associate Type List with TYPED_TEST_SUITE]
  F --> G[Define TYPED_TESTs using TypeParam]
  G --> H[Tests Run for Each Type in List]
  I[Define Type-Parameterized Fixture Template<T>: Test] --> J[Declare Pattern with TYPED_TEST_SUITE_P]
  J --> K[Define TYPED_TEST_P tests]
  K --> L[Register Tests with REGISTER_TYPED_TEST_SUITE_P]
  L --> M[Instantiate Tests with INSTANTIATE_TYPED_TEST_SUITE_P and Types]
  M --> N[Tests Run for Each Instantiated Type]
```

---

## Source Links

The core header files managing parameterized and typed tests, generators, and utilities:

- `gtest-param-test.h` - Implements value-parameterized macros and generators.
- `gtest-typed-test.h` - Implements typed and type-parameterized test macros.
- `gtest-param-util.h` - Provides supporting parameter generator implementations and utilities.

For concrete usage examples, see:

- `gtest-typed-test_test.cc` and `gtest-typed-test2_test.cc` for typed and instantiated tests.

---

This documentation is part of the GoogleTest C++ testing framework reference.

---