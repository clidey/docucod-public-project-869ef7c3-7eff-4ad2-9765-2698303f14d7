---
title: "Parameterized & Typed Tests"
description: "How to write and register value-parameterized and type-parameterized tests, enabling code coverage across input ranges and templated types. Includes setup patterns, sample code, and typical pitfalls."
---

# Parameterized & Typed Tests

Harness the full power of GoogleTest's parameterized and typed test macros to run your test logic across multiple input values and type combinations seamlessly. These advanced techniques empower you to write less repetitive, more maintainable test code that automatically expands test coverage through data-driven and type-driven patterns.

## Overview

Parameterized and typed tests enable you to define a test once and execute it multiple times with different parameters or types. This encourages reusable test logic, thorough validation across input ranges, and validation of template-based or polymorphic code.

- **Value-Parameterized Tests:** Run the same test logic with different input *values* supplied via parameter generators.
- **Typed Tests:** Create test fixtures based on a template parameterized by a *type*.
- **Type-Parameterized Tests:** More flexible typed tests where test patterns are defined independently and instantiated with specific types later.

## Value-Parameterized Tests

### What They Are

Value-parameterized tests let you test code against multiple input values without duplicating test logic. They are useful to validate behavior over ranges, configurations, or multiple implementations via parameter input.

### Defining Value-Parameterized Tests

1. **Define a test fixture class** derived from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the parameter type. Conveniently, inherit from `testing::TestWithParam<T>` which provides this:

```cpp
class FooTest : public testing::TestWithParam<const char*> {
  // Test fixture setup
};
```

2. **Define parameterized tests** using the `TEST_P` macro:

```cpp
TEST_P(FooTest, HandlesInput) {
  const auto& param = GetParam();
  EXPECT_TRUE(Process(param));
}
```

3. **Instantiate the test suite** with parameters using `INSTANTIATE_TEST_SUITE_P` and parameter generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values("alpha", "beta", "gamma"));
```

Test names generated will include the instantiation prefix and parameter index for easy filtering and debugging.

### Parameter Generators

GoogleTest offers versatile generators:

| Generator        | Behavior                                           |
| ---------------- | -------------------------------------------------|
| `Range(begin, end[, step])` | Sequences numbers in a range, excludes `end`.    |
| `Values(v1, ..., vN)`        | Explicit list of values.                         |
| `ValuesIn(container)`        | Values from containers or iterator ranges.      |
| `Bool()`                    | Yields `{false, true}`.                           |
| `Combine(g1, ..., gN)`      | Cartesian product of multiple generators, yielding `std::tuple`.

### Customizing Names

You can supply a name generator function/functor as the optional fourth argument of `INSTANTIATE_TEST_SUITE_P` for meaningful and valid test name suffixes based on parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInst, FooTest,
    testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

### Notes and Best Practices

- `TestName` and suite names **must not contain underscores (`_`)** to avoid internal naming conflicts.
- Parameters must be copyable. For pointers, lifetime management is your responsibility.
- Parameter generator expressions are evaluated during `InitGoogleTest()`, after `main()` starts, allowing dynamic setup.
- You can instantiate a suite multiple times to test different parameter sets.

## Typed Tests

### What They Are

Typed tests let you run the same test logic on multiple types. This is valuable when validating class or function templates, or conforming to interfaces across types.

### Defining Typed Tests

1. **Define a test fixture class template** derived from `testing::Test` parameterized by a type:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  using List = std::list<T>;
  static T shared_;
  T value_;
};
```

2. **Associate a list of types** using `::testing::Types` and `TYPED_TEST_SUITE`:

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write typed tests** with `TYPED_TEST`, referring to the type by the special `TypeParam` identifier:

```cpp
TYPED_TEST(MyTypedTest, ProcessesValue) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  EXPECT_FALSE(values.empty());
}
```

### Optional: Custom Type Name Suffixes

You can specify a name generator class with a static templated `GetName(int index)` function to customize how type names appear on tests, aiding readability:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    return "unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Notes and Best Practices

- Typed test fixtures can have static data members shared across type instances.
- Non-static members must be accessed via `this` inside test bodies.
- Typed tests must be defined in the same translation unit as the suite via `TYPED_TEST_SUITE`.
- You can instantiate typed tests for a single type directly without wrapping in `Types<>`.

## Type-Parameterized Tests

### What They Are

Type-parameterized tests provide flexibility by defining type-parameterized test patterns independent of the types. Tests can be registered first, then instantiated later with different types, even across translation units. This suits interface or concept compliance tests that multiple implementations need to satisfy.

### Defining Type-Parameterized Tests

1. **Define a test fixture class template** similarly to typed tests:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // ...
};
```

2. **Declare the test suite as type-parameterized** with `_P` suffix macro:

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. **Define type-parameterized tests** with `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypeParamTest, DoesAction) {
  TypeParam value = 0;
  // ... test logic ...
}

TYPED_TEST_P(MyTypeParamTest, HasProperty) { ... }
```

4. **Register the test names** with `REGISTER_TYPED_TEST_SUITE_P`:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesAction, HasProperty);
```

5. **Instantiate the test suite** with specific types:

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

### Notes and Best Practices

- Type-parameterized test bodies must use `TypeParam` to refer to the current type.
- Tests are registered separately to allow reuse across multiple type instantiations.
- You can instantiate the same test suite in multiple translation units with different type lists.
- Custom name suffix generation can be applied in `INSTANTIATE_TYPED_TEST_SUITE_P` similar to typed tests.

## Practical Example: Typed Tests

```cpp
template <typename T>
class CommonTest : public testing::Test {
 public:
  static void SetUpTestSuite() { shared_ = new T(5); }
  static void TearDownTestSuite() { delete shared_; shared_ = nullptr; }

 protected:
  CommonTest() : value_(1) {}

  void SetUp() override { EXPECT_EQ(1, value_); value_++; }
  void TearDown() override { EXPECT_EQ(2, value_); value_++; }

  T value_;
  static T* shared_;
};

template <typename T>
T* CommonTest<T>::shared_ = nullptr;

using MyTypes = testing::Types<char, int>;
TYPED_TEST_SUITE(CommonTest, MyTypes);

TYPED_TEST(CommonTest, ValuesAreCorrect) {
  EXPECT_EQ(5, *TestFixture::shared_);
  EXPECT_EQ(2, this->value_);
}

TYPED_TEST(CommonTest, ValuesAreStillCorrect) {
  ASSERT_NE(nullptr, this->shared_);
  EXPECT_EQ(5, *this->shared_);
  EXPECT_EQ(2, this->value_);
}
```

## Typical Pitfalls and Tips

- **Underscore characters** in test suite or test names cause internal naming conflicts. Avoid them.
- Always call `InitGoogleTest` before `RUN_ALL_TESTS` to ensure proper flag parsing.
- Parameter generators are evaluated after `main()` starts, so prepare external dependencies beforehand.
- When using type-parameterized tests, register all tests before instantiation to avoid runtime errors.
- Use `SCOPED_TRACE` to add context messages inside test subroutines when assertions may fail, to clarify test failure origin.
- If you have a test suite where not all value-parameterized tests are instantiated, suppress warnings with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

## Troubleshooting

- **Test suite or test name collisions:** Renaming to avoid underscores or duplications resolves most.
- **Undefined references to static members:** Remember to define static members outside the class body.
- **Tests not running or missing:** Ensure correct usage of `INSTANTIATE_TEST_SUITE_P` for parameterized tests.
- **Compilation errors with COMMA inside type names:** Wrap type names containing commas with extra parentheses for `MOCK_METHOD` usage.

## Related Documentation

- [GoogleTest Primer](getting-started/first-test-validation/writing-your-first-test) — for first steps writing tests
- [Testing Reference](docs/reference/testing.md) — detailed API for `TEST`, `TEST_F`, `TEST_P`, etc.
- [Advanced GoogleTest Topics](docs/advanced.md) — detailed techniques for fixtures and test setup
- [Mocking Reference](docs/reference/mocking.md) — for advanced mocking scenarios
- [FAQ](docs/faq.md) — common questions including test naming and fixture design

## Summary

Parameterized and typed tests offer versatile, scalable means to execute your test code against broad input spaces and various type parameters. From value-driven test inputs to type-parameterized test patterns, GoogleTest provides robust macros to reduce repetition while increasing coverage and confidence.

For complex scenarios, type-parameterized tests unlock reusable test patterns, while value-parameterized tests facilitate dynamic, data-driven validation. Use the provided macros (`TEST_P`, `TYPED_TEST`, `TYPED_TEST_P`) with defined fixtures and instantiate with rich parameter generators or type lists to compose your test coverage efficiently.

---

<CardGroup cols={2}>
<Card title="Value-Parameterized Test Macro">
Use `TEST_P` for defining test logic that executes over various input parameters combined via `INSTANTIATE_TEST_SUITE_P`.
</Card>
<Card title="Typed Test Macro">
Use `TYPED_TEST` in conjunction with `TYPED_TEST_SUITE` to test over multiple types provided at compile-time.
</Card>
</CardGroup>

---

<Steps>
<Step title="Define Fixture">
Create a test fixture inheriting from `TestWithParam<T>` or `Test` template.
</Step>
<Step title="Write Tests">
Write tests using `TEST_P` or `TYPED_TEST` to implement test logic using params or types.
</Step>
<Step title="Instantiate Suites">
Use `INSTANTIATE_TEST_SUITE_P` or `TYPED_TEST_SUITE` to supply parameters or type lists.
</Step>
<Step title="Run Tests">
Initialize GoogleTest and execute tests with `RUN_ALL_TESTS()`.
</Step>
</Steps>

---

This completes the guide to Parameterized and Typed Tests in GoogleTest. Leveraging these features will significantly improve your testing flexibility and code quality.
