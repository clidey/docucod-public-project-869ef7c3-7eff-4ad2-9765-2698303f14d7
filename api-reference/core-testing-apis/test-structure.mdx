---
title: "Test Case and Fixture Structure"
description: "Overview of how to define test cases, fixtures, and typed/parameterized tests. Explains the macro APIs, class inheritance models, and configuration options used to set up and group tests for clear, scalable testing suites."
---

# Test Case and Fixture Structure

This page presents a detailed overview of how to define, organize, and structure test cases and fixtures within GoogleTest, including the use of typed and parameterized tests. It explains how to leverage the macro APIs, the inheritance models for test fixtures, and configuration options to create clear, maintainable, and scalable test suites.

---

## 1. Test Cases and Simple Tests

A *test case* in GoogleTest groups related tests logically. Each test in a test case exercises a specific behavior or scenario.

### Defining a Simple Test with `TEST`

Use the `TEST(TestSuiteName, TestName)` macro to create a test:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}
```

- The first argument is the test suite name (grouping tests).
- The second argument is the individual test name.
- Both must be valid C++ identifiers without underscores for simplicity and to avoid internal naming conflicts.

Each `TEST` is a standalone C++ function with no return value. Assertions inside determine the test's pass/fail state.

### Important Guidelines

- Keep test suite and test names simple, avoiding underscores (`_`). This prevents naming clashes and reserved identifier violations.
- Test suite names should group logically related tests.
- If two tests have the same suite and name in different namespaces, they are separate and allowed.

---

## 2. Test Fixtures: Sharing Common Setup with `TEST_F`

When multiple tests need to share initialization or teardown code, test fixtures provide a clean and structured way.

### Defining a Fixture Class

Create a class derived from `testing::Test`:

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Initialize data for each test
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};
```

- Use `protected:` access so derived tests can access members.
- Initialization can be done in constructor or `SetUp()`; prefer constructor for simple setups.
- Destructor or `TearDown()` may be overridden for cleanup.

### Using the Fixture in Tests

Refer to the fixture class in `TEST_F`:

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  auto* n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

Each test uses a fresh instance of the fixture, ensuring no cross-test contamination.

---

## 3. Typed Tests: Running the Same Test Code on Multiple Types

Typed tests enable executing the same tests for various types without code duplication.

### Defining Typed Test Suites

Declare a template test fixture:

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_;
};
```

List the types to test:

```cpp
using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyFixture, MyTypes);
```

### Writing Typed Tests

Use `TYPED_TEST` to define tests with access to `TypeParam` representing the current type:

```cpp
TYPED_TEST(MyFixture, HasDefaultValue) {
  TypeParam value = this->value_;
  // test something with value
}
```

Typed tests give compile-time type safety and help detect type-dependent bugs.

---

## 4. Value-Parameterized Tests: Running Tests with Different Parameters

These tests run the same code for a set of input values.

### Defining Parameterized Tests

Inherit from `testing::TestWithParam<T>` where `T` is the parameter type:

```cpp
class MyParamTest : public testing::TestWithParam<int> {};
```

Then define tests using `TEST_P`:

```cpp
TEST_P(MyParamTest, IsEven) {
  int param = GetParam();
  EXPECT_EQ(param % 2, 0);
}
```

### Instantiating Parameterized Tests

Generate test cases with `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyParamTest, testing::Values(2, 4, 6));
```

You can also use ranges, containers, or combinations for more complex parameters.

---

## 5. Naming and Best Practices

### Why Avoid Underscores in Test Names?

Underscores can cause internal symbol collisions or reserved identifier violations when GoogleTest generates code:

- Names are internally concatenated, meaning `TestSuite_TestName_Test` forms class names.
- Starting or ending with underscores or using multiple underscores may lead to errors or ambiguities.

### Fixture Construction

- Prefer constructors for simple setup and cleanup via destructors.
- Use `SetUp()` and `TearDown()` when:
  - Virtual dispatch is needed.
  - Assertions in setup and teardown are required.
  - Throwing exceptions or robust teardown logic is necessary.

### Test Isolation

Each `TEST` or `TEST_F` uses a new fixture instance, preventing shared state between tests.

---

## 6. Summary of Macros and Usage

| Macro                            | Purpose                                            |
|---------------------------------|----------------------------------------------------|
| `TEST(TestSuite, TestName)`      | Simple test without fixture.                        |
| `TEST_F(FixtureName, TestName)`  | Test using a fixture class for setup/teardown.    |
| `TYPED_TEST_SUITE(Fixture, Types)`| Define typed test suite over multiple types.     |
| `TYPED_TEST(Fixture, TestName)` | Define typed test, referring to `TypeParam`.       |
| `TEST_P(Fixture, TestName)`      | Define parameterized test with runtime params.    |
| `INSTANTIATE_TEST_SUITE_P`       | Instantiate parameterized tests with parameters.  |

---

## 7. Troubleshooting Tips

- Always define a default constructor for fixtures; GoogleTest needs to instantiate them.
- Watch for naming rules that prohibit underscores in test suite and test names.
- Use `ASSERT_*` assertions to guard against invalid data before dereferencing pointers.
- Avoid mixing `EXPECT_CALL` and mock method calls in arbitrary order; set expectations before using mocks.
- Be mindful of the volatile state in parameterized and typed tests to prevent shared mutable state issues.

---

## 8. Additional Resources

For more in-depth information and examples, please refer to:

- [GoogleTest Primer](overview/core-concepts-architecture/core-concepts-terminology.md)
- [Writing and Running Your First Test](getting-started/configuration-validation/first-test.md)
- [Parameterized and Typed Tests Guide](guides/core-workflows/parameterized-tests.md)

---

<CardGroup cols={2}>
<Card title="Quick Sample: Using `TEST_F`">
```cpp
class FooTest : public testing::Test {
 protected:
  FooTest() { count_ = 0; }
  int count_;
};

TEST_F(FooTest, IncrementCount) {
  count_++;
  EXPECT_EQ(count_, 1);
}

TEST_F(FooTest, StartsAtZero) {
  EXPECT_EQ(count_, 0);
}
```
</Card>
<Card title="Example: Typed Test">
```cpp
template <typename T>
class StackTest : public testing::Test {
 public:
  Stack<T> stack_;
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.IsEmpty());
}
```
</Card>
</CardGroup>

---

## 9. Visual Workflow

```mermaid
flowchart TD
  A[Write Test using TEST, TEST_F, TEST_P, or TYPED_TEST] --> B[Define Fixture if needed]
  B --> C[Add Setup and TearDown]
  C --> D[Add Test Logic and Assertions]
  D --> E[Compile and Run via RUN_ALL_TESTS()]
  E -->|Pass| F[Test Complete]
  E -->|Fail| G[Debug and Fix Test]
  G --> A
```

---

## 10. Key Best Practices

- Use **fixtures** to share common setup/teardown logic and data among related tests.
- Use **typed tests** to run the same test logic on multiple types, minimizing code duplication.
- Use **value-parameterized tests** to verify behaviors across diverse input data systematically.
- Avoid underscores in test and test suite names to prevent naming conflicts.
- Define **default constructors** to prevent instantiation errors.

---

This page equips you to structure your tests effectively using GoogleTest's core macros and fixture concepts, preparing you to write robust, maintainable, and scalable C++ tests.

---