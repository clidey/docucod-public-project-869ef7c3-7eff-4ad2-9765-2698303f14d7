---
title: "Mock Classes and MOCK_METHOD"
description: "Reference guide to declaring and implementing mock classes in your tests using the MOCK_METHOD macro suite. Details argument matching, signature declaration, and supported method qualifiers for fine-grained control over mock behavior."
---

# Mock Classes and MOCK_METHOD

This reference page details how to declare and implement mock classes in C++ tests leveraging the powerful `MOCK_METHOD` macro family from GoogleMock. It covers the syntax for mocking methods, argument handling, qualifiers, and advanced use cases to give you fine-grained control over mock behavior.

---

## Overview of Mock Classes and `MOCK_METHOD`

To create mocks for interfaces or classes in your tests, derive a mock class and declare mocked methods using the `MOCK_METHOD` macro. This macro takes 3 or 4 parameters that closely resemble the method signature:

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- **ReturnType**: The return type of the method.
- **MethodName**: The exact method name you want to mock.
- **Args...**: The full list of arguments enclosed in parentheses.
- **Specs...** (optional): A comma-separated list of qualifiers such as `const`, `override`, `noexcept`, calling conventions, and reference qualifiers.

All `MOCK_METHOD` declarations *must be placed inside the `public:` section* of your mock class regardless of the method's original access specifier.

You do not need to provide method definitions; `MOCK_METHOD` generates them automatically.

### Basic Example

Given the interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual void GoTo(int x, int y) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};
```

You can mock it as:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(void, GoTo, (int x, int y), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

This approach saves time and removes boilerplate, automatically generating mocks consistent with the interface.

### Handling Commas in Arguments

If your method involves template types or argument types with commas (e.g., `std::pair`, `std::map`), `MOCK_METHOD` can incorrectly parse the arguments. To avoid this, you have two options:

#### 1. Wrap argument types with parentheses

```cpp
class MyMock {
 public:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
};
```

#### 2. Use type aliases

```cpp
class MyMock {
 public:
  using BoolAndInt = std::pair<bool, int>;
  MOCK_METHOD(BoolAndInt, GetPair, ());
  using MapIntDouble = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

The second method is preferred for clarity and maintaining proper C++ syntax.

### Qualifiers Supported by `MOCK_METHOD`

The optional **fourth parameter** to `MOCK_METHOD` specifies additional qualifiers:

| Qualifier                | Description                                                                             |
|--------------------------|-----------------------------------------------------------------------------------------|
| `const`                  | Marks the mock method as a `const` method. Required if overriding a `const` method.     |
| `override`               | Adds the `override` keyword. Recommended when mocking virtual methods to catch mistakes.|
| `noexcept`               | Marks the method `noexcept`. Required if overriding a `noexcept` method.                |
| `Calltype(calltype)`     | Specifies calling convention (e.g., `Calltype(STDMETHODCALLTYPE)`) useful on Windows.   |
| `ref(&)` or `ref(&&)`    | Marks the method with a reference qualifier. Required to mock methods with ref qualifiers.|

Example:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
MOCK_METHOD(int, Bar, (double x, double y), (const, Calltype(STDMETHODCALLTYPE)));
```

### Mocking Overloaded Methods

You can mock overloaded methods naturally by providing distinct `MOCK_METHOD` declarations for each version:

```cpp
MOCK_METHOD(int, Add, (Element x), (override));
MOCK_METHOD(int, Add, (int times, Element x), (override));
MOCK_METHOD(Bar&, GetBar, (), (override));
MOCK_METHOD(const Bar&, GetBar, (), (const, override));
```

If you do not mock all overloads, use `using` declarations to bring the unaffected overloads into scope to avoid hiding them:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring hidden overloads into scope
  MOCK_METHOD(int, Add, (Element x), (override));
};
```

### Mocking Class Templates

Mock class templates behave the same as regular classes. Your mock should inherit from the template class and mock its virtual methods:

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};

template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

### Mocking Non-Virtual Methods

gMock can mock non-virtual methods using the same `MOCK_METHOD` syntax, without the `override` specifier.
This technique is useful for high-performance dependency injection. Because these mocks are unrelated to the real classes, you will typically use templates or other compile-time polymorphism to inject them in tests.

Example:

```cpp
class ConcretePacketStream {
 public:
  void AppendPacket(Packet* new_packet);
  const Packet* GetPacket(size_t packet_number) const;
  size_t NumberOfPackets() const;
};

class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};

// Use with a template
template <class PacketStream>
void CreateConnection(PacketStream* stream) { ... }
```

### Mocking Private or Protected Methods

`MOCK_METHOD` declarations must always be in the `public:` section of your mock class, even if the method being mocked is private or protected in the base class. This enables `EXPECT_CALL` and `ON_CALL` to access the mock methods from test code.

```cpp
class Foo {
 protected:
  virtual void Resume();
 private:
  virtual int GetTimeOut();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Resume, (), (override));
  MOCK_METHOD(int, GetTimeOut, (), (override));
};
```

### Old-Style `MOCK_METHODn` macros

Legacy macros like `MOCK_METHOD1`, `MOCK_CONST_METHOD2`, and variants with suffixes `_T` or `_WITH_CALLTYPE` exist for compatibility but the generic `MOCK_METHOD` macro is recommended.

---

## Usage Patterns and Tips

### Setting Expectations with `EXPECT_CALL`

`EXPECT_CALL` defines *expected* calls to mock methods, including argument matchers, call count (`Times()` clause), order, and return behavior.

Example:

```cpp
EXPECT_CALL(mock_object, MethodName(arg_matchers...))
  .Times(Exactly(2))
  .WillOnce(Return(1))
  .WillOnce(Return(2));
```

See more detailed usage at [EXPECT_CALL documentation](reference/mocking.md#EXPECT_CALL).

### Default Behaviors with `ON_CALL`

Use `ON_CALL` to define what a mock method should do when called but without asserting that it *must* be called.

Example:

```cpp
ON_CALL(mock_object, MethodName(_))
  .WillByDefault(Return(default_value));
```

This is useful for providing default return values or behaviors.

### Handling Move-Only Types

`MOCK_METHOD` supports mocking methods with move-only types (e.g., `std::unique_ptr`). Define as usual and provide custom lambda actions to create fresh move-only objects for each call if needed.

Example:

```cpp
MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));

EXPECT_CALL(mock_buzzer_, MakeBuzz("hello"))
  .WillOnce([](StringPiece) {
    return std::make_unique<Buzz>(AccessLevel::kInternal);
  });
```

To mock methods consuming move-only arguments:

```cpp
MOCK_METHOD(bool, ShareBuzz, (std::unique_ptr<Buzz> buzz, int64_t timestamp), (override));
EXPECT_CALL(mock_buzzer_, ShareBuzz(NotNull(), _)).WillOnce(Return(true));
```

### Delegating to Fakes or Real Objects

You can delegate mock method calls to an existing fake or real class instance for default behavior, preserving the ability to set expectations:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(char, DoThis, (int n), (override));

  MockFoo() {
    ON_CALL(*this, DoThis)
      .WillByDefault([this](int n) { return real_.DoThis(n); });
  }

 private:
  Foo real_;
};
```

### Mock Strictness and Behavior Levels

GoogleMock supports different strictness levels to control warnings or errors on uninteresting calls:

- `NiceMock<T>`: suppresses warnings on uninteresting calls.
- `NaggyMock<T>`: (default) warns on uninteresting calls.
- `StrictMock<T>`: treats uninteresting calls as errors.

These wrappers inherit from your mock class `T` and can be constructed with the same parameters.

### Naming and Managing Mock Methods

Use descriptive method and argument names. Always place mocks in appropriate test or dedicated namespaces. To improve compile time for large mocks, consider defining the mock class constructor and destructor in `.cc` files instead of inline.

---

## Example: Complete Mock Class Definition

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

---

## Troubleshooting

### Common Issues

- **Compile errors with commas in argument types:** Wrap the type in parentheses or use type aliases.
- **Overloading ambiguity:** Use `using Base::Method;` to prevent hiding base class methods.
- **Warning for const parameters:** Top-level `const` qualifiers on primitive parameters can trigger MSVC warnings; remove unnecessary const.
- **Destructors not called:** Ensure your base class has a virtual destructor.
- **Uninteresting call warnings:** Use `NiceMock` or add catch-all `EXPECT_CALL(...).Times(AnyNumber())` to suppress.

### Best Practices

- Always set expectations before exercising the mock.
- Use `RetiresOnSaturation()` to retire expectations once fulfilled.
- Use sequences (`Sequence` and `InSequence`) to specify order when important.
- Use `ON_CALL` for default behavior without constraining test.

---

## Further Reading and References

- [gMock for Dummies](docs/gmock_for_dummies.md) — Beginner-friendly guide
- [gMock Cookbook](docs/gmock_cook_book.md) — Advanced recipes and tips
- [Mocking Reference](docs/reference/mocking.md) — Detailed API and macro specs
- [Matchers Reference](api-reference/matchers-actions-cardinalities/argument-matchers) — Argument matching techniques
- [Actions Reference](api-reference/matchers-actions-cardinalities/actions-api) — Specifying mock method behaviors
- [Mock Strictness Wrappers](api-reference/mock-behavior-config/nice-naggy-strict-mock) — Controlling mock warnings and errors

---

Unlock the full power of mocking in your C++ tests by mastering `MOCK_METHOD` macros and the flexible gMock ecosystem. This enables precise control over mock classes, expectations, behaviors, and test assertions.
