---
title: "Advanced Test Registration: Typed and Parameterized Tests"
description: "Advanced mechanisms for extensible test code: value-parameterized and type-parameterized tests allow specification of input ranges and generic test logic over multiple types. Coverage includes macro usage, sample patterns, and best practices for maximizing reuse."
---

# Advanced Test Registration: Typed and Parameterized Tests

## Overview

GoogleTest provides powerful mechanisms to write **reusable and extensible tests** by supporting both value-parameterized and type-parameterized tests. These advanced features enable you to define a single generic test logic that can be automatically instantiated with multiple sets of input values or multiple types, significantly reducing boilerplate and improving test coverage.

In this documentation, you will learn how to leverage macros and patterns for creating typed and parameterized tests, how to supply input ranges or type lists, and best practices to maximize code reuse and maintain test clarity.

---

## 1. Value-Parameterized Tests

Value-parameterized tests enable you to define **test logic once** and run the same test multiple times with different parameter values. This is ideal when testing a function or class behavior over a range of inputs.

### 1.1 Defining a Value-Parameterized Test

To create a value-parameterized test, you use:

- `::testing::TestWithParam<T>` as the base test fixture, where `T` is the parameter type.
- `INSTANTIATE_TEST_SUITE_P` macro to supply the parameter values.

### 1.2 Example: Testing a Comparator

```cpp
#include <gtest/gtest.h>

class ComparatorTest : public ::testing::TestWithParam<int> {};

TEST_P(ComparatorTest, HandlesValue) {
  int value = GetParam();
  EXPECT_TRUE(value >= 0);
}

INSTANTIATE_TEST_SUITE_P(
    NonNegativeValues,
    ComparatorTest,
    ::testing::Values(0, 1, 42, 100));
```

In this example, the test `HandlesValue` runs 4 times with parameters 0, 1, 42, and 100.

### 1.3 Supplying Parameters

You can provide parameter sets using:

- `::testing::Values` for explicit values
- `::testing::Range` to specify range-based parameters
- `::testing::ValuesIn` to use container values

### 1.4 Accessing Parameters

`GetParam()` method defined in `TestWithParam` returns the current parameter to the test.

### 1.5 Best Practices for Parameterized Tests

- Use meaningful test suite and test names to clarify test intent.
- Limit parameters to types that are copyable and easily printable for test output clarity.
- Prefer `ValuesIn` over `Values` for large or dynamically generated parameter sets.
- Keep parameterized tests focused on one behavior to avoid brittle tests.

---

## 2. Type-Parameterized Tests

Type-parameterized tests allow writing generic test logic that can be instantiated across multiple types. This is useful when testing templates or different implementations of an interface.

### 2.1 Defining a Type-Parameterized Test

Steps:

- Define a template test fixture: `template <typename T> class MyTest : public ::testing::Test { ... }`.
- Use `TYPED_TEST_SUITE` (or the older `TYPED_TEST_CASE`) macro to specify the list of types.
- Write tests using `TYPED_TEST` macro.

### 2.2 Example: Testing a Template Stack Class

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.IsEmpty());
}

TYPED_TEST(StackTest, PushAndPop) {
  this->stack_.Push(TypeParam());
  EXPECT_FALSE(this->stack_.IsEmpty());
  this->stack_.Pop();
  EXPECT_TRUE(this->stack_.IsEmpty());
}
```

The above defines tests that will run for `int`, `double`, and `std::string` stacks.

### 2.3 Supplying Types

Use `::testing::Types<T1, T2, ...>` to provide the list of types in `TYPED_TEST_SUITE`.

### 2.4 Accessing the Current Type

Inside `TYPED_TEST`, the current type is accessible as `TypeParam`.

### 2.5 Best Practices for Typed Tests

- Keep tests focused to one template parameter type list.
- Avoid mixing typed-test fixtures with value-parameterized tests.
- Use type aliasing or traits classes to customize behavior per type if needed.

---

## 3. Combining Type and Value Parameterization

GoogleTest now supports combining type and value parameterization for advanced scenarios. Generally, this involves writing a template test fixture that also inherits from `TestWithParam` and using appropriate macros such as `TYPED_TEST_SUITE_P`.

This is an advanced usage scenario covered in detail in GoogleTest advanced documentation outside this reference.

---

## 4. Macros and Usage Patterns

| Macro                         | Purpose                                           |
|-------------------------------|--------------------------------------------------|
| `TEST_P(TestSuiteName, TestName)` | Defines a value-parameterized test method.       |
| `INSTANTIATE_TEST_SUITE_P(Prefix, TestSuiteName, Params)` | Instantiates tests with parameter inputs.          |
| `TYPED_TEST_SUITE(TestFixtureName, Types)` | Registers types for type-parameterized tests.      |
| `TYPED_TEST(TestFixture, TestName)` | Defines a typed test method for each supplied type. |

### Notes on Naming

- Test suite/class names for parameterized tests cannot clash with regular tests.
- Instantiated tests get names prefixed to differentiate parameter sets.

---

## 5. Troubleshooting Common Issues

### Test Not Running
- Ensure you use `INSTANTIATE_TEST_SUITE_P` to register parameterized test instances.
- Verify correct macro usage, e.g., `TEST_P` not `TEST` for parameterized tests.

### Parameter Type Errors
- Make sure parameter types are copyable and have proper print operators for test output.
- Use type aliases to simplify complex types.

### Overlapping Test Names
- Use unique prefixes in `INSTANTIATE_TEST_SUITE_P` to avoid conflicts.

### Confusing Failures Due to Sticky Expectations
- Remember typed and parameterized tests generate many instantiations; failures may be due to incorrect parameter ranges.

---

## 6. Best Practices Summary

- Write generic test fixture logic reusable across parameters and types.
- Use parameterized tests to avoid code duplication and improve test maintenance.
- Use `ValuesIn` or `Range` for large or continuous parameter spaces.
- Combine typed tests with traits or helper templates for flexibility.
- Avoid excessive parameter counts to keep tests manageable.

---

## 7. References and Further Reading

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) - Basic test writing
- [Value-Parameterized Tests](https://google.github.io/googletest/reference/value_param_test.html) - Full guide
- [Typed Tests](https://google.github.io/googletest/reference/typed_test.html) - Full guide
- [Advanced Test Registration](https://google.github.io/googletest/reference/advanced.html#typed-and-parameterized-tests) - Official docs
- Related Topics:
  - [Test Declaration and Registration Macros](../core-testing-apis/test-declaration.md)

---

## 8. Example Test Suite Combining Typed and Parameterized Tests

```cpp
template <typename T>
class MathTest : public ::testing::TestWithParam<T> {
 public:
  T value() const { return GetParam(); }
};

using TestTypes = ::testing::Types<int, double>;

TYPED_TEST_SUITE(MathTest, TestTypes);

TYPED_TEST(MathTest, IsNonNegative) {
  EXPECT_GE(this->value(), 0);
}

INSTANTIATE_TEST_SUITE_P(
    PositiveIntsAndDoubles,
    MathTest,
    ::testing::Values(TypeParam(1), TypeParam(2), TypeParam(10)));
```

This test runs `IsNonNegative` for both `int` and `double` types with the specified values.
