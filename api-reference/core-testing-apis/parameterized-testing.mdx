---
title: "Parameterized and Typed Tests"
description: "Guide to creating and configuring value-parameterized and type-parameterized tests. Includes macros for parameterization, examples, and typical use cases to streamline comprehensive test coverage for multiple values and types."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write more comprehensive and maintainable tests by providing two powerful paradigms: **value-parameterized tests** and **type-parameterized tests**. These approaches help you effortlessly test code against multiple values and types without duplicating test logic.

This page guides you through creating, configuring, and instantiating value-parameterized and type-parameterized tests. You will find clear instructions, macro references, practical tips, and concrete examples that streamline expanding your test coverage.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic repeatedly, varying a test parameter over multiple values. This is especially useful when you want to verify behavior under different input conditions, feature flags, or configurations.

### 1. Defining a Value-Parameterized Test Fixture

Start by defining a fixture class that inherits from both `testing::Test` and `testing::WithParamInterface<T>`, where `T` is the parameter type. For convenience, inherit from `testing::TestWithParam<T>`, which combines both:

```cpp
class FooTest : public testing::TestWithParam<int> {
  // You can add member variables, helper methods, SetUp(), etc.
};
```

### 2. Writing Tests Using `TEST_P`

Use the `TEST_P` macro to define tests within the parameterized fixture. Access the current parameter inside the test with `GetParam()`:

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(IsValid(param));
}
```

Multiple `TEST_P` definitions can coexist in the same test fixture.

### 3. Instantiating Tests with Parameters Using `INSTANTIATE_TEST_SUITE_P`

Instantiate the test fixture with a collection of parameter values using `INSTANTIATE_TEST_SUITE_P`. The parameter generator can produce sequences of values for the parameterized tests.

Here’s a basic example with `Values`:

```cpp
INSTANTIATE_TEST_SUITE_P(
  MyValues, FooTest,
  testing::Values(1, 2, 3));
```

This creates and runs tests with parameters 1, 2, and 3.

#### Supported Parameter Generators

GoogleTest provides several generator functions to create parameter sequences:

| Generator               | Description                                                                                               |
|-------------------------|-----------------------------------------------------------------------------------------------------------|
| `Range(begin, end [, step])` | Generate a sequence from `begin` up to but not including `end`, optionally stepping by `step` (default 1).      |
| `Values(v1, v2, ..., vN)`    | Explicitly specify individual values to test against.                                                  |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Yield values from C-style arrays, STL containers, or iterator ranges.                                        |
| `Bool()`                     | Generates boolean values `{false, true}`.                                                               |
| `Combine(g1, g2, ..., gN)`   | Produces tuples that represent the Cartesian product of values from given generators.                    |
| `ConvertGenerator<T>(g)` or `ConvertGenerator(g, func)` | Converts generated values to a different type `T`, with optional transformation function for types not implicitly convertible. |

#### Example — Using `Combine`

```cpp
class CombinedTest : public testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(CombinedTest, WorksForIntAndBool) {
  int number = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  EXPECT_TRUE(TestLogic(number, flag));
}

INSTANTIATE_TEST_SUITE_P(
  IntBoolTests, CombinedTest,
  testing::Combine(testing::Range(1, 4), testing::Bool()));
```

This will run tests for all pairs where the integer is 1, 2, 3 and the boolean is true or false.

### 4. Customizing Parameter Names

By default, test names include the index of the parameter. You can provide a custom function to generate meaningful names from parameters using the optional last argument of `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(
  NamedTests, FooTest, testing::Values(10, 20, 30),
  [](const testing::TestParamInfo<FooTest::ParamType>& info) {
    return "Value" + std::to_string(info.param);
  });
```

**Note:** The generated test names must contain only alphanumeric characters and underscores.

### 5. Allowing Uninstantiated Parameterized Tests

By default, if you write `TEST_P` but forget to instantiate with `INSTANTIATE_TEST_SUITE_P`, GoogleTest generates a failing verification test. To suppress this, if intentional, use:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);
```

### Best Practices

- Keep parameters simple and copyable. When using raw pointers, handle lifetime explicitly.
- Use custom naming functions for complex parameter types to improve test readability.
- Avoid overusing `Combine` with many parameters to limit exponential growth in test counts.

---

## Typed Tests

Typed tests allow you to test the same test logic across multiple types, making it ideal for verifying templates, interfaces, or concepts over a known set of types.

### 1. Defining a Typed Test Fixture Template

Define a fixture class template parameterized on the type being tested. It must derive from `testing::Test`.

```cpp
template <typename T>
class MyTypedFixture : public testing::Test {
 public:
  using Type = T;
  ... // implementation details
};
```

### 2. Associating Types with the Suite Using `TYPED_TEST_SUITE`

Declare a type list and bind it to your test fixture using the `TYPED_TEST_SUITE` macro:

```cpp
using MyTypes = testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyTypedFixture, MyTypes);
```

**Note:** The type alias `MyTypes` is necessary for the macro to parse the list properly.

### 3. Writing Typed Tests with `TYPED_TEST`

Use `TYPED_TEST` instead of `TEST_F` to define tests that will be instantiated for each type:

```cpp
TYPED_TEST(MyTypedFixture, TestWorks) {
  TypeParam value = TypeParam();  // TypeParam represents the current type
  // Inside the test, you can also use `this->` to access members
  EXPECT_TRUE(SomeCheck(value));
}
```

You can define multiple `TYPED_TEST` blocks for the fixture.

### 4. Running Typed Tests

When you run your test binary, GoogleTest automatically executes all tests for every type listed.

### 5. Customizing Type Names

You may provide a type name generator class with a static templated method `GetName(int)` to assign readable suffixes to the types in the test output:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
  }
};

TYPED_TEST_SUITE(MyTypedFixture, MyTypes, MyTypeNames);
```

### 6. Notes

- Typed tests require a fixed set of types known at compile time.
- They are ideal when you want to check that different types conform to one interface or behavior.

---

## Type-Parameterized Tests

Type-parameterized tests are similar to typed tests but become *abstract* test patterns that can later be instantiated with different sets of types. This allows code reuse across translation units and greater modularity.

### 1. Defining the Test Fixture and Patterns

Define a fixture class template deriving from `testing::Test` as usual.

Declare it as a *type-parameterized* test suite using `TYPED_TEST_SUITE_P`.

Define tests using `TYPED_TEST_P`. Inside tests, use `TypeParam` to refer to the parameterized type.

```cpp
template <typename T>
class MyAbstractTest : public testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyAbstractTest);

TYPED_TEST_P(MyAbstractTest, DoesSomething) {
  TypeParam value{};
  EXPECT_TRUE(Helper(value));
}
```

### 2. Registering Tests

Before instantiating, register the test suite and included tests by name:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyAbstractTest, DoesSomething);
```

### 3. Instantiating the Suite with a Type List

Instantiate the suite with a specific set of types using `INSTANTIATE_TYPED_TEST_SUITE_P`:

```cpp
using RealTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyAbstractTest, RealTypes);
```

Tests defined in `MyAbstractTest` will run for each instantiated type.

### 4. Instance Differentiation

The instantiation name prefix helps distinguish multiple instantiations of the same abstract test suite.

### 5. Use Cases

- Designing library code that offers interface contracts for other implementations to verify.
- Writing reusable test suites decoupled from concrete type lists.

### Notes

- You must register tests for type-parameterized test suites before instantiation.
- You can instantiate the same suite multiple times with different types.

---

## Practical Example: Value-Parameterized Test

```cpp
// Define a fixture with int parameter.
class IsEvenTest : public testing::TestWithParam<int> {};

// Define a parameterized test.
TEST_P(IsEvenTest, CheckIsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

// Instantiate the test suite with some parameters.
INSTANTIATE_TEST_SUITE_P(CommonNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

This runs the `CheckIsEven` test four times with parameters 2, 4, 6, and 8.

---

## Practical Example: Typed Test

```cpp
// Fixture template for types.
template <typename T>
class NumericTest : public testing::Test {
 public:
  T zero{0};
};

// Type list.
using MyNumericTypes = testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericTest, MyNumericTypes);

// Define typed test.
TYPED_TEST(NumericTest, ZeroIsZero) {
  EXPECT_EQ(this->zero, TypeParam(0));
}
```

This runs the `ZeroIsZero` test once per type in the list.

---

## Practical Example: Type-Parameterized Test

```cpp
// Fixture template.
template <typename T>
class AbstractContainerTest : public testing::Test {
  // ...
};

// Declare type-parameterized test suite.
TYPED_TEST_SUITE_P(AbstractContainerTest);

TYPED_TEST_P(AbstractContainerTest, DefaultIsEmpty) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

// Register tests.
REGISTER_TYPED_TEST_SUITE_P(AbstractContainerTest, DefaultIsEmpty);

// Instantiate with different types.
using ContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(StdContainers, AbstractContainerTest, ContainerTypes);
```

---

## Summary of Macros

| Macro                       | Description                                                |
|-----------------------------|------------------------------------------------------------|
| `TEST_P(TestSuiteName, TestName)` | Defines an individual value-parameterized test.               |
| `INSTANTIATE_TEST_SUITE_P(InstantiationName, TestSuiteName, param_generator, name_generator=optional)` | Instantiates the parameterized test suite with parameters. |
| `TYPED_TEST_SUITE(TestFixtureName, Types, optionalNameGenerator)` | Defines a typed test suite for a list of types.             |
| `TYPED_TEST(TestSuiteName, TestName)` | Defines an individual typed test for the suite.                |
| `TYPED_TEST_SUITE_P(TestFixtureName)`          | Declares a type-parameterized test suite (abstract).              |
| `TYPED_TEST_P(TestSuiteName, TestName)`        | Defines an individual type-parameterized test.                   |
| `REGISTER_TYPED_TEST_SUITE_P(TestSuiteName, TestNames...)` | Registers type-parameterized tests in an abstract suite.   |
| `INSTANTIATE_TYPED_TEST_SUITE_P(InstantiationName, TestSuiteName, Types)` | Instantiates a type-parameterized test suite.               |
| `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName)`   | Allows uninstantiated parameterized test suite.              |

---

## Troubleshooting & Common Pitfalls

- **Forgetting Instantiation**: Defining parameterized tests with `TEST_P` but omitting `INSTANTIATE_TEST_SUITE_P` causes a verification failure unless suppressed.
- **Invalid Test or Suite Names**: Test suite and test names must not contain underscores `_` as GoogleTest uses them internally.
- **Parameter Naming Constraints**: Custom name generators must produce valid C++ identifiers; otherwise, test registration will fail.
- **Complex Parameter Types**: Use `ConvertGenerator` to adapt complex types or types not implicitly convertible from generated values.
- **Lifetime Management**: When using raw pointers as parameters, ensure their validity throughout the test.

---

## Additional Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) (Advanced guide)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [INSTANTIATE_TEST_SUITE_P Macro Reference](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TYPED_TEST and TYPED_TEST_SUITE Reference](reference/testing.md#TYPED_TEST_SUITE)

---

Empower your tests to cover more ground with less code by leveraging GoogleTest's parameterized testing paradigms. Instantiate your tests with diverse values and types to catch edge cases and ensure robust correctness.
