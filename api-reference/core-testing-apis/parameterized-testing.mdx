---
title: "Parameterized & Typed Tests"
description: "Covers the syntax and workflows for value- and type-parameterized tests, allowing tests to run against varied data or multiple types. Illustrates best practices and common pitfalls for scalable, reusable test patterns."
---

# Parameterized & Typed Tests

GoogleTest empowers you with **parameterized testing capabilities**, allowing you to reuse test logic across varying data values or data types. This page covers the syntax and user workflows for **value-parameterized tests** (run tests against different values) and **typed tests** (run tests against different types), as well as **type-parameterized tests** (abstract patterns instantiated later). You will find best practices, common scenarios, and pitfalls to create scalable, maintainable test patterns.

---

## Value-Parameterized Tests

### Overview

Value-parameterized tests run the same test logic against different parameter values of any copyable type, enabling powerful data-driven testing patterns without duplicating code.

### Defining Value-Parameterized Tests

1. **Create a test fixture** deriving from `testing::TestWithParam<T>`, where `T` is the parameter type.

2. **Define tests using** `TEST_P(TestFixtureName, TestName)`. Within the test body, access the parameter by calling `GetParam()`.

3. **Instantiate the test suite** with specific parameters using `INSTANTIATE_TEST_SUITE_P(InstantiationName, TestFixtureName, param_generator)`, where `param_generator` comes from GoogleTest's rich set of generators.

### Example

```cpp
class MyTest : public ::testing::TestWithParam<int> {};

TEST_P(MyTest, IsEven) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, MyTest, testing::Values(2, 4, 6, 8));
```

### Parameter Generators

GoogleTest provides multiple parameter generators in namespace `::testing`:

| Generator          | Description                                               |
|--------------------|-----------------------------------------------------------|
| `Range(start,end)`  | Produces values in `[start, end)` with step 1 (or specified). |
| `Values(v1, .. vN)` | Produces each specified value explicitly.                 |
| `ValuesIn(container)` | Produces each value in a container or iterator range.    |
| `Bool()`           | Produces `false` and `true`.                              |
| `Combine(g1, g2, ... gN)` | Cartesian product of multiple generators producing tuples. |

You can compose generators to test combinations. For example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyCombinationTests, MyTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Customizing Test Names

By default, test names include the index of the parameter but not a readable parameter representation. You can supply a custom name generator as the last argument to `INSTANTIATE_TEST_SUITE_P`.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedParams, MyTest, testing::Values(1, 2),
    [](const testing::TestParamInfo<int>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

**Important note:** Test names can only contain alphanumeric characters or underscores and must be unique and non-empty. Avoid underscores in suite or test names.

### Abstract Value-Parameterized Tests

You can define your value-parameterized test suite in one source file and instantiate it elsewhere. This is common when defining *abstract tests* verifying interface conformance:

- Define fixture and tests (`TEST_P`) in a header and a `.cc` file.
- Consumers include your header and instantiate with appropriate parameters.

### Controlling Instantiation Checks

If you have a suite declared with `TEST_P` but do not instantiate it, GoogleTest will fail with a verification test. You can suppress this check with:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestFixtureName);
```

### Tips & Best Practices

- Use value-parameterized tests when inputs differ but are of the same type.
- Use `GetParam()` inside tests to work with parameters.
- Keep parameter generators simple and readable.
- Combine multiple generators for multi-dimensional parameters.


---

## Typed Tests

### Overview

Typed tests execute the same test code on different **types** specified at compile time, ideal when you want to verify multiple implementations or types satisfy the same behavior.

You must **know** the list of types at test definition time.

### Defining Typed Tests

1. Create a **test fixture template** class deriving from `testing::Test`, templated on type `T`.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  using List = std::list<T>;
  static T shared_;
  T value_;
};
```

2. Define a **type list alias**:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

3. Use `TYPED_TEST(TestFixtureName, TestName)` to write tests. The special name `TypeParam` refers to the current type.

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  ...
}
```

### Custom Type Name Generation

Optionally provide a class with a static method template to customize test name suffixes:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, unsigned int>) return "unsignedInt";
    return "unknown";
  }
};
TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

### Tips & Best Practices

- Typed tests are best when the same interface and construction pattern applies to all types.
- The test output shows the type executing the test, helping with diagnostics.
- Use `TestFixture::` and `typename TestFixture::` prefixes where necessary.
- Type parameter lists must be known and fixed at test definition.


---

## Type-Parameterized Tests

### Overview

Type-parameterized tests give you the power to define **abstract test patterns** independent of type lists and instantiate the pattern with different types anywhere, potentially multiple times.

This is the ultimate reusable pattern, commonly used to verify interface or concept conformance.

### Defining Type-Parameterized Tests

1. Define your fixture class template deriving from `testing::Test`.

```cpp
template <typename T>
class FooTest : public testing::Test {
  void DoSomethingInteresting();
  ...
};
```

2. Declare the test suite pattern:

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. Define tests using `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  this->DoSomethingInteresting();
  ...
}
```

4. Register test names:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

5. Instantiate the test pattern with types anywhere:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, FooTest, MyTypes);
```

### Benefits

- Allows test definitions independent of concrete type lists.
- Supports multiple instantiations, facilitating modular testing in libraries.
- Enables sharing of test patterns across translation units.

### Tips & Best Practices

- Put your `TYPED_TEST_P` definitions in headers for reuse.
- Register all tests before instantiation.
- Use unique prefixes with `INSTANTIATE_TYPED_TEST_SUITE_P` to keep instances distinct.

---

## Guidelines & Common Pitfalls

- **Naming restrictions:** Avoid underscores (`_`) in test suite and test names; they can cause compilation or runtime errors.
- Ensure your test fixtures have default constructors for GoogleTest to instantiate.
- Use public `SetUpTestSuite()` and `TearDownTestSuite()` when using `TEST_P` fixtures.
- Provide unique instantiations to prevent name collisions.
- When using `TYPED_TEST` or `INSTANTIATE_TYPED_TEST_SUITE_P`, the type alias (`using` or `typedef`) is mandatory for parsing.
- Don't forget to `REGISTER_TYPED_TEST_SUITE_P` all test names before instantiation in type-parameterized tests.
- Prefer typed tests when the type list is known upfront; prefer type-parameterized tests when designing reusable test libraries where users instantiate with their own types.

---

## Summary

GoogleTest's parameterized and typed tests allow you to write **concise, scalable, and reusable test logic** by abstracting either the data values or the data types:

- **Value-Parameterized Tests** allow testing over varying data values using `TEST_P` and `INSTANTIATE_TEST_SUITE_P` with generators.
- **Typed Tests** run tests repeatedly over a known list of types at the time of definition (`TYPED_TEST_SUITE`, `TYPED_TEST`).
- **Type-Parameterized Tests** separate test pattern definition and instantiation, enabling more flexible reuse (`TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, `INSTANTIATE_TYPED_TEST_SUITE_P`).

Both parameterized and typed tests improve test coverage, consistency, and reduce boilerplate in testing C++ projects.

---

## Further Reading

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [Testing Reference - Parameterized & Typed Tests](../reference/testing.md#TYPED_TEST_SUITE)
- [FAQ: Typed Tests vs. Value-Parameterized Tests](../docs/faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests)

---

[GoogleTest](https://github.com/google/googletest) source and samples provide practical examples illustrating the use of typed and parameterized tests in real-world testing scenarios.
