---
title: "Parameterized and Typed Tests"
description: "Explains how to write value- and type-parameterized tests, enabling comprehensive coverage with varying inputs and types. Covers test generator APIs, test registration macros, and provides concise examples for common use cases."
---

# Parameterized and Typed Tests

This reference explains how to write comprehensive and flexible value- and type-parameterized tests with GoogleTest. Parameterized tests allow you to run the same test logic repeatedly with different inputs and type parameters, enabling broad coverage with minimal code duplication.

You will learn about test parameter generators, test registration macros, and see concise examples covering common use cases.

---

## 1. Overview of Parameterized Tests

GoogleTest supports two primary forms of parameterized testing:

- **Value-Parameterized Tests:** Run a test case multiple times using specific runtime values as parameters.
- **Typed (Type-Parameterized) Tests:** Repeat tests for a list of types at compile time.

Parameterized tests reduce boilerplate by reusing test logic with varied inputs or types.

### Why Use Parameterized Tests?

Imagine you want to verify a function behaves correctly across a wide range of inputs. Instead of manually writing multiple tests, parameterized tests let you define the test once and plug in different parameter values or types.

---

## 2. Writing Value-Parameterized Tests

Value-parameterized tests execute the same test body for a set of provided parameter values.

### 2.1 Define a Test Fixture

Define a test fixture that inherits from `::testing::TestWithParam<T>`, where `T` is your parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Fixture setup if needed
};
```

You can also inherit separately from `::testing::Test` and `::testing::WithParamInterface<T>` if this fits your test hierarchy better.

### 2.2 Write Tests Using `TEST_P`

Define your tests using the `TEST_P` macro instead of `TEST_F` or `TEST`. Within the test, access the parameter using `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  int param = GetParam();
  EXPECT_TRUE(MyFunction(param));
}
```

You can define multiple tests under the same fixture.

### 2.3 Instantiate Tests with Parameter Generators

Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with specific parameter values or generators.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NumberTests, FooTest,
    ::testing::Values(1, 2, 3));
```

This generates tests named `NumberTests/FooTest.DoesBlah/0`, `/1`, `/2`, each running with parameter values 1, 2, and 3.

#### Parameter generator functions in the `::testing` namespace:

| Generator              | Description                                                                              |
|-------------------------|------------------------------------------------------------------------------------------|
| `Range(start, end [, step])` | Yields values from `start` to just before `end` with the given step (default 1).         |
| `Values(v1, v2, ..., vN)`       | Yields the explicitly provided values.                                                  |
| `ValuesIn(container_or_iterators)` | Yields values from containers, arrays, or iterator ranges.                              |
| `Bool()`                         | Yields `{false, true}`, handy for testing boolean conditions.                           |
| `Combine(g1, g2, ..., gN)`       | Creates Cartesian product tuples by combining multiple generators' values.              |
| `ConvertGenerator<T>(gen)`       | Converts generated values to a specified type `T`. Useful when implicit conversions don’t exist.

##### Examples

```cpp
// Simple instantiation with integers
INSTANTIATE_TEST_SUITE_P(IntSequence, FooTest, Values(3, 5, 8));

// Using Range generator
INSTANTIATE_TEST_SUITE_P(RangeSequence, FooTest, Range(1, 4));  // Generates 1, 2, 3

// Using ValuesIn with a container
std::vector<std::string> strings = {"foo", "bar"};
INSTANTIATE_TEST_SUITE_P(StringSequence, FooTest, ValuesIn(strings));

// Combining multiple parameter sequences
INSTANTIATE_TEST_SUITE_P(
    CombinedTests, FooTest,
    Combine(Values(1, 2), Bool()));  // Yields (1, false), (1, true), (2,false), (2,true)
```

### 2.4 Custom Parameter Name Generators

The optional fourth argument to `INSTANTIATE_TEST_SUITE_P` allows you to specify a custom function or functor to generate human-readable test names based on the parameter.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNameInstances, FooTest, Values(10, 20),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

Avoid spaces or punctuation in generated names—use only alphanumeric characters and underscores.

### 2.5 Accessing Parameters in Tests

Your test body accesses parameters through `GetParam()`:

```cpp
TEST_P(FooTest, ExampleUsage) {
  auto value = GetParam();
  EXPECT_GT(value, 0);
}
```

This enables concise and focused test logic.

### 2.6 Best Practices and Notes

- Parameter values passed to generators are evaluated during `InitGoogleTest()` (usually after `main` starts), not at `INSTANTIATE_TEST_SUITE_P` call site.
- Ensure the parameter type `T` is copyable.
- Use `ConvertGenerator` when implicit conversions cannot be applied.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName)` if a test suite may not be instantiated to prevent warnings/errors.

---

## 3. Writing Typed and Type-Parameterized Tests

Typed tests allow running the same test logic on a list of types, while type-parameterized tests provide additional flexibility with test registration and registration of multiple translation units.

### 3.1 Typed Tests

Use typed tests when you know the list of types at compile time and want to run the same tests for each.

#### Steps to write typed tests

1. Define a fixture class template:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_{};
};
```

2. Define a type list:

```cpp
using MyTypes = ::testing::Types<int, char, double>;
```

3. Associate the type list with the test suite using the `TYPED_TEST_SUITE` macro:

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. Write tests using `TYPED_TEST`:

```cpp
TYPED_TEST(MyTypedTest, HasDefaultValue) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```

Within the test, `TypeParam` is the current type.

### 3.2 Type-Parameterized Tests

Type-parameterized tests separate test pattern declaration from instantiation, allowing:
- Test patterns to be defined without specific types upfront.
- One test pattern to be instantiated multiple times with different types in any translation unit.

#### Usage pattern

1. Define a fixture template class.

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {};
```

2. Declare the test suite as type-parameterized with `_P` suffix:

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);
```

3. Define tests with `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypeParamTest, TestFeature) {
  TypeParam value{};
  EXPECT_TRUE(SomeCheck(value));
}
```

4. Register the tests:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestFeature);
```

5. Instantiate the tests with concrete types:

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

---

## 4. Test Registration Macros Summary

| Macro                         | Purpose                                                                                      |
|-------------------------------|----------------------------------------------------------------------------------------------|
| `TEST_P(TestFixture, TestName)` | Defines an individual value-parameterized test.                                              |
| `INSTANTIATE_TEST_SUITE_P(Prefix, TestFixture, ParamGenerator[, NameGenerator])` | Instantiates a parameterized test suite with parameters and optional custom test names.       |
| `TYPED_TEST_SUITE(Fixture, Types[, NameGenerator])` | Defines typed test suite with list of types.                                                 |
| `TYPED_TEST(Fixture, TestName)` | Defines test body in a typed test suite.                                                     |
| `TYPED_TEST_SUITE_P(Fixture)` | Declares a type-parameterized test suite (pattern).                                         |
| `TYPED_TEST_P(Fixture, TestName)` | Defines a test in a type-parameterized pattern.                                              |
| `REGISTER_TYPED_TEST_SUITE_P(Fixture, TestNames...)` | Registers tests in a type-parameterized suite.                                               |
| `INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, Suite, Types[, NameGenerator])` | Instantiates the type-parameterized test suite with concrete types.                             |

---

## 5. Practical Examples

### 5.1 Simple Value-Parameterized Test

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

This test will run four times, once for each even number.

### 5.2 Using `Combine` to Test Multiple Parameters

```cpp
class StringBoolTest
    : public ::testing::TestWithParam<std::tuple<std::string, bool>> {};

TEST_P(StringBoolTest, BehaviorBasedOnParams) {
  const auto& [text, flag] = GetParam();
  if (flag) {
    EXPECT_FALSE(text.empty());
  } else {
    EXPECT_TRUE(text.empty() || text == "");
  }
}

INSTANTIATE_TEST_SUITE_P(
    ComboTests, StringBoolTest,
    ::testing::Combine(::testing::Values("foo", ""), ::testing::Bool()));
```

Tests all pairs of the two strings and boolean flags.

### 5.3 Typed Test Example

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {};

TYPED_TEST_SUITE(NumericLimitsTest, ::testing::Types<int, double>);

TYPED_TEST(NumericLimitsTest, HasPositiveMin) {
  EXPECT_GT(std::numeric_limits<TypeParam>::min(), 0);
}
```

### 5.4 Type-Parameterized Test Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeEmpty) {
  TypeParam c;
  EXPECT_TRUE(c.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeEmpty);

using MyContainers = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```

---

## 6. Troubleshooting & Common Pitfalls

- **No tests run?** Make sure your `INSTANTIATE_TEST_SUITE_P` is actually called; parameterized tests require instantiation.
- **Parameter type issues?** Ensure the types used with generator functions are compatible and copyable.
- **Name collisions in tests?** Use unique prefixes in instantiations to avoid test naming conflicts.
- **Dangling references in `ConvertGenerator`?** Specify explicit types or use value types within conversion lambdas to avoid lifetime issues.
- **Suppressed or missing tests warnings?** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to silence legitimate uninstantiated test warnings when appropriate.

---

## 7. Additional Tips

- Use `ValuesIn` to cleanly pass container contents as test parameters.
- Combine multiple parameter sets with `Combine` to test complex interactions.
- Customize test name suffixes with lambdas or functors to improve test output clarity.
- Prefer `TestWithParam<T>` over directly inheriting from `Test` and `WithParamInterface<T>` unless necessary.
- For typed tests, use the optional name generator to produce readable type names for test reports.

---

## 8. References & Further Reading

- [Value-Parameterized Tests Guide](../guides/real-world-usage-and-best-practices/parameterized-and-typed-tests.mdx)
- [Testing Reference - TEST_P, INSTANTIATE_TEST_SUITE_P](../docs/reference/testing.md#TEST_P)
- [Typed and Type-Parameterized Tests Guide](../docs/reference/testing.md#TYPED_TEST_SUITE)
- [Parameter Generators in gtest-param-test.h](#)

---

GoogleTest’s parameterized and typed testing API enables writing expressive, maintainable tests that cover broad input ranges and types with minimal duplication. Use the macros and generators provided to craft scalable and clear test suites aligned with your project’s testing goals.
