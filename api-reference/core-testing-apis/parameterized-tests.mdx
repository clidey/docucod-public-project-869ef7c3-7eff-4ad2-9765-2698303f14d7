---
title: "Parameterized & Typed Tests"
description: "Document the patterns and APIs for value- and type-parameterized tests, enabling users to author suites that iterate over different input values or types. Covers macro usage, registration, and result exploration for comprehensive test coverage."
---

# Parameterized & Typed Tests

GoogleTest empowers you to write tests that automatically iterate over a set of input values or types, eliminating repetitive code and improving coverage. This page covers the APIs and patterns for crafting value-parameterized and type-parameterized tests, guiding you through defining fixtures, instantiating tests with parameters, and customizing test names for clear results.

---

## Value-Parameterized Tests (Using Values as Test Parameters)

Value-parameterized tests allow you to run the same test logic multiple times, once for each parameter in a sequence. This enables comprehensive testing of your code against various inputs without duplicating test code.

### Defining a Value-Parameterized Test Fixture

Start by defining a test fixture inheriting from `::testing::TestWithParam<T>`, where `T` is the type of parameter you want to test. This fixture provides access to the current test parameter via the `GetParam()` method.

```cpp
class MyValueTest : public ::testing::TestWithParam<int> {
  // Common setup or utilities can be added here.
};
```

### Writing Parameterized Tests

Define tests using the `TEST_P` macro (the `P` stands for Parameterized). Write your test case body using the test fixture and extract the current parameter using `GetParam()`.

```cpp
TEST_P(MyValueTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

### Instantiating Tests with Parameter Lists

Use `INSTANTIATE_TEST_SUITE_P` to generate test instances using parameter generators. The first argument is an instantiation name, used as a prefix in test names for clarity and filtering.

GoogleTest provides several parameter generators:

| Generator         | Description                                                |
|-------------------|------------------------------------------------------------|
| `Values(...)`     | Generates tests from an explicit list of values.           |
| `ValuesIn(...)`   | Generates tests from elements of a container or range.     |
| `Range(start,end[,step])` | Generates values in `[start, end)` by step increments.  |
| `Bool()`          | Generates `{false, true}` for Boolean parameter testing.   |
| `Combine(...)`    | Produces Cartesian product of multiple generators.          |

Examples:

```cpp
// Using Values
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyValueTest, Values(2, 4, 6, 8));

// Using ValuesIn with an array
const int vals[] = {10, 20, 30};
INSTANTIATE_TEST_SUITE_P(MultiplesOfTen, MyValueTest, ValuesIn(vals));

// Using Range
INSTANTIATE_TEST_SUITE_P(ZeroToFive, MyValueTest, Range(0, 6));

// Using Bool
class FlagTest : public ::testing::TestWithParam<bool> {};
TEST_P(FlagTest, Condition) { /* Test body */ }
INSTANTIATE_TEST_SUITE_P(BoolSequence, FlagTest, Bool());

// Using Combine for multiple parameters
class AnimalTest : public ::testing::TestWithParam<std::tuple<std::string, int>> {};

TEST_P(AnimalTest, Behavior) {
  auto [animal, age] = GetParam();
  // ...
}

INSTANTIATE_TEST_SUITE_P(
    AnimalVariations, AnimalTest,
    Combine(Values("cat", "dog"), Values(1, 5)));
```

### Customizing Test Names

By default, instantiated tests have names formed as `InstantiationName/TestSuiteName.TestName/Index`, which may be unclear with complex parameters. You can supply a custom name generator as an optional fourth argument to `INSTANTIATE_TEST_SUITE_P`. It must be a callable taking a `TestParamInfo<ParamType>` and returning a sanitized string identifier.

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedAnimals, AnimalTest,
    Combine(Values("cat", "dog"), Values(1, 5)),
    [](const testing::TestParamInfo<std::tuple<std::string, int>>& info) {
      const auto& [animal, age] = info.param;
      return animal + "_age_" + std::to_string(age);
    });
```

Ensure names contain only ASCII alphanumeric characters or underscores.

### Best Practices and Pitfalls

- **Use descriptive instantiation names** to distinguish parameter cases clearly.
- **Avoid raw pointers as parameters** unless managing lifetime carefully.
- **Beware of dangling references** when using `ValuesIn` with temporaries.
- **Define parameterized tests logically**, focusing on reusable fixtures.
- **Naming conventions matter**: Use consistent, filter-friendly identifiers.

---

## Type-Parameterized Tests (Using Types as Test Parameters)

Type-parameterized tests enable running the same test logic for different types, ensuring your templates or polymorphic code works as expected.

### Defining a Type-Parameterized Test Fixture

Define a class template fixture deriving from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
  // additional fixture setup
};
```

### Registering Types for the Test Suite

Use `TYPED_TEST_SUITE` (or deprecated `TYPED_TEST_CASE`) to associate the test suite with a `::testing::Types<...>` list.

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Defining Typed Tests

Use `TYPED_TEST` instead of `TEST_F` to define test cases. Inside the test, use the special typedef `TypeParam` as the current type.

```cpp
TYPED_TEST(MyTypedTest, IsZeroInitialized) {
  TypeParam zero{};
  EXPECT_EQ(value_, zero);
}
```

### Custom Test Names Based on Types

Optionally provide a NameGenerator class with a static template method `GetName(int)` to generate custom test suite suffixes.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    else if constexpr (std::is_same_v<T, float>) return "Float";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices and Pitfalls

- **Keep test fixture lightweight**: don't put heavy setup per type unless necessary.
- **Custom names help test result clarity**, especially when debugging.
- **Prefer `TYPED_TEST_SUITE` over deprecated macros**.

---

## Type-Parameterized Tests with Registration (For Flexible Definitions)

For more complex scenarios where test definitions and instantiations are separated, GoogleTest provides `TYPED_TEST_SUITE_P` and associated macros.

### Declaring and Defining Tests

Use `TYPED_TEST_SUITE_P` to declare the test suite template and `TYPED_TEST_P` to define tests:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, PropertyA) {
  // Test code using TypeParam
}

TYPED_TEST_P(MyTypeParamTest, PropertyB) {
  // Another test
}
```

### Registering Tests

Register all test names for the suite with `REGISTER_TYPED_TEST_SUITE_P`:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, PropertyA, PropertyB);
```

### Instantiating With Types

Instantiate the suite with types at the call site using `INSTANTIATE_TYPED_TEST_SUITE_P`:

```cpp
using TestTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, TestTypes);
```

---

## Accessing Test Parameters in Parameterized Tests

- Use `GetParam()` in value-parameterized (`TEST_P`) or type-parameterized tests to access the current parameter or type.
- For type-parameterized tests, use the alias `TypeParam` inside test bodies.

---

## Exploring Test Results and Naming

- Instantiated tests have systematic names combining the instantiation prefix, test suite name, test name, and parameter index.
- Use `--gtest_filter` with these names for selective test runs.
- Custom name generators improve output readability and debugging.

---

## Troubleshooting and Tips

- If no tests run, verify you have instantiated your parameterized tests with `INSTANTIATE_TEST_SUITE_P`.
- Watch out for dangling parameter references when using `ValuesIn` with temporaries; prefer container variables.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(SomeTestSuite)` if you intentionally want to delay instantiation.
- For custom parameter types, use `ConvertGenerator` to transform parameters to the expected type.

---

## Summary Example

```cpp
#include <gtest/gtest.h>

class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveNumbers, FooTest, Values(1, 2, 3, 4));

// Typed test example

template <typename T>
class MyTypedTest : public testing::Test {};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, DefaultConstructible) {
  TypeParam value{};
  (void)value;  // Test code here
}
```

This will run the `IsPositive` test with values 1, 2, 3, and 4, and run the typed test for `int` and `double`.

---

## See Also

- [Writing & Running Tests](../core-testing-apis/writing-and-running-tests)
- [GoogleTest Primer](../../getting-started/first-test-and-validation/quickstart-primer)
- [Organizing Tests into Suites](../../guides/core-testing-workflows/organizing-test-suites)
- [Advanced Parameterized Tests Usage](../../guides/core-testing-workflows/parameterized-tests)

---

<CalloutGroup title="Best Practices">
<Callout title="Start Simple">
Begin with simple `Values` and basic fixtures. Progressively use `Combine` and `ConvertGenerator` for complex scenarios.
</Callout>
<Callout title="Name Your Tests Meaningfully">
Use custom name generators to produce descriptive test names that aid filtering and debugging.
</Callout>
<Callout title="Avoid Dangling Parameters">
Keep parameter containers alive throughout your testâ€™s lifetime to prevent references to destroyed objects.
</Callout>
</CalloutGroup>
