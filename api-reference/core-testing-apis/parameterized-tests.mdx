---
title: "Parameterized and Typed Tests"
description: "Covers value- and type-parameterized testing APIs, empowering users to run the same test logic across multiple data inputs or types. Guides readers through macros and parameter generation utilities necessary for robust, DRY test design."
---

# Parameterized and Typed Tests

GoogleTest empowers you to write robust, DRY (Don't Repeat Yourself) tests by allowing you to run the same test logic across multiple input values or types. This page details the value-parameterized and type-parameterized testing APIs, guiding you through the essential macros and parameter generation utilities vital for building comprehensive test suites that are both maintainable and expressive.

---

## Value-Parameterized Tests

Value-parameterized tests enable you to write tests once and run them multiple times with different input parameters. This approach is vital when your codeâ€™s behavior varies based on inputs, configurations, or implementations.

### Defining Value-Parameterized Tests

1. **Create a Test Fixture with Parameters**: Your test fixture should inherit from `testing::TestWithParam<T>`, where `T` is the type of the test parameter.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Define setup, teardown, and other members as usual.
};
```

2. **Define Parameterized Test Cases**: Use the `TEST_P` macro to define individual parameterized tests. Inside the test, access the current parameter with `GetParam()`.

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}

TEST_P(FooTest, HasFeature) {
  // Additional tests using GetParam()
}
```

3. **Instantiate Test Suites with Parameters**: Use `INSTANTIATE_TEST_SUITE_P` to specify which parameter values should be supplied to the test suite.

For example:

```cpp
INSTANTIATE_TEST_SUITE_P(ExampleInstantiation,
                         FooTest,
                         testing::Values("meeny", "miny", "moe"));
```

This expands tests with names like:

- ExampleInstantiation/FooTest.DoesBlah/0 (parameter "meeny")
- ExampleInstantiation/FooTest.DoesBlah/1 (parameter "miny")
- ExampleInstantiation/FooTest.DoesBlah/2 (parameter "moe")

You can also instantiate with other parameter generators such as `Range()`, `ValuesIn()`, `Bool()`, and combined generators using `Combine()`. These generators create sequences or Cartesian products of parameters efficiently.

### Built-in Parameter Generators

| Generator        | Description                                                                                 |
|------------------|---------------------------------------------------------------------------------------------|
| `Range(start,end[,step])` | Generates a sequence `{start, start+step, ...}` up to but excluding `end`.                |
| `Values(v1,v2,...,vN)`    | Enumerates specified individual values as parameters.                                    |
| `ValuesIn(container)`      | Generates parameters from any STL container or iterator range.                           |
| `Bool()`                  | Yields `{false, true}` for Boolean testing.                                             |
| `Combine(g1, g2, ..., gN)`| Produces Cartesian product of the given parameter sequences as `std::tuple`s.            |

Example using combined Boolean parameters:

```cpp
class FlagDependentTest : public testing::TestWithParam<std::tuple<bool, bool>> {
  void SetUp() override {
    std::tie(flag1_, flag2_) = GetParam();
  }
  bool flag1_, flag2_;
};

TEST_P(FlagDependentTest, FeatureTest) {
  EXPECT_TRUE(TestFeature(flag1_, flag2_));
}

INSTANTIATE_TEST_SUITE_P(BoolCombinations, FlagDependentTest,
                         testing::Combine(testing::Bool(), testing::Bool()));
```

### Customizing Parameter Names

By default, GoogleTest names parameterized tests using the index of the parameter. To generate more meaningful test names, provide a custom name generator as the last argument to `INSTANTIATE_TEST_SUITE_P`. This function or functor takes a `TestParamInfo<ParamType>` and returns a `std::string` representing the test suffix.

Example with a lambda custom name generator:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest, testing::Values("hello", "world"),
    [](const testing::TestParamInfo<const char*>& info) {
      std::string name = info.param;
      // Sanitize: replace non-alphanumeric chars with '_'
      std::replace_if(name.begin(), name.end(),
                      [](char c) { return !std::isalnum(c); }, '_');
      return name;
    });
```

> **Note:** Test names must be unique and contain only alphanumeric characters and underscores.

### Combining Generators with `Combine()`

Use `Combine()` for testing multiple parameter dimensions simultaneously. It generates the full Cartesian product.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedTest, MultiParamTest,
    testing::Combine(testing::Values(1, 2), testing::Values(true, false)));
```

This instantiates tests for `(1, true)`, `(1, false)`, `(2, true)`, and `(2, false)`.

---

## Typed Tests

Typed tests allow you to execute the same test logic across a list of types, ensuring your code works with multiple type instantiations without duplicating code.

### Defining Typed Tests

1. **Define a Class Template Fixture**: Create a test fixture class template parameterized by a type.

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  // You can define members and typedefs using T.
  using List = std::list<T>;
  static T shared_;
  T value_;
};
```

2. **Associate a List of Types**: Use `TYPED_TEST_SUITE` to specify the type list.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

3. **Define Typed Tests**: Use `TYPED_TEST` to define tests that will be run for each type.

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_; // Access TypeParam representing the current test type
  // Test logic here
  typename TestFixture::List values;
  values.push_back(n);
}

TYPED_TEST(FooTest, HasPropertyA) {
  // Additional tests
}
```

> **Tip:** Access the fixture members via `this->` and typedefs via `typename TestFixture::`.

### Type Name Customization

You can customize type name suffixes for better test names by supplying an optional third argument to `TYPED_TEST_SUITE`, a class that generates names for each type.

```cpp
class MyTypeNames {
 public:
  template<typename T>
  static std::string GetName(int) {
    if (std::is_same<T, char>::value) return "char";
    if (std::is_same<T, int>::value) return "int";
    if (std::is_same<T, unsigned int>::value) return "unsignedInt";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(FooTest, MyTypes, MyTypeNames);
```

---

## Type-Parameterized Tests

Type-parameterized tests allow defining generic test logic that can be instantiated later with arbitrary type lists, useful when you want to write abstract tests over types without knowing them upfront.

### Defining Type-Parameterized Tests

1. **Define a Class Template Fixture**:

```cpp
template <typename T>
class FooTest : public testing::Test {
  // Generic test fixture
};
```

2. **Declare a Type-Parameterized Test Suite**:

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. **Define Tests Using `TYPED_TEST_P`**:

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;  // Use TypeParam for current type
  // Test logic
}

TYPED_TEST_P(FooTest, HasPropertyA) {
  // Additional tests
}
```

4. **Register the Tests**:

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

5. **Instantiate Test Suites with Specific Types**:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, FooTest, MyTypes);
```

The first argument of the instantiation macro is a unique prefix added to the test suite name to distinguish multiple instantiations.

### Use Cases

Type-parameterized tests shine when you:

- Design interface conformity tests for multiple implementations.
- Test generic template libraries against a wide variety of types.

---

## Practical Tips & Best Practices

- Always ensure your test and suite names follow GoogleTest conventions: valid C++ identifiers without underscores to avoid filtering issues.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FixtureName);` to suppress errors for parameterized tests that are defined but not instantiated.
- Write custom parameter name generators to generate clear, readable test names, especially when parameters are complex types such as strings or tuples.
- Leverage `Combine()` to test multiple parameter dimensions efficiently, but keep the number of test instances manageable.
- For types or parameters requiring explicit conversion, use `ConvertGenerator<T>()` with conversion functors to ensure parameters are correctly constructed.

---

## Troubleshooting

- **Empty Parameter Instantiation**: If a parameterized test suite is defined but not instantiated or instantiated with an empty parameter set, GoogleTest inserts a synthetic test to avoid test detection errors. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings when intended.

- **Invalid Test Names**: Custom test names must only contain alphanumeric characters and underscores. Spaces, dashes, or other symbols result in errors during test registration.

- **Parameter Order Sensitivity**: Ensure `INSTANTIATE_TEST_SUITE_P` calls occur at global or namespace scope, not inside functions, so parameters are evaluated properly during test initialization.

- **Dangling References in Lambdas**: When using lambdas as parameter converters, beware of dangling references if the lambda parameter type does not exactly match the stored parameter type.

---

## References & Related Links

- [Value-Parameterized Tests in Advanced Guide](../guides/core-testing-workflows/advanced-parameterized-tests.md)
- [Typed and Type-Parameterized Tests in Advanced Guide](../guides/core-testing-workflows/advanced-parameterized-tests.md#typed-tests)
- [`INSTANTIATE_TEST_SUITE_P` Reference](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [`TEST_P` Reference](../reference/testing.md#TEST_P)
- [`TYPED_TEST` & `TYPED_TEST_SUITE` Reference](../reference/testing.md#TYPED_TEST)
- [CUSTOM Parameter Name Generators](../guides/core-testing-workflows/advanced-parameterized-tests.md#custom-naming)

Explore the [GoogleTest Primer](primer.md) and [Assertions Reference](assertions.md) for foundational knowledge complementing parameterized test usage.

---

## Example

```cpp
// Fixture for value-parameterized test
class MyParamTest : public ::testing::TestWithParam<int> {};

TEST_P(MyParamTest, IsEven) {
  EXPECT_EQ(0, GetParam() % 2);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyParamTest,
                         testing::Values(2, 4, 6, 8));

// Fixture for typed test
template<typename T>
class MyTypedTest : public ::testing::Test {
 protected:
  T value_ = 0;
};

using MyTypes = ::testing::Types<int, long, short>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsZeroInitially) {
  EXPECT_EQ(0, this->value_);
}

// Fixture for type-parameterized test
template <typename T>
class MyTypeParamTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Suppress unused variable warning
  SUCCEED();
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, IsDefaultConstructible);

using MyParamTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyParamTypes);
```
