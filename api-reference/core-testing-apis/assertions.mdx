---
title: "Assertions and Expectations"
description: "Explains the rich set of built-in assertions, from equality checks to exception and death tests. Details how to use fatal and non-fatal assertions, providing clear examples for verifying diverse conditions in tests."
---

# Assertions and Expectations

GoogleTest empowers you with a rich, expressive set of assertions designed to verify your C++ code's behavior effectively. This page introduces you to its comprehensive collection of assertion macros—ranging from simple equality checks to sophisticated exception and death tests—and explains how to harness fatal (`ASSERT_`) and non-fatal (`EXPECT_`) assertions to craft robust, informative tests.

---

## Understanding Assertions: Fatal vs. Non-Fatal

GoogleTest’s assertions come as pairs, distinguished by whether failure aborts the current test function:

- **Fatal assertions (`ASSERT_`)**: Trigger a fatal failure upon failure and abort the current function immediately, preventing further execution and potentially avoiding cascading errors.
- **Non-fatal assertions (`EXPECT_`)**: Record a failure but allow the test function to continue, enabling multiple verifications within a single test.

When deciding which to use, consider the test flow: use `ASSERT_` when subsequent lines depend on passing the assertion, and `EXPECT_` when you want to collect multiple failure points before returning.

---

## Basic Assertion Types

### Boolean Checks
- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Verifies the condition is `true`.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Verifies the condition is `false`.

These assertions support streaming custom failure messages and work seamlessly with predicates returning `testing::AssertionResult` for richer diagnostics.

**Example:**
```cpp
EXPECT_TRUE(IsValid(input)) << "Input validation failed for value: " << input;
ASSERT_FALSE(flags.empty()) << "Flag list should not be empty";
```

### Equality and Relational Checks

Perform comparisons with clear failure messages:

| Macro            | Operation          | Explanation                                       |
|------------------|--------------------|-------------------------------------------------|
| `EXPECT_EQ(a,b)` / `ASSERT_EQ(a,b)` | Equal (`==`)         | Checks if two values are equal                  |
| `EXPECT_NE(a,b)` / `ASSERT_NE(a,b)` | Not equal (`!=`)     | Checks if two values are unequal                |
| `EXPECT_LT(a,b)` / `ASSERT_LT(a,b)` | Less than (`<`)       | Checks if a is less than b                      |
| `EXPECT_LE(a,b)` / `ASSERT_LE(a,b)` | Less or equal (`<=`)  | Checks if a is less than or equal to b         |
| `EXPECT_GT(a,b)` / `ASSERT_GT(a,b)` | Greater than (`>`)    | Checks if a is greater than b                   |
| `EXPECT_GE(a,b)` / `ASSERT_GE(a,b)` | Greater or equal (`>=`)| Checks if a is greater than or equal to b      |

**Note:**
- Comparing pointers with these macros does pointer comparison.
- For C-string content comparison, use string-specific assertions (see below).

**Example:**
```cpp
ASSERT_EQ(vector.size(), expected_size) << "Unexpected vector length";
EXPECT_LT(actual_value, limit) << "Value exceeds limit";
```

### String Comparisons

For C strings and wide strings, use assertions that compare **contents** rather than pointer addresses:

| Macro               | Meaning                                    |
|---------------------|--------------------------------------------|
| `EXPECT_STREQ(a,b)` / `ASSERT_STREQ(a,b)`   | Strings are equal                          |
| `EXPECT_STRNE(a,b)` / `ASSERT_STRNE(a,b)`   | Strings are not equal                      |
| `EXPECT_STRCASEEQ(a,b)` / `ASSERT_STRCASEEQ(a,b)` | Equal ignoring case                     |
| `EXPECT_STRCASENE(a,b)` / `ASSERT_STRCASENE(a,b)` | Not equal ignoring case                 |

These handle null pointers gracefully and convert wide strings to UTF-8 for output.

**Example:**
```cpp
EXPECT_STREQ(output.c_str(), expected_str) << "Output string mismatch";
ASSERT_STRCASEEQ(user_input, "ADMIN");
```

### Floating-Point Comparisons

Due to floating-point rounding errors, direct equality is rare. These assertions address approximate equality:

| Macro                   | Meaning                                                          |
|-------------------------|------------------------------------------------------------------|
| `EXPECT_FLOAT_EQ(a,b)` / `ASSERT_FLOAT_EQ(a,b)`     | Checks float values are approximately equal within 4 ULPs        |
| `EXPECT_DOUBLE_EQ(a,b)` / `ASSERT_DOUBLE_EQ(a,b)`   | Checks double values are approximately equal within 4 ULPs       |
| `EXPECT_NEAR(val1,val2,abs_error)` / `ASSERT_NEAR`  | Checks values differ by no more than `abs_error`                 |

**Example:**
```cpp
EXPECT_DOUBLE_EQ(computed_value, expected_value) << "Values differ significantly";
ASSERT_NEAR(measured, baseline, 0.01);
```

---

## Advanced Assertion Types

### Exception Assertions (Requires Exceptions Enabled)

Test if code throws expected exceptions:

| Macro                          | Description                               |
|--------------------------------|-------------------------------------------|
| `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW` | Verifies `statement` throws `exception_type` |
| `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW`         | Verifies `statement` throws any exception    |
| `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW`           | Verifies `statement` throws no exception     |

**Example:**
```cpp
EXPECT_THROW(Foo(), std::runtime_error) << "Foo() should throw runtime_error";
ASSERT_NO_THROW(Bar());
```

### Predicate Assertions

For complex predicates, GoogleTest provides predicates that:

- Automatically print values of arguments on failure.
- Support up to 5 arguments.
- Support custom formatters to tailor failure messages.

These are useful when `EXPECT_TRUE/ASSERT_TRUE` is not descriptive enough.

|
Macro                | Description                           |
|---------------------|-----------------------------------------|
| `EXPECT_PREDn(pred, args...)` / `ASSERT_PREDn`      | Verify predicate `pred(args...) == true`  |
| `EXPECT_PRED_FORMATn(formatter, args...)` / `ASSERT_PRED_FORMATn` | Custom message formatter                     |

**Example:**
```cpp
bool IsPrime(int n) { ... }
EXPECT_PRED1(IsPrime, value) << "Value is not prime";
```

Or with a predicate-formatter for better messages:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}
...
EXPECT_PRED_FORMAT1(IsEven, num);
```

### Death Assertions

Death tests verify that code terminates the process as expected—useful for testing assertions and fatal errors.

| Macro                          | Description                               |
|--------------------------------|-------------------------------------------|
| `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH` | Verifies `statement` terminates process and emits stderr matching `matcher` |
| `EXPECT_DEATH_IF_SUPPORTED` / `ASSERT_DEATH_IF_SUPPORTED` | Like `EXPECT_DEATH` on supported platforms, otherwise does nothing |
| `EXPECT_DEBUG_DEATH` / `ASSERT_DEBUG_DEATH` | Like `EXPECT_DEATH`, but only in debug mode |
| `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT` | Verifies process exits with status satisfying `predicate` and stderr matching `matcher` |

**Example:**
```cpp
EXPECT_DEATH(DoDangerousStuff(), "Invalid argument");
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
```

**Note:** Death tests run the code in a child process, isolated from the test runner.

---

## Explicit Success and Failure

GoogleTest offers macros to explicitly report success or failure currently unknown from an expression:

- `SUCCEED()`: Reports a successful assertion. Useful as a documentation aid or checkpoint inside complex tests.
- `FAIL()`: Reports a fatal failure, causing an immediate return from the function (can only be used in `void` functions).
- `ADD_FAILURE()`: Reports a non-fatal failure, allowing continued execution.
- `ADD_FAILURE_AT(file, line)`: Reports a non-fatal failure at a specific file and line.

**Example:**
```cpp
switch(state) {
  case READY:
    SUCCEED() << "State is ready";
    break;
  default:
    FAIL() << "Unexpected state encountered";
}
```

---

## Generalized Assertions Using Matchers

Harness the power of GoogleMock’s matchers for expressive conditions with:

- `EXPECT_THAT(value, matcher)` / `ASSERT_THAT(value, matcher)`

Matchers read like English and generate informative failure messages, allowing checks against sub-strings, patterns, ranges, containers, and more.

**Example:**
```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(name, StartsWith("John"));
EXPECT_THAT(log, MatchesRegex(".*Error .*"));
ASSERT_THAT(age, AllOf(Gt(18), Lt(65)));
```

---

## Custom Failure Messages with Streaming

All assertion macros allow streaming custom messages using `<<`, enabling detailed contextual information to aid debugging.

**Example:**
```cpp
EXPECT_EQ(buffer.size(), expected_size) << "Buffer size mismatch: " 
                                       << "expected " << expected_size 
                                       << ", but got " << buffer.size();
```

---

## Scoped Traces: Adding Context to Failures

When an assertion fails deep in helper subroutines, use `SCOPED_TRACE(message);` to include additional trace messages showing where the failure path was triggered.

**Example:**
```cpp
void Helper(int input) {
  SCOPED_TRACE("Helper called with input=" << input);
  EXPECT_GT(input, 0);
}

TEST(MyTestSuite, TestHelper) {
  for (int i = -1; i < 2; ++i) {
    SCOPED_TRACE(testing::Message() << "Loop iteration " << i);
    Helper(i);
  }
}
```

This provides layered tracing, making it easier to pinpoint test failures.

---

## Best Practices

- Use **non-fatal** assertions (`EXPECT_`) for verifying multiple independent expectations within the same test.
- Use **fatal** assertions (`ASSERT_`) when subsequent steps depend on the assertion’s truth to avoid crashes or misleading results.
- Prefer built-in assertions over manual condition checks; they provide better diagnostics and reduce boilerplate.
- When comparing strings, always use the string-specific assertions to check **contents** and avoid pointer comparison pitfalls.
- For floating-point, avoid direct equality and instead use approximate comparisons like `EXPECT_FLOAT_EQ` or `EXPECT_NEAR`.
- For exceptional code paths, always use the exception assertions to verify proper exception behavior.
- Use `EXPECT_THAT` with matchers for expressive and readable assertions, especially with complex data.
- Stream custom messages in assertions to add clarity to failures.
- Use `SCOPED_TRACE` generously within nested or iterative tests to enrich failure context.

---

## Common Pitfalls and Troubleshooting

<AccordionGroup title="Common Issues with Assertions">
<Accordion title="Using ASSERT_* in Non-void Functions">
Fatal assertions cause immediate return, which is only permitted inside `void` functions. Attempting to use `ASSERT_*` in functions returning a value will cause compilation errors. Use `EXPECT_*` or refactor your function to return void when fatal failure semantics are required.
</Accordion>
<Accordion title="Pointer vs. Value Comparison for Strings">
Using `EXPECT_EQ` or `ASSERT_EQ` on C strings compares pointer values, not string content. To compare string content, use `EXPECT_STREQ` or `ASSERT_STREQ`. Mixing these up causes false failures or successes.
</Accordion>
<Accordion title="Death Tests Do Not Propagate Side Effects">
Code in death test macros runs in a child process. Any in-memory side effects (like memory deallocation) won't affect the parent process. Avoid managing resources in death tests or account for this isolation.
</Accordion>
<Accordion title="Multiple Death Assertions on Same Line">
Placing more than one death assertion on the same source line leads to compilation errors due to macro expansions. Ensure each death test macro is on its own line.
</Accordion>
<Accordion title="Evaluating Assertion Arguments Exactly Once">
All assertion macros evaluate their arguments exactly once, avoiding side effects from multiple evaluations. Use this property to write concise and safe assertions.
</Accordion>
</AccordionGroup>

---

## Example: Using Various Assertions

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>  // For matchers.

// Basic test using equality and boolean assertions.
TEST(BasicMathTest, AdditionWorks) {
  int sum = 2 + 2;
  EXPECT_EQ(sum, 4) << "Sum should be 4";
  ASSERT_TRUE(sum == 4) << "Sum must be correct before continuing";
}

// String content test.
TEST(StringTest, CompareCStrings) {
  const char* a = "hello";
  const char* b = "hello";
  EXPECT_STREQ(a, b) << "C strings must have same contents";
}

// Floating-point approximate equality.
TEST(FloatTest, CloseEnough) {
  double x = 0.1 + 0.2;
  double y = 0.3;
  EXPECT_DOUBLE_EQ(x, y) << "Floating point sums can be imprecise";
}

// Exception testing.
TEST(ExceptionTest, ThrowsRuntimeError) {
  EXPECT_THROW(throw std::runtime_error("fail"), std::runtime_error);
}

// Using matchers for expressive tests.
TEST(PathTest, MatchesPrefix) {
  std::string path = "/usr/local/bin/app";
  EXPECT_THAT(path, testing::StartsWith("/usr/local"));
}

// Death test example (POSIX only).
#if GTEST_HAS_DEATH_TEST
TEST(DeathTest, SegfaultOnNull) {
  EXPECT_DEATH( {
    int* p = nullptr;
    *p = 42;
  }, "");
}
#endif
```

---

## Additional Assertions and Utilities

Explore the full range of GoogleTest assertions in the [Assertions Reference](reference/assertions.md) including:

- `SUCCEED()`, `FAIL()` and custom failure macros
- Predicate assertions for complex checks
- Windows HRESULT checks
- Floating-point predicate format assertions

These empower you to write nuanced, clear, and diagnostic-rich tests.

---

## Summary

GoogleTest’s assertion library is designed to let you express expected properties of your code clearly and robustly, quickly identifying failures with precise and actionable diagnostics. With fatal and non-fatal assertions, rich predicate support, flexible exception checks, and death tests, you can confidently verify your C++ code’s behavior in an organized and expressive manner.

---

## Next Steps

- Consult [Writing and Structuring Tests](../guides/core-testing-workflows/writing-and-structuring-tests.md) for integrating assertions into effective tests.
- Explore [Specifying Expectations and Actions](../guides/mocking-and-behavior-verification/specifying-expectations-and-actions.md) to combine assertions with mocking.
- Use [Quick Validation Checklist](../getting-started/validation-troubleshooting/validate-setup.md) to verify your environment.

---

For comprehensive details, see the [Assertions Reference](reference/assertions.md).

---

## External Links
- GoogleTest official repo: [https://github.com/google/googletest](https://github.com/google/googletest)
- GoogleTest Primer: [primer.md](../primer.md)
- GoogleMock Matchers reference: [matchers.md](reference/matchers.md)
- Death Tests Advanced Info: [advanced.md#death-tests](../advanced.md#death-tests)

---

<p align="center"><em>This documentation section is dedicated strictly to assertions and expectations in GoogleTest as part of its Core Testing APIs.</em></p>
