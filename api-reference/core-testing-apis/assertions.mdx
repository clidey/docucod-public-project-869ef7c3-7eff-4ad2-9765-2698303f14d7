---
title: "Assertions"
description: "Complete reference for all assertion macros provided by GoogleTest. Details the usage, expected parameters, and behavioral differences between fatal (ASSERT_*) and non-fatal (EXPECT_*) assertion macros, empowering users to effectively verify diverse test conditions."
---

# Assertions Reference

This page provides a comprehensive reference for all assertion macros provided by GoogleTest. These macros empower you to verify diverse test conditions effectively by checking boolean conditions, comparing values, validating exceptions, and more. Assertion macros come in pairs: `ASSERT_*` macros generate fatal failures (aborting the current function), while `EXPECT_*` macros generate nonfatal failures (allowing the function to continue). This distinction lets you control test flow based on assertion criticality.

All assertion macros support streaming custom failure messages using the `<<` operator. Any value streamable to `ostream` can be used, including wide strings which GoogleTest converts to UTF-8 for output.

---

## 1. Explicit Success and Failure

Sometimes, your test logic requires signaling success or failure without testing a specific value.

### SUCCEED

- **Usage**: `SUCCEED()`
- **Purpose**: Generates a success explicitly. Does not guarantee overall test success but documents intent.
- **Example**:

  ```cpp
  SUCCEED() << "Explicit success message.";
  ```

### FAIL

- **Usage**: `FAIL()`
- **Purpose**: Generates a fatal failure immediately aborting the current function. Use in void-returning functions.
- **Example**:

  ```cpp
  if (unexpected_condition) {
    FAIL() << "Unexpected failure happened.";
  }
  ```

### ADD_FAILURE

- **Usage**: `ADD_FAILURE()`
- **Purpose**: Generates a nonfatal failure allowing the current function to continue.
- **Example**:

  ```cpp
  ADD_FAILURE() << "Minor failure, but continuing tests.";
  ```

### ADD_FAILURE_AT

- **Usage**: `ADD_FAILURE_AT(file_path, line_number)`
- **Purpose**: Generates a nonfatal failure at the specified source file location.
- **Example**:

  ```cpp
  ADD_FAILURE_AT("myfile.cc", 123) << "Problem here.";
  ```

---

## 2. Generalized Assertion

### EXPECT_THAT / ASSERT_THAT

- **Usage**: 
  ```cpp
  EXPECT_THAT(value, matcher);
  ASSERT_THAT(value, matcher);
  ```
- **Purpose**: Uses gMock matchers for expressive verification (e.g., matching substrings, ranges, regex).
- **Example**:

  ```cpp
  using ::testing::StartsWith;
  EXPECT_THAT(my_string, StartsWith("Hello"));
  ASSERT_THAT(number, ::testing::AllOf(::testing::Gt(5), ::testing::Lt(10)));
  ```

- **Value**: Provides readable assertions with detailed failure messaging.

---

## 3. Boolean Condition Assertions

### EXPECT_TRUE / ASSERT_TRUE

- **Checks**: Conditions evaluate to `true`.
- **Example**:
  ```cpp
  EXPECT_TRUE(is_valid);
  ASSERT_TRUE(IsReady());
  ```

### EXPECT_FALSE / ASSERT_FALSE

- **Checks**: Conditions evaluate to `false`.
- **Example**:
  ```cpp
  EXPECT_FALSE(has_errors);
  ASSERT_FALSE(IsEmpty());
  ```

---

## 4. Binary Comparisons

These macros compare two values using relational operators. Arguments must be comparable and are evaluated exactly once.

| Macro           | Purpose                                           |
|-----------------|---------------------------------------------------|
| `EXPECT_EQ`     | Verify `val1 == val2`                            |
| `ASSERT_EQ`     | Same as `EXPECT_EQ`, but fatal failure          |
| `EXPECT_NE`     | Verify `val1 != val2`                            |
| `ASSERT_NE`     | Fatal version of `EXPECT_NE`                     |
| `EXPECT_LT`     | Verify `val1 < val2`                             |
| `ASSERT_LT`     | Fatal version of `EXPECT_LT`                     |
| `EXPECT_LE`     | Verify `val1 <= val2`                            |
| `ASSERT_LE`     | Fatal version of `EXPECT_LE`                     |
| `EXPECT_GT`     | Verify `val1 > val2`                             |
| `ASSERT_GT`     | Fatal version of `EXPECT_GT`                     |
| `EXPECT_GE`     | Verify `val1 >= val2`                            |
| `ASSERT_GE`     | Fatal version of `EXPECT_GE`                     |

**Important Details:**

- Pointer types use pointer equality, not content equality. For C strings, use the dedicated string macros (see next section).
- When comparing a pointer to `NULL`, prefer `EXPECT_EQ(ptr, nullptr)`.

---

## 5. C-String Comparisons

These specifically compare C strings by content, not by pointer.

| Macro              | Purpose                                   |
|--------------------|-------------------------------------------|
| `EXPECT_STREQ`     | Verify C strings are equal                |
| `ASSERT_STREQ`     | Fatal version of `EXPECT_STREQ`           |
| `EXPECT_STRNE`     | Verify C strings are not equal            |
| `ASSERT_STRNE`     | Fatal version of `EXPECT_STRNE`           |
| `EXPECT_STRCASEEQ` | Verify C strings are equal ignoring case |
| `ASSERT_STRCASEEQ` | Fatal version of `EXPECT_STRCASEEQ`       |
| `EXPECT_STRCASENE` | Verify C strings differ ignoring case    |
| `ASSERT_STRCASENE` | Fatal version of `EXPECT_STRCASENE`       |

**Example:**

```cpp
EXPECT_STREQ("hello", "hello");
ASSERT_STRCASEEQ("FOO", "foo");
```

Wide strings (`wchar_t*`) are also supported, being converted to UTF-8 in outputs.

---

## 6. Floating-Point Comparisons

Due to rounding errors, exact equality is rare. GoogleTest provides specialized macros for approximate comparisons:

| Macro            | Purpose                                          |
|------------------|--------------------------------------------------|
| `EXPECT_FLOAT_EQ` | Verify floats are approximately equal (4 ULPs)  |
| `ASSERT_FLOAT_EQ` | Fatal version of `EXPECT_FLOAT_EQ`               |
| `EXPECT_DOUBLE_EQ`| Verify doubles are approximately equal (4 ULPs) |
| `ASSERT_DOUBLE_EQ`| Fatal version of `EXPECT_DOUBLE_EQ`              |
| `EXPECT_NEAR`    | Verify difference is within an absolute error   |
| `ASSERT_NEAR`    | Fatal version of `EXPECT_NEAR`                    |

**Example:**

```cpp
EXPECT_FLOAT_EQ(3.14f, my_float_value);
ASSERT_DOUBLE_EQ(3.141592653, my_double_value);
EXPECT_NEAR(expected, actual, 0.001);
```

---

## 7. Exception Assertions

Require exceptions enabled in your build environment.

| Macro             | Purpose                                         |
|-------------------|-------------------------------------------------| 
| `EXPECT_THROW`    | Verifies statement throws a specific exception |
| `ASSERT_THROW`    | Fatal version                                   |
| `EXPECT_ANY_THROW`| Verifies statement throws any exception         |
| `ASSERT_ANY_THROW`| Fatal version                                   |
| `EXPECT_NO_THROW` | Verifies statement does not throw exception    |
| `ASSERT_NO_THROW` | Fatal version                                   |

**Example:**

```cpp
EXPECT_THROW(MyFunc(), std::runtime_error);
ASSERT_NO_THROW(ClearCache());
```

Note: The statement can be a compound block surrounded by {}.

---

## 8. Predicate Assertions

Enable more complex verification with detailed failure messages.

### EXPECT_PRED* / ASSERT_PRED*

- Invoke a predicate function or functor returning `bool`. Arity: 1 to 5 parameters.
- Arguments must be streamable to `ostream`.

### EXPECT_PRED_FORMAT* / ASSERT_PRED_FORMAT*

- Invoke a predicate-formatter function returning `testing::AssertionResult`.
- Allows full customization of failure messages.

**Example predicate function:**

```cpp
bool IsEven(int n) { return (n % 2) == 0; }
EXPECT_PRED1(IsEven, value);
```

**Example predicate-formatter:**

```cpp
testing::AssertionResult IsEvenFormatted(const char* expr, int n) {
  if (IsEven(n)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " evaluates to " << n << ", which is odd.";
}
EXPECT_PRED_FORMAT1(IsEvenFormatted, value);
```

---

## 9. Windows HRESULT Assertions (For Windows only)

| Macro                      | Purpose                        |
|----------------------------|--------------------------------|
| `EXPECT_HRESULT_SUCCEEDED` | Verify HRESULT is a success code |
| `ASSERT_HRESULT_SUCCEEDED` | Fatal version                   |
| `EXPECT_HRESULT_FAILED`    | Verify HRESULT is failure code  |
| `ASSERT_HRESULT_FAILED`    | Fatal version                   |

**Example:**

```cpp
EXPECT_HRESULT_SUCCEEDED(CoInitialize(nullptr));
ASSERT_HRESULT_FAILED(MyComCall());
```

---

## 10. Death Assertions

Verify that a statement causes the process to terminate.

| Macro                | Purpose                                                    |
|----------------------|------------------------------------------------------------|
| `EXPECT_DEATH`       | Asserts statement causes process death with stderr regex  |
| `ASSERT_DEATH`       | Fatal version                                             |
| `EXPECT_DEATH_IF_SUPPORTED` | Runs death test if supported else does nothing        |
| `ASSERT_DEATH_IF_SUPPORTED` | Fatal version of above                                 |
| `EXPECT_DEBUG_DEATH` | Runs death test in debug mode only                         |
| `ASSERT_DEBUG_DEATH` | Fatal version                                             |
| `EXPECT_EXIT`        | Asserts process exits with status, stderr matching regex  |
| `ASSERT_EXIT`        | Fatal version                                             |

The death test runs the statement in a subprocess. The parent verifies:

- Process exited (non-zero for death tests, or satisfy predicate for exit tests)
- STDERR matches given regex (or matcher)

**Example:**

```cpp
EXPECT_DEATH({int x = 0; MyCrashFunc(&x);}, "segmentation fault");
EXPECT_EXIT(NormalExit(), ::testing::ExitedWithCode(0), "Success");
```

---

## 11. Additional Notes

### Streaming Custom Messages

All assertions allow streaming informative messages using the `<<` operator.

### Use of ASSERT_ vs EXPECT_

Prefer `EXPECT_` unless failure makes further execution meaningless.

### Single-Evaluation of Arguments

Assertions evaluate arguments exactly once to avoid side effects.

### How to Check for Fatal Failures in Subroutines

Use `ASSERT_NO_FATAL_FAILURE(subroutine());` or check `HasFatalFailure()`.

### Skipping Tests at Runtime

Use `GTEST_SKIP() << "reason";` to skip tests dynamically.

---

## Code Examples

### Using ASSERT_EQ and EXPECT_EQ

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  ASSERT_EQ(Factorial(0), 1) << "Factorial of zero should be 1";
}

TEST(FactorialTest, HandlesPositiveInput) {
  for (int i = 1; i <= 5; ++i) {
    EXPECT_EQ(Factorial(i), ExpectedFactorialValue(i))
        << "Mismatch at i=" << i;
  }
}
```

### Using EXPECT_THROW

```cpp
TEST(MyExceptionTest, ThrowsOnInvalidInput) {
  EXPECT_THROW(MyFunction(-1), std::invalid_argument);
}
```

### Streaming Custom Failure Messages

```cpp
EXPECT_TRUE(IsValidConfig(config)) << "Invalid config: " << config.ToString();
```

### Using Predicate Assertions

```cpp
bool IsPositive(int n) { return n > 0; }

EXPECT_PRED1(IsPositive, value);
```

### Using Death Assertions

```cpp
EXPECT_DEATH({ AbortFunction(); }, "Fatal error");
```

### Scoped Trace to Enhance Failure Context

```cpp
void Helper(int index) {
  SCOPED_TRACE(testing::Message() << "Index: " << index);
  EXPECT_EQ(Process(index), expected[index]);
}

TEST(MyTestSuite, ProcessTests) {
  for (int i = 0; i < 10; ++i) {
    Helper(i);
  }
}
```

Multiple failures inside `Helper` will output the trace line with index.

---