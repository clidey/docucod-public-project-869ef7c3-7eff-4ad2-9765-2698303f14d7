---
title: "Assertions and Expectations"
description: "Provides a complete reference for writing assertions in tests, including equality, inequality, exception, predicate, and user-defined assertions. Details both fatal (ASSERT_*) and non-fatal (EXPECT_*) variants, how to interpret assertion results, and examples of advanced idioms."
---

# Assertions and Expectations Reference

This page provides a comprehensive guide to GoogleTest's assertion macros that power robust C++ testing. You'll learn how to write and interpret assertions that verify code behavior, including equality checks, inequality, exceptions, predicates, and custom assertions. Both fatal (`ASSERT_*`) and non-fatal (`EXPECT_*`) variants are covered, to help you control test flow according to your needs.

---

## Introduction

Assertions are the fundamental mechanism through which your tests verify expected behavior. Each assertion can either pass (success) or fail (nonfatal or fatal failure), impacting whether subsequent test code is executed. GoogleTest offers extensive macros categorized by their intent and use case.

You can stream detailed failure messages directly to assertions using the `<<` operator for enhanced diagnostics.

---

## 1. Explicit Success and Failure

These are basic assertions to mark outcomes explicitly without evaluating conditions.

### SUCCEED()

- Generates a success.
- Useful in documenting successful checkpoints.
- Does **not** cause the overall test to succeed (no impact on test pass/fail status).

### FAIL()

- Causes a fatal failure, aborting the current function immediately.
- Usable only in `void` functions due to semantics.
- Example:

```cpp
FAIL() << "Reached an unexpected code path!";
```

### ADD_FAILURE()

- Reports a nonfatal failure but lets the current function proceed.

### ADD_FAILURE_AT(file, line)

- Reports a nonfatal failure at the specified file and line.
- Use for failure points outside the current source location.

---

## 2. General Assertions Using Matchers

GoogleTest supports powerful matcher-based assertions for expressive validations using `EXPECT_THAT` and `ASSERT_THAT`, derived from gMock syntax.

```cpp
#include <gmock/gmock.h>

EXPECT_THAT(value, StartsWith("Hello"));
EXPECT_THAT(number, AllOf(Gt(5), Lt(10)));
```

Matchers provide detailed failure messages and can be combined or customized.

---

## 3. Boolean Condition Assertions

These verify simple true/false conditions.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

If conditions fail, they report the value and print any user-supplied stream message.

Example:

```cpp
EXPECT_TRUE(ptr != nullptr) << "Pointer must not be null";
ASSERT_FALSE(error_flag) << "Unexpected error";
```

---

## 4. Binary Comparison Assertions

These compare two values according to usual relational operators.

All these come in fatal `ASSERT_` and nonfatal `EXPECT_` variants.

| Assertion      | Description                            |
|----------------|-------------------------------------|
| `EXPECT_EQ` / `ASSERT_EQ`  | Verifies `val1 == val2`                 |
| `EXPECT_NE` / `ASSERT_NE`  | Verifies `val1 != val2`                 |
| `EXPECT_LT` / `ASSERT_LT`  | Verifies `val1 < val2`                  |
| `EXPECT_LE` / `ASSERT_LE`  | Verifies `val1 <= val2`                 |
| `EXPECT_GT` / `ASSERT_GT`  | Verifies `val1 > val2`                  |
| `EXPECT_GE` / `ASSERT_GE`  | Verifies `val1 >= val2`                 |

**Important Notes:**
- Arguments are evaluated exactly once.
- Using these on pointers compares addresses; use string-specific macros for C strings.
- For nullptr, use `EXPECT_EQ(ptr, nullptr)` instead of `EXPECT_EQ(ptr, NULL)`.

Example:

```cpp
EXPECT_EQ(5, CalculateSum(2, 3));
ASSERT_NE(nullptr, my_pointer);
```

---

## 5. String Comparison Assertions

These compare **C strings** or wide C strings by content rather than pointer equality.

| Assertion        | Description                                |
|------------------|-------------------------------------------|
| `EXPECT_STREQ` / `ASSERT_STREQ`   | Verifies two C strings have identical content |
| `EXPECT_STRNE` / `ASSERT_STRNE`   | Verifies two C strings differ in content      |
| `EXPECT_STRCASEEQ` / `ASSERT_STRCASEEQ` | Case-insensitive string equality           |
| `EXPECT_STRCASENE` / `ASSERT_STRCASENE` | Case-insensitive string inequality         |

For wide strings (`wchar_t*`), equivalent semantics apply with Unicode-aware UTF-8 output.

Example:

```cpp
EXPECT_STREQ("hello", GetName().c_str());
ASSERT_STRNE(user_input, "exit");
```

---

## 6. Floating-Point Comparison

Due to the imprecision of floating-point math, GoogleTest provides specialized assertions with tolerance based on ULPs (Units in the Last Place) or user-defined absolute errors.

| Assertion      | Description                                  |
|----------------|---------------------------------------------|
| `EXPECT_FLOAT_EQ` / `ASSERT_FLOAT_EQ` | Checks floats approximately equal (within 4 ULPs) |
| `EXPECT_DOUBLE_EQ` / `ASSERT_DOUBLE_EQ` | Checks doubles approximately equal (within 4 ULPs) |
| `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR` | Checks the difference doesn't exceed `abs_error` |

Example:

```cpp
EXPECT_FLOAT_EQ(result, expected_value);
ASSERT_NEAR(loss, 0.01, 0.001);
```

---

## 7. Exception Assertions

These verify exception-throwing behavior if exceptions are enabled.

- `EXPECT_THROW(statement, ExceptionType)` / `ASSERT_THROW`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW`

The `statement` can be a block, not just a single expression.

Example:

```cpp
EXPECT_THROW({ Process(invalid_input); }, std::invalid_argument);
ASSERT_NO_THROW(Calculate(42));
```

---

## 8. Predicate Assertions

Predicate assertions allow verifying complex Boolean predicates with clearer error messages.

### EXPECT_PRED*

Macros `EXPECT_PRED1` to `EXPECT_PRED5`, and corresponding `ASSERT_PRED*`, accept a predicate function or functor and values to test.

Example:

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, value);
```

### EXPECT_PRED_FORMAT*

If you need custom failure messages or your predicate cannot convert to bool directly, use `EXPECT_PRED_FORMAT*` variants with a predicate-formatter function returning `testing::AssertionResult`.

Example:

```cpp
AssertionResult IsEvenFmt(const char* expr, int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << expr << " is " << n << ", which is not even.";
}
EXPECT_PRED_FORMAT1(IsEvenFmt, value);
```

These assertions evaluate arguments exactly once, prevent side-effects surprises, and provide rich diagnostics.

---

## 9. Windows HRESULT Assertions

On Windows, the following macros help verify `HRESULT` results:

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)` — verifies that `expr` returned a success HRESULT.
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)` — verifies that `expr` returned a failure HRESULT.

Example:

```cpp
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(...));
EXPECT_HRESULT_FAILED(DoFailingOperation());
```

Failure messages include the corresponding system error text for easier troubleshooting.

---

## 10. Death Assertions

Death tests verify that some code causes the process to terminate under expected conditions.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH` — verifies `statement` terminates with non-zero exit and `stderr` output matches `matcher`.
- `EXPECT_DEATH_IF_SUPPORTED` / `ASSERT_DEATH_IF_SUPPORTED` — same, but no failure if death tests unsupported.
- `EXPECT_DEBUG_DEATH` / `ASSERT_DEBUG_DEATH` — runs only in debug mode.
- `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT` — verifies termination, exit code predicate, and output.

Death test statements can be compound blocks.

**Important:** Name your test suite with the suffix `DeathTest` to ensure they run before other tests, improving reliability.

Example:

```cpp
TEST(MyDeathTest, CheckCrash) {
  ASSERT_DEATH({ CrashFunction(); }, "Expected error message");
}

TEST(MyDeathTest, ExitNormally) {
  EXPECT_EXIT(NormalExit(), ExitedWithCode(0), "Success");
}
```

---

## 11. Using Assertions in Sub-Routines

When putting assertions in helper functions, keep in mind that fatal failures abort only the current function, not the calling test. To handle this:

- Use `SCOPED_TRACE()` to add contextual trace messages at call sites:

```cpp
void Helper(int n) {
  SCOPED_TRACE(testing::Message() << "n = " << n);
  EXPECT_EQ(n % 2, 0);
}
```

- Use `ASSERT_NO_FATAL_FAILURE(Helper())` to ensure no fatal failures occurred.
- Check `HasFatalFailure()` after the call to abort or skip further test logic if needed.

`SCOPED_TRACE` annotations help identify which iteration or call caused the assertion failure, especially inside loops or recursive calls.

---

## 12. Best Practices and Tips

- Prefer `EXPECT_` macros when you want to continue running tests after failure.
- Use `ASSERT_` macros to stop test execution immediately on a failure.
- Stream additional messages to assertions to provide more insight when they fail.
- For complex checks, implement predicate formatters to enhance failure messages.
- Avoid placing fatal assertions in constructors or destructors; use `SetUp()` and `TearDown()` instead.
- When using death tests, make sure test suites use consistent naming (`*DeathTest`) for proper order.

---

## 13. Example Usage

```cpp
TEST(FooTest, Example) {
  int val = ComputeValue();

  EXPECT_EQ(val, 42) << "Value should match the answer to everything.";

  ASSERT_TRUE(IsValid(val)) << "Value must be valid to proceed.";

  EXPECT_PRED1(IsEven, val) << "Value is expected to be even.";

  ASSERT_NO_FATAL_FAILURE(HelperFunction(val));
}

TEST(DeathSuite, ShouldCrash) {
  ASSERT_DEATH({ CrashFunction(); }, "Segmentation fault");
}
```

---

## 14. Troubleshooting Common Issues

- **Fatal assertions in non-void functions cause compilation errors:** Use only `EXPECT_` macros or refactor to void functions.
- **Missing test failures:** Ensure `RUN_ALL_TESTS()` return value is used to detect failures.
- **Death tests not running:** Verify test suite naming and death test style flags.
- **Unexpected continued test execution after `ASSERT_*`:** Fatal failures abort only current function; use `HasFatalFailure()` or `ASSERT_NO_FATAL_FAILURE()` as needed.

---

This reference empowers you to craft precise, informative, and maintainable tests using GoogleTest's rich assertion framework.

---

# Related Documentation

- [Assertions Reference](reference/assertions.md) - Detailed macro definitions
- [Advanced GoogleTest Topics](guides/real-world-usage-and-best-practices/using-assertions-effectively) - Deep dive into assertions and predicate usage
- [Writing and Running Tests](api-reference/core-testing-apis/writing-tests) - Test definitions and execution
- [Death Tests Guide](guides/performance-and-specialized-use-cases/writing-and-using-death-tests) - Practical death test writing
- [Predicate Assertions](reference/assertions.md#predicates) - Usage and customization
- [SCOPED_TRACE](guides/real-world-usage-and-best-practices/using-assertions-effectively#adding-traces-to-assertions) - Debugging assistance

For practical examples and usage patterns, refer also to the [GoogleTest Primer](overview/introduction-overview/product-welcome).

---

<Info>
This page offers a precise, user-focused guide on all assertion macros in GoogleTest, catering to C++ developers who want to write comprehensive verifications for their code. It explains how to choose and use different assertions for your testing goals and handling test flow.
</Info>
