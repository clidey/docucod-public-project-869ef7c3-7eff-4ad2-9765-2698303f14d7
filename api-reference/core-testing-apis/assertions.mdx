---
title: "Assertions and Assertions Macros"
description: "Reference for the wide range of assertion macros provided by GoogleTest, such as EXPECT_EQ, ASSERT_NE, and custom user assertions. Coverage includes argument contracts, fatal/non-fatal behaviors, and typical error-handling practices, enabling users to express and validate expectations in their test logic."
---

# Assertions and Assertions Macros

GoogleTest provides a comprehensive suite of assertion macros that allow you to validate the behavior of your code with precision and clarity. This reference documents these macros, focusing on their usage patterns, argument requirements, and differences between non-fatal (`EXPECT_`) and fatal (`ASSERT_`) variants.

---

## 1. Understanding Assertions in GoogleTest

Assertions are the core building block for expressing expected conditions in your tests. They come in pairs:

- **`EXPECT_` macros:** Generate *nonfatal* failures allowing the current test function to continue.
- **`ASSERT_` macros:** Generate *fatal* failures that abort the current function immediately.

Both support streaming custom failure messages using the `<<` operator for enhanced debugging.

---

## 2. Common Patterns and Behavior

### 2.1 Fatal vs Nonfatal Assertions

- Use `ASSERT_` macros when continuing the test after a failure makes no sense (e.g., essential preconditions).
- Use `EXPECT_` macros when you want the test to proceed to check further assertions even after a failure.

### 2.2 Streaming Custom Messages

All assertions accept any data streamable to an `ostream` for additional context, for example:

```cpp
EXPECT_TRUE(is_valid) << "Validation failed due to invalid input";
```

### 2.3 Evaluation Guarantees

Arguments to assertions are evaluated exactly once, so it's safe for them to have side effects, but the order of evaluation is undefined.

---

## 3. Boolean Condition Assertions

### EXPECT_TRUE / ASSERT_TRUE

Verify that a condition evaluates to true.

```cpp
EXPECT_TRUE(x > 0);
ASSERT_TRUE(is_initialized) << "Object was not initialized.";
```

### EXPECT_FALSE / ASSERT_FALSE

Verify that a condition evaluates to false.

---

## 4. Binary Comparison Assertions

These macros compare two values with the respective relational operator. They print both values upon failure for diagnostic clarity.

### Equality and Inequality

- **`EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`**: Verify `val1 == val2`. For pointers, checks pointer equality (not content).
  - Use `EXPECT_STREQ` or `EXPECT_STRNE` for C-style string content comparisons.

- **`EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`**: Verify `val1 != val2`. Same pointer caveats as above.

### Ordering Comparisons

- `EXPECT_LT` / `ASSERT_LT`: less than
- `EXPECT_LE` / `ASSERT_LE`: less than or equal
- `EXPECT_GT` / `ASSERT_GT`: greater than
- `EXPECT_GE` / `ASSERT_GE`: greater than or equal

Example:

```cpp
EXPECT_LT(actual_value, upper_bound);
ASSERT_GE(array_size, 1);
```

---

## 5. String Comparison Assertions

Specifically for C-style strings â€” comparing content rather than pointer addresses.

- `EXPECT_STREQ` / `ASSERT_STREQ`: expect two C strings to be equal.
- `EXPECT_STRNE` / `ASSERT_STRNE`: expect two C strings to be unequal.
- `EXPECT_STRCASEEQ` / `ASSERT_STRCASEEQ`: case-insensitive equality.
- `EXPECT_STRCASENE` / `ASSERT_STRCASENE`: case-insensitive inequality.


---

## 6. Floating-Point Comparisons

Due to rounding errors, exact floating-point comparisons (`EXPECT_EQ`) are discouraged. Use these specialized assertions:

- `EXPECT_FLOAT_EQ` / `ASSERT_FLOAT_EQ`: approximate equality for `float` values (within 4 ULPs).
- `EXPECT_DOUBLE_EQ` / `ASSERT_DOUBLE_EQ`: approximate equality for `double` values (within 4 ULPs).
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`: check if `|val1 - val2| <= abs_error`.

---

## 7. Exception Assertions

Verify exception throwing behavior (enabled if exceptions are enabled in the build):

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`

---

## 8. Explicit Success and Failure

- **`SUCCEED()`**: Marks a test as succeeded (documentary, no visible output currently).
- **`FAIL()`**: Generates a fatal failure and aborts the current function; suitable only in `void` methods.
- **`ADD_FAILURE()`**: Generates a nonfatal failure but allows function continuation.

Example to mark unexpected code paths:

```cpp
switch(value) {
  case expected_value: break;
  default:
    FAIL() << "Unexpected value encountered!";
}
```

---

## 9. Predicate and Matcher-based Assertions

### 9.1 `EXPECT_THAT` / `ASSERT_THAT`

enable assertions using [matchers](reference/matchers.md) for expressive validation.

Example:

```cpp
EXPECT_THAT(str, StartsWith("Hello"));
ASSERT_THAT(numbers, AllOf(Gt(0), Lt(100)));
```

Matchers provide rich composability for complex comparisons.

### 9.2 Predicate Assertions

- `EXPECT_PRED1` to `EXPECT_PRED5` and their `ASSERT_` counterparts allow asserting a predicate function with 1 to 5 arguments.

- `EXPECT_PRED_FORMAT` variants enable custom formatting of failure messages.

Use when you want to verify custom Boolean functions or fine-tune assertion output.

Example:

```cpp
bool IsEven(int n) { return (n % 2) == 0; }
EXPECT_PRED1(IsEven, value);
```

---

## 10. HRESULT Assertions (Windows-Only)

Convenient macros to verify success or failure of `HRESULT`-returning functions:

- `EXPECT_HRESULT_SUCCEEDED(expression)` / `ASSERT_HRESULT_SUCCEEDED(expression)`
- `EXPECT_HRESULT_FAILED(expression)` / `ASSERT_HRESULT_FAILED(expression)`

Includes printing of readable error messages on failure.

---

## 11. Death Assertions

Assertions that expect the tested code to terminate the process, used for fatal condition checking.

- `EXPECT_DEATH` / `ASSERT_DEATH`
- `EXPECT_DEATH_IF_SUPPORTED` / `ASSERT_DEATH_IF_SUPPORTED`
- `EXPECT_DEBUG_DEATH` / `ASSERT_DEBUG_DEATH` (run only in debug mode)
- `EXPECT_EXIT` / `ASSERT_EXIT` allow specifying the exit status predicate and output matcher

Example:

```cpp
ASSERT_DEATH({ DoUnsafeOperation(); }, "Error.*fatal");
EXPECT_EXIT(NormalExit(), ExitedWithCode(0), "Success");
```


---

## 12. Best Practices and Common Pitfalls

- **Set expectations before exercising code:** Expectations (e.g., `EXPECT_CALL`) must be set before the mock method is invoked, or behavior is undefined.
- **Use `ASSERT_` for preconditions:** If your test cannot meaningfully continue after a failed check, use `ASSERT_` variants.
- **Prefer `EXPECT_` for multiple checks:** Allows multiple assertions to run and report collectively.
- **Do not use `EXPECT_EQ` on `const char*`:** Use `EXPECT_STREQ` for string content comparison instead.
- **Use `EXPECT_THAT` to leverage Matchers:** For enhanced flexibility whether testing strings, containers, or custom types.
- **Passing custom failure messages:** Use streaming to provide detailed diagnostics on failure.
- **Avoid side-effects in predicate parameters:** Arguments are evaluated once but avoid costly or modifying side effects.
- **When testing exceptions, enable exceptions:** Ensure your build supports exceptions.

---

## 13. Examples

### 13.1 Simple Equality Check

```cpp
TEST(MathTest, BasicEquality) {
  EXPECT_EQ(add(2, 2), 4);
  ASSERT_NE(subtract(5, 3), 0) << "Subtraction failed";
}
```

### 13.2 Floating-Point Check

```cpp
TEST(CalculationTest, NearEquality) {
  EXPECT_NEAR(compute_pi(), 3.1415, 0.0001);
}
```

### 13.3 String Content Comparison

```cpp
TEST(StringTest, ContentEquality) {
  const char* s1 = "hello";
  const char* s2 = "hello";
  EXPECT_STREQ(s1, s2);
}
```

### 13.4 Boolean Condition

```cpp
TEST(ConditionTest, IsTrue) {
  EXPECT_TRUE(is_ready());
  ASSERT_FALSE(has_error()) << "Unexpected error state";
}
```

### 13.5 Matcher Usage

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;

TEST(MatcherTest, StringPrefix) {
  std::string greeting = "Hello, World!";
  EXPECT_THAT(greeting, StartsWith("Hello"));
}
```

### 13.6 Predicate Assertion

```cpp
bool IsPositive(int n) { return n > 0; }

TEST(PredicateTest, PositiveCheck) {
  EXPECT_PRED1(IsPositive, 5);
}
```

---

## 14. Troubleshooting

- **Assertion macro not accepting your input?** Check that types support streaming for messages.
- **Test aborts unexpectedly?** Use `EXPECT_` macros instead of `ASSERT_` where possible.
- **Comparing C strings?** Use `EXPECT_STREQ` or `EXPECT_STRNE` instead of `EXPECT_EQ` to compare content.
- **Floating point comparisons failing?** Avoid `EXPECT_EQ` for floats/doubles, use `EXPECT_FLOAT_EQ`, `EXPECT_DOUBLE_EQ`, or `EXPECT_NEAR` with an error bound.
- **Death test hangs or fails?** Use the naming convention `*DeathTest` for tests and ensure test runs single-threaded when possible.

---

For exhaustive details on all assertion macros, including less common ones, see the [GoogleTest Assertions Reference](reference/assertions.md).

---

## 15. Integration with Mocking Framework

While this page covers assertions generally, you can integrate assertions with GoogleMock invocations for verifying mock interactions. For example, use assertions inside your mock action lambdas or to validate matchers via `EXPECT_THAT`.

---

## 16. Additional Resources

- [GoogleTest Assertions Reference](reference/assertions.md)
- [Matchers Reference for expressive, composable predicates](reference/matchers.md)
- [GoogleMock Tutorial for mocks and expectations](guides/mocking_patterns/defining_and_using_mocks.md)
- [GoogleTest Primer](docs/primer.md) for fundamental testing concepts

---

This reference arms you with the building blocks to validate virtually any aspect of your C++ code efficiently, reliably, and expressively, setting the foundation for maintainable, robust test suites.