---
title: "Assertions"
description: "Defines the full range of GoogleTest assertion macros and facilities. Explains standard, predicate, fatal/non-fatal, and custom assertions, with practical signaling and error message patterns. Includes usage scenarios, contextual examples, and best practices for effective C++ unit testing."
---

# GoogleTest Assertions Reference

This documentation page provides a comprehensive overview of the assertion macros and facilities offered by GoogleTest to validate and verify C++ code behavior. It covers the full range of assertions from standard Boolean and equality checks to predicate assertions and advanced features such as exception assertions and death tests. You will find practical usage scenarios, detailed examples, and best practices for writing effective and maintainable tests.

---

## Understanding Assertions in GoogleTest

Assertions are fundamental statements used in tests that check if a condition holds true. In GoogleTest, an assertion records success or failure, providing diagnostics if something unexpected occurs.

Assertions fall into two categories:

- **Fatal assertions** (`ASSERT_*` macros) cause the test function to abort immediately on failure.
- **Non-fatal assertions** (`EXPECT_*` macros) record the failure but allow the test function to continue.

Use fatal assertions when proceeding after failure doesn't make sense (e.g., dereferencing pointers). Use non-fatal assertions when you want to collect multiple failures in one test.

You can stream additional context messages using the `<<` operator, helping diagnose issues quickly.

---

## Explicit Success and Failure

GoogleTest provides macros to explicitly signal a test _success_ or _failure_, regardless of any condition.

### SUCCEED()

- Generates an explicit success.
- It's documentary and currently produces no visible output.
- Useful to mark a particular code path as verified.

```cpp
SUCCEED();
SUCCEED() << "Reached checkpoint X";
```

### FAIL()

- Generates a **fatal failure** and aborts the current function immediately.
- Must only be used in `void` returning functions.

```cpp
if (!condition) FAIL() << "Condition is false, expected true.";
```

### ADD_FAILURE()

- Generates a **nonfatal failure** allowing the test function to continue.
- Can be used to record unexpected error conditions without aborting.

```cpp
if (unexpected_event) ADD_FAILURE() << "Unexpected event occurred.";
```

### ADD_FAILURE_AT(file, line)

- Like `ADD_FAILURE()`, but reports failure at specified source file and line.

```cpp
ADD_FAILURE_AT("foo.cc", 42) << "Failure occurred at foo.cc:42";
```

---

## Boolean Assertions

Check truthfulness or falseness of expressions.

### EXPECT_TRUE(condition) / ASSERT_TRUE(condition)

Verifies `condition` is `true`.

```cpp
EXPECT_TRUE(IsValid(input)) << "Input validation failed";
ASSERT_TRUE(ptr != nullptr);
```

### EXPECT_FALSE(condition) / ASSERT_FALSE(condition)

Verifies `condition` is `false`.

```cpp
EXPECT_FALSE(IsError()) << "Error occurred unexpectedly";
```

---

## Binary Comparisons

Compare two operands with relational or equality operators. These macros accept arbitrary types as long as they support the respective operations.

### Equality and Inequality

- `EXPECT_EQ(val1, val2) / ASSERT_EQ(val1, val2)`: checks `val1 == val2`.
- `EXPECT_NE(val1, val2) / ASSERT_NE(val1, val2)`: checks `val1 != val2`.

**Important:**
- For C-string pointers, these check pointer equality, not content equality.
- Use [`EXPECT_STREQ`](#string-comparisons) to compare C-string contents.
- Prefer `nullptr` over `NULL` when comparing pointer equality.

```cpp
EXPECT_EQ(expected_count, actual_count);
ASSERT_NE(ptr, nullptr);
```

### Order Comparisons

- `EXPECT_LT(val1, val2) / ASSERT_LT(val1, val2)`: `val1 < val2`
- `EXPECT_LE(val1, val2) / ASSERT_LE(val1, val2)`: `val1 <= val2`
- `EXPECT_GT(val1, val2) / ASSERT_GT(val1, val2)`: `val1 > val2`
- `EXPECT_GE(val1, val2) / ASSERT_GE(val1, val2)`: `val1 >= val2`

```cpp
EXPECT_LT(value, 100);
ASSERT_GE(size, min_size);
```

---

## String Comparisons

Specialized macros exist for comparing C-style strings (`char*`) or wide strings (`wchar_t*`). They compare string contents, not pointer addresses.

### EXPECT_STREQ(str1, str2) / ASSERT_STREQ(str1, str2)

Verifies that `str1` and `str2` have equal character sequences.

```cpp
EXPECT_STREQ("hello", some_cstring);
ASSERT_STREQ(expected_wide_str, actual_wide_str);
```

### EXPECT_STRNE(str1, str2) / ASSERT_STRNE(str1, str2)

Verifies that `str1` and `str2` have different character sequences.

### EXPECT_STRCASEEQ(str1, str2) / ASSERT_STRCASEEQ(str1, str2)

Compares strings ignoring case differences.

### EXPECT_STRCASENE(str1, str2) / ASSERT_STRCASENE(str1, str2)

Verifies strings differ ignoring case.

**Tip:** Streaming can be used to add custom messages.

```cpp
EXPECT_STREQ("Hello", value) << "String value is incorrect!";
```

---

## Floating-Point Comparisons

Comparing floating-point numbers must account for rounding errors.

### EXPECT_FLOAT_EQ(val1, val2) / ASSERT_FLOAT_EQ(val1, val2)

Checks whether `val1` and `val2` (floats) are approximately equal within 4 ULPs.

### EXPECT_DOUBLE_EQ(val1, val2) / ASSERT_DOUBLE_EQ(val1, val2)

Checks approximate equality for `double` types, similar to `EXPECT_FLOAT_EQ`.

### EXPECT_NEAR(val1, val2, abs_error) / ASSERT_NEAR(val1, val2, abs_error)

Verifies `abs(val1 - val2) <= abs_error`.

```cpp
EXPECT_FLOAT_EQ(computed_result, expected_value);
ASSERT_NEAR(distance, 1.0, 0.001);
```

---

## Exception Assertions

These macros test if code throws or does not throw exceptions. Exception support must be enabled.

### EXPECT_THROW(statement, exception_type) / ASSERT_THROW(statement, exception_type)

Verifies that `statement` throws an exception of the specified type.

### EXPECT_ANY_THROW(statement) / ASSERT_ANY_THROW(statement)

Verifies that `statement` throws any exception.

### EXPECT_NO_THROW(statement) / ASSERT_NO_THROW(statement)

Verifies that `statement` does not throw any exception.

```cpp
EXPECT_THROW(Foo(), std::runtime_error);
ASSERT_NO_THROW(Initialize());
```

---

## Predicate Assertions

Assert complex conditions with improved messages by printing argument values.

### EXPECT_PREDn(pred, val1, val2, ...)/ASSERT_PREDn

Checks a predicate function returning `bool` with n arguments.

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, number);
```

For overloaded or template functions, specify the function type explicitly to avoid compiler errors.

### EXPECT_PRED_FORMATn(pred_formatter, val1, val2, ...)/ASSERT_PRED_FORMATn

Use predicate-formatters that return `testing::AssertionResult` with custom failure messages.

```cpp
testing::AssertionResult IsDivisible(const char* expr1, const char* expr2, int n, int divisor) {
  if (n % divisor == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr1 << " is not divisible by " << expr2;
}
EXPECT_PRED_FORMAT2(IsDivisible, value, divisor);
```

---

## Windows HRESULT Assertions

Checks Windows API HRESULTs with readable messages.

### EXPECT_HRESULT_SUCCEEDED(expression) / ASSERT_HRESULT_SUCCEEDED(expression)

Ensures the HRESULT indicates success.

### EXPECT_HRESULT_FAILED(expression) / ASSERT_HRESULT_FAILED(expression)

Ensures the HRESULT indicates failure.

```cpp
EXPECT_HRESULT_SUCCEEDED(CoCreateInstance(...));
```

---

## Death Assertions

Verify that executing code causes process termination or abnormal exit.

### EXPECT_DEATH(statement, matcher) / ASSERT_DEATH(statement, matcher)

Verifies `statement` causes the process to terminate, and `stderr` output matches `matcher` (regex or gMock matcher).

### EXPECT_DEATH_IF_SUPPORTED / ASSERT_DEATH_IF_SUPPORTED

Runs death test if supported, otherwise passes trivially.

### EXPECT_DEBUG_DEATH / ASSERT_DEBUG_DEATH

Runs death test only in debug mode, otherwise runs `statement` normally.

### EXPECT_EXIT(statement, predicate, matcher) / ASSERT_EXIT

Verifies that `statement` terminates with exit status satisfying `predicate` and output matches `matcher`.

Common predicates:

- `ExitedWithCode(int code);`
- `KilledBySignal(int signal);` (POSIX only)

```cpp
EXPECT_DEATH(MyFunction(), "Fatal error occurred");
EXPECT_EXIT(Cleanup(), testing::ExitedWithCode(0), "Cleanup completed");
```

> **Important:** Name test suites with `*DeathTest` suffix to ensure proper ordering and isolations, as death tests run separately.

---

## Skipping Test Execution

Use `GTEST_SKIP()` to prevent a test or test fixture from running further.

```cpp
TEST(SkipTest, Examples) {
  if (!IsFeatureSupported()) {
    GTEST_SKIP() << "Feature not supported.";
  }
  // test code here
}
```

It can be used in both individual tests and fixture `SetUp()` methods.

---

## Additional Facilities

### RecordProperty(key, value)

Records a key-value pair as additional test metadata for XML/JSON reports.

```cpp
RecordProperty("MaxHeapUsage", 1024);
RecordProperty("Author", "alice");
```

- Keys **must not** clash with reserved XML attributes like `name`, `status`, `time`, etc.
- Can be called outside a test; depending on context, properties are attributed appropriately.

---

## Best Practices and Usage Tips

- Use `EXPECT_*` macros for non-fatal assertions to collect multiple failures per test.
- Use `ASSERT_*` macros to prevent further invalid operations after critical failures.
- Stream detailed messages with `<<` to provide context.
- Use predicate-formatters for complex checks needing custom failure messages.
- Be careful using fatal assertions in constructors or destructors; use `SetUp`/`TearDown` instead.
- Use `SCOPED_TRACE` macro or `ScopedTrace` class for better tracing in nested tests or helper functions.
- Name death test suites with `*DeathTest` to ensure correct execution order.
- Use value-parameterized and typed tests for scalable coverage.

---

## Example Code Snippets

### Basic Equality Assertion

```cpp
TEST(MyTestSuite, TestEquality) {
  int expected = 5;
  int actual = ComputeValue();
  EXPECT_EQ(expected, actual) << "Mismatch in ComputeValue output";
}
```

### Predicate Assertion

```cpp
bool IsPrime(int n) { ... }
TEST(PrimeTest, CheckPrime) {
  EXPECT_PRED1(IsPrime, 7);
}
```

### Death Test

```cpp
TEST(MyDeathTest, ExitOnNull) {
  ASSERT_DEATH(CheckNotNull(nullptr), "Null pointer error");
}
```

### Using `SCOPED_TRACE` for context

```cpp
void Helper(int i) {
  EXPECT_EQ(i % 2, 0);
}

TEST(ContextTest, WithTrace) {
  for (int i = 0; i < 5; ++i) {
    SCOPED_TRACE(testing::Message() << "i = " << i);
    Helper(i);
  }
}
```

---

## Troubleshooting Common Issues

- **Mixing TEST and TEST_F in the same test suite:** GoogleTest requires the same fixture type for all tests in a suite. Mixing causes failure. Use `TEST_F` consistently or separate suites.
- **Using fatal assertions in constructors/destructors:** Avoid; they only abort the function, leading to partial object state and obscure errors.
- **Assertion macros require void-returning functions for fatal assertions:** For non-void functions, use non-fatal assertions or redesign.
- **Disable tests temporarily with `DISABLED_` prefix on test or suite names; use `--gtest_also_run_disabled_tests` to run them.**

---

## Additional References and Related Topics

- [GoogleTest Primer](primer.md) — Introductory concepts
- [Assertions Reference](reference/assertions.md) — Full list and details
- [Advanced GoogleTest Topics](advanced.md) — Predicate assertions, death tests, test events
- [Using Assertions for Effective Validation](guides/gtest-core-guides/using-assertions.mdx) — Guide with detailed explanations
- [Test Structure and Lifecycle](api-reference/core-testing-apis/test-structure-and-lifecycle.mdx) — For test organization and flow

---

For complete API usage, explore related reference pages on Parameterized and Typed Tests, Matchers, and Mocking APIs.

---

# Summary
This page provides an in-depth reference for GoogleTest's assertion macros and facilities, enabling users to verify and communicate the correctness of their C++ code effectively. It covers standard Boolean and comparison assertions, string and floating-point checks, predicate assertions with custom messages, exception and death test handling, skipping tests, and logging additional test properties. Detailed examples support practical adoption and highlight troubleshooting and best practices.

---