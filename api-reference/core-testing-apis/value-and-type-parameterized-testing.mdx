---
title: "Value and Type Parameterized Testing"
description: "Guides users through GoogleTest's parameterized testing frameworks for both value and type variations. Explains use of macros, test generators, and instantiation mechanisms to maximize coverage and reduce code duplication. Includes usage patterns and best practices for scalable test suites."
---

# Value and Type Parameterized Testing

GoogleTest provides powerful frameworks to write scalable and reusable tests by varying parameters over values and types. This page guides you through using GoogleTest's parameterized test mechanisms to:

- Maximize test coverage without code duplication.
- Write flexible test patterns that adapt to multiple inputs.
- Leverage type variations to verify template-based code.

You will learn about key macros, test generators, and instantiation patterns, with best practices and practical examples to organize your tests for clarity and maintainability.

---

## 1. Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic with multiple input values, empowering you to avoid duplicating tests for similar scenarios.

### Writing a Value-Parameterized Test

1. **Define a fixture class** that inherits from `::testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyType {
 public:
  explicit MyType(const std::string& a_value) : value_(a_value) {}
  const std::string& value() const { return value_; }
 private:
  std::string value_;
};

class ValueParamTest : public ::testing::TestWithParam<MyType> {};
```

2. **Define tests using `TEST_P` macro**, where you can access the test parameter by invoking `GetParam()`.

```cpp
TEST_P(ValueParamTest, TestA) {
  // Use GetParam() inside your test
}

TEST_P(ValueParamTest, TestB) {
  // Another test using the same fixture
}
```

3. **Instantiate the test suite with parameter values using `INSTANTIATE_TEST_SUITE_P`**.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, ValueParamTest,
    ::testing::Values(
        MyType("one line"), MyType("two\nlines"),
        MyType("a very\nlong line")));
```

This creates tests named like `MyInstantiation/ValueParamTest.TestA/0` and similar, each running with a different parameter value.

### Parameter Generators

Use GoogleTest's built-in generators (within `::testing` namespace) for easy parameter sets:

| Generator               | Description                                         |
|-------------------------|-----------------------------------------------------|
| `Range(begin, end [, step])` | Generates a sequence of values `[begin, begin+step, ...)` excluding `end`. Default `step` is 1. |
| `Values(v1, v2, ..., vN)`    | Generates specified values explicitly.           |
| `ValuesIn(container)`          | Generates values from arrays or STL containers.   |
| `Bool()`                     | Generates `false` and `true`.                       |
| `Combine(g1, g2, ..., gN)`   | Generates the Cartesian product (all combinations) of multiple generators as tuples. |

#### Example With Containers

```cpp
std::vector<int> v = {1, 2, 3};
INSTANTIATE_TEST_SUITE_P(MyInstance, MyTest, ValuesIn(v));
```

### Custom Naming of Test Instances

You can supply an optional name generator function or functor to create readable test names based on the parameter:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, ValueParamTest,
    ::testing::Values(...),
    [](const ::testing::TestParamInfo<MyType>& info) {
      std::string name = "Param" + std::to_string(info.index);
      return name;
    });
```

Test names should use only alphanumeric characters and underscores.

### Best Practices

- Choose meaningful parameter types and values to cover different scenarios.
- Use custom name generators for clarity when test parameters are complex.
- Avoid mixing parameterized tests without corresponding instantiations; use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when needed.

---

## 2. Typed Tests

Typed tests allow reuse of the same test logic for different data types. This is especially useful for template classes or functions.

### Defining Typed Tests

1. **Create a fixture class template** deriving from `testing::Test`:

```cpp
template <typename T>
class TypedTest : public testing::Test {};
```

2. **Define a type list** using `::testing::Types<>`:

```cpp
typedef ::testing::Types<int*, MyArray<bool, 42>> MyTypes;
```

3. **Associate the types with the fixture using `TYPED_TEST_SUITE`:**

```cpp
TYPED_TEST_SUITE(TypedTest, MyTypes);
```

4. **Write tests using the `TYPED_TEST` macro.** Inside the test, `TypeParam` refers to the current type:

```cpp
TYPED_TEST(TypedTest, TestA) {
  // Use TypeParam as the type parameter
}

TYPED_TEST(TypedTest, TestB) {
  // Another typed test
}
```

### Custom Test Names

You may specify a custom name generator class for nicer test suite names:

```cpp
class NameGenerator {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int*>) return "IntPtr";
    if constexpr (std::is_same_v<T, MyArray<bool, 42>>) return "BoolArray";
    return "UnknownType";
  }
};

TYPED_TEST_SUITE(TypedTest, MyTypes, NameGenerator);
```

This will affect display names for the test suites.

---

## 3. Type-Parameterized Tests

Type-parameterized tests extend typed tests by allowing test patterns to be defined without specifying the types immediately.

This helps when defining interface or concept tests that many implementations must satisfy.

### Defining Type-Parameterized Tests

1. **Declare the test fixture template:**

```cpp
template <typename T>
class TypeParamTest : public testing::Test {};
```

2. **Use the `_P` variants to define the test suite and tests:**

```cpp
TYPED_TEST_SUITE_P(TypeParamTest);

TYPED_TEST_P(TypeParamTest, TestA) { /*...*/ }
TYPED_TEST_P(TypeParamTest, TestB) { /*...*/ }

REGISTER_TYPED_TEST_SUITE_P(TypeParamTest, TestA, TestB);
```

3. **Instantiate the test suite with concrete types:**

```cpp
using MyTypes = ::testing::Types<int*, MyArray<bool, 42>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, TypeParamTest, MyTypes);
```

The tests expand for each type in `MyTypes`.

### Notes

- The `_P` macros allow you to spread definitions and instantiations across translation units.
- You *must* register the test names before instantiation.

---

## Common Pitfalls and Best Practices

- Always ensure that `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` macros correspond to existing `TEST_P` or `REGISTER_TYPED_TEST_SUITE_P` definitions respectively.
- Mark unused parameterized tests with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Use clearly unique instantiation prefixes to avoid name collisions.
- Customize test instance names for readability, especially for complex types or values.
- Remember that test suite and test names should avoid underscores to prevent conflicts (see FAQ).

---

## Example Walkthrough

Given:

```cpp
class ValueParamTest : public ::testing::TestWithParam<MyType> {};

TEST_P(ValueParamTest, TestA) { ... }

INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, ValueParamTest,
    ::testing::Values(MyType("one line"), MyType("two\nlines")));
```

All generated tests will run `TestA` with each `MyType` parameter.

For typed tests:

```cpp
template <typename T>
class TypedTest : public testing::Test {};

typedef testing::Types<int*, MyArray<bool, 42>> MyTypes;

TYPED_TEST_SUITE(TypedTest, MyTypes);

TYPED_TEST(TypedTest, TestA) { /* use TypeParam here */ }
```

`TestA` runs once for each type in `MyTypes`.

For type-parameterized tests:

```cpp
template <typename T>
class TypeParamTest : public testing::Test {};

TYPED_TEST_SUITE_P(TypeParamTest);

TYPED_TEST_P(TypeParamTest, TestA) { /*...*/ }
TYPED_TEST_P(TypeParamTest, TestB) { /*...*/ }

REGISTER_TYPED_TEST_SUITE_P(TypeParamTest, TestA, TestB);

using MyTypes = testing::Types<int*, MyArray<bool, 42>>;

INSTANTIATE_TYPED_TEST_SUITE_P(My, TypeParamTest, MyTypes);
```

---

## Troubleshooting

- **Test not running?** Verify `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` matches test suite names exactly.
- **No tests instantiated?** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors if no instantiations are expected.
- **Test names hard to read?** Use custom name generators for better naming.
- **Compiler errors about missing default constructors?** Ensure your fixture classes have default constructors or proper setup.

---

## Further Reading & References

- [Testing Reference: Value and Type Parameterized Tests](../reference/testing.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- Google's official source and sample tests for parameterized tests ([gtest-param-test.h](googletest/include/gtest/gtest-param-test.h), [gtest-typed-test.h](googletest/include/gtest/gtest-typed-test.h))
- FAQ on naming conventions and test fixtures ([FAQ](../faq.md))

---

This page equips you with the knowledge to efficiently write parameterized tests in GoogleTest, enabling deep and broad automated testing with minimal code duplication.