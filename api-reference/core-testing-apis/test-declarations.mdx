---
title: "Test and Fixture Declarations"
description: "Describes the APIs for defining standard tests, parameterized tests, and test fixtures. Guides users in structuring tests for reusability and maintainability using macros and class inheritance. Includes code snippets to illustrate test patterns."
---

# Test and Fixture Declarations

GoogleTest provides a powerful and flexible framework for defining tests, parameterized tests, and test fixtures in C++. This page describes the core APIs and best practices for structuring your tests to maximize reusability, maintainability, and clarity. By using test fixtures and parameterized tests effectively, you can write cleaner code that shares setup and teardown logic while ensuring thorough coverage with minimal duplication.

---

## Understanding Test Declarations

At the heart of test definition lies the goal to organize testing logic according to the scope and intent of tests. GoogleTest achieves this through a comprehensive macro-based API that allows declarations of:

- **Standard Tests**
- **Test Fixtures**
- **Parameterized Tests**

Let's explore each concept progressively.

### Writing Standard Tests

A standard test is the simplest form of a test, no shared state or setup beyond the test body itself:

```cpp
TEST(TestSuiteName, TestName) {
  // Arrange - setup your environment if needed

  // Act - perform the operation to test

  // Assert - verify outcomes
  EXPECT_EQ(actual, expected);
}
```

**Key points:**

- The first parameter `TestSuiteName` groups related tests.
- The second parameter `TestName` represents the unique name of the test.
- Tests are effectively independent and self-contained.

### When to Use Standard Tests

Use `TEST` when the scenario you are testing does not require common setup or teardown across multiple tests. It's straightforward and ideal for isolated, simple checks.

---

## Test Fixtures: Structure for Reusability and Setup Reuse

For more complex test scenarios requiring common setup/teardown logic and shared test data, GoogleTest provides **test fixtures**.

### Declaring a Test Fixture

A test fixture is a class derived from `testing::Test` where you can place common test data and helper functions.

```cpp
class MyTestFixture : public ::testing::Test {
 protected:
  // Code for setup before each test
  void SetUp() override {
    // Setup shared resources
  }

  // Code for cleanup after each test
  void TearDown() override {
    // Cleanup resources
  }

  // Shared test variables
  int shared_value_;
};
```

### Writing Tests Using the Fixture

You associate tests with fixtures using `TEST_F` instead of `TEST`:

```cpp
TEST_F(MyTestFixture, TestCase1) {
  shared_value_ = 42;
  EXPECT_EQ(shared_value_, 42);
}

TEST_F(MyTestFixture, TestCase2) {
  // shared_value_ is fresh and can be initialized differently here
  shared_value_ = 100;
  EXPECT_GT(shared_value_, 0);
}
```

**Important:** Each `TEST_F` case runs with a fresh instance of the fixture class, ensuring tests do not share state inadvertently.

### Benefits of Using Fixtures

- **Reusability:** Sharing setup/teardown code reduces duplication.
- **Isolation:** Each test has a new fixture instance, preventing side-effects.
- **Maintainability:** Centralized setup makes changes easier.
- **Readability:** Tests describe intent clearly without boilerplate code.

### Best Practices

- Use `SetUp()` and `TearDown()` for resource initialization and cleanup.
- Keep fixtures focused; avoid bloating them with unrelated functionality.
- Use protected members for shared test data.
- Prefer constructor/destructor only when no failure reporting or complex setup is needed.

---

## Parameterized Tests: Running the Same Test Logic with Different Inputs

When your tests need to check a function or component against many input values or types, parameterized tests eliminate redundant code.

### Defining Parameterized Test Fixtures

These extend ordinary fixtures but use the `TestWithParam<T>` template, where `T` is the parameter type.

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
 protected:
  void SetUp() override {
    // Setup code, if any
  }
};
```

### Writing Parameterized Tests

Use the `TEST_P` macro to define the parameterized test:

```cpp
TEST_P(MyParamTest, HandlesVariousValues) {
  int value = GetParam();
  EXPECT_TRUE(ProcessValue(value));
}
```

### Instantiating Parameterized Tests

Define different test parameter sets with `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(
  VariousInts,
  MyParamTest,
  ::testing::Values(1, 5, 10, 50));
```

Tests will run with each value as input, applying the same logic.

### Advanced Parameterization

- Use different generators like `ValuesIn()`, `Range()`, or `Combine()` for tuples.
- Combine parameterized tests with typed tests to cover multiple types.

### Example: Parameterized Test for Factorial

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesCorrectly) {
  int n = GetParam();
  EXPECT_EQ(Factorial(n), ExpectedFactorial(n));
}

INSTANTIATE_TEST_SUITE_P(ValidInputs, FactorialTest, ::testing::Values(0, 1, 5, 10));
```

### Value and Type Parameterized Tests

- **Value-Parameterized Tests:** Use when the parameter set consists of values.
- **Type-Parameterized Tests:** Use when you want to run tests over a set of types.

---

## Organizing Tests Using Class Inheritance and Macros

GoogleTest encourages organizing tests by grouping common code with class inheritance and macros to increase clarity and control.

### Using Fixtures with Inheritance

Inherit fixtures to add or override setup logic:

```cpp
class BaseFixture : public ::testing::Test {
 protected:
  void SetUp() override { /* base setup */ }
};

class DerivedFixture : public BaseFixture {
 protected:
  void SetUp() override {
    BaseFixture::SetUp();
    // additional setup
  }
};

TEST_F(DerivedFixture, SpecializedTest) {
  // Test logic
}
```

### Combining Fixtures and Parameterized Tests

Inherit `TestWithParam<T>` in fixture base classes to create powerful combinations.

---

## Practical Tips for Test and Fixture Declarations

- **Isolate test state:** Rely on fresh fixture instances per test.
- **Minimize test dependencies:** Avoid writing tests reliant on complex shared state.
- **Use parameterized tests to reduce duplication:** Test varying inputs smoothly.
- **Keep tests focused:** Each test should verify a single logical property.
- **Use descriptive names:** Both for test suites and test cases.
- **Set expectations early:** For mocks in fixtures, use `SetUp()` or the constructor.

---

## Example Patterns

### Simple Test

```cpp
TEST(MathTest, AdditionWorks) {
  EXPECT_EQ(2 + 2, 4);
}
```

### Test Fixture

```cpp
class VectorTest : public ::testing::Test {
 protected:
  std::vector<int> v;

  void SetUp() override {
    v = {1, 2, 3};
  }
};

TEST_F(VectorTest, SizeIsCorrect) {
  EXPECT_EQ(v.size(), 3);
}

TEST_F(VectorTest, CanModifyElements) {
  v[1] = 10;
  EXPECT_EQ(v[1], 10);
}
```

### Parameterized Test

```cpp
class PrimeTest : public ::testing::TestWithParam<int> {};

TEST_P(PrimeTest, CheckIsPrime) {
  int n = GetParam();
  EXPECT_TRUE(IsPrime(n));
}

INSTANTIATE_TEST_SUITE_P(
  KnownPrimes,
  PrimeTest,
  ::testing::Values(2, 3, 5, 7, 11));
```

---

## Troubleshooting Common Issues

If you encounter:

- **Tests failing unexpectedly:** Ensure each fixture runs with fresh state.
- **Compilation errors in tests:** Check that your fixture classes inherit from `::testing::Test`.
- **Parameter mismatches:** Verify parameterized test types and parameter lists match.
- **Mocks not behaving in fixtures:** Define expectations in `SetUp()` or before exercising the code under test.


<Info>
GoogleTest test declarations are the building blocks for reliable and maintainable C++ tests. Mastering fixtures and parameterized tests will significantly improve your productivity and code quality.
</Info>

---

## See Also

- [GoogleTest Primer](overview/intro-product-essentials/what-is-googletest)
- [Test Fixtures and Parameterized Tests Guide](guides/advanced-testing-and-best-practices/test-fixtures-parameterized)
- [Writing and Running Your First Test](getting-started/initial-setup-usage/writing-first-test)
- [gMock Cookbook](docs/gmock_cook_book.md) for mocking patterns
- [Mocking Reference](docs/reference/mocking.md)

---

## References

- GoogleTest Primer: https://github.com/google/googletest/blob/main/docs/primer.md
- Test Fixtures and Parameterized Tests Guide: /guides/advanced-testing-and-best-practices/test-fixtures-parameterized
- gMock Cookbook: https://google.github.io/googletest/gmock_cook_book.html

---

## Summary

This page described the APIs and usage patterns for defining standard tests (`TEST`), test fixtures (`TEST_F` with classes derived from `::testing::Test`), and parameterized tests (`TEST_P` with `TestWithParam<T>`). It emphasized structuring tests to promote reusability, maintainability, and clarity using macros and class inheritance.

The provided examples show how to write simple, fixture-based, and parameterized tests. Best practices and common pitfalls highlight how users can design expressive and effective test suites. This documentation serves as a cornerstone for mastering GoogleTest's test definition and execution model.
