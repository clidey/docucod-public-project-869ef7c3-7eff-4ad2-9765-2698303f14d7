---
title: "Parameterized and Typed Tests"
description: "In-depth reference on leveraging parameterized and typed test suites. Covers macros, value and type generators, factory and registration APIs, and real-world scenarios for scaling test coverage across varied data."
---

# Parameterized and Typed Tests

Explore powerful techniques in GoogleTest for scaling your test coverage with data-driven and type-driven strategies. This comprehensive guide delves into creating flexible and maintainable test suites using parameterized tests, typed tests, and type-parameterized tests. Learn how to harness macros, generators, and registration APIs to efficiently express complex test scenarios and maximize code reuse.

---

## Overview

Parameterization and typing unlock the capability to run the same test logic across multiple data points and types without duplication. This not only improves coverage but also ensures consistency and reduces maintenance effort. GoogleTest offers a rich set of tools to support these advanced testing workflows.

This documentation covers:

- Value-Parameterized Tests using `TEST_P` and `INSTANTIATE_TEST_SUITE_P`
- Generators for parameter values, including `Range`, `Values`, `ValuesIn`, `Bool`, and `Combine`
- Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`
- Type-Parameterized Tests with `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, and related registration macros
- Factory functions to dynamically register tests `RegisterTest`
- Customization of parameter naming for clarity in reporting

---

## Value-Parameterized Tests

Value-parameterized tests let you run the same test code with different input values. This approach is ideal when your test logic depends on varying parameters such as inputs, flags, or configuration options.

### Writing Value-Parameterized Tests

1. Define a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Your fixture code
};
```

2. Write tests with the `TEST_P` macro using your fixture.

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_TRUE(Process(param));
}
```

3. Instantiate the test suite with parameters using `INSTANTIATE_TEST_SUITE_P` and generators.

```cpp
INSTANTIATE_TEST_SUITE_P(PositiveCases, FooTest, testing::Values(1, 2, 3));
```

### Parameter Generators

| Generator                       | Description                                                                  |
| -------------------------------|------------------------------------------------------------------------------|
| `Range(begin, end [, step])`    | Generates values from `begin` to `end` (exclusive) with optional stepping.   |
| `Values(v1, v2, ..., vN)`       | Enumerates explicit values.                                                   |
| `ValuesIn(container or iter)`   | Generates values from array, container, or iterator range.                   |
| `Bool()`                       | Generates `false` and `true` values.                                        |
| `Combine(g1, g2, ..., gN)`      | Creates Cartesian product of multiple generators as `std::tuple`s.           |
| `ConvertGenerator<T>(g, func)` | Converts generated values using `func` to type `T` for test fixtures.        |

Example combining generators:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CombinedCases, FooTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Accessing Parameters

Within `TEST_P`, access the parameter with `GetParam()`:

```cpp
TEST_P(FooTest, PositiveCheck) {
  auto value = GetParam();
  EXPECT_GT(value, 0);
}
```

### Custom Parameter Naming

By default, GoogleTest names instantiated tests numerically. To improve readability in test output, provide a custom name generator function when instantiating:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, FooTest, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

Parameter naming rules:
- Must be non-empty, unique
- Only alphanumeric characters and underscores
- Avoid underscores in test suite and test names to prevent collisions (see [FAQ on underscores](../faq.md#why-not-underscores))

---

## Typed Tests

Typed tests enable running the same test logic over multiple types, such as verifying different container implementations or arithmetic types behave as expected.

### Writing Typed Tests

1. Define a *test fixture template* parameterized on a type `T` derived from `testing::Test`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
public:
  T value_;
  // Fixture setup
};
```

2. Define a type list using `testing::Types<...>`.

```cpp
using MyTypes = testing::Types<int, double, char>;
```

3. Associate the type list with the test suite:

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. Write tests using `TYPED_TEST`, referring to the current type as `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->value_;
  EXPECT_TRUE(val == val);
}
```

### Customizing Test Names

You can specify a class with a static templated method for generating type suffixes:

```cpp
class TypeNameGenerator {
public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, char>) return "char";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, TypeNameGenerator);
```

---

## Type-Parameterized Tests

Type-parameterized tests are abstract test patterns designed to be instantiated with varying type sets later, possibly multiple times, enabling reusable type-driven test definitions.

### Writing Type-Parameterized Tests

1. Define a *test fixture template* and declare it for type-parameterization:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // Test fixture implementation
};

TYPED_TEST_SUITE_P(MyTypeParamTest);
```

2. Define tests with `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
  TypeParam val = TypeParam();
  EXPECT_TRUE(SomeCondition(val));
}
```

3. Register all tests with `REGISTER_TYPED_TEST_SUITE_P`:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething);
```

4. Instantiate with types using `INSTANTIATE_TYPED_TEST_SUITE_P`:

```cpp
using MyTypes = testing::Types<int, long, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyTypes);
```

---

## Advanced Usage

### Dynamic Test Registration

Programmatically register tests when macros are insufficient using `RegisterTest`:

```cpp
void RegisterMyDynamicTests(std::vector<int> params) {
  for (int p : params) {
    testing::RegisterTest(
      "MyTestSuite",
      ("Test" + std::to_string(p)).c_str(),
      nullptr, std::to_string(p).c_str(),
      __FILE__, __LINE__,
      [p]() -> MyFixture* { return new MyTestFixture(p); });
  }
}
```

### Combining Parameter Generators

Use `Combine()` to test multiple parameters simultaneously:

```cpp
INSTANTIATE_TEST_SUITE_P(
    Combinations, MyTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Converting Parameters

Transform generated parameters into custom types with `ConvertGenerator`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomTypes, MyTest,
    testing::ConvertGenerator<MyCustomType>(
        testing::Combine(testing::Values(1, 2), testing::Bool()),
        [](const std::tuple<int, bool>& t) {
          return MyCustomType(std::get<0>(t), std::get<1>(t));
        }));
```

---

## Best Practices and Tips

- Always give unique, clear names to instantiations to avoid confusion in results.
- Avoid underscores in test suite and test names to prevent internal name collisions.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors if you intentionally define parameterized tests without instantiations.
- Utilize `SCOPED_TRACE` to add contextual traces for complex assertions inside parameterized test bodies.
- For complex types in parameter names, provide custom name generators to improve output legibility.

---

## Troubleshooting

- **Test Not Running:** Ensure `INSTANTIATE_TEST_SUITE_P` has been called for your parameterized test.
- **Name Collisions:** Avoid underscores in test suite or test names; see FAQ for guidance.
- **Dangling References in Generators:** When using lambdas with objects like `std::string_view`, specify explicit generated types in `ConvertGenerator` to avoid lifetime issues.
- **Unexpected Empty Parameter Sets:** Confirm the parameter generators produce elements as expected (e.g., ranges are valid).
- **Failing to Access Parameter:** Make sure your fixture inherits from `TestWithParam<T>` or implements `WithParamInterface`.

---

## Examples

### Basic Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Typed Test Example

```cpp
template<typename T>
class NumericLimitsTest : public testing::Test {};

typedef testing::Types<int, float, double> NumericTypes;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsNonNegative) {
  EXPECT_GE(std::numeric_limits<TypeParam>::min(), 0);
}
```

### Type-Parameterized Tests

```cpp
template <class T>
class ContainerTest : public testing::Test { /* ... */ };

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsInitiallyEmpty) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsInitiallyEmpty);

using ContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainers, ContainerTest, ContainerTypes);
```
