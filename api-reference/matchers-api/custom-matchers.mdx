---
title: "Custom and Advanced Matchers"
description: "Guides users through creating custom matchers, leveraging the extensibility of the matcher framework for domain-specific or complex testing scenarios."
---

# Custom and Advanced Matchers

This guide empowers you to extend GoogleTest's matcher framework by creating custom and advanced matchers tailored to your domain-specific or complex testing scenarios. Leveraging this extensibility will enable you to write expressive, readable, and maintainable tests that verify intricate behaviors.

---

## Introduction to Custom Matchers

Matchers drive flexible and clear test expectations by verifying arguments and values against conditions. While GoogleTest provides a rich library of built-in matchers, there are times when none quite fit your unique needs. Custom matchers fill this gap.

Custom matchers can test properties hand-tailored to your data structures, enforce domain invariants, or compose complex logical conditions that built-in matchers cannot capture easily.

## Defining Custom Matchers with the `MATCHER` Macros

GoogleTest offers a family of macros to quickly define custom matchers with minimal boilerplate.

### Basic Custom Matcher Syntax

```cpp
MATCHER(Name, "Description string") { 
  return /* boolean expression involving 'arg' */;
}
```

- `Name`: the matcher name
- `arg`: the variable representing the value being matched
- The block returns `true` if `arg` satisfies the matcher condition
- The string documents what the matcher checks, simplifying failure messages

#### Example: Match Even Numbers

```cpp
MATCHER(IsEven, "") {
  return (arg % 2) == 0;
}

// Usage
EXPECT_CALL(mock, Foo(IsEven()));
EXPECT_THAT(value, IsEven());
```

If the assertion fails, the description automatically prints like:
```
Value of: value
Expected: is even
  Actual: 7
```

### Customizing Descriptions

You can provide a custom failure description string based on matcher negation or parameters:

```cpp
MATCHER(IsDivisibleBy7, absl::StrCat(negation ? "isn't" : "is", " divisible by 7")) {
  return (arg % 7) == 0;
}
```

### Using `result_listener` to Provide Detailed Diagnostics

To improve failure messages, stream extra context about the match to `result_listener`:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

This yields detailed output like:
```
Value of: some_expression
Expected: is divisible by 7
  Actual: 27 (the remainder is 6)
```

### Using Assertions Inside Matchers

You can also use `EXPECT_...` assertions inside matchers for concise verification with clear diagnostics:

```cpp
MATCHER(IsDivisibleBy7, "") {
  const auto remainder = arg % 7;
  EXPECT_EQ(remainder, 0);
  return true;
}
```

## Parameterized Matchers

When your matcher depends on input data, parameterize it with `MATCHER_P`, `MATCHER_P2`, up to `MATCHER_P10`:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}

EXPECT_THAT(Blah("a"), HasAbsoluteValue(n));
```

Descriptions will automatically include parameters, providing user-friendly diagnostics.

## Advanced Matcher Creation via MatcherInterface

For full control, especially when building reusable or complex matchers, implement the `MatcherInterface<T>` directly:

```cpp
class DivisibleBy7Matcher : public ::testing::MatcherInterface<int> {
public:
  bool MatchAndExplain(int n, std::ostream* os) const override {
    const int remainder = n % 7;
    if (remainder != 0 && os) {
      *os << "the remainder is " << remainder;
    }
    return remainder == 0;
  }
  void DescribeTo(std::ostream* os) const override {
    *os << "is divisible by 7";
  }
  void DescribeNegationTo(std::ostream* os) const override {
    *os << "is not divisible by 7";
  }
};

::testing::Matcher<int> DivisibleBy7() {
  return ::testing::Matcher<int>(new DivisibleBy7Matcher());
}
```

## Polymorphic Matchers

To create matchers usable on multiple types, implement template methods inside your matcher class and create polymorphic matchers with `MakePolymorphicMatcher()`.

Example for a polymorphic matcher that matches any non-null pointer:

```cpp
class NotNullMatcher {
public:
  template <typename Pointer>
  bool MatchAndExplain(Pointer p, std::ostream*) const {
    return p != nullptr;
  }
  void DescribeTo(std::ostream* os) const {
    *os << "isn't NULL";
  }
  void DescribeNegationTo(std::ostream* os) const {
    *os << "is NULL";
  }
};

::testing::PolymorphicMatcher<NotNullMatcher> NotNull() {
  return ::testing::MakePolymorphicMatcher(NotNullMatcher());
}
```

## Composite Matchers

You can compose matchers by passing other matchers as parameters. For example:

```cpp
MATCHER_P(DistanceFrom, target, "") {
  return (arg - target) < 10;
}

// Allows checking that an element's distance from a target meets a condition.
EXPECT_THAT(value, DistanceFrom(42));
```

Compose compound logic by combining with built-in matchers like `AllOf()`, `AnyOf()`, and `Not()`.

## Best Practices and Tips

- **Keep Matchers Pure:** Matchers must have no side effects and depend solely on input value.
- **Use Matchers to Improve Test Readability:** Express intent clearly and avoid brittle tests.
- **Parameterize Matchers for Reusability:** Generic matchers allow code reuse and expressive assertions.
- **Provide Rich Failure Messages:** Use `result_listener` and descriptive messages to aid debugging.
- **Leverage Polymorphism for Generality:** Allow matchers to match multiple types when applicable.

## Further Reading and Resources

- [Matchers Reference](builtin-matchers.md) — Explore built-in matchers for immediate use.
- [Mocking API — Expectation and Actions](expectations-actions.md) — For controlling mock behaviors.
- [gMock Cookbook](gmock_cook_book.md) — Comprehensive recipes for mocking and matchers.

---

This page guides you through creating custom and advanced matchers that integrate seamlessly into GoogleTest's powerful matching system, enabling you to tailor test verifications precisely to your domain logic and complex conditions.
