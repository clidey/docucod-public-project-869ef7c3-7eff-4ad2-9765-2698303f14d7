---
title: "Mock Method Macros"
description: "Definitive guide to MOCK_METHOD, related macros, and their usage to declare mock member functions with const/override qualifiers, call specifications, and custom signatures. Includes qualifiers, syntax, and example classes to quickly get started."
---

# Mock Method Macros

This guide provides an authoritative reference on `MOCK_METHOD` and related macros used within GoogleMock (gMock) for declaring mock member functions in C++. It covers the syntax, qualifiers, and usage scenarios necessary to declare mock methods with precise behavior control, including examples and tips for typical mocking requirements.

---

## Overview of `MOCK_METHOD`

The `MOCK_METHOD` macro is central to creating mock member functions in a mock class. It declares a mock method named `method_name` with a specified return type and argument list.

### Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Qualifiers));
```

- **ReturnType:** The return type of the mocked method.
- **MethodName:** The name of the mocked method.
- **Args...:** The method's argument types enclosed in parentheses.
- **Qualifiers (optional):** A comma-separated list of method qualifiers enclosed in parentheses.

The qualifiers allow marking the method as `const`, `override`, `noexcept`, or specify calling conventions and reference qualifiers. Qualifiers provide adherence to the base class method's exact signature.

### Qualifiers Supported

| Qualifier                  | Description                                                               |
|----------------------------|---------------------------------------------------------------------------|
| `const`                    | Makes the mock method const-qualified. Required when overriding const methods. |
| `override`                 | Marks the mock method as overriding a virtual method. Recommended practice. |
| `noexcept`                 | Sets the method as `noexcept`. Required if overriding a `noexcept` method.  |
| `Calltype(...)`            | Defines the calling convention (e.g., `Calltype(STDMETHODCALLTYPE)`), mainly for Windows. |
| `ref(&)` or `ref(&&)`      | Marks the method with a reference qualifier (lvalue or rvalue). Required if overriding methods that are reference-qualified. |

### Important Notes

- Always place `MOCK_METHOD` declarations in the `public:` section of the mock class regardless of the access level of the base method. This permits usage with `ON_CALL` and `EXPECT_CALL` outside the class.
- If your return type or argument types include commas (e.g., `std::pair<int, int>`), enclose the type with an extra set of parentheses or define a type alias to avoid macro parsing issues.

Example of handling commas in types:

```cpp
class MyMock {
 public:
  // Don't compile due to comma in return type:
  // MOCK_METHOD(std::pair<bool, int>, GetPair, ()); // Error

  // Correct ways:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  using BoolIntPair = std::pair<bool, int>;
  MOCK_METHOD(BoolIntPair, GetPair, ());
};
```

---

## Common Use Cases

### Simple Mock Method

```cpp
class MockFoo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, SetName, (const std::string& name), (override));
};
```

### Mocking Overloaded Methods

Overloaded methods can be mocked by declaring each overload separately with proper signatures:

```cpp
class Base {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int times, int x) = 0;
  virtual const std::string& GetName() const = 0;
  virtual std::string& GetName() = 0;
  virtual ~Base() = default;
};

class MockBase : public Base {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
  MOCK_METHOD(const std::string&, GetName, (), (const, override));
  MOCK_METHOD(std::string&, GetName, (), (override));
};
```

If you omit some overloads, the compiler may warn about hiding base class methods. Use the base class's `using` statements to bring them into scope if not mocking:

```cpp
class MockBase : public Base {
 public:
  using Base::Add; // Bring other overload(s) into scope
  MOCK_METHOD(int, Add, (int x), (override));
};
```

### Mocking Class Templates

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface() = default;
  virtual int GetSize() const = 0;
  virtual void Push(const T& value) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& value), (override));
};
```

---

## Best Practices and Tips

- **Always declare mock methods as `public`** in the mock class regardless of the access level in the base to allow easy access by `ON_CALL` and `EXPECT_CALL` macros.
- Use the `(override)` qualifier to ensure your mock method properly overrides the intended method and catch signature mismatches early.
- Wrap complex return or argument types containing commas with extra parentheses or typedefs to resolve macro parsing issues.
- Use `const` qualifier on mock methods to match the base method and to mock const methods.
- When mocking methods with reference qualifiers like `&` or `&&`, use `ref(&)` or `ref(&&)` respectively.
- For calling conventions on Windows, use `Calltype(...)` qualifier.
- When mocking destructors (impossible via `MOCK_METHOD`), add a mock method like `Die()` and call it in the destructor for testing object lifetime.

## Full Example

```cpp
#include <gmock/gmock.h>
#include <string>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetValue() const = 0;
  virtual void SetValue(int value) = 0;
  virtual std::string Describe(int type) = 0;

 private:
  void PrivateMethod();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(void, SetValue, (int value), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));

  // Mock private method by declaring it public here.
  MOCK_METHOD(void, PrivateMethod, (), (override));
};

// Usage in tests
//
// MockFoo foo;
// ON_CALL(foo, GetValue()).WillByDefault(testing::Return(42));
// EXPECT_CALL(foo, SetValue(testing::_)).Times(1);
```

---

## Troubleshooting Common Issues

### Compile Errors Due to Commas in Type Lists

If the macro fails to parse your argument or return types due to commas, either wrap those types in parentheses or use type aliasing.

### Warnings or Errors About Missing Qualifiers

Make sure your mock method exactly matches the qualifiers of the base method (e.g., add `const`, `override`, `noexcept` as necessary).

### Mock Method Not Invoked or Ignored

Confirm that the mocked method is declared `public`.

### Mocking Non-virtual Methods

By default, `MOCK_METHOD` only works with virtual methods. For non-virtual methods, consider using templates or delegates instead.

---

## Additional Reference

For more about setting expectations, cardinalities, and actions for mock methods, see the [Setting Expectations & Cardinalities](https://google.github.io/googletest/gmock_cook_book.html#SettingExpectations) and [Actions API](../api-reference/matchers-actions/actions-reference) documentation.

For practical guides on using mocks, including sample workflows, see the [Mocking Basics](../../guides/core-workflows/mocking-basics) and [gMock Cookbook](../../docs/gmock_cook_book.md).

---

<Callout>
Note that `MOCK_METHOD` only declares the function; it does not generate standalone implementations in source files. The macro generates necessary definitions inline within the mock class to intercept calls and route them through the mocking framework.
</Callout>

---

## Cross-Language SDKs and Further Usage

For advanced mocking features including sequence control, ordering constraints, and complex actions, see respective documentation pages on `EXPECT_CALL` styling and mocking usage patterns.

---

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "googlemock/include/gmock/gmock-function-mocker.h", "range": "1-405"}]} />