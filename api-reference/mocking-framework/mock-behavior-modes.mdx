---
title: "Nice, Naggy, and Strict Mocks"
description: "Describes the specialized NiceMock, NaggyMock, and StrictMock wrappers that control mock object behavior in response to unexpected calls, enabling more precise test feedback or leniency as needed."
---

# Nice, Naggy, and Strict Mocks

GoogleMock provides specialized wrappers—`NiceMock`, `NaggyMock`, and `StrictMock`—that help control how mock objects react to uninteresting or unexpected calls. These wrappers enable you to tune your tests with different levels of strictness around mock method calls that have no explicit expectations, giving you precise feedback or leniency according to your testing needs.

---

## Understanding Mock Behavior Modes

When you define a mock class using `MOCK_METHOD`, any call to a mock method without a matching `EXPECT_CALL` is called an *uninteresting call*. By default, GoogleMock treats these calls in a way that issues warnings but allows the test to continue. The behavior wrappers help you customize this:

- **NiceMock**: Suppresses warnings on uninteresting calls.
- **NaggyMock**: The current default, prints warnings on uninteresting calls.
- **StrictMock**: Treats uninteresting calls as errors, failing the test.

These wrappers are template classes wrapping your mock class, inheriting its constructors, so use them exactly like your mock class but with the desired mode of strictness.

### When to Use Each Wrapper

- **`NiceMock<T>`**: Use this when you want to ignore any unexpected method calls that your test hasn't specifically expected. It's the least strict mode and helps reduce noisy warnings in stable tests.

- **`NaggyMock<T>`**: The default mock behavior, useful during development or debugging when you want to be informed of unexpected calls without failing immediately.

- **`StrictMock<T>`**: Use this when you want the highest level of adherence to expected behavior, ensuring your code only calls mock methods explicitly expected and fails tests otherwise. This is ideal when you want to tightly control interaction and catch any unintended calls early.

---

## Creating and Using Nice, Naggy, and Strict Mocks

Suppose you have a mock class named `MockFoo`:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
};
```

### Using a Raw Mock (Naggy by Default)

By default, if you call `DoThat()` or any method without an expectation, you'll get a warning:

```cpp
MockFoo mock_foo;
EXPECT_CALL(mock_foo, DoThis());

mock_foo.DoThis();      // Matches expectation
mock_foo.DoThat();     // Warning about uninteresting call
```

### Suppressing Warnings with `NiceMock`

To prevent noisy warnings for uninteresting calls, wrap your mock in `NiceMock`:

```cpp
using ::testing::NiceMock;

NiceMock<MockFoo> nice_foo;
EXPECT_CALL(nice_foo, DoThis());

nice_foo.DoThis();      // Matches expectation
nice_foo.DoThat();     // No warning
```

This is especially helpful when the behavior of some methods is irrelevant to your test.

### Treating Uninteresting Calls as Failures Using `StrictMock`

To ensure any unexpected calls cause a test failure, use `StrictMock`:

```cpp
using ::testing::StrictMock;

StrictMock<MockFoo> strict_foo;
EXPECT_CALL(strict_foo, DoThis());

strict_foo.DoThis();    // Matches expectation
strict_foo.DoThat();    // Test fails
```

This is ideal when you want tests to enforce full strictness on mock call usage.

### Working with Constructor Arguments

Both `NiceMock`, `NaggyMock`, and `StrictMock` will "inherit" all constructors from your mock class, so you can pass constructor parameters transparently:

```cpp
class MockBar {
 public:
  explicit MockBar(std::string s) : str_(s) {}
  MOCK_METHOD(void, DoSomething, ());

  const std::string& str() const { return str_; }

 private:
  std::string str_;
};

NiceMock<MockBar> nice_bar("example");
EXPECT_CALL(nice_bar, DoSomething());
nice_bar.DoSomething();
```

---

## Behavior Differences and Caveats

### Effect Only on Uninteresting Calls

These wrappers affect only *uninteresting* calls—calls to mock methods **without any matching `EXPECT_CALL`**. They do *not* affect unexpected calls to methods with expectations but that do not match. Unexpected calls always cause a failure regardless of strictness mode.

### Limitations

- These wrappers **only affect mock methods defined directly in your mock class** via `MOCK_METHOD`. If methods are defined in base classes, the strictness behavior may not apply fully.

- Nesting wrappers like `NiceMock<StrictMock<MockFoo>>` is *not supported*.

- Proper functioning requires that your mock class destructor is virtual.

### Impact on Test Maintenance

- Using `StrictMock` or `NaggyMock` may cause your tests to be more brittle, as any code refactoring that alters mock calls may produce warnings or failures.

- The general recommendation is:
  - Use `NiceMock` for everyday tests to suppress unnecessary warnings.
  - Use `NaggyMock` (the current default) when debugging or writing new tests.
  - Use `StrictMock` sparingly when you want tight enforcement.

---

## Examples

### Example 1: NiceMock suppresses warnings for unexpected calls

```cpp
using ::testing::NiceMock;

class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
  MOCK_METHOD(void, DoThat, ());
};

TEST(ExampleTest, NiceMockExample) {
  NiceMock<MockFoo> mock;

  EXPECT_CALL(mock, DoThis());

  mock.DoThis();  // OK
  mock.DoThat();  // No warning or failure
}
```

### Example 2: StrictMock fails on unexpected calls

```cpp
using ::testing::StrictMock;

class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
  MOCK_METHOD(void, DoThat, ());
};

TEST(ExampleTest, StrictMockExample) {
  StrictMock<MockFoo> mock;

  EXPECT_CALL(mock, DoThis());

  mock.DoThis();  // OK

  // The following will generate a test failure because DoThat
  // is called with no expectation.
  mock.DoThat();
}
```

### Example 3: Using constructor arguments with wrappers

```cpp
using ::testing::NiceMock;

class MockBar {
 public:
  explicit MockBar(int x, const std::string& str) : x_(x), str_(str) {}
  MOCK_METHOD(void, Operation, ());
  int GetX() const { return x_; }
  std::string GetStr() const { return str_; }
 private:
  int x_;
  std::string str_;
};

TEST(ExampleTest, ConstructorArguments) {
  NiceMock<MockBar> mock_bar(42, "hello");

  EXPECT_EQ(42, mock_bar.GetX());
  EXPECT_EQ("hello", mock_bar.GetStr());

  EXPECT_CALL(mock_bar, Operation());
  mock_bar.Operation();
}
```

---

## Best Practices and Tips

- **Choose strictness level thoughtfully:** Use `NiceMock` to reduce noise while developing and running stable test suites. Only switch to `StrictMock` when you want to enforce exact call patterns.

- **Avoid nesting strictness wrappers:** Such nesting can cause unexpected behavior or compile errors.

- **Use `EXPECT_CALL` sparingly:** Prefer `ON_CALL` to set default mock behaviors and use `EXPECT_CALL` only when you must verify a call.

- **Remember sticky expectations:** If you specify multiple `EXPECT_CALL`s for the same method, the last matching expectation (closest to the code) takes precedence.

- **Suppress warnings on specific methods:** If you want selective suppression while using a naggy or strict mock, establish explicit expectations with `.Times(AnyNumber())`.

- **Virtual destructors are important:** Ensure mock base classes have virtual destructors for proper strictness wrapper behavior.

---

## Troubleshooting

### Unwanted warnings with `NiceMock`
If you still see warnings about uninteresting calls even when using `NiceMock`, confirm that:

- The methods you want to suppress warnings for are declared with `MOCK_METHOD` directly in your mock class.
- The mock class destructor is virtual.

### Unexpected failures with `StrictMock`
If tests fail because of unexpected calls:

- Confirm that all methods your code under test calls on the mock have corresponding `EXPECT_CALL`s.
- Use catch-all matchers like `_` with `.Times(AnyNumber())` if necessary to allow some calls.

### Compilation errors when mixing wrappers
Ensure you do not nest `NiceMock`, `NaggyMock`, or `StrictMock` on the same mock, as this is unsupported.

---

## Summary

GoogleMock’s Nice, Naggy, and Strict mocks enable fine-grained control over how your mock objects treat unexpected or uninteresting method calls. Whether you want silence, warnings, or strict errors on unmapped calls, these wrappers let you tune test feedback to your needs, leading to cleaner tests and better debugging experiences. Their usage fits directly into any testing workflow relying on mocks, and understanding their behavior is vital for effective GoogleMock use.

---

## Related Documentation

- [gMock Cookbook — The Nice, the Strict, and the Naggy](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy)
- [Mocking Reference — NiceMock, NaggyMock, StrictMock](reference/mocking.md#NiceMock)
- [Defining & Using Mock Objects](api-reference/mocking-framework/define-and-use-mocks.md)
- [Expectations, Actions & Sequences](api-reference/mocking-framework/expectations-and-actions.md)
- [Example Usage in GoogleMock cheat sheet](docs/gmock_cheat_sheet.md#UsingMocks)

---

## Diagram: Interaction of Mocks with Strictness Wrappers

```mermaid
classDiagram

class MockFoo {
  +void DoThis()
  +void DoThat()
}

class NiceMock~T~ {
  +Constructors
  +SuppressWarnings()
}

class NaggyMock~T~ {
  +Constructors
  +PrintWarning()
}

class StrictMock~T~ {
  +Constructors
  +FailOnUninterestingCalls()
}

MockFoo <|-- NiceMock~MockFoo~
MockFoo <|-- NaggyMock~MockFoo~
MockFoo <|-- StrictMock~MockFoo~

Note over NiceMock~MockFoo~,NaggyMock~MockFoo~,StrictMock~MockFoo~:
  - Inherit from MockFoo
  - "Inherit" constructors

```
