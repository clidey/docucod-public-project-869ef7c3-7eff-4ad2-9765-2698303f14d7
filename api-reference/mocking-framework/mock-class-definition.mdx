---
title: "Mock Class Definition and MOCK_METHOD Macros"
description: "Explains the single most important macro (MOCK_METHOD) for creating mock classes, with examples of different function signatures, const/cv/ref qualifications, and variadic types. Also covers integrating mocks into existing test cases."
---

# Mock Class Definition and MOCK_METHOD Macros

This page explains the core macro `MOCK_METHOD` for creating mock classes in GoogleMock. It guides you through defining mock methods for different function signatures, including const-qualified, cv/ref-qualified, and variadic types, with comprehensive examples. Additionally, it covers best practices for integrating mocks into your test cases effectively.

---

## Overview of `MOCK_METHOD`

`MOCK_METHOD` is the fundamental macro to declare mock methods inside mock classes. It mimics the signature of the original virtual method you want to mock. GoogleMock generates all necessary boilerplate for mocking, saving you the tedium and intricacies of manual mock implementation in C++.

### Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (qualifiers));
```

- **ReturnType**: The return type of the method.
- **MethodName**: The name of the method.
- **Args...**: The argument types as a parenthesized list.
- **qualifiers** *(optional)*: One or more qualifiers such as `const`, `override`, `noexcept`, calling convention, or reference qualifiers (e.g., `ref(&)`).

**Note**: `MOCK_METHOD` must be declared in the **public** section of the mock class regardless of the original method's access modifiers. This enables external use of `EXPECT_CALL` and `ON_CALL` on these methods.

### Example: Mocking a Simple Class

Given a class:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};
```

You can define a mock class as:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

### Handling Commas in Templates

When argument or return types contain commas (e.g., template types such as `std::pair`), wrap those types in **extra parentheses** or use type aliases to avoid parsing errors.

Example:

```cpp
class MockFoo {
 public:
  // Using extra parentheses
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));

  // Using type aliases
  using BoolAndInt = std::pair<bool, int>;
  MOCK_METHOD(BoolAndInt, GetPair, ());

  using MapIntDouble = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

## Qualifiers Supported

The fourth `specs` parameter of `MOCK_METHOD` accepts the following qualifiers:

| Qualifier                    | Purpose                                                                                     |
| ---------------------------- | ------------------------------------------------------------------------------------------- |
| `const`                      | Marks the method as `const`. Required if overriding a `const` method.                        |
| `override`                   | Marks the method with `override` keyword for better safety and clarity.                      |
| `noexcept`                   | Marks the method with `noexcept`. Required if overriding a `noexcept` method.                |
| `Calltype(...)`              | Specifies calling convention (e.g., `Calltype(STDMETHODCALLTYPE)`) useful on Windows.       |
| `ref(&)` or `ref(&&)`        | Marks the method with reference qualifiers for lvalue/rvalue qualification.                  |

You can combine qualifiers by separating them with commas inside parentheses:

```cpp
MOCK_METHOD(void, Func, (), (const, noexcept, override));
```

## Overloaded Methods

You can mock overloaded methods by mocking all overloads separately.

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int Add(Element x);
  virtual int Add(int times, Element x);
  virtual Bar& GetBar();
  virtual const Bar& GetBar() const;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (Element x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));

  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

If you mock only some overloads, use `using BaseClass::Method;` to bring in base class overloads to avoid hiding.

## Mocking Class Templates

Mock class templates follow the same pattern, mocking virtual methods including virtual destructors.

```cpp
template <typename Elem>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const Elem& x) = 0;
};

template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

## Handling Non-virtual Methods

You can create mock classes for non-virtual methods used with *compile-time* polymorphism (e.g., templates). These mocks are unrelated to real classes but have matching method signatures without `override`.

```cpp
class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

You need to select which implementation to use at compile time by templating your code on the stream type.

## Old-style `MOCK_METHODn` Macros

Legacy macros `MOCK_METHODn` (where `n` is the number of arguments) are still supported but migration to the generic `MOCK_METHOD` is recommended.

| Old Macro Example                         | New Equivalent                                              |
| --------------------------------------- | ----------------------------------------------------------- |
| `MOCK_METHOD1(Foo, bool(int))`           | `MOCK_METHOD(bool, Foo, (int))`                             |
| `MOCK_CONST_METHOD1(Foo, bool(int))`     | `MOCK_METHOD(bool, Foo, (int), (const))`                    |
| `MOCK_METHOD1_T(Foo, bool(int))`         | `MOCK_METHOD(bool, Foo, (int))`                             |
| `MOCK_CONST_METHOD1_T(Foo, bool(int))`   | `MOCK_METHOD(bool, Foo, (int), (const))`                    |
| `MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))` | `MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))` |

## Nice, Strict, and Naggy Mock Wrappers

You can wrap your mock classes to control handling of uninteresting calls (calls without explicit expectations):

| Wrapper              | Behavior on Uninteresting Calls                                           |
| -------------------- | ------------------------------------------------------------------------- |
| `NiceMock<T>`        | Ignores uninteresting calls (no warnings/errors).                         |
| `NaggyMock<T>`       | Warns on uninteresting calls (default behavior).                          |
| `StrictMock<T>`      | Fails the test on uninteresting calls.                                   |

They are subclasses of your mock class and inherit constructors, allowing seamless replacement.

Example:

```cpp
using ::testing::NiceMock;
using ::testing::NaggyMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_foo;      // Suppresses warnings.
NaggyMock<MockFoo> naggy_foo;    // Warns on unexpected calls.
StrictMock<MockFoo> strict_foo;  // Errors on unexpected calls.
```

**Note:** These wrappers only affect mock methods directly declared with `MOCK_METHOD` in the specified class. Methods mocked in base classes may not be affected. Also, ensure your mock class has a **virtual destructor** for correct behavior.

## Integrating Mocks Into Your Tests

Typical flow:

1. Include `<gmock/gmock.h>` and import required symbols (e.g., `using ::testing::Return;`).
2. Define your mock class with `MOCK_METHOD` macros.
3. Instantiate mock objects in tests.
4. Use `ON_CALL` to define default actions if desired.
5. Use `EXPECT_CALL` to set expectations on method calls, with matchers, cardinalities, and actions.
6. Exercise your production code using the mocks.
7. Upon destruction, mocks automatically verify all expectations were met.

Example test snippet:

```cpp
using ::testing::Return;

TEST(BarTest, DoesThis) {
  MockFoo foo;

  ON_CALL(foo, GetSize())
      .WillByDefault(Return(1));

  EXPECT_CALL(foo, Describe(5))
      .Times(3)
      .WillRepeatedly(Return("Category 5"));

  EXPECT_EQ(MyProductionFunction(&foo), "good");
}
```

## Best Practices and Tips

- Always place `MOCK_METHOD` declarations in `public` sections.
- Wrap complex argument or return types with parentheses or typedefs to resolve comma parsing issues.
- Use `override` qualifiers for clarity and safety.
- Use wrappers (`NiceMock`, `StrictMock`) according to your test needs to control strictness on uninteresting calls.
- Prefer `ON_CALL` for setting up default behaviors without enforcing call counts.
- Use `EXPECT_CALL` for expectations that must be verified.
- Use `RetiresOnSaturation()` on expectations in sequences or when they should retire after fulfillment to avoid sticky expectations.
- Provide virtual destructors for mock base classes to ensure proper cleanup and avoid unexpected behaviors with mock strictness wrappers.

## References

For comprehensive details and extended usage scenarios, see:

- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html#MockClass)
- [gMock Cookbook - Creating Mock Classes](https://google.github.io/googletest/gmock_cook_book.html#CreatingMockClasses)
- [gMock Mocking Reference - MOCK_METHOD](https://google.github.io/googletest/reference/mocking.html#MOCK_METHOD)
- [Strict, Naggy, and Nice Mocks](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy)

---

## Summary

Understand how to define mock methods in mock classes using `MOCK_METHOD`. Master qualifiers and strategies for mocking overloaded and template methods. Seamlessly integrate mock classes into your tests with default actions and strictness wrappers.

---

## Example: Full Minimal Mock Class

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
};
```

Instantiate the mock in tests and set expectations:

```cpp
using ::testing::Return;

MockFoo foo;
ON_CALL(foo, GetSize()).WillByDefault(Return(5));
EXPECT_CALL(foo, Describe("test")).WillOnce(Return("desc"));

// Use foo in tested code, expectations are automatically verified on destruction.
```
