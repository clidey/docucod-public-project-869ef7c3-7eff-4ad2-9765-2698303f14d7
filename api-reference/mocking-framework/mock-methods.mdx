---
title: "Mock Methods and Fixtures"
description: "Detailed reference for defining mock methods using core macros (e.g., MOCK_METHOD), templated mocks, and integrating mocks into test fixtures. Includes practical advice on simulating interface contracts and leveraging advanced function signature support."
---

# Mock Methods and Fixtures

This reference page details how to define mock methods in GoogleMock using core macros such as `MOCK_METHOD`, how to create templated mock classes, and best practices for integrating mocks into test fixtures. It provides practical guidance on simulating interface contracts and leveraging advanced function signature support to mock complex, overloaded, or templated interfaces.

---

## Defining Mock Methods with `MOCK_METHOD`

At the heart of mocking in GoogleMock lies the `MOCK_METHOD` macro. It allows you to declare mock implementations of virtual interface methods within your mock classes quickly and consistently.

### Syntax Overview
```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- **ReturnType**: The return type of the mocked method.
- **MethodName**: The name of the method you are mocking.
- **Args...**: Parenthesized list of argument types.
- **Specs...** (optional): Comma-separated method qualifiers, wrapped in parentheses. These include:
  - `const` for const-qualified methods
  - `override` to mark overrides explicitly
  - `noexcept` for noexcept-qualified methods
  - `Calltype(...)` for specifying custom calling conventions (e.g., `Calltype(STDMETHODCALLTYPE)` on Windows)
  - `ref(...)` for reference qualifiers like `ref(&)` or `ref(&&)`

### Example: Mocking a Simple Interface
Given an abstract interface:
```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetValue() const = 0;
  virtual bool Process(int x, int y) = 0;
};
```
You define its mock class like this:
```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(bool, Process, (int x, int y), (override));
};
```

### Handling Unprotected Commas in Types
If your return type or argument type contains commas (like template types), wrap them in parentheses to avoid macro parsing issues.

```cpp
class MockFoo {
 public:
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
};
```

Alternatively, define type aliases:
```cpp
using BoolAndInt = std::pair<bool, int>;
using MapIntDouble = std::map<int, double>;
class MockFoo {
 public:
  MOCK_METHOD(BoolAndInt, GetPair, ());
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

### Mocking const, noexcept, and calltype methods
You specify method qualifiers in the fourth parameter:
```cpp
MOCK_METHOD(bool, Foo, (int n), (const, noexcept, override));
MOCK_METHOD(int, Bar, (double x), (Calltype(STDMETHODCALLTYPE), override));
```


## Mocking Templated Interfaces

You can define mock classes for class templates exactly as you would for ordinary classes.

### Example: Mocking a Template Interface
```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface();
  virtual void Push(const T& value) = 0;
  virtual void Pop() = 0;
  virtual int GetSize() const = 0;
  virtual const T& GetTop() const = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(void, Push, (const T& elem), (override));
  MOCK_METHOD(void, Pop, (), (override, final));
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(const T&, GetTop, (), (const));
};
```


## Old-Style `MOCK_METHODn` Macros

Legacy macros like `MOCK_METHOD0`, `MOCK_METHOD1_T`, and others are still supported for backward compatibility, but their use is discouraged. These macros encode the argument count into the macro name and differ in syntax slightly.

Example equivalence:
```cpp
// Old style
MOCK_METHOD2(Foo, bool(int, double));

// New style
MOCK_METHOD(bool, Foo, (int, double));
```


## Integrating Mock Objects in Test Fixtures

Mocks should be integrated into test classes or fixtures for reusable setup and controlled lifetimes.

### Basic Workflow
1. Include `gmock/gmock.h` and create your mock class.
2. Create mock object instances as members or local variables.
3. Use `ON_CALL` to define default behaviors for mock methods when calls may happen but aren't checked strictly.
4. Use `EXPECT_CALL` to set expectations on mock methods, specifying the precise calls and behaviors your test cares about.
5. Run your code under test using the mocks.
6. GoogleMock verifies expectations when mocks are destructed.

### Example Test Fixture Using Mock Class
```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::Return;
using ::testing::_;

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(bool, Process, (int x, int y), (override));
};

class FooTest : public ::testing::Test {
 protected:
  MockFoo mock_foo;
};

TEST_F(FooTest, ReturnsValue) {
  ON_CALL(mock_foo, GetValue()).WillByDefault(Return(42));
  EXPECT_CALL(mock_foo, Process(10, _)).Times(1).WillOnce(Return(true));

  // Exercise code that uses mock_foo...
  EXPECT_EQ(42, mock_foo.GetValue());
  EXPECT_TRUE(mock_foo.Process(10, 20));
}
```


## Overloaded, Const, and Reference-Qualified Methods

GoogleMock fully supports mocking overloaded functions, const-qualified methods, and methods with reference qualifiers.

Use the same `MOCK_METHOD` macro, specifying the qualifiers in the specs parameter:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(int, Overloaded, (), (override));
  MOCK_METHOD(int, Overloaded, (int x), (const, override));
  MOCK_METHOD(int, RefQualified, (), (ref(&), override));
  MOCK_METHOD(int, RefQualified, (), (ref(&&), override));
};
```

To disambiguate when setting expectations for overloaded or const methods, use the wrappers:
```cpp
EXPECT_CALL(mock, Overloaded());
EXPECT_CALL(::testing::Const(mock), Overloaded(42));
```


## Specifying Calling Conventions

On Windows, some methods use non-default calling conventions (e.g., `STDMETHODCALLTYPE`). `MOCK_METHOD` supports this through the `Calltype` qualifier:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
MOCK_METHOD(int, Bar, (double x, double y), (const, Calltype(STDMETHODCALLTYPE)));
```


## Using `MockFunction` for Mocking std::function

GoogleMock offers the `MockFunction<R(Args...)>` template to mock `std::function` types (e.g., callbacks) easily. It provides a single mock method `Call()` with the specified signature and an `AsStdFunction()` helper to convert the mock to a `std::function` compatible object.

### Example
```cpp
using ::testing::Return;
using ::testing::MockFunction;

MockFunction<int(std::string)> callback_mock;
EXPECT_CALL(callback_mock, Call("test"))
    .WillOnce(Return(1));

std::function<int(std::string)> callback = callback_mock.AsStdFunction();
EXPECT_EQ(1, callback("test"));
```


## Best Practices and Tips

- Always place `MOCK_METHOD` declarations in the `public:` section of your mock classes regardless of original method access level to enable `ON_CALL` and `EXPECT_CALL` to work properly.
- Use `ON_CALL` to define default behaviors that do not require verification that the method is called.
- Use `EXPECT_CALL` to specify the methods calls you want to verify, including argument matchers, cardinalities (number of times expected), and actions.
- Leverage `NiceMock<T>` to suppress warnings about uninteresting calls, `NaggyMock<T>` for the default warning behavior, or `StrictMock<T>` to treat uninteresting calls as failures.
- When mocking templated interfaces, avoid over-complicated macro usages by switching to the new `MOCK_METHOD` form rather than the legacy macros.
- When mocking complex or overloaded interfaces, use `Const()` and explicit argument matchers to disambiguate overloads.
- For methods accepting or returning move-only types (`std::unique_ptr`), write `MOCK_METHOD` definitions with the usual syntax and prefer lambdas or callable objects in actions to safely handle move semantics.
- Consider delegating mock methods to real or fake objects by setting default actions with `ON_CALL` that forward calls to other objects.


## Troubleshooting Common Pitfalls

- **Compile errors due to commas in types:** Wrap the type in parentheses or use type aliases.
- **Overloaded methods ambiguity:** Always specify argument types explicitly in expectations or use `Const()` wrapper for const-qualified methods.
- **Uninteresting call warnings:** Suppress via `NiceMock` or specify a catch-all expectation with `EXPECT_CALL(mock, Method(_)).Times(AnyNumber());`
- **Mixing legacy and new mock macros:** Prefer migrating to new `MOCK_METHOD` style to avoid confusion.
- **Move-only argument mocking:** Use lambdas or functor actions. Avoid returning move-only values via `Return` if the cached value gets moved.
- **Mock method names colliding with macros (e.g., Windows API):** GoogleMock handles this, but be mindful in your test code.
- **Mock object lifetime issues:** Ensure mocks are deleted to invoke verification or explicitly call `Mock::VerifyAndClearExpectations(&mock_obj)`.


## Related Macros and Classes

- **`EXPECT_CALL`** — sets expectations on calls to mock methods.
- **`ON_CALL`** — defines default actions for mock methods without imposing call expectations.
- **`NiceMock`, `NaggyMock`, `StrictMock`** — wrappers controlling mock strictness and handling of uninteresting calls.
- **`MockFunction`** — utility for mocking `std::function` types.
- **`Const()`** — helper to specify calling const-qualified methods.
- **`Sequence` and `InSequence`** — control call ordering.


---

For detailed examples and elaborations on expectations and actions, please refer to the [Expectations and Actions](expectations-actions) and [Matchers Reference](matchers) documentation pages.


---

## Summary
This page empowers you to define powerful, flexible mocks with the `MOCK_METHOD` macro family and guides you on integrating mocks in tests effectively, while also addressing complex use cases like templates, overloads, and special call conventions.


<Callout title="Tip">
If you are testing interactions with interfaces that have non-trivial default implementations or fakes, consider using `ON_CALL` to delegate your mock defaults to those objects, which enhances test flexibility.
</Callout>


## Example
```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (int x, int count), (override));
};

TEST(FooTest, Example) {
  MockFoo foo;

  ON_CALL(foo, GetSize())
      .WillByDefault(Return(5));

  EXPECT_CALL(foo, Process(_, 10))
      .Times(2)
      .WillRepeatedly(Return(true));

  EXPECT_EQ(foo.GetSize(), 5);
  EXPECT_TRUE(foo.Process(1, 10));
  EXPECT_TRUE(foo.Process(2, 10));
}
```

---