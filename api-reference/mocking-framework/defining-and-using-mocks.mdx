---
title: "Defining and Using Mock Objects"
description: "A practical guide to declaring mock classes and methods, using the MOCK_METHOD macros, and integrating mocks into your tests. Demonstrates how to create, customize, and verify mock behaviors for dependency isolation."
---

# Defining and Using Mock Objects

GoogleTest's mocking framework, gMock, empowers you to define mock classes and methods to isolate dependencies in your C++ tests. This page guides you through how to declare mock classes using the `MOCK_METHOD` macros, configure their expected behaviors, and verify that your code interacts correctly with these mocks.

---

## Defining a Mock Class

Defining mocks in gMock is straightforward and declarative. To mock an interface or class:

- Inherit from the class or interface you want to mock.
- Declare mock methods using `MOCK_METHOD` macros in the `public` section.

### Basic Syntax

```cpp
class MockClass : public InterfaceClass {
 public:
  MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (Specs...));
};
```

- The first parameter is the return type.
- The second is the method name.
- The third is the argument list in parentheses.
- The optional fourth parameter specifies qualifiers like `const` and `override`.

### Example

Given an interface:

```cpp
class Foo {
 public:
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};
```

Define a mock class:

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

### Tips for Complex Types

If your return or argument types contain commas (e.g., `std::pair<int, int>`), either:

- Wrap the type with extra parentheses to disambiguate commas:
  ```cpp
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));
  ```
- Or use type aliases:
  ```cpp
  using BoolIntPair = std::pair<bool, int>;
  MOCK_METHOD(BoolIntPair, GetPair, ());
  ```

### Mocking Class Templates

You can mock template classes the same way:

```cpp
template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

### Access Level

Always put `MOCK_METHOD` declarations in the `public` section. This enables `EXPECT_CALL` and `ON_CALL` macros to access the mock methods regardless of base class access modifiers.

### Overloaded Methods

Mock each overload separately:

```cpp
MOCK_METHOD(int, Add, (Element x), (override));
MOCK_METHOD(int, Add, (int times, Element x), (override));
```

You may need to use the `Const()` wrapper to distinguish `const` overloads.

---

## Using Mocks in Tests

Once your mock classes are defined, use them to verify interactions:

### Basic Workflow

1. Import necessary gMock symbols.
2. Instantiate the mock object.
3. Set expectations using `EXPECT_CALL`.
4. Run code that uses the mock.
5. Automatic verification runs when mock is destructed.

### Example

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using ::testing::AtLeast;

class PainterTest : public ::testing::Test {
 protected:
  MockTurtle turtle;  // Assume MockTurtle is a mock of Turtle interface
};

TEST_F(PainterTest, CanDrawSomething) {
  EXPECT_CALL(turtle, PenDown())
      .Times(AtLeast(1));

  Painter painter(&turtle);  // Class that uses Turtle
  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));
}
```

If your code does not fulfill the expectations (e.g., `PenDown()` is never called), the test will fail immediately with a clear message.

### Important Guidelines

- Set expectations *before* exercising the code.
- Use `_` matcher to specify "ignore argument".
- If methods are overloaded, provide argument matchers explicitly.
- Use sequences (`InSequence`) or `.After()` clauses to specify call order if needed.

---

## Setting Expectations with `EXPECT_CALL`

### Syntax Overview

```cpp
EXPECT_CALL(mock_object, MethodName(matchers...))
    .With(multi_arg_matcher)
    .Times(cardinality)
    .InSequence(sequences...)
    .After(expectations...)
    .WillOnce(action)
    .WillRepeatedly(action)
    .RetiresOnSaturation();
```

- `With()` applies a multi-argument matcher on *all* arguments.
- `Times()` controls the expected number of calls (0, once, any number, range).
- `InSequence()` enforces a strict call order within given sequences.
- `After()` enforces partial ordering (call must occur after other expectations).
- `WillOnce()` defines behavior for one call.
- `WillRepeatedly()` defines behavior for all subsequent calls.
- `RetiresOnSaturation()` makes an expectation inactive when saturated.

### Call Count (Cardinality) Examples

| Cardinality          | Meaning                                   |
|----------------------|-------------------------------------------|
| `Times(0)`           | Call is disallowed.                       |
| `Times(1)` (default) | Call once.                               |
| `Times(AnyNumber())` | Call zero or more times.                  |
| `Times(AtLeast(n))`  | Call at least `n` times.                  |
| `Times(Between(m,n))`| Call between `m` and `n` times inclusive.|

### Example with Call Sequence

```cpp
using ::testing::InSequence;

{
  InSequence seq;
  EXPECT_CALL(mock, Initialize());
  EXPECT_CALL(mock, Process(5));
  EXPECT_CALL(mock, Cleanup());
}
```

Here, `Initialize()` must be called before `Process(5)` and `Cleanup()`.

### Important Notes

- Multiple expectations can coexist; the *most recent* that matches arguments takes precedence.
- Over-saturation or missing calls cause test failures with detailed diagnostics.

---

## Setting Default Actions with `ON_CALL`

`ON_CALL` defines default behavior for mock methods *without* setting expectations.

### Syntax

```cpp
ON_CALL(mock_object, MethodName(matchers...))
    .With(multi_arg_matcher)
    .WillByDefault(action);
```

- Useful to specify common behavior shared across tests.
- Default actions are overridden by matching `EXPECT_CALL` actions.

### Example

```cpp
ON_CALL(mock, GetValue(5))
    .WillByDefault(Return(42));

EXPECT_CALL(mock, GetValue(5))
    .Times(AnyNumber());
```

If you omit `EXPECT_CALL`, calling `GetValue(5)` will use the default action but warn if not expected.

### Best Practice

Use `ON_CALL` to set general behavior in test setup, and `EXPECT_CALL` to specify exact expected interactions.

---

## Controlling Mock Behavior Modes

By default, mocks are "naggy": uninteresting calls generate warnings but not failures.

You can change this behavior by wrapping your mock in:

- `NiceMock<T>`: suppresses warnings for uninteresting calls.
- `StrictMock<T>`: treats uninteresting calls as test failures.

Example:

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> nice_foo;
```

Note: These wrappers only affect methods declared directly in `T`, not base classes.

---

## Advanced Mock Usage Tips

### Verifying and Clearing Expectations Early

Force verification before destruction:

```cpp
ASSERT_TRUE(Mock::VerifyAndClearExpectations(&mock_obj));
```

Avoid altering expectations after verification to prevent undefined behavior.

### Delegating to Fakes or Real Objects

You can delegate the default actions of a mock to an existing fake or real implementation:

```cpp
ON_CALL(*this, Method).WillByDefault([this](args...) {
  return fake_.Method(args...);
});
```

Allows tests to verify interactions while preserving realistic behavior.

### Mocking Destructors

You cannot directly mock destructors. Use a mock method called from the destructor:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() override { Die(); }
};
```

Then test call order of `Die()` using `EXPECT_CALL` and sequences.

### Mocking Non-Virtual Methods

While mocking virtual methods is standard, you can mock non-virtual methods for high-performance injection by defining mock classes unrelated to the real class but with identical method signatures (without `override`). Use template-based techniques to switch implementations at compile time.

---

## Common Pitfalls & Troubleshooting

- **Uninteresting call warnings:** If you see warnings, ensure either to add appropriate `EXPECT_CALL`s, use `NiceMock`, or accept the warning as informative.
- **Overlapping expectations:** Later expectations override earlier ones; order matters.
- **Parameters mismatch:** Use `_` matcher to ignore argument values if they are not relevant to the test.
- **Non-virtual base method:** Make sure methods you want to mock are virtual.
- **Destructor issues:** Destructors must be virtual to avoid memory leaks and to ensure mock destruction.

---

## Example Scenario

Suppose you want to test a graphics module using a `Turtle` interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenDown() = 0;
  virtual int GetX() const = 0;
  // ...
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};

TEST(DrawTest, PenDownCalled) {
  MockTurtle turtle;
  EXPECT_CALL(turtle, PenDown()).Times(1);

  Painter painter(&turtle);
  painter.Draw();
}
```

This test asserts that `PenDown()` is invoked exactly once during `Draw()`.

---

## References and Related Pages

- [gMock Cheat Sheet](https://github.com/google/googletest/blob/main/docs/gmock_cheat_sheet.md): Quick reference for mock syntax.
- [Mocking Reference](/docs/reference/mocking.md): Detailed API and classes.
- [gMock for Dummies](https://github.com/google/googletest/blob/main/docs/gmock_for_dummies.md): Beginner friendly tutorial.
- [Mocking Scenarios Guide](/guides/core-workflows/mocking-scenarios): Complex real-world mock usages.
- [Actions Reference](/docs/reference/actions.md): Built-in mock actions.

---

By following this guide, you harness gMock to effectively design mocks that isolate dependencies, improve test clarity, and rigorously verify your C++ code’s interaction contracts.