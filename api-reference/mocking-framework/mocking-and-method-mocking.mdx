---
title: "Mocking Methods and Classes"
description: "How to define mock classes and methods using the MOCK_METHOD macro and friends. Covers best practices for creating, configuring, and using mocks to simulate real object behavior in unit tests."
---

# Mocking Methods and Classes

Mocking is a fundamental technique in GoogleMock to simulate and control the behavior of objects and their methods during unit testing. This page guides you through defining mock classes and methods using the `MOCK_METHOD` macro, along with best practices for creating and using mocks to validate interactions in your C++ tests.

---

## Defining Mock Classes

Mock classes are C++ classes that use gMock macros to provide mock implementations of virtual methods in interfaces or base classes. This allows you to verify calls, specify return values, and control behavior in tests.

### Using `MOCK_METHOD`

The core macro for defining a mock method is:

```cpp
MOCK_METHOD(return_type, method_name, (args...), (optional_specs));
```

- **`return_type`**: The return type of the method you are mocking.
- **`method_name`**: The name of the method.
- **`args...`**: Comma-separated list of argument types enclosed in parentheses.
- **`optional_specs`**: An optional comma-separated list of specifiers such as `const`, `override`, `noexcept`, calling convention modifiers like `Calltype(...)`, or reference qualifiers like `ref(&)`.

The macro expands to generate method declarations with mocked behavior.

**Example**:

```cpp
class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

#### Handling Commas Within Types

If your return type or argument type contains commas (e.g., templates like `std::pair<int, int>`), you must wrap the type in extra parentheses or provide a type alias:

```cpp
// Wrapping with parentheses
MOCK_METHOD((std::pair<int, int>), GetPair, ());

// Or using type aliases
using IntPair = std::pair<int, int>;
MOCK_METHOD(IntPair, GetPair, ());
```

#### Where To Define `MOCK_METHOD`

All `MOCK_METHOD` declarations must be in the `public:` section of your mock class, even if in the base class the corresponding virtual method is `protected` or `private`. This visibility requirement allows `ON_CALL` and `EXPECT_CALL` to reference the mocked functions.

### Mocking Overloaded Functions

You can mock overloaded methods by defining `MOCK_METHOD` for each overload separately. If you only mock some overloads, the remaining base class versions are hidden, and the compiler will warn.

Use `using BaseClass::MethodName;` to bring unmocked overloads into scope.

Example:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring in unmocked overloads
  MOCK_METHOD(int, Add, (Element x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));
};
```

### Mocking Class Templates

Mock class templates are defined similar to normal classes:

```cpp
template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

### Mocking Non-virtual Methods

gMock can mock non-virtual methods by defining a mock class with identical signatures but no inheritance. Use template-based dependency injection or other compile-time polymorphism techniques to swap implementations between production and testing.

Example:

```cpp
class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

### Mocking Free Functions

Direct mocking of free functions is not supported. Instead, abstract such functions behind interfaces and mock those interfaces.

Alternatively, rewrite your code to accept `std::function` parameters and use `MockFunction` templates to mock them.

### Old Style `MOCK_METHODn` Macros

Before 2018, `MOCK_METHODn` macros were used based on the number of arguments. Transition to the modern `MOCK_METHOD` macro whenever possible.


## Setting Expectations and Behaviors

Once you have mock methods, you specify expectations on how they should be called and how they behave.

### Using `EXPECT_CALL`

Sets an expectation that a mock method will be invoked with specific argument matchers. You can chain modifiers to control call cardinality, order, and behavior.

```cpp
EXPECT_CALL(mock_object, Method(matchers...))
  .Times(cardinality)
  .InSequence(sequence)
  .After(other_expectations)
  .WillOnce(action)
  .WillRepeatedly(action);
```

Examples:

```cpp
EXPECT_CALL(turtle, Forward(100))
    .Times(2)
    .WillRepeatedly(Return());
```

### Using `ON_CALL`

Sets the default behavior of a mock method when no explicit expectation is set. Does not enforce call occurrence.

```cpp
ON_CALL(mock_object, Method(matchers...))
    .WillByDefault(action);
```

---

## Best Practices & Common Pitfalls

- Always place `EXPECT_CALL` **before** the mock method is invoked.
- Use `ON_CALL` to specify default actions, especially in fixture setup.
- Prefer `RetiresOnSaturation()` to avoid expectation stickiness when ordering matters.
- Use `NiceMock` or `StrictMock` wrappers to control uninteresting call warnings and errors.
- Wrap arguments with unprotected commas in parentheses or use type aliases.
- When mocking overloaded methods, bring unmocked overloads into scope with `using`.
- Delegate calls to fakes or parent classes using lambda-based default actions for code reuse.

---

## Examples

### Simple Mock Class

```cpp
#include <gmock/gmock.h>

class Turtle {
 public:
  virtual ~Turtle() {}
  virtual void PenUp() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};
```

### Using Default Actions and Expectations in Tests

```cpp
using ::testing::Return;
using ::testing::_;

TEST(PainterTest, CallsPenUp) {
  MockTurtle turtle;
  // Default action for GetX is to return 0 unless overridden.
  ON_CALL(turtle, GetX()).WillByDefault(Return(0));

  // Expect Forward is called with any int.
  EXPECT_CALL(turtle, Forward(_)).Times(1);

  // Call to PenUp expected once.
  EXPECT_CALL(turtle, PenUp()).Times(1);

  turtle.PenUp();
  turtle.Forward(10);
}
```

### Mocking Overloaded Method

```cpp
class Foo {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int times, int x) = 0;
};

class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring in overloads not mocked
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
};
```

### Mocking Method with Move-Only Types

```cpp
class Buzzer {
 public:
  virtual std::unique_ptr<Buzz> MakeBuzz(const std::string& text) = 0;
  virtual bool ShareBuzz(std::unique_ptr<Buzz> buzz, int64_t timestamp) = 0;
};

class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (const std::string& text), (override));
  MOCK_METHOD(bool, ShareBuzz, (std::unique_ptr<Buzz> buzz, int64_t timestamp), (override));
};
```

Set expectations:

```cpp
EXPECT_CALL(mock_buzzer, MakeBuzz("hello"))
    .WillOnce(Return(std::make_unique<Buzz>()));
EXPECT_CALL(mock_buzzer, ShareBuzz(_, _)).WillOnce(Return(true));
```

---

## Advanced Techniques

### Delegating Calls to a Fake or Real Object

You can have mocked methods delegate their default action to a real or fake object.

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, DoThis, (int n), (override));

  void DelegateToReal() {
    ON_CALL(*this, DoThis).WillByDefault([this](int n) {
      return real_.DoThis(n);
    });
  }

 private:
  Foo real_;
};
```

### Controlling Strictness

Wrap your mock object with `NiceMock`, `NaggyMock` (default), or `StrictMock` to control warnings/errors on uninteresting calls.

```cpp
NiceMock<MockFoo> nice_mock;    // suppress warnings on uninteresting calls
StrictMock<MockFoo> strict_mock; // treat uninteresting calls as errors
```

### Handling Mock Method Destructors

Destructors cannot be mocked directly. Instead, add a `Die()` method to your mock and call it in the destructor:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() override { Die(); }
};
```

Now you can set expectations on `Die()` to verify destruction order.

---

## Troubleshooting Tips

- **Compilation errors with `MOCK_METHOD`**: Check for unescaped commas in types; wrap them in parentheses or use typedefs.
- **Uninteresting call warnings**: Use `NiceMock` for less verbosity or add catch-all expectations with `Times(AnyNumber())`.
- **Unexpected calls failures**: Verify argument matchers and order constraints; run tests with `--gmock_verbose=info` for detailed tracing.
- **Return values for move-only types**: Use lambdas or `WillOnce([](...) { return std::make_unique<T>(); })` for multiple calls.
- **Overridden methods not recognized**: Ensure the method in base class is `virtual` and that you add `override` specifiers in mocks.
- **Mock object verifications not occurring**: Ensure mock objects are destructed or explicitly call `Mock::VerifyAndClearExpectations(&mock)`.

---

## References and Next Steps

- See the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for advanced recipes using mocks.
- Review [Setting Expectations](https://google.github.io/googletest/gmock_for_dummies.html#setting-expectations) for how to use `EXPECT_CALL` and `ON_CALL` effectively.
- Explore related [Actions Reference](../actions.md) to define what mocked methods should do.
- Understand [Matchers](../matchers-api.md) to specify how to match method arguments precisely.
- Leverage [Nice, Strict, and Naggy Mock](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy) for managing uninteresting calls.


---