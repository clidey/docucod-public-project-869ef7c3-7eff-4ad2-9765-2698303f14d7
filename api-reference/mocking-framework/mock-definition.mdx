---
title: "Defining and Using Mock Classes"
description: "Step-by-step reference for defining mock classes using GoogleMock's core macros. Includes syntax for generating mock methods, handling constructors and destructors, and integrating mocks with GoogleTest test cases."
---

# Defining and Using Mock Classes

This section provides a step-by-step reference for defining mock classes using GoogleMock's core macros. It covers the syntax for generating mock methods, managing constructors and destructors, and integrating mocks with GoogleTest test cases, empowering you to create flexible, verifiable mock implementations for your C++ interfaces.

---

## Overview of Mock Class Definition

Mock classes in GoogleMock are defined as C++ classes that inherit from your interfaces or base classes. You declare mocked methods using the `MOCK_METHOD` macro, which automatically generates method stubs that integrate with GoogleMock's expectation and action framework.

### The MOCK_METHOD Macro

The `MOCK_METHOD` macro simplifies creating a mock method:

```cpp
MOCK_METHOD(ReturnType, MethodName, (Arguments...), (Qualifiers));
```

- **ReturnType**: matches the return type of the real method.
- **MethodName**: name of the method to mock.
- **Arguments**: types and names of parameters inside parentheses.
- **Qualifiers** (optional): method qualifiers such as `const`, `override`, `noexcept`, reference qualifiers, or calling conventions.


### Qualifiers Explained

| Qualifier               | Purpose                                   |
| ------------------------| ------------------------------------------|
| `const`                 | For mocking a `const` method. Required if overriding a `const` method.
| `override`              | Marks the method as override; recommended to catch signature mismatches.
| `noexcept`              | For overriding methods declared as `noexcept`.
| `Calltype(...)`         | For specifying calling conventions (e.g., Windows API `STDMETHODCALLTYPE`).
| `ref(&)` or `ref(&&)`   | For reference qualifiers (lvalue or rvalue reference qualified methods).


### Handling Commas in Types
If your return type or argument types include commas (e.g., template types like `std::pair<int, int>`), wrap the entire type in parentheses or use a type alias:

```cpp
// Wrapping in parentheses:
MOCK_METHOD((std::pair<int, int>), GetPair, ());

// Using type aliases:
using IntPair = std::pair<int, int>;
MOCK_METHOD(IntPair, GetPair, ());
```

### Placement of MOCK_METHOD
Always place `MOCK_METHOD` declarations in the `public:` section of your mock class, regardless of the access level of the base class method. This is necessary because GoogleMock uses these methods for stub implementations and expectation tracking.

---

## Writing a Simple Mock Class

Suppose you have an interface:

```cpp
class Turtle {
 public:
  virtual ~Turtle() {};
  virtual void PenUp() = 0;
  virtual void PenDown() = 0;
  virtual void Forward(int distance) = 0;
  virtual void Turn(int degrees) = 0;
  virtual int GetX() const = 0;
  virtual int GetY() const = 0;
};
```

You can define a mock class as follows:

```cpp
#include <gmock/gmock.h>

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, PenDown, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(void, Turn, (int degrees), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
  MOCK_METHOD(int, GetY, (), (const, override));
};
```

The mock methods inherit the exact signatures of the interface methods, enabling you to inspect and control their usage in tests.

---

## Usage Within Tests

### Typical Flow:
1. Create a mock object instance.
2. Specify default behaviors with `ON_CALL` if needed.
3. Set expectations with `EXPECT_CALL`.
4. Exercise the code under test.
5. Destruction of the mock (usually at scope end) automatically verifies expectations.

Example:

```cpp
using ::testing::AtLeast;
using ::testing::Return;

TEST(PainterTest, DrawsCircle) {
  MockTurtle turtle;

  EXPECT_CALL(turtle, PenDown())
      .Times(AtLeast(1));
  EXPECT_CALL(turtle, Forward(100))
      .Times(AtLeast(1));

  Painter painter(&turtle);
  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));
}
```

Here, the test verifies that `PenDown()` and `Forward(100)` are called at least once when `DrawCircle` is invoked.

---

## Handling Overloaded Methods

If your interface includes overloaded methods, you mock each overload separately:

```cpp
class Foo {
 public:
  virtual int Add(int x) = 0;
  virtual int Add(int x, int y) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int x, int y), (override));
};
```

If you donâ€™t mock all overloads, the others will be hidden. To fix this, you may re-expose them with `using`.

---

## Mocking Template Classes

You can mock template classes with the same approach:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface() {}
  virtual int GetSize() const = 0;
  virtual void Push(const T& x) = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

---

## Constructors and Destructors

Mock classes behave like normal C++ classes. Though you don't need to define constructors or destructors explicitly, you may do so to control compilation speed or initialization:

- Moving constructor/destructor definitions to `.cc` files reduces compile times.

### Mocking Destructors

Destructors cannot be mocked directly with `MOCK_METHOD`. To observe destructor calls:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() override { Die(); }
};
```

Use `EXPECT_CALL(mock, Die())` to set expectations on destruction.

---

## Integration With GoogleTest

Mocks integrate seamlessly with GoogleTest's framework:

- When a mock object is destroyed, its expectations are automatically verified.
- Use `EXPECT_CALL` to set expectations on method calls, specifying matchers, call counts, and behaviors.
- `ON_CALL` can set default behaviors without imposing call expectations.

Example usage:

```cpp
using ::testing::Return;
using ::testing::_;

TEST(FooTest, Example) {
  MockFoo foo;

  ON_CALL(foo, GetSize()).WillByDefault(Return(10));
  EXPECT_CALL(foo, GetSize()).Times(AtLeast(1));

  ASSERT_EQ(foo.GetSize(), 10);
}
```

---

## Tips and Best Practices

- **Always set expectations before exercising the code under test** to ensure determinism.
- **Use `override` in mock methods** to catch signature mismatches early.
- **Wrap types with commas inside parentheses or use type aliases** when defining mock methods.
- **Define mock classes for interfaces you own or control; avoid mocking third-party classes directly.**
- **Use `NiceMock` or `StrictMock` wrapper templates** to control warnings and failures on unexpected or uninteresting calls.
- **When mocking non-virtual methods, use template-based techniques or adapt your design to use interfaces.**

---

## Common Pitfalls

- Forgetting to mark destructors in base classes as virtual will cause resource leaks or undefined behavior.
- Omitting `override` may hide signature mismatches.
- Misordering `EXPECT_CALL`s can cause unexpected call matching due to overriding behavior.
- Calling mock methods before setting expectations leads to undefined behavior.

---

## Summary

Defining and using mock classes in GoogleMock revolves around the `MOCK_METHOD` macro, which auto-generates necessary mock methods within a derived mock class. This approach enables powerful specification of expected interactions using `EXPECT_CALL`, and seamless behavioral customization using `ON_CALL`. Proper use of qualifiers and careful placement of mocking code ensure clean, maintainable tests integrated tightly with GoogleTest.

---

## Example: Complete Mock Class

```cpp
#include <gmock/gmock.h>

class FooInterface {
 public:
  virtual ~FooInterface() {}
  virtual int Compute(int x, int y) = 0;
  virtual std::string Name() const = 0;
};

class MockFoo : public FooInterface {
 public:
  MOCK_METHOD(int, Compute, (int x, int y), (override));
  MOCK_METHOD(std::string, Name, (), (const, override));
};

// Usage in test:
TEST(FooTest, ComputesCorrectly) {
  MockFoo mock;
  EXPECT_CALL(mock, Compute(3, 4))
      .WillOnce(::testing::Return(7));
  EXPECT_CALL(mock, Name())
      .WillRepeatedly(::testing::Return("MockFoo"));

  ASSERT_EQ(mock.Compute(3, 4), 7);
  ASSERT_EQ(mock.Name(), "MockFoo");
}
```

---

## Additional Resources

- [Using Mocks to Isolate Dependencies guide](/guides/mocking-and-advanced-patterns/using-mocks)
- [Mocking Reference](reference/mocking.md)
- [gMock for Dummies](gmock_for_dummies.md)
- [gMock Cookbook](gmock_cook_book.md)

---

<Check>
Ensure your mock class:
- Declares all mocked methods as `virtual` overrides with correct qualifiers.
- Places `MOCK_METHOD` macros in the public section.
- Defines constructors/destructors suitably to optimize compile time.
- Uses `EXPECT_CALL` before exercising mock methods.
</Check>

---