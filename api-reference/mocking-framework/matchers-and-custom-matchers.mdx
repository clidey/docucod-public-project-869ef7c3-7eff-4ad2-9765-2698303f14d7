---
title: "Matchers and Custom Matchers"
description: "Provides an in-depth guide to using built-in and custom matchers for argument validation in both assertions and mock expectations. Explains polymorphic matchers, composition, and type-specific behaviors."
---

# Matchers and Custom Matchers

This page offers a detailed examination of matchers within the GoogleMock framework, focusing on how they empower you to specify fine-grained argument expectations in mocks and assertions. You'll learn about built-in polymorphic matchers, how to compose complex matching criteria, and how to author your own custom matchers for domain-specific validation.

---

## Introduction to Matchers

Matchers allow you to express predicates on the arguments passed to mock functions or on values checked by assertions. They are the foundation to GoogleMock's flexible and readable testing approach.

### What Are Matchers?

- A **matcher** is an object that can test whether a given value satisfies certain criteria.
- You provide matchers as arguments to `EXPECT_CALL` and `EXPECT_THAT` to verify calls and values.
- Examples of matchers:
  - `_`: matches any value (`AnythingMatcher`).
  - `Eq(value)`: matches values equal to `value`.
  - `Gt(5)`, `Lt(10)`: greater or less than comparisons.
  - `NotNull()`: matches any non-null pointer.

Matchers are polymorphic and may automatically adapt to the type provided in context.

---

## Built-in Matchers

GoogleMock provides a rich library of built-in matchers designed for common scenarios.

### Basic Predicate Matchers

- **Equality:** `Eq(value)` matches values equal to `value`.
- **Inequality:** `Ne(value)` matches values not equal to `value`.
- **Ordering:** `Lt(value)`, `Le(value)`, `Gt(value)`, and `Ge(value)`.
- **Special:** `_` matches anything.

```cpp
EXPECT_CALL(mock_obj, Foo(Eq(42)));
EXPECT_CALL(mock_obj, Bar(NotNull()));
EXPECT_THAT(value, Gt(5));
```

### String Matchers

- `StrEq()`, `StrNe()`: matches string equality (C strings or std::string).
- `StrCaseEq()`, `StrCaseNe()`: string equality ignoring case.
- `HasSubstr()`: matches strings containing a substring.
- `StartsWith()`, `EndsWith()`: matches prefixes or suffixes.

```cpp
EXPECT_THAT(name, StartsWith("John"));
EXPECT_THAT(text, HasSubstr("error"));
```

### Matchers for Containers

- `ElementsAre()`, `UnorderedElementsAre()`: match exact or unordered sequences.
- `Contains()`: verifies that a container has an element matching a value or matcher.
- `Each()`: verifies that all elements satisfy a matcher.
- `SizeIs()`: matches on container size.

### Pointer and Reference Matchers

- `IsNull()`, `NotNull()` for pointers.
- `Ref(variable)`: matches arguments that reference a specific variable.
- `Pointee(matcher)`: matches pointers whose pointee matches the matcher.

```cpp
EXPECT_CALL(mock, Bar(Pointee(Ge(3))));
```

### Compound Matchers

You can combine matchers:

- `AllOf(m1, m2, ...)`: matches if all matchers match.
- `AnyOf(m1, m2, ...)`: matches if any matcher matches.
- `Not(m)`: negates matcher `m`.

```cpp
EXPECT_CALL(mock, Foo(AllOf(Gt(5), Ne(10))));
```

### Advanced Matchers

- `Key(matcher)` and `Pair(first_matcher, second_matcher)` for matching `std::pair`.
- `Field()` and `Property()` to match fields or properties of objects.
- `ResultOf(function, matcher)` to match return values of a callable applied to the argument.
- `WhenDynamicCastTo<T>(matcher)` matches if `dynamic_cast<T>` succeeds and the cast result matches.

---

## Using Matchers in Your Tests

### Simple Usage

Matchers can be used directly in `EXPECT_CALL` or `EXPECT_THAT`:

```cpp
EXPECT_CALL(mock, ProcessValue(Gt(10)));
EXPECT_THAT(result, HasSubstr("success"));
```

When a matcher check fails, GoogleMock provides detailed failure messages, including expected description and actual values.

### Matching Multiple Arguments

Matchers correspond positionally to the arguments of the mocked method.

When matching a function call with multiple parameters:

```cpp
EXPECT_CALL(mock, Compute(Ge(10), Lt(20), _));
```

You can simplify by omitting argument matchers to `_` (matches anything).

### Wildcard Matcher

Use `_` when the value of an argument doesn't matter.

### Multiplier & Cardinality

Matchers can also be used in conjunction with `Times()` and other expectation modifiers to specify how often a call should occur matching given arguments.

---

## Creating Custom Matchers

When built-in matchers are insufficient, you can define your own custom matchers for precise control over argument validation.

### Writing Custom Matchers Using the MATCHER Macro

The simplest way is to use the `MATCHER` macro, which defines a polymorphic matcher:

```cpp
MATCHER(IsEven, "") {  // Description string is optional
  return (arg % 2) == 0;
}
```

You can then use:

```cpp
EXPECT_CALL(mock, Foo(IsEven()));
EXPECT_THAT(x, IsEven());
```

#### Adding Descriptive Messages

You can enhance match failure messages by streaming additional information:

```cpp
MATCHER(IsEven, "") {
  if (arg % 2 == 0) return true;
  *result_listener << "which has remainder " << (arg % 2);
  return false;
}
```

### Parameterized Matchers

You can add parameters to your matcher by using `MATCHER_P`, `MATCHER_P2`, etc., up to 10 parameters.

Example:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") {
  return (arg % divisor) == 0;
}

EXPECT_THAT(value, IsDivisibleBy(3));
```

### Implementing Matcher Interface Manually

For complex needs, you can implement the `MatcherInterface<T>` yourself:

```cpp
class DivisibleByMatcher : public MatcherInterface<int> {
 public:
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, MatchResultListener* listener) const override {
    if (n % divisor_ == 0) return true;
    if (listener) *listener << "which has remainder " << (n % divisor_);
    return false;
  }

  void DescribeTo(std::ostream* os) const override {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const override {
    *os << "is not divisible by " << divisor_;
  }

 private:
  const int divisor_;
};

Matcher<int> DivisibleBy(int divisor) {
  return MakeMatcher(new DivisibleByMatcher(divisor));
}
```

### Writing Polymorphic Matchers

If your matcher should work with multiple types, implement it as a polymorphic matcher with template `MatchAndExplain`:

```cpp
class IsNullMatcher {
 public:
  template <typename T>
  bool MatchAndExplain(const T* p, MatchResultListener*) const {
    return p == nullptr;
  }

  void DescribeTo(std::ostream* os) const { *os << "is NULL"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "isn't NULL"; }
};

inline PolymorphicMatcher<IsNullMatcher> IsNull() {
  return MakePolymorphicMatcher(IsNullMatcher());
}
```

### Tips for Writing Matchers

- Your matcher must be **pure**—no side effects.
- Use `result_listener` in `MATCHER` or `MatchAndExplain` to provide detailed failure reports.
- Always implement both `DescribeTo` and `DescribeNegationTo` for helpful messages.
- When parameterizing matchers, include parameter values in description strings for clarity.

---

## Composing and Casting Matchers

### Combining Existing Matchers

Use:

- `AllOf(m1, m2, …)`: all must match.
- `AnyOf(m1, m2, …)`: any must match.
- `Not(m)`: the negation.

### Safe Matcher Casting

`SafeMatcherCast<T>(m)` casts matcher `m` to type `Matcher<T>`. It performs compile-time checks to ensure type safety and avoids unsafe conversions common in C++.

Use this when you know the matcher is compatible but the types differ (e.g., matching an `int` argument using a `Matcher<long>`).

```cpp
EXPECT_CALL(mock, DoThing(SafeMatcherCast<int>(m)));
```

---

## Practical Examples

### Using Built-in Matchers

```cpp
using ::testing::_;
using ::testing::Ge;
using ::testing::StartsWith;
using ::testing::NotNull;

EXPECT_CALL(mock, Foo(Ge(10), NotNull()));
EXPECT_THAT(s, StartsWith("prefix"));
```

### Custom Matcher Example

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0) return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}

EXPECT_CALL(mock, Process(IsDivisibleBy7()));
EXPECT_THAT(value, Not(IsDivisibleBy7()));
```

### Matching Object Fields

```cpp
EXPECT_CALL(mock, Handle(
    Field(&Widget::size, Ge(10))));

EXPECT_THAT(widget, Property(&Widget::Name, StartsWith("Test")));
```

### Matching Pointer Targets

```cpp
EXPECT_CALL(mock, SetData(Pointee(Ge(5))));
```

---

## Troubleshooting and Common Pitfalls

- Matchers must be verbose in failures; provide and customize descriptive messages.
- Don't use unsafe casts—prefer `SafeMatcherCast` when needed.
- Remember matchers are pure functions: no side effects or dependence on global state.
- Overly strict expectations cause brittle tests; combine matchers or use wildcards sensibly.
- Use `EXPECT_CALL` and `ON_CALL` macros wisely to balance between verifying behavior and providing default actions.

---

## Additional Resources

* [Matchers Reference](matchers.md) — Comprehensive list and explanation of built-in matchers.
* [Mocking Reference](mocking.md) — Overall guide for working with mocks.
* [gMock Cookbook](gmock_cook_book.md) — Practical recipes including custom matcher usage.
* [Using Assertions and Matchers](assertions-matchers.md) — How to write expressive assertions with matchers.

---

## Summary

Matchers in GoogleMock enable you to write compact, readable, and expressive tests by precisely describing expected argument conditions. This page details how to use built-in matchers, combine them, and create custom matchers to validate even the most complex argument patterns.

For comprehensive mastery, explore the related matchers, mocking references, and the gMock cookbook. Together, these resources empower you to write robust unit tests that catch errors early and improve maintainability.
