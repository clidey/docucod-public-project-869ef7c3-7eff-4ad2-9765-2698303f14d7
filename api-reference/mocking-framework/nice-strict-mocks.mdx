---
title: "Nice, Naggy, and Strict Mocks"
description: "Wrappers and templates for controlling mock behavior regarding uninteresting calls. Explains when to use NiceMock, NaggyMock, and StrictMock to tune test output and enforcement."
---

# Nice, Naggy, and Strict Mocks

Control how your mock objects handle uninteresting calls with the provided wrapper templates. These templates let you tune the test verbosity and enforcement, empowering you to strike the right balance between flexibility and strictness in your mock-based testing.

---

## Overview

When you use GoogleMock to create mocks, calls to mock methods without matching `EXPECT_CALL` expectations are considered *uninteresting calls*. By default, such calls generate warnings to alert you that your test did something you did not explicitly expect. But sometimes you want to suppress these warnings, and sometimes you want them to cause test failures.

GoogleMock provides three wrappers for mock classes that control this behavior:

- **`NiceMock<T>`**: Suppresses warnings on uninteresting calls.
- **`NaggyMock<T>`**: The default behavior that prints warnings on uninteresting calls.
- **`StrictMock<T>`**: Treats uninteresting calls as test failures.

Each template takes a mock class you defined and creates a subclass with the designated behavior.

---

## When to Use Which Wrapper

| Wrapper               | Behavior on uninteresting calls               | Use Case
|----------------------|-----------------------------------------------|----------------------------
| `NiceMock<T>`         | Silently ignore uninteresting calls           | When you want to focus only on expected calls, suppress noisy warnings, and keep tests maintainable.
| `NaggyMock<T>` (default) | Print warnings for uninteresting calls         | When you want to be alerted about possible misses but don't want to fail tests immediately.
| `StrictMock<T>`       | Fail tests on uninteresting calls             | When you want the strictest control, ensuring that any unexpected calls cause immediate test failures.

---

## Using the Wrappers

These wrappers can be used just like your mock class. They *inherit* constructors, so you can pass any arguments that your mock class constructors accept.

```cpp
using ::testing::NiceMock;
using ::testing::NaggyMock;
using ::testing::StrictMock;

class MockFoo {
 public:
  MOCK_METHOD(void, DoThis, ());
  MOCK_METHOD(int, DoThat, (bool));
};

// NaggyMock (default behavior)
NaggyMock<MockFoo> naggy_foo;
EXPECT_CALL(naggy_foo, DoThis());
naggy_foo.DoThis();      // No warning
naggy_foo.DoThat(true);  // Warning: uninteresting call

// NiceMock
NiceMock<MockFoo> nice_foo;
EXPECT_CALL(nice_foo, DoThis());
nice_foo.DoThis();       // No warning
nice_foo.DoThat(true);   // No warning (suppressed)

// StrictMock
StrictMock<MockFoo> strict_foo;
EXPECT_CALL(strict_foo, DoThis());
strict_foo.DoThis();      // No warning
strict_foo.DoThat(true);  // Test fails: unexpected call
```


**Note:** All three templates require that the mock class has virtual destructor and that mock methods are defined via `MOCK_METHOD` macros **directly** in that class. Inheritance chains with mock methods in base classes may not behave as expected with these wrappers.

---

## Key Details and Behavior

### 1. Relationship to Mock Classes

Each wrapper is a subclass of the provided mock class template parameter. This means:

- `NiceMock<T>` behaves exactly like `T` but treats uninteresting calls silently.
- `NaggyMock<T>` behaves like the default mock with warnings.
- `StrictMock<T>` treats uninteresting calls as failures.

### 2. Constructor Forwarding

These wrappers forward all constructors to the base mock class, so you can pass constructor arguments transparently.

Example:

```cpp
NiceMock<MockFoo> nice_foo("argument");
StrictMock<MockBar> strict_bar(5, "test");
```

### 3. Strictness Restrictions

You cannot apply multiple strictness wrappers on the same mock class hierarchy. For example, `NiceMock<NaggyMock<MockFoo>>` is **not** supported.

### 4. Limitations

- Wrappers only affect mock methods declared with the `MOCK_METHOD` macro in the mock class itself.
- If the mock class's destructor is not virtual, the wrappers might malfunction.

---

## Understanding Uninteresting vs Unexpected Calls

- **Uninteresting calls:** Calls to mock methods for which no `EXPECT_CALL` is set. By default, these cause warnings.
- **Unexpected calls:** Calls to mock methods with existing expectations that do *not* match the arguments or call count. These always cause errors regardless of wrapper.

`NiceMock` suppresses *uninteresting call* warnings but does **not** allow unexpected calls. `NaggyMock` warns on uninteresting calls. `StrictMock` treats uninteresting calls as errors.

---

## Common Usage Patterns and Recommendations

### When to use `NiceMock`

- Most tests should use `NiceMock` to reduce noise from uninteresting calls.
- It makes tests more maintainable by focusing on what actually matters.
- Suppresses warnings but *does not* disable failure on unexpected calls.

### When to use `NaggyMock`

- Use during test development or debugging to catch uninteresting calls without failing tests.
- Default behavior of mocks.

### When to use `StrictMock`

- Use sparingly for highly disciplined tests.
- Ensures *any* uninteresting call fails the test immediately.
- Useful when strict enforcement is needed to avoid silent test issues.

### Example: Switching from Naggy to Nice Mock

```cpp
// This mock warns on uninteresting calls
MockFoo naggy_foo;
naggy_foo.DoSomething();  // Warning printed

// This mock suppresses such warnings
NiceMock<MockFoo> nice_foo;
nice_foo.DoSomething();  // No warning
```

---

## Troubleshooting

### Unexpected Calls Still Fail on NiceMock

`NiceMock<T>` suppresses warnings for uninteresting calls only. If you call mock methods with arguments that have `EXPECT_CALL` expectations that don't match, those calls are still errors.

### Mock Methods in Base Classes Not Affected

If your mock methods are declared in a base class of your mock, the wrappers may not apply strictness correctly. Ensure all `MOCK_METHOD` macros are used directly in the decorated class.

### Destructor Virtuality

If the mock class does not have a `virtual` destructor, `NiceMock`, `NaggyMock`, and `StrictMock` might not behave correctly. Add a virtual destructor to the mock.

---

## Summary

The `NiceMock`, `NaggyMock`, and `StrictMock` class templates allow you to finely control how your mock objects respond to uninteresting calls, balancing between test output verbosity and strict failure enforcement. Use them appropriately to improve test maintainability and clarity.

---

## References

- [GoogleMock Cookbook - The Nice, the Strict, and the Naggy](https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy)
- [Mocking Reference - NiceMock, NaggyMock, StrictMock](https://google.github.io/googletest/reference/mocking.html#NiceMock)
- [GoogleMock Test Suite for NiceStrictNaggy](https://github.com/google/googletest/blob/main/googlemock/test/gmock-nice-strict_test.cc)
- [gMock for Dummies - Basic Mock Usage](https://google.github.io/googletest/gmock_for_dummies.html)

---

## Practical Example

```cpp
#include <gmock/gmock.h>

class Interface {
 public:
  virtual ~Interface() = default;
  virtual int Foo(int x) = 0;
};

class MockInterface : public Interface {
 public:
  MOCK_METHOD(int, Foo, (int x), (override));
};

// Using NiceMock suppresses warnings for uninteresting calls
NiceMock<MockInterface> mock_nice;
EXPECT_CALL(mock_nice, Foo(42)).WillOnce(testing::Return(100));

mock_nice.Foo(42);  // OK
mock_nice.Foo(1);    // No warning, call proceeds with default action

// Using StrictMock causes failures on uninteresting calls
StrictMock<MockInterface> mock_strict;
EXPECT_CALL(mock_strict, Foo(42)).WillOnce(testing::Return(100));

mock_strict.Foo(42);  // OK
mock_strict.Foo(1);    // Test fails: unexpected call
```
