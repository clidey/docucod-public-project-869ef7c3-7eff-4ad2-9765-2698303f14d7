---
title: "Parameterized and Typed Tests"
description: "API overview for writing value-parameterized and type-parameterized tests. Illustrates how to use provided macros and templates to run the same test logic across diverse datasets or types, maximizing test coverage and code reuse."
---

# Parameterized and Typed Tests

GoogleTest enables you to write robust, maintainable tests that run the same test logic over many input values or types to maximize coverage and minimize duplicate test code. This page provides a comprehensive overview of **value-parameterized tests** and **type-parameterized tests** — powerful paradigms supported out of the box — along with descriptions of the provided macros and templates that make implementation intuitive and efficient.

---

## Value-Parameterized Tests Overview

Value-parameterized tests allow you to run the *same* test logic repeatedly, each time with a different **runtime parameter value**. This approach is ideal when you want to validate code against various data inputs without duplicating test code.

### Workflow for Writing Value-Parameterized Tests

1. **Define a Test Fixture Class**

   Your fixture should inherit from `::testing::TestWithParam<T>` where `T` is the type of the parameter you want to test against. This class provides the `GetParam()` accessor to retrieve the current parameter value within tests.

   ```cpp
   class FooTest : public ::testing::TestWithParam<const char*> {
     // Usual test fixture members here.
   };
   ```

2. **Write Parameterized Tests Using `TEST_P` Macro**

   Use `TEST_P` (the 'P' indicates parameterized) to define test functions that operate against your fixture class.

   ```cpp
   TEST_P(FooTest, HandlesVariousStrings) {
     const char* param = GetParam();
     EXPECT_TRUE(foo.DoWork(param));
   }
   ```

3. **Instantiate the Tests Using `INSTANTIATE_TEST_SUITE_P`**

   This macro binds concrete parameter values to your test suite. You provide a unique prefix and a parameter generator that defines the values or range of values you want to run your tests against.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(ExampleInstantiation,
                            FooTest,
                            ::testing::Values("one", "two", "three"));
   ```

### Built-in Parameter Generators

GoogleTest supplies several useful parameter generators in the `testing` namespace:

| Generator                     | Description                                                                                     |
|-------------------------------|-------------------------------------------------------------------------------------------------|
| `Range(begin, end [, step])`  | Generates a sequence of values from `begin` (inclusive) to `end` (exclusive) by `step`.         |
| `Values(v1, v2, ..., vN)`     | Enumerates an explicit list of parameter values.                                                |
| `ValuesIn(container)`          | Uses values from a C-style array, STL container, or any iterator range to produce parameters.   |
| `Bool()`                      | Convenience generator yielding the boolean values `false` and `true`.                          |
| `Combine(g1, g2, ..., gN)`    | Produces combinations (Cartesian product) of the parameters generated by given generators.      |
| `ConvertGenerator<T>(gen)`    | Casts generated parameters to a user-defined type, with optional conversion function support.  |

Example - Combining two generators:

```cpp
class AnimalTest : public ::testing::TestWithParam<std::tuple<const char*, Color>> {};

TEST_P(AnimalTest, AnimalLooksNice) {
  const auto& [animal, color] = GetParam();
  EXPECT_TRUE(IsNice(animal, color));
}

INSTANTIATE_TEST_SUITE_P(
  AnimalVariations, AnimalTest,
  ::testing::Combine(::testing::Values("cat", "dog"), ::testing::Values(BLACK, WHITE)));
```

### Defining Custom Names for Parameter Instances

The last argument to `INSTANTIATE_TEST_SUITE_P` accepts a callable to customize the test name suffixes generated for each parameter value. This helps generate readable and unique test case names.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite,
    ::testing::Values(...),
    [](const ::testing::TestParamInfo<MyTestSuite::ParamType>& info) {
      std::string name = ...;  // create a unique, ASCII-safe name
      return name;
    });
```


---

## Typed Tests Overview

Typed tests allow you to write tests that are *parameterized by type* rather than values. This is ideal to verify that template classes or functions behave correctly for a set of types without duplicating test logic.

### Typed Tests: Fixed Type Lists

1. **Define a Fixture Class Template**

   Create your test fixture as a template class derived from `::testing::Test`.

   ```cpp
   template <typename T>
   class MyTypedTest : public ::testing::Test {
   public:
     // fixture members here
   };
   ```

2. **Associate with a List of Types**

   Use `using` combined with `::testing::Types<...>` to define the list of types.

   ```cpp
   using MyTypes = ::testing::Types<char, int, double>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Define Typed Tests with `TYPED_TEST`**

   Write your tests referencing the current type parameter as `TypeParam`.

   ```cpp
   TYPED_TEST(MyTypedTest, DoesSomething) {
     TypeParam value{};
     EXPECT_TRUE(DoWork(value));
   }
   ```

This approach compiles once per type in your list, running one test instance per type.

### Type-Parameterized Tests: Abstract Suites

Similar to typed tests but allows your test suite to be *defined independently* of the type list, which is specified later. This supports code reuse across multiple type lists or modules.

Steps:

1. **Define Fixture Template and Declare with `TYPED_TEST_SUITE_P`**

   ```cpp
   template <typename T>
   class FooTest : public ::testing::Test {};

   TYPED_TEST_SUITE_P(FooTest);
   ```

2. **Define Typed Tests with `TYPED_TEST_P`**

   ```cpp
   TYPED_TEST_P(FooTest, DoesBlah) {
     TypeParam x = 0;
     // test body
   }

   TYPED_TEST_P(FooTest, HasPropertyA) { /* ... */ }
   ```

3. **Register Typed Tests**

   ```cpp
   REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
   ```

4. **Instantiate with a Type List via `INSTANTIATE_TYPED_TEST_SUITE_P`**

   ```cpp
   using MyTypes = ::testing::Types<char, int, double>;
   INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
   ```

This allows you to write the generic typed tests once and instantiate them multiple times with different type lists.

---

## Practical Tips and Best Practices

- Always use **unique instantiation prefixes** with `INSTANTIATE_TEST_SUITE_P` to avoid naming collisions.
- When using parameter generators, prefer `ValuesIn` for existing containers.
- Use `Combine` for testing all combinations of multiple parameters, but beware exponential explosion.
- Implement **custom name generators** for parameterized tests when parameters are not trivially printable.
- Typed tests work at compile time with types, so your test fixture must be templated accordingly.
- For complex type parameters, consider `ConvertGenerator` to adapt generated types into your fixture's parameter type.
- Remember that both value and typed parameters must be copyable; you are responsible for resource management if they are pointers.

---

## Summary

The power of GoogleTest’s parameterized and typed tests lies in their ability to effortlessly run the *same test suite* across diverse data or types, thereby enhancing test coverage and reducing code duplication. By understanding and leveraging the macros `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, `TYPED_TEST`, and their parameterized counterparts, you enable scalable, flexible testing strategies.

For real-world usage examples and advanced variations, refer to the samples provided in the GoogleTest repository and the [Advanced GoogleTest Topics](../docs/advanced.md).


---

## References

- [Value-Parameterized Tests](../docs/advanced.md#value-parameterized-tests)
- [Typed Tests and Type-Parameterized Tests](../docs/advanced.md#typed-tests)
- [`TEST_P` Macro](../docs/reference/testing.md#TEST_P)
- [`INSTANTIATE_TEST_SUITE_P` Macro](../docs/reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [`TYPED_TEST_SUITE` & `TYPED_TEST` Macro](../docs/reference/testing.md#TYPED_TEST_SUITE)
- [`TYPED_TEST_SUITE_P` & `TYPED_TEST_P` Macros](../docs/reference/testing.md#TYPED_TEST_SUITE_P)
- [GoogleTest Sample Tests](https://github.com/google/googletest/tree/main/googletest/samples)


---

## Example Code Summary

```cpp
// Define a fixture for value-parameterized tests.
class FooTest : public ::testing::TestWithParam<const char*> {};

// Define parameterized tests.
TEST_P(FooTest, CanProcessStrings) {
  EXPECT_TRUE(ProcessString(GetParam()));
}

// Instantiate the test suite with a list of string parameters.
INSTANTIATE_TEST_SUITE_P(FooStrings, FooTest,
                         ::testing::Values("alpha", "beta", "gamma"));


// Typed test fixture template.
template <typename T>
class MyTypedTest : public ::testing::Test {};

// List of types to instantiate typed tests over.
using MyTypes = ::testing::Types<int, double, char>;

// Associate fixture with types.
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

// Define typed tests operating on the type parameter.
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam value{};
  EXPECT_TRUE(TestAlgorithm(value));
}
```
