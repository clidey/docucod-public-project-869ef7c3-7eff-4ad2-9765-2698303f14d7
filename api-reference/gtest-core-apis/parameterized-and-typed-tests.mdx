---
title: "Parameterized and Typed Tests"
description: "Define tests that run across a range of input values and types. Explore macros, helpers, and usage patterns for parameterized (`TEST_P`) and type-parameterized (`TYPED_TEST`) tests, as well as utilities for value combintation and test instantiation."
---

# Parameterized and Typed Tests

Define tests that run across a range of input values and types. This page guides you through using GoogleTest macros, helpers, and usage patterns for parameterized (`TEST_P`) and type-parameterized (`TYPED_TEST`) tests, along with utilities for combining values and instantiating tests.

---

## Introduction

Automate running your tests against varied inputs without duplicating test code. Whether you want to test multiple values with a single test logic or verify the same test logic against different types, GoogleTest provides two powerful models:

- **Value-Parameterized Tests**: Run the same test code with different parameter values.
- **Typed/Type-Parameterized Tests**: Run the same test code against different data types.

This approach promotes maintainable, concise, and scalable tests, saving you from writing repetitive test functions for each input or type.

---

## Value-Parameterized Tests (Using `TEST_P`)

Value-parameterized tests let you write tests that receive their parameters at runtime. These are ideal for data-driven testing or verifying multiple variations with the same logic.

### How to Write Value-Parameterized Tests

1. **Define a Test Fixture Class**

    Derive your test fixture from `::testing::TestWithParam<T>`, where `T` is the parameter type. `T` can be any copyable type.

    ```cpp
    class FooTest : public ::testing::TestWithParam<int> {
      // Additional setup or members here
    };
    ```

2. **Write Tests Using `TEST_P`**

    Use `TEST_P` in place of `TEST` or `TEST_F`. Inside, access the test parameter with `GetParam()`.

    ```cpp
    TEST_P(FooTest, HandlesVariousInputs) {
      int param = GetParam();
      EXPECT_TRUE(Validate(param));
    }
    ```

3. **Instantiate the Test Suite with Parameters**

    Use `INSTANTIATE_TEST_SUITE_P` to provide data for the tests. GoogleTest offers several parameter generators:

    - `Values(...)` for explicit parameter lists
    - `ValuesIn(container)` for container elements
    - `Range(begin, end, [step])` for sequential ranges
    - `Bool()` for boolean true/false
    - `Combine(...)` for Cartesian products of multiple generators

    ```cpp
    INSTANTIATE_TEST_SUITE_P(Default, FooTest, ::testing::Values(1, 2, 3));
    ```

### Example

```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenValues, IsEvenTest, testing::Values(2, 4, 6, 8));
```

### Combining Parameters

You may combine multiple parameter generators to test variations of multiple values simultaneously:

```cpp
INSTANTIATE_TEST_SUITE_P(CombinedParams, MyTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Custom Test Name Generation

You can specify a callable to generate readable test name suffixes based on parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, MyTestSuite, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Allowing Uninstantiated Tests

If you define a `TEST_P` without instantiating it, GoogleTest signals an error. Use:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FooTest);
```

to suppress the error when appropriate.

---

## Typed Tests (Using `TYPED_TEST`) and Type-Parameterized Tests (Using `TYPED_TEST_P`)

Typed tests let you run the same test logic for different types, ideal when verifying multiple implementations or types against a common contract.

### Typed Tests (`TYPED_TEST`)

Typed tests require knowing the list of types when writing the tests.

1. **Define a Template Fixture Class**

    Derive your fixture class as a template from `::testing::Test`:

    ```cpp
    template <typename T>
    class MyTypedTest : public ::testing::Test {
    public:
      T value_;
    };
    ```

2. **Associate Types with the Fixture**

    Define a type list and associate it with your fixture using `TYPED_TEST_SUITE`:

    ```cpp
    using MyTypes = ::testing::Types<int, char, double>;
    TYPED_TEST_SUITE(MyTypedTest, MyTypes);
    ```

3. **Write Typed Tests**

    Use `TYPED_TEST` to define test logic. Refer to the current type with `TypeParam`:

    ```cpp
    TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
      TypeParam n = this->value_;
      EXPECT_EQ(0, n);
    }
    ```

### Type-Parameterized Tests (`TYPED_TEST_P`)

Type-parameterized tests let you define the test patterns without specifying the types initially, which are instantiated later.

1. **Define a Template Fixture Class**

    ```cpp
    template <typename T>
    class MyPatternTest : public ::testing::Test {};
    ```

2. **Declare a Type-Parameterized Test Suite**

    ```cpp
    TYPED_TEST_SUITE_P(MyPatternTest);
    ```

3. **Define Tests Using `TYPED_TEST_P`**

    ```cpp
    TYPED_TEST_P(MyPatternTest, BasicTest) {
      TypeParam value = 0;
      EXPECT_EQ(0, value);
    }
    ```

4. **Register Test Names**

    ```cpp
    REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, BasicTest);
    ```

5. **Instantiate with Types**

    ```cpp
    using MyTypes = ::testing::Types<int, char>;
    INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyPatternTest, MyTypes);
    ```

### Custom Naming

Similarly to typed tests, you can provide a custom class for generating type names.

---

## Utilities for Parameterized Testing

### Parameter Generators

GoogleTest provides a rich set of generators for test parameters:

| Generator   | Description |
|-------------|-------------|
| `Range(start, end, step = 1)` | Sequential values from start to just before end.
| `Values(v1, v2, ..., vN)`      | Explicit list of values.
| `ValuesIn(container)`          | Values from containers or iterator ranges.
| `Bool()`                      | `false` and `true`.
| `Combine(g1, g2, ..., gN)`    | Cartesian product of multiple generators.
| `ConvertGenerator<T>(gen)`    | Casts generated values to type `T`.
| `ConvertGenerator(gen, func)` | Applies a callable `func` to convert generated values.

---

## Practical Tips and Best Practices

- **Parameter Naming**: Avoid underscores in test suite and test names to prevent conflicts and ensure stable test name generation.
- **Test Isolation**: Each parameterized test runs with a fresh test fixture instance.
- **Code Reuse**: Favor `TYPED_TEST` when checking multiple types with identical construction pattern; use `TEST_P` for variable data that may need factory functions.
- **Test Names**: Provide custom name generators when default parameter stringification isn't readable or stable.
- **Instantiations**: Always instantiate your parameterized tests with `INSTANTIATE_TEST_SUITE_P`, or explicitly allow uninstantiated tests.

---

## Troubleshooting

- **Test Does Not Run or Error on Registration**: Ensure `INSTANTIATE_TEST_SUITE_P` is invoked for each `TEST_P` or `TYPED_TEST_P`.
- **Name Collisions**: Avoid underscores in test and suite names to prevent name mangling issues.
- **Dangling References in Name Generators**: When using lambdas that accept parameters by `string_view` from temporary strings, explicitly specify the type to avoid dangling references.
- **Not Seeing Parameter Variations**: Confirm that parameter generators produce the expected number and set of values.

---

## Example: Value-Parameterized Test

```cpp
class IsPositiveTest : public ::testing::TestWithParam<int> {};

TEST_P(IsPositiveTest, HandlesPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(Positives, IsPositiveTest, testing::Values(1, 2, 3, 4));
```


## Example: Typed Test

```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {
protected:
  T max_value_ = std::numeric_limits<T>::max();
};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, MaxValueIsPositive) {
  EXPECT_GT(this->max_value_, 0);
}
```

## Example: Type-Parameterized Test (Pattern)

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
  (void)container;
}

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed, InitialSizeIsZero);

using MyContainers = ::testing::Types<std::vector<int>, std::list<char>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, ContainerTest, MyContainers);
```

---

## Additional Resources

- [Parameterized and Typed Tests - Advanced Guide](../advanced.md#value-parameterized-tests) for detailed concepts and best practices
- [Testing Reference - Macros and Utilities for Parameterized Tests](reference/testing.md#TEST_P)
- [GoogleTest Primer](primer.md) for beginner-friendly introduction to tests and fixtures

---

## Summary

Parameterized and typed tests empower you to write concise, reusable test logic that runs over many input values or types. This page covers defining fixtures, writing tests with `TEST_P`, `TYPED_TEST`, and `TYPED_TEST_P`, managing instantiation, combining parameters, and custom naming for clarity. Test engineers should use value-parameterized tests for input data variations and typed tests for verifying interface compliance across types.


---

## See Also

- [INSTANTIATE_TEST_SUITE_P](reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [TYPED_TEST_SUITE](reference/testing.md#TYPED_TEST_SUITE)
- [REGISTER_TYPED_TEST_SUITE_P](reference/testing.md#REGISTER_TYPED_TEST_SUITE_P)
- [Test Fixtures and TEST_F](primer.md#same-data-multiple-tests)
- [GoogleTest FAQ on Typed vs Parameterized Tests](docs/faq.md#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests)

---

## Callouts

<Tip>
Use value-parameterized tests (`TEST_P`) when you want to run the same test logic against a range of values or configurations.
</Tip>

<Tip>
Use typed tests (`TYPED_TEST`) if you want to run tests against multiple types with the same construction pattern.
</Tip>

<Warning>
Always instantiate parameterized tests with `INSTANTIATE_TEST_SUITE_P` to avoid runtime errors.
</Warning>

<Note>
Avoid underscores `_` in test suite and test names to prevent name mangling issues.
</Note>

---

This completes the documentation for "Parameterized and Typed Tests" focused on defining tests running across varied inputs and types in GoogleTest.
