---
title: "Test Declaration and Execution"
description: "How to define and register unit tests, organize test suites, and control test execution flow with the GoogleTest core classes and macros. Learn to structure your C++ tests for maximum discoverability and maintainability."
---

# Test Declaration and Execution

Understand how to define and register unit tests, organize them into test suites, and control the flow of test execution using GoogleTest's core classes and macros. This guide helps you structure your C++ tests for maximum discoverability, maintainability, and efficient testing workflows.

---

## Introduction

GoogleTest provides a simple yet powerful framework for declaring and executing tests in C++. Effective test declaration lays the foundation for robust, readable, and maintainable testing code. This page focuses specifically on the core API elements you use to declare tests, register them either statically or dynamically, and manage their execution flow.

## Test Macros: Defining Tests

GoogleTest offers several macros that you use to declare tests. Each macro serves different purposes aligned with your testing needs.

### `TEST` Macro

Use `TEST(TestSuiteName, TestName)` to define an individual test function inside a test suite. It represents the simplest form of test declaration:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

- Both `TestSuiteName` and `TestName` must be valid C++ identifiers without underscores.
- Tests grouped under the same `TestSuiteName` form a logical unit.

### `TEST_F` Macro

Use `TEST_F(TestFixtureName, TestName)` when your tests require a shared setup using a test fixture class.

```cpp
class QueueTest : public ::testing::Test {
 protected:
  QueueTest() { /* Constructor for setup */ }
  void SetUp() override { /* Per-test setup */ }
  void TearDown() override { /* Per-test tear down */ }
  Queue<int> q0_, q1_, q2_;
};

TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

- The test fixture class must inherit from `testing::Test`.
- Each test with `TEST_F` creates a fresh instance of the fixture.

### `TEST_P` and `INSTANTIATE_TEST_SUITE_P`: Value-Parameterized Tests

Value-parameterized tests allow running the same test logic repeatedly against different input data.

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, DoesBlah) {
  int param = GetParam();
  EXPECT_TRUE(Something(param));
}

INSTANTIATE_TEST_SUITE_P(
    MyGroup, FooTest,
    testing::Values(1, 2, 3));
```

- `TEST_P` defines a parameterized test.
- `INSTANTIATE_TEST_SUITE_P` generates tests for each parameter value.
- Use provided generators like `Values()`, `Range()`, `Bool()`, or custom generators.
- You can specify custom naming functions for parameterized tests.

### Typed and Type-Parameterized Tests

If you want to run tests over sets of types rather than values, GoogleTest provides typed and type-parameterized tests.

- `TYPED_TEST_SUITE` and `TYPED_TEST` allow defining and running typed tests.
- `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, and `INSTANTIATE_TYPED_TEST_SUITE_P` offer more flexible type-parameterized test definitions and instantiations.

Example of typed test suite:

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  T value_;
};

using MyTypes = ::testing::Types<char, int, unsigned>;
TYPED_TEST_SUITE(MyFixture, MyTypes);

TYPED_TEST(MyFixture, DoesStuff) {
  TypeParam val = this->value_;
  EXPECT_TRUE(SomeCondition(val));
}
```

## Test Fixture Special Methods

Beyond the per-test `SetUp()` and `TearDown()`, GoogleTest supports per-test-suite shared setup and teardown through:

- `static void SetUpTestSuite()` - Called once before the first test runs in the suite.
- `static void TearDownTestSuite()` - Called once after the last test in the suite.

This supports expensive resource allocation once per suite rather than per test.

## Dynamic Test Registration

You can register tests programmatically at runtime using `::testing::RegisterTest`. This advanced API lets you create tests when test cases or parameters are unknown at compile time.

Example:

```cpp
class MyFixture : public testing::Test {
  // Optional shared setup/teardown
  static void SetUpTestSuite() { ... }
  static void TearDownTestSuite() { ... }
  void SetUp() override { ... }
  void TearDown() override { ... }
};

class MyTest : public MyFixture {
 public:
  explicit MyTest(int data) : data_(data) {}
  void TestBody() override {
    EXPECT_TRUE(Validate(data_));
  }
 private:
  int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
      "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr, std::to_string(v).c_str(),
      __FILE__, __LINE__,
      [=]() -> MyFixture* { return new MyTest(v); });
  }
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  RegisterMyTests({1, 2, 3});
  return RUN_ALL_TESTS();
}
```

## Running Tests

Once tests are declared and registered, run them through:

- Calling `testing::InitGoogleTest(&argc, argv)` to initialize the framework and parse flags.
- Calling `RUN_ALL_TESTS()` which executes all registered tests, returns 0 if all pass or 1 otherwise.

### Main Function Example

Typically, you can link your tests with the `gtest_main` library and avoid writing your own `main`. Otherwise:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

## Test Naming Rules and Considerations

- Avoid underscores in test suite and test names.
- All tests in a suite must use the same fixture class.
- Disabled tests are prefixed with `DISABLED_` and excluded from running unless overridden.

## Test Execution Flow

1. GoogleTest discovers all registered tests, grouped by test suites.
2. Per-test-suite setup (`SetUpTestSuite`) executes once.
3. Each test runs inside a fresh fixture instance:
    - Fixture constructor
    - `SetUp()` method
    - Test body
    - `TearDown()` method
    - Fixture destructor
4. Per-test-suite teardown (`TearDownTestSuite`) executes once after all tests.

## Accessing Metadata in Tests

Use `::testing::UnitTest::GetInstance()->current_test_info()` to get details about the currently running test, such as name, file, and line number.

Example:

```cpp
const testing::TestInfo* info = testing::UnitTest::GetInstance()->current_test_info();
std::cout << "Current test suite: " << info->test_suite_name() << std::endl;
std::cout << "Current test: " << info->name() << std::endl;
```

## Tips & Best Practices

- Prefer `TEST_F` when multiple tests share setup logic.
- Use `TEST_P` with `INSTANTIATE_TEST_SUITE_P` for data-driven tests.
- Implement `SetUpTestSuite` for expensive shared resources.
- Use `TEST` for simple, independent tests.
- Avoid mixing `TEST` and `TEST_F` with the same suite name.
- Always call `RUN_ALL_TESTS()` once per program and return its value from `main()`.

## Troubleshooting Common Issues

- Compilation errors in fixtures usually relate to missing default constructors.
- Ensure the first test suite registered uses a unique fixture.
- Using underscores in names may cause unexpected behavior; avoid them.
- Tests not running? Check filters and disabled test settings.
- Fatal assertions cause immediate test abortion, but other tests continue executing.

## Additional Test Utilities

- `FRIEND_TEST` macro to allow tests access to private class members.
- `SCOPED_TRACE` macro to add context to failures in helper functions or loops.
- `GTEST_SKIP()` to skip tests at runtime with optional messages.
- `::testing::Test::RecordProperty()` for logging custom key/value information per test.

---

## Related Concepts and API

- [Assertions](../assertions.md) - Validating test expectations.
- [Parameterized and Typed Tests](../advanced.md#value-parameterized-tests) - Advanced test patterns.
- [Test Configuration and Execution](../getting-started/project-setup/configuration-options.md) - Command-line controls.
- [Global Test Environment](../advanced.md#global-set-up-and-tear-down) - For shared setup outside suites.

---

## Example: Registering and Running Tests

```cpp
// Define a fixture
class MyTestFixture : public testing::Test {
protected:
  void SetUp() override { /* ... */ }
  void TearDown() override { /* ... */ }
};

// Define tests using the fixture
TEST_F(MyTestFixture, DoesSomething) {
  EXPECT_TRUE(DoSomething());
}

TEST_F(MyTestFixture, DoesSomethingElse) {
  EXPECT_EQ(42, GetMeaningOfLife());
}

// main function
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This minimal example defines a fixture, two tests using it, and runs all registered tests.

---

## Diagram: Test Execution Flow

```mermaid
flowchart TD
  A[Start main()] --> B[Call InitGoogleTest()]
  B --> C[RUN_ALL_TESTS()]
  C --> D{For Each TestSuite}
  D --> E[Call SetUpTestSuite()]
  E --> F{For Each Test in Suite}
  F --> G[Create Test Fixture]
  G --> H[Call SetUp()]
  H --> I[Run TestBody()]
  I --> J[Call TearDown()]
  J --> K[Delete Fixture]
  K --> F
  F --> L[Call TearDownTestSuite()]
  L --> M[Next TestSuite]
  M --> N[Tests Completed]
  N --> O[Return test result]
```

---

## Summary

This page equips you with the foundational knowledge needed to declare and execute tests using GoogleTest's core API macros and classes, helping you build organized and maintainable test suites. From simple tests to advanced parameterized and typed tests, it covers naming conventions, lifecycle methods, dynamic registration, and execution control, ensuring your tests are discoverable, extensible, and efficient.

