---
title: "Test Macros and Assertions"
description: "Details all primary and advanced assertion macros (e.g., EXPECT_*, ASSERT_*) provided by GoogleTest, including their signatures, use cases, expected results, and sample code. Covers predicate assertions, fatal vs. non-fatal behavior, and assertion result objects."
---

# Test Macros and Assertions

GoogleTest provides a rich set of assertion macros designed to help you verify the correctness of your C++ code during testing. These macros allow you to check conditions, compare values, handle exceptions, and express complex testing logic with clear, actionable feedback. This document details the available assertion macros, their behaviors, usage patterns, and sample usages, enabling you to write expressive, maintainable tests.

---

## 1. Understanding Assertions in GoogleTest

Assertions are fundamental building blocks of test validation in GoogleTest. They come mainly in pairs:

- **`EXPECT_*` assertions**: Generate nonfatal failures on failure, allowing the test function to continue execution.
- **`ASSERT_*` assertions**: Generate fatal failures on failure, aborting the current test function immediately.

This distinction enables you to control the test flow precisely: use `EXPECT_*` when you want to see multiple failures in one test, and `ASSERT_*` when continuing after failure is meaningless or unsafe.

All assertions support streaming custom failure messages with the `<<` operator, thus enabling contextual diagnostics:

```cpp
EXPECT_TRUE(my_condition) << "Condition was expected to be true but wasn't.";
```

Anything streamable to `std::ostream` (e.g., strings, numbers, objects implementing `operator<<`) can be used.

---

## 2. Explicit Success and Failure Assertions

These macros allow you to explicitly mark success or failure, independent of value testing, useful for control flow scenarios.

### SUCCEED()

Indicates success at a given point. It is mainly documentary and currently does not produce user-visible output.

```cpp
SUCCEED();
```

### FAIL()

Generates a fatal failure and aborts the current function. Only usable in `void`-returning functions.

```cpp
FAIL() << "This code should not be reached.";
```

### ADD_FAILURE()

Generates a nonfatal failure, allowing the function to continue.

```cpp
ADD_FAILURE() << "A nonfatal failure occurred.";
```

### ADD_FAILURE_AT(file, line)

Generates a nonfatal failure at a specified file and line number.

```cpp
ADD_FAILURE_AT("myfile.cc", 123) << "Failure in specific location.";
```

---

## 3. Generalized Assertion with Matchers

The `EXPECT_THAT` family allows verification using rich, composable matchers from GoogleMock's matcher library.

```cpp
EXPECT_THAT(value, matcher);
ASSERT_THAT(value, matcher);
```

Matchers let you construct expressive, English-like assertions and provide detailed failure messages. Examples:

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
using ::testing::MatchesRegex;
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(value1, StartsWith("Hello"));
EXPECT_THAT(value2, MatchesRegex("Line \d+"));
ASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));
```

Matchers empower you to create precise expectations for container contents, strings, numeric ranges, and more.

---

## 4. Boolean Condition Assertions

Simplify checks for truth or falsehood.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Verifies *condition* is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Verifies *condition* is false.

Example:

```cpp
EXPECT_TRUE(is_valid) << "Expected is_valid to be true.";
ASSERT_FALSE(has_error) << "No errors expected.";
```

---

## 5. Binary Comparison Assertions

Check relational comparisons between two values.

### Core Macros

| Macro         | Description                               |
| ------------- | ----------------------------------------- |
| `EXPECT_EQ` / `ASSERT_EQ` | Checks equality (`==`). Pointer equality for pointers. For C-strings, use `EXPECT_STREQ` instead. |
| `EXPECT_NE` / `ASSERT_NE` | Checks inequality (`!=`). Pointer inequality for pointers. For C-strings, use `EXPECT_STRNE`. |
| `EXPECT_LT` / `ASSERT_LT` | Checks less than (`<`). |
| `EXPECT_LE` / `ASSERT_LE` | Checks less than or equal (`<=`). |
| `EXPECT_GT` / `ASSERT_GT` | Checks greater than (`>`). |
| `EXPECT_GE` / `ASSERT_GE` | Checks greater than or equal (`>=`). |

Example:

```cpp
EXPECT_EQ(actual_value, expected_value);
ASSERT_GT(count, 0) << "Count must be positive.";
```

### Pointer Comparisons and C-Strings

- Pointer comparisons (`EXPECT_EQ` on pointers) check address equality, not content.
- Use `EXPECT_STREQ` or `EXPECT_STRNE` for C-string *content* comparisons.
- When comparing pointers to `NULL`, prefer `nullptr`.

---

## 6. String Comparison Assertions

Specialized macros for C-string (including wide string) content comparison:

| Macro                 | Behavior                                  |
|-----------------------|------------------------------------------|
| `EXPECT_STREQ` / `ASSERT_STREQ` | Compares C strings for equality by content. |
| `EXPECT_STRNE` / `ASSERT_STRNE` | Compares C strings for inequality by content. |
| `EXPECT_STRCASEEQ` / `ASSERT_STRCASEEQ` | Compares C strings for equality, ignoring case. |
| `EXPECT_STRCASENE` / `ASSERT_STRCASENE` | Compares C strings for inequality, ignoring case. |

Example:

```cpp
const char* actual = "Hello";
EXPECT_STREQ(actual, "Hello");
EXPECT_STRCASEEQ(actual, "hello");
```

Wide strings (`wchar_t*`) are supported similarly. Failed comparisons print UTF-8 representations.

---

## 7. Floating-Point Comparisons

Due to rounding errors, floating-point values require specialized macros:

| Macro                 | Behavior                                  |
|-----------------------|------------------------------------------|
| `EXPECT_FLOAT_EQ` / `ASSERT_FLOAT_EQ` | Approximately equal `float`s within 4 ULPs. |
| `EXPECT_DOUBLE_EQ` / `ASSERT_DOUBLE_EQ` | Approximately equal `double`s within 4 ULPs. |
| `EXPECT_NEAR` / `ASSERT_NEAR` (val1, val2, abs_error) | Verifies the absolute difference is within `abs_error`.

Example:

```cpp
EXPECT_FLOAT_EQ(calculated, expected);
ASSERT_NEAR(calculated, expected, 0.001);
```

Edge cases like infinity and NaN are handled correctly.

---

## 8. Exception Assertions

Use these macros if exceptions are enabled in your build.

| Macro                    | Verifies                                   |
|--------------------------|---------------------------------------------|
| `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW` | statement throws an exception of the given type. |
| `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW` | statement throws an exception of any type. |
| `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW` | statement does not throw any exceptions. |

Example:

```cpp
EXPECT_THROW(SomeFunction(), std::runtime_error);
EXPECT_NO_THROW(SafeFunction());
```

The `statement` can be a compound block `{ ... }`.

---

## 9. Predicate Assertions

Predicate assertions allow you to use complex predicates while receiving detailed failure messages. They come in two varieties:

### 9.1 Expect/Assert Predicate Macros

- `EXPECT_PRED1(pred, val1)` ... up to `EXPECT_PRED5`
- `ASSERT_PRED1(pred, val1)` ... up to `ASSERT_PRED5`

The *pred* is a Boolean function or functor accepting the given number of parameters.

Example:

```cpp
bool IsPrime(int n) { ... }
EXPECT_PRED1(IsPrime, 7);
```

### 9.2 Predicate-Formatter Assertions

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)` ... up to `EXPECT_PRED_FORMAT5`
- `ASSERT_PRED_FORMAT1(pred_formatter, val1)` ... up to `ASSERT_PRED_FORMAT5`

The `pred_formatter` returns a `testing::AssertionResult` that can produce customized failure messages.

Example:

```cpp
testing::AssertionResult IsPositive(const char* expr, int val) {
  if (val > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " is not positive";
}

EXPECT_PRED_FORMAT1(IsPositive, x);
```

---

## 10. HRESULT Assertions (Windows Only)

Macros to check `HRESULT` success or failure:

| Macro                           | Behavior                               |
|---------------------------------|----------------------------------------|
| `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED` | Asserts `expr` is a success `HRESULT`.
| `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED` | Asserts `expr` is a failure `HRESULT`.

Example:

```cpp
EXPECT_HRESULT_SUCCEEDED(CoCreateInstance(...));
```

---

## 11. Death Assertions

Verify that code causes the process to terminate as expected.

| Macro                                      | Description                                        |
|--------------------------------------------|---------------------------------------------------|
| `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH` | Verifies `statement` causes process termination with `stderr` matching `matcher`. |
| `EXPECT_DEATH_IF_SUPPORTED(statement, matcher)` / `ASSERT_DEATH_IF_SUPPORTED` | Runs death test if supported, otherwise no-op. |
| `EXPECT_DEBUG_DEATH(statement, matcher)` / `ASSERT_DEBUG_DEATH` | Death test running only in debug mode, else runs `statement` normally. |
| `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT` | Verifies `statement` exits with status satisfying `predicate` and `stderr` matches `matcher`.

Example:

```cpp
EXPECT_DEATH(AbortFunction(), "Segmentation fault");
EXPECTED_EXIT(ExitFunction(), testing::ExitedWithCode(0), "Success");
```

Death tests are typically run in a separate process to isolate the tested crash.

---

## 12. Best Practices & Common Pitfalls

- Use `EXPECT_*` macros preferentially unless test continuation on failure is unsafe.
- Use custom failure messages with the streaming operator for clarity.
- For floating-point comparisons, prefer `EXPECT_FLOAT_EQ` or `EXPECT_NEAR`.
- Use matchers via `EXPECT_THAT` for expressive and maintainable assertions.
- Avoid over-specifying expectations that can make tests brittle.
- When writing death tests, separate test suites with `*DeathTest` suffix.
- Use `ASSERT_*` macros within void-returning functions to avoid compiler errors.
- For complex predicates, consider predicate-formatters for better failure diagnostics.

---

## 13. Examples

### 13.1 Basic Equality Assertion

```cpp
EXPECT_EQ(actual_value, expected_value);
```

### 13.2 Boolean Condition with Custom Message

```cpp
EXPECT_TRUE(is_valid_condition) << "Condition must be true for correctness.";
```

### 13.3 Using EXPECT_THAT with Matcher

```cpp
#include <gmock/gmock.h>

EXPECT_THAT(my_string, testing::StartsWith("Hello"));
```

### 13.4 Floating-Point Approximate Equality

```cpp
EXPECT_NEAR(calculated_result, expected_result, 0.01);
```

### 13.5 Exception Checking

```cpp
EXPECT_THROW(FunctionThatThrows(), std::runtime_error);
EXPECT_NO_THROW(SafeFunction());
```

### 13.6 Death Test

```cpp
EXPECT_DEATH({ CauseCrash(); }, "Expected crash message regex");
```

### 13.7 Predicate Assertion

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, number);
```

### 13.8 Predicate-Formatter Assertion

```cpp
testing::AssertionResult IsPositive(const char* expr, int value) {
  if (value > 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " evaluates to " << value << ", which is not positive.";
}
EXPECT_PRED_FORMAT1(IsPositive, x);
```

---

## 14. Additional Resources

- [GoogleTest Assertions Reference](reference/assertions.md)
- [Matchers Reference](reference/matchers.md)
- [Advanced Assertions and Matchers Guide](guides/core-testing-workflows/advanced-assertions-and-matchers.md)
- [Death Tests](reference/gtest-core-api/death-tests.md)
- [Predicate Assertions](reference/assertions.md#predicates)

---

This documentation equips you with the declarative macros and techniques to verify complex program behaviors rigorously and obtain clear feedback to accelerate your C++ testing workflow.

<Source url="https://github.com/google/googletest" paths={[{"path": "docs/reference/assertions.md", "range": "1-345"}]} />
