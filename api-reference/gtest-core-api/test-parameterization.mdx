---
title: "Value and Type Parameterized Tests"
description: "Explains how to define and execute value- and type-parameterized tests to maximize coverage. Includes code snippets to demonstrate usage for common C++ testing scenarios."
---

# Value and Type Parameterized Tests

GoogleTest enhances your testing capabilities by allowing the creation of value- and type-parameterized tests. These specialized test types enable you to write more concise, maintainable tests that cover a wider range of scenarios without duplicating code. This page guides you through defining and executing parameterized tests with practical examples tailored for typical C++ development.

---

## Introduction to Parameterized Tests

Instead of writing separate tests for each input value or type, parameterized tests let you run the same test logic across multiple inputs. This improves coverage, reduces boilerplate, and clearly communicates your intent to test variations.

GoogleTest supports two main forms:

- **Value-Parameterized Tests:** The test logic uses a single parameter variable that takes on different values.
- **Type-Parameterized Tests:** The test logic is templated on a type, allowing you to test algorithms or classes for multiple data types systematically.

---

## Value-Parameterized Tests

### Defining a Value-Parameterized Test

Start by defining a test fixture that inherits from `::testing::TestWithParam<T>`, where `T` is the parameter type. Inside the test body, access the current parameter with `GetParam()`.

```cpp
#include <gtest/gtest.h>

class MyIntTest : public ::testing::TestWithParam<int> {};

TEST_P(MyIntTest, IsEven) {
  int n = GetParam();
  EXPECT_TRUE(n % 2 == 0);
}
```

Here, the test `IsEven` will run for different integers specified later.

### Instantiating a Value-Parameterized Test Suite

Use the `INSTANTIATE_TEST_SUITE_P` macro to bind the test parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(EvenNumbers, MyIntTest, ::testing::Values(2, 4, 6, 8));
```

This instantiates `MyIntTest` with the integer values 2, 4, 6, and 8. The test will run once for each of these.

#### Parameter Generators

GoogleTest offers multiple parameter generators to flexibly express inputs:

| Generator               | Description                                                                                  |
|-------------------------|----------------------------------------------------------------------------------------------|
| `Range(begin, end[, step])` | Generates values from `begin` up to but not including `end`, with the optional `step`.      |
| `Values(v1, v2, ..., vN)`   | Enumerates explicit values.                                                                |
| `ValuesIn(container)`        | Uses values from a container or iterator range.                                            |
| `Bool()`                    | Generates `false` and `true`.                                                             |
| `Combine(g1, g2, ..., gN)`  | Generates Cartesian product of other generators to create tuples of parameters.             |
| `ConvertGenerator<T>(g)`    | Converts values generated by `g` into type `T` using static cast or a conversion function. |

Example combining multiple parameters:

```cpp
INSTANTIATE_TEST_SUITE_P(
  MyCombinations, MyTest,
  ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

### Customizing Test Case Names

To make test outputs clearer, you can supply a custom naming function to generate user-friendly test suffixes. The function receives a `TestParamInfo<T>` with `.param` and `.index` members:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedInst, MyTest, ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

### Using Parameters in Tests

Within your `TEST_P` you typically use `GetParam()` to access the current value. This allows parameter-dependent assertions or test logic:

```cpp
TEST_P(MyIntTest, DivisibleBy) {
  int divisor = GetParam();
  EXPECT_EQ(0, 10 % divisor);
}
```

### Allowing Uninstantiated Parameterized Tests

By default, GoogleTest requires every parameterized test to be instantiated or it will emit a failure. Use the macro `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName)` to suppress this if you have valid cases where no instantiations are generated.

---

## Type-Parameterized Tests

Type-parameterized tests allow running test logic across multiple types. This is especially useful for container tests or generic algorithms.

### Defining a Typed Test Suite

Create a class template that inherits from `::testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_{};
};
```

Declare the types to test with a typedef or `using` as a GoogleTest `Types` list:

```cpp
using MyTypes = ::testing::Types<int, float, double>;
```

Then associate the types with the test suite:

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Writing Typed Tests

Inside the test, use the special typename `TypeParam` to refer to the current type:

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam n = this->value_;
  EXPECT_EQ(n, TypeParam{});
}
```

### Type-Parameterized Test Suites with Registration

When the tests need to be registered before instantiation (for example, to separate definition and instantiation), use the `TYPED_TEST_SUITE_P` and `REGISTER_TYPED_TEST_SUITE_P` macros. You then instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

Example:

```cpp
// Define typed tests
TYPED_TEST_SUITE_P(MyFixture);
TYPED_TEST_P(MyFixture, Test1) { ... }
TYPED_TEST_P(MyFixture, Test2) { ... }

// Register tests
REGISTER_TYPED_TEST_SUITE_P(MyFixture, Test1, Test2);

// Instantiate for specific types
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyFixture, MyTypes);
```

---

## Best Practices

- Use parameterized tests to reduce duplication and increase test coverage efficiently.
- Name your tests and test suites clearly to reflect parameterization.
- Use custom name generators when the default parameter output is not descriptive enough.
- Avoid over-parameterization; keep your parameter lists focused and meaningful.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if you have valid reasons for not instantiating some parameterized tests.

---

## Troubleshooting and Tips

- Remember that parameters passed can be complex types; ensure proper type conversions if needed using `ConvertGenerator`.
- Avoid dangling references in name generators or parameter generators when passing temporary objects.
- When using typed tests, ensure your types correctly fulfill any assumptions or requirements used in the test logic.
- If tests don't run as expected, verify that instantiations are correctly provided and macros are used in the proper order.

---

## Additional References

For deeper understanding of parameterized tests and their advanced usage, consider reviewing:

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests)
- [Typed Tests](../advanced.md#typed-tests)
- [GoogleTest Primer](../primer.md)

Practical coding examples are also available in the [guides on Parameterized and Type-Parameterized Tests](/guides/real_world_patterns_advanced/parameterized_and_typed_tests).

---

For source browsing and contributions, see the main repository here:

[GoogleTest on GitHub](https://github.com/google/googletest)

