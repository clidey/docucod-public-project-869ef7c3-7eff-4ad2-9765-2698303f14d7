---
title: "Test Structure and Macros"
description: "Covers fundamental macros and patterns for writing test cases and test suites. Explains TEST, TEST_F, and typed test macros, outlining usage patterns, best practices, and customization for complex projects. Includes typical workflows and edge-case handling."
---

# Test Structure and Macros

GoogleTest provides powerful macros and structures to help you write robust, expressive, and maintainable unit tests in C++. This documentation covers the fundamental macros for defining test cases and test suites, describes their usage patterns, offers best practices for writing tests, and explores customization options for complex projects.

---

## 1. Understanding the Test Macro Basics

### `TEST(TestSuiteName, TestName)`

The simplest way to declare a test in GoogleTest is using the `TEST()` macro. It defines a new test function named `TestSuiteName.TestName` which will be run within the framework.

- Defines a standalone test without any shared setup or teardown.
- Must be placed in the global scope (outside any class).
- The test function has no parameters and returns void.

Example:
```cpp
TEST(MathTests, AdditionWorks) {
  int sum = 2 + 2;
  EXPECT_EQ(sum, 4);
}
```

### Naming Conventions

- `TestSuiteName` groups related tests. Avoid collisions by using descriptive names.
- `TestName` describes a specific test case or scenario.

### When To Use

- Use `TEST()` for simple, independent test cases.
- Prefer this when no common fixture or state sharing is needed.


## 2. Using Test Fixtures with `TEST_F`

Frequently, tests share common setup or teardown code. GoogleTest provides **test fixtures** to support this pattern.

### Declaring a Fixture

Define a class deriving from `testing::Test`:
```cpp
class MyFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Code here is run before each test
  }

  void TearDown() override {
    // Code here is run after each test
  }

  // Data members accessible from all tests in this fixture
  int shared_resource_;
};
```

### Writing Tests Using the Fixture

Use the `TEST_F()` macro to write tests that utilize the fixture:
```cpp
TEST_F(MyFixture, BehaviorUnderTest) {
  shared_resource_ = 42;
  EXPECT_EQ(shared_resource_, 42);
}
```

### Benefits

- Eliminates duplication of setup/teardown code.
- Provides shared test state safely.
- Supports access to fixture members within each test.

### Usage Guidelines

- Use `TEST_F` only with fixtures derived from `testing::Test`.
- Avoid side effects that leak state across tests.


## 3. Typed Tests: Parameterizing Test Suites with Types

For testing template classes or type-specific behavior, GoogleTest supports **typed tests** using `TYPED_TEST_SUITE` and `TYPED_TEST` macros.

### Declaring the Typed Test Suite

```cpp
template <typename T>
class TypedFixture : public ::testing::Test {
 public:
  T value_;
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(TypedFixture, MyTypes);
```

### Writing Typed Tests

```cpp
TYPED_TEST(TypedFixture, IsDefaultConstructible) {
  TypeParam value{};
  (void)value;  // Silence unused variable warnings
  SUCCEED();   // Test passes if compilation succeeds
}
```

### Key Points

- `TypeParam` is a typedef for the current type.
- All typed tests share the same fixture template.
- Test names appear as `<TestSuiteName>/<TestName>/0`, `/1`, etc. reflecting type indexing.


## 4. Type-Parameterized Tests with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`

For defining test patterns to be instantiated explicitly with multiple types later.

### Defining the Type-Parameterized Test Suite

```cpp
template <typename T> class MyTypePattern : public ::testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyTypePattern);

TYPED_TEST_P(MyTypePattern, TestName) {
  // Use 'TypeParam' inside
}

REGISTER_TYPED_TEST_SUITE_P(MyTypePattern, TestName /*, other tests */);
```

### Instantiating With Specific Types

```cpp
using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypePattern, MyTypes);
```


## 5. Best Practices for Test Naming and Structure

- Prefer descriptive test suite and test names that communicate intent.
- Use test fixtures (`TEST_F`) for related tests sharing setup/teardown.
- Parameterize test suites (`TYPED_TEST`, `TYPED_TEST_P`) to avoid duplication.
- Keep individual tests focused and small for clarity and maintenance.
- Avoid dependencies or side-effects between tests.


## 6. Handling Edge Cases and Advanced Patterns

### Omitting Argument Lists in `EXPECT_CALL` for Non-Overloaded Methods

You can omit parentheses when using `EXPECT_CALL` for methods without overloads, simplifying expectation declarations:
```cpp
EXPECT_CALL(mock_obj, MethodName).Times(2);
```

### Resolving Method Overloads

Use wrappers such as `Const()` or explicit casting to clarify which overloaded method you intend to mock:
```cpp
EXPECT_CALL(Const(mock_obj), OverloadedMethod(5));
```

### Mocking Private or Protected Members

Mock methods must be declared `public` to `EXPECT_CALL` and `ON_CALL` them even if the original methods are private or protected.

### Customizing Test Run Ordering

Use `InSequence` or explicit `Sequence` objects with `EXPECT_CALL` to enforce call orders.


## 7. Common Workflows Using Test Macros

<Steps>
  <Step title="Write Your Test Suite">
    Build a test suite using `TEST()` or `TEST_F()` by defining test cases relevant to your code.
  </Step>
  <Step title="Setup Fixtures for Shared State">
    Define fixtures derived from `testing::Test` and use `TEST_F` when tests need shared setup/teardown.
  </Step>
  <Step title="Run Tests and Verify Behavior">
    Build and run your tests using your test runner. GoogleTest will manage the execution and reporting.
  </Step>
  <Step title="Refactor Using Typed Tests for Templates">
    Use typed tests when testing template classes or multiple types with the same behavior.
  </Step>
</Steps>


## 8. Troubleshooting and Tips

<AccordionGroup title="Troubleshooting Test Macro Issues">
  <Accordion title="Compilation Errors with MOCK_METHOD or EXPECT_CALL">
    Ensure macros are placed correctly, method signatures align, and required headers are included.
  </Accordion>
  <Accordion title="Ambiguous Method Overloads">
    Use `Const()` or explicit casting to resolve overloaded method ambiguities.
  </Accordion>
  <Accordion title="Test Fixture Crashes or Unexpected Behavior">
    Check that the fixture correctly initializes members and does not leak between tests.
  </Accordion>
</AccordionGroup>

<Tip>
  Remember to construct expectations before exercising mock objects. Setting expectations afterwards leads to undefined behavior.
</Tip>


## 9. Related Macros and Extensions

- `EXPECT_CALL` — for setting call expectations on mocks.
- `ON_CALL` — for setting default mock behaviors without expectations.
- `MOCK_METHOD` — for declaring mock methods inside mock classes.
- `INSTANTIATE_TYPED_TEST_SUITE_P` — for instantiating typed test suites.


## 10. Example: Using Various Test Macros in Practice

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::Test;
using ::testing::TYPED_TEST_SUITE;

// Simple test
TEST(MathTest, SimpleAdd) {
  EXPECT_EQ(2 + 2, 4);
}

// Test fixture
class MyFixture : public Test {
 protected:
  void SetUp() override { shared_value_ = 10; }
  int shared_value_;
};

TEST_F(MyFixture, UsesSharedValue) {
  EXPECT_EQ(shared_value_, 10);
}

// Typed test
template <typename T>
class TypedTest : public Test {
 public:
  T value;
};

using MyTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(TypedTest, MyTypes);

TYPED_TEST(TypedTest, IsDefaultZero) {
  TypeParam zero{};
  EXPECT_EQ(zero, 0);
}
```

---

Additional details for working with mocks, matchers, and expectations can be found in the [Mocking Reference](reference/mocking.md), [gMock for Dummies](docs/gmock_for_dummies.md), and [gMock Cookbook](docs/gmock_cook_book.md).


---

<Source url="https://github.com/google/googletest" paths='[{"path": "docs/reference/mocking.md", "range": "1-483"}]' />