---
title: "Test Cases and Suites API"
description: "Explains the macros and facilities for defining, registering, and organizing test cases and test suites, including type- and value-parameterized tests. Describes suite lifecycle, fixtures, and how users can instantiate test variants."
---

# Test Cases and Suites API

GoogleTest provides comprehensive macros and APIs to define, register, and organize your tests into coherent groups called test suites. This page details the facilities available for creating simple tests, fixture-based tests, parameterized tests (both value- and type-parameterized), and managing their lifecycle within test suites. It also explains how to instantiate parameterized test variants and handle suite-level setup and teardown efficiently.

---

## Overview of Test Suites and Test Cases

In GoogleTest, a **test suite** groups related tests logically, facilitating organization and reporting. Each **test** (historically called test case in GoogleTest) exercises a particular path of your code and verifies expected behavior.

- The **TEST()** macro defines a single test belonging to a test suite.
- The **TEST_F()** macro defines a test that shares a common fixture with others in the suite.
- Parameterized tests extend this by allowing tests to accept input parameters and run multiple variants automatically.

> **Note:** GoogleTest prefers the term *Test Suite* over *Test Case* following modern standards and is progressively deprecating the older nomenclature.

## Defining Simple Tests with `TEST`

Define individual tests directly in a suite using `TEST(test_suite_name, test_name)`.

Example:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(3), 6);
}
```

Here, `FactorialTest` is the test suite name shared by both tests.

### Workflow

1. Define test logic inside the macro body.
2. Use assertions (`EXPECT_`, `ASSERT_`) to verify conditions.
3. GoogleTest registers tests automatically; no manual enumeration needed.

## Using Fixtures with `TEST_F`

When tests share common setup, teardown, or data, define a fixture class derived from `testing::Test`. The `TEST_F(fixture_name, test_name)` macro will then create tests using that fixture.

Example:

```cpp
class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    q_.Enqueue(1);
  }

  Queue<int> q_;
};

TEST_F(QueueTest, DequeueReturnsEnqueuedItem) {
  int* item = q_.Dequeue();
  ASSERT_NE(item, nullptr);
  EXPECT_EQ(*item, 1);
  delete item;
}
```

GoogleTest ensures a fresh fixture instance per test, thus isolation is guaranteed.

### Fixture Lifecycle

- `SetUpTestSuite()` / `TearDownTestSuite()`: run once per suite before and after all tests.
- `SetUp()` / `TearDown()`: run before and after each individual test.

## Value-Parameterized Tests with `TEST_P` and `INSTANTIATE_TEST_SUITE_P`

Value-parameterized tests enable running the same test with varying input data, ideal for data-driven testing.

### Writing a Parameterized Test

1. Define a class derived from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class MyTest : public testing::TestWithParam<int> {};
```

2. Write tests with `TEST_P` instead of `TEST_F`, and access the parameter via `GetParam()`:

```cpp
TEST_P(MyTest, IsEven) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}
```

3. Instantiate test variants supplying parameters with `INSTANTIATE_TEST_SUITE_P`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    EvenNumbers, MyTest, testing::Values(2, 4, 6, 8));
```

This generates tests named like `EvenNumbers/MyTest.IsEven/0`, `.../1` etc.

### Parameter Generators

GoogleTest provides several parameter generators for convenience:

| Generator           | Produces                                           |
|---------------------|----------------------------------------------------|
| `Range(begin, end)`  | Integers from `begin` up to but not including `end`|
| `Values(...)`       | The listed values                                  |
| `ValuesIn(container)`| Values from container or iterators                 |
| `Bool()`            | `false` and `true`                                 |
| `Combine(...)`      | Cartesian product of multiple generators           |
| `ConvertGenerator`  | Converts generated values with a callable or cast |


### Allowing Uninstantiated Parameterized Tests

If `TEST_P` is declared without instantiation, GoogleTest flags an error unless suppressed:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTest);
```

## Type-Parameterized Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`

Type-parameterized tests allow writing tests that run over multiple types.

### Writing Typed Tests

1. Define a class template fixture derived from `testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```

2. Define the types to test using `testing::Types`:

```cpp
using MyTypes = testing::Types<int, double, char>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write typed tests using `TYPED_TEST`:

```cpp
TYPED_TEST(MyTypedTest, DoesSomething) {
  TypeParam val = this->value_;
  EXPECT_TRUE(SomeTrait<TypeParam>::Check(val));
}
```

Tests run once per type in the list.

## Type-Parameterized Tests with `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`

For reusable abstract test patterns that can be instantiated with any list of types later.

### Steps:

1. Define the typed test suite and tests with `_P` macros.

```cpp
TYPED_TEST_SUITE_P(MyTypedTest);
TYPED_TEST_P(MyTypedTest, Test1) {
  ...
}
```

2. Register all test names:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypedTest, Test1, Test2);
```

3. Instantiate with types:

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTypedTest, MyTypes);
```

## Registering Tests Programmatically

In advanced cases where `TEST` macros are insufficient, use `testing::RegisterTest`:

```cpp
TestInfo* RegisterTest(
    const char* suite_name,
    const char* test_name,
    const char* type_param,
    const char* value_param,
    const char* file,
    int line,
    Factory factory);
```

The `factory` is a callable that returns a new test fixture pointer. Must be invoked before `RUN_ALL_TESTS()`.

### Example:

```cpp
class MyFixture : public testing::Test {
 public:
  static void SetUpTestSuite() { /* ... */ }
  static void TearDownTestSuite() { /* ... */ }
};

class MyTest : public MyFixture {
 public:
  explicit MyTest(int data) : data_(data) {}
  void TestBody() override { /* ... */ }
 private:
  int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
        "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr,
        std::to_string(v).c_str(), __FILE__, __LINE__,
        [=]() -> MyFixture* { return new MyTest(v); });
  }
}
```

## Test Suite Lifecycle

GoogleTest manages test suite lifecycle to optimize resource usage and enforce isolation.

- `SetUpTestSuite()`: called once before running the first test in the suite.
- `TearDownTestSuite()`: called once after running the last test in the suite.

These are static methods implemented in your fixture class and are ideal for expensive shared resource initialization or cleanup.

## Recording Test Properties

You can log arbitrary key-value properties to tests or suites by calling:

```cpp
testing::Test::RecordProperty("Key", "Value");
```

Properties recorded during a test appear in XML output as attributes of the `<testcase>` element. When recorded in `SetUpTestSuite` or `TearDownTestSuite`, they appear under the `<testsuite>` element.

## Best Practices and Tips

- **Test isolation**: Define a fresh fixture for each test to prevent state bleed.
- **Naming conventions**: Avoid underscores in suite or test names for better tooling compatibility.
- **Parameter generators**: Use built-in generators to reduce boilerplate and errors.
- **Instantiations**: Always instantiate all parameterized tests to avoid silent test omissions, or explicitly mark with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- **Per-suite setup**: Use `SetUpTestSuite`/`TearDownTestSuite` for expensive shared fixtures.

## Troubleshooting Common Issues

- **Compiler errors with `TEST_F`**: Ensure the fixture class is fully defined before using `TEST_F` or you may get errors like `virtual outside class declaration`.
- **Failure to run parameterized tests**: Check that all `TEST_P` tests are instantiated via `INSTANTIATE_TEST_SUITE_P` or suppressed.
- **Side effects in parameters**: Parameters must remain valid for the entire scope of the test.

## Summary of Key Macros and Classes

| Macro/Type                               | Purpose                                  |
|-----------------------------------------|------------------------------------------|
| `TEST(suite, test)`                     | Define a simple test                      |
| `TEST_F(fixture, test)`                 | Define a test using a fixture             |
| `TEST_P(fixture, test)`                 | Define a value-parameterized test         |
| `INSTANTIATE_TEST_SUITE_P(name, fixture, generator)` | Instantiate parameterized test variants |
| `TYPED_TEST_SUITE(fixture, types)`     | Define typed test suite                    |
| `TYPED_TEST(fixture, test)`             | Define typed test                         |
| `TYPED_TEST_SUITE_P(fixture)`           | Define type-parameterized (abstract) suite|
| `TYPED_TEST_P(fixture, test)`           | Define type-parameterized test            |
| `REGISTER_TYPED_TEST_SUITE_P(fixture, tests...)` | Register tests for type-parameterized suite|
| `INSTANTIATE_TYPED_TEST_SUITE_P(name, fixture, types)` | Instantiate type-parameterized suite|

---

## Diagram: Test Suite and Test Structure

```mermaid
graph TD
  UnitTest["UnitTest Singleton"] --> TestSuiteList["TestSuites List"]
  subgraph TestSuite
    direction TB
    classDef testSuite fill:#cff,stroke:#036,stroke-width:1px;
    TestSuiteObj1["TestSuite 'FactorialTest'"]:::testSuite
    TestSuiteObj2["TestSuite 'QueueTest'"]:::testSuite
  end

  TestSuiteList --> TestSuiteObj1
  TestSuiteList --> TestSuiteObj2

  subgraph Tests_in_Factorial
    direction TB
    Test1["Test: HandlesZeroInput"]
    Test2["Test: HandlesPositiveInput"]
  end

  subgraph Tests_in_Queue
    direction TB
    Test3["Test_F: IsEmptyInitially"]
    Test4["Test_F: DequeueWorks"]
  end

  TestSuiteObj1 --> Tests_in_Factorial
  TestSuiteObj2 --> Tests_in_Queue

  note right of Test4
    Each TEST_F gets fresh
    fixture instance.
  end

  click UnitTest "googletest/include/gtest/gtest.h" "UnitTest class and singleton management"
  click TestSuiteObj1 "googletest/include/gtest/gtest.h" "TestSuite class"
  click TestSuiteObj2 "googletest/include/gtest/gtest.h" "TestSuite management"
  click Test1 "googletest/include/gtest/gtest.h" "TEST macro and TestInfo"
  click Test4 "googletest/include/gtest/gtest.h" "TEST_F macro details"
```

---

## Additional Resources

- [GoogleTest Primer](primer.md) — Learn basic test writing and core concepts.
- [Value-Parameterized Tests Guide](../guides/advanced-testing-patterns/parameterized-tests.md) — Deep dive on parameterized tests.
- [Typed Tests Guide](../guides/advanced-testing-patterns/parameterized-tests.md#typed-tests) — Details on typed and type-parameterized tests.
- [Advanced Testing Patterns](advanced.md) — Broader advanced usage including fixture sharing and suites.
- [Testing Reference](reference/testing.md) — API reference for all test macros, classes, and helpers.

---

This documentation helps you structure your tests into suites, reuse fixtures, and expand testing coverage with parameterized mechanisms, ensuring your code is robust and maintainable.