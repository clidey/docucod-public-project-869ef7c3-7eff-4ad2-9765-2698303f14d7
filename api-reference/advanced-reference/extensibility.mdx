---
title: "Extending Assertions and Matchers"
description: "Explains APIs and best practices for adding custom assertion results, extending the matcher framework, and integrating domain-specific checks into the GoogleTest/GoogleMock ecosystem for advanced test coverage."
---

# Extending Assertions and Matchers

This page details how you can expand the capabilities of GoogleTest and GoogleMock by adding custom assertion results, creating new matchers, and integrating domain-specific checks into the existing matcher framework. Leveraging these APIs and best practices enables you to achieve advanced test coverage tailored to your unique application needs.

---

## Introduction

GoogleTest and GoogleMock’s matcher framework is powerful and versatile. Yet, there are scenarios where the built-in assertions and matchers do not suffice, especially when working with domain-specific data or complex validation logic. This page guides you through extending the assertions and matchers to align with your testing goals.

By following these APIs and recommendations, you gain:

- The ability to add detailed, meaningful assertion results that improve test feedback.
- The power to craft expressive, reusable, and composable matchers fitting your domain logic.
- Seamless integration of your extensions with GoogleTest/GoogleMock, preserving uniform test semantics and error reporting.

---

## Framework Overview

The matcher framework in GoogleTest allows matchers to express complex conditions on arguments, and assertions to report nuanced pass/failure status. At the core, matchers evaluate whether a value meets their criteria, provide descriptions, and explain match failures to users.

Two primary extension points exist:

1. **Custom Assertion Results:** You can generate detailed test assertion outcomes using `AssertionResult` objects. These carry both pass/fail status and rich messages.

2. **Custom Matchers:** By implementing matchers via provided macros or interfaces, your matchers participate naturally in expectation expressions (`EXPECT_CALL`), assertions (`EXPECT_THAT`), and error reporting.

---

## Adding Custom Assertion Results

GoogleTest uses `::testing::AssertionResult` to represent the outcome of an assertion.

### Creating `AssertionResult` Objects

An `AssertionResult` encapsulates whether an expectation passed or failed along with an optional detailed message.

Use the following API:

- `AssertionSuccess()` creates a passing assertion result.
- `AssertionFailure()` creates a failing assertion result.

Example:

```cpp
// Custom function that returns a detailed assertion result.
AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return AssertionSuccess();
  } else {
    return AssertionFailure() << n << " is odd, expected even.";
  }
}

// Usage in a test.
EXPECT_TRUE(IsEven(4));  // Passes silently.
EXPECT_TRUE(IsEven(5));  // Fails with message '5 is odd, expected even.'
```

### Practical Tips
- Embed rich explanations in failure messages to help diagnose issues.
- Return `AssertionSuccess()` to indicate the check passed.
- Use streaming syntax `<<` with `AssertionFailure()` to append descriptive messages incrementally.

---

## Extending the Matcher Framework

Match a value against a custom condition by defining a matcher. GoogleTest offers two streamlined methods to create matchers:

### 1. Using the `MATCHER` and `MATCHER_P` Macros

These macros simplify writing custom matchers.

- **`MATCHER(name, description)`**: Defines a matcher with no parameters.
- **`MATCHER_P(name, param, description)`**: Defines a parameterized matcher.

Example:

```cpp
MATCHER(IsEven, "is an even number") {
  return (arg % 2) == 0;
}

MATCHER_P(IsDivisibleBy, divisor, "is divisible by given divisor") {
  return (arg % divisor) == 0;
}

// Usage in tests:
EXPECT_THAT(4, IsEven());
EXPECT_THAT(10, IsDivisibleBy(5));
```

The string parameter gives a description used in test failure messages. Use streaming syntax for enhanced explanations.

### 2. Implementing Matcher Classes Directly

For more control or polymorphic matchers, define a matcher class exposing:

- A `bool MatchAndExplain(const T& value, std::ostream* os) const` method.
- `void DescribeTo(std::ostream* os) const` for describing matching criteria.
- `void DescribeNegationTo(std::ostream* os) const` for negated descriptions.

Wrap your class in a factory function returning `Matcher<T>`.

Example:

```cpp
class IsEvenMatcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    if ((n % 2) == 0) return true;
    if (os != nullptr) *os << "which is odd";
    return false;
  }

  void DescribeTo(std::ostream* os) const { *os << "is even"; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is odd"; }
};

inline Matcher<int> IsEven() {
  return MakeMatcher(new IsEvenMatcher());
}

// Usage
EXPECT_THAT(5, IsEven());  // Fails with detailed message.
```

### Matcher Composition

Custom matchers integrate seamlessly with built-in matchers. They support combinators like `AllOf()`, `AnyOf()`, and `Not()`.

```cpp
EXPECT_THAT(value, AllOf(IsEven(), Gt(10)));
```

### Important Considerations
- Matchers must be pure functions without side effects.
- Descriptions should be readable and useful for debugging.
- Support polymorphism when the matcher should work with multiple types.
- For parameterized matchers, adequately describe parameters in the failure messages.

---

## Integrating Domain-Specific Checks

Your domain may demand assertions or matcher logic unique to your application, such as verifying complex data structures, business rules, or proprietary protocols.

### Strategy

1. **Define Clear Criteria:** Determine the precise property or invariant you want to verify.
2. **Choose Extension Point:** Small checks can use `AssertionResult`, more reusable complex checks should be implemented as matchers.
3. **Provide Descriptive Diagnostics:** Your matcher/ assertion should help a user quickly localize the test failure cause.
4. **Keep Interfaces Simple:** Avoid overly detailed or noisy checks. Keep failure messages concise but informative.

### Example: Custom Matcher for a Domain Object

```cpp
class Widget {
 public:
  int id() const;
  std::string name() const;
  bool IsValid() const;
};

MATCHER_P(ValidWidgetWithName, expected_name, "valid widget with name") {
  return arg.IsValid() && arg.name() == expected_name;
}

// Usage
EXPECT_THAT(widget, ValidWidgetWithName("foo"));
```

This example checks for widget validity plus a name match, providing a clear expression of intent.

---

## Best Practices

- **Start simple:** Use built-in assertions and matchers when they suffice.
- **Leverage expressive failure messages:** Users rely on these for quick diagnosis.
- **Test your matchers:** Write tests verifying that your custom assertions and matchers behave correctly for matching & mismatching cases.
- **Avoid side-effects:** Matchers may be called multiple times internally — side effects cause undefined behavior.
- **Use parameterized matchers for flexibility:** Helps reuse logic with different expected values.
- **Chain matchers and assertions where possible:** Create expressive and maintainable tests.

---

## Troubleshooting

### Test Assertion Does Not Provide Useful Feedback

- Enhance your matcher or assertion with detailed `DescribeTo` and diagnostic messages.
- Use streaming in `AssertionFailure()` to provide context.

### Custom Matcher Fails to Compile or Works Unexpectedly

- Ensure types match expected matcher signatures.
- Verify template parameters if polymorphic.
- Avoid using actions or mocks inside matchers (no mocking calls in matcher code).

### Failure to Integrate with Existing Framework

- Confirm matcher signature compatibility.
- Use GoogleTest macro helpers (`MATCHER`, `MATCHER_P`) where possible for better integration.

---

## Additional Resources

- [GoogleMock Cookbook (Extending Matchers & Actions)](https://google.github.io/googletest/gmock_cook_book.html#new-matchers)
- [Matchers Reference](reference/matchers.md)
- [Actions Reference](reference/actions.md)
- [Mocking Reference](reference/mocking.md)

These resources provide thorough recipes, examples, and API details to deepen your mastery of custom assertions and matchers.

---

## Summary

Extending GoogleTest’s assertions and matchers empowers you to build rich, understandable, and domain-relevant tests. By mastering custom assertion results and matchers, you can closely align tests with your application logic, improving test quality and maintainability.

Embrace the provided macros and interfaces to create precise failure diagnostics and expressive match conditions that integrate seamlessly with GoogleMock’s powerful mocking system.


---
