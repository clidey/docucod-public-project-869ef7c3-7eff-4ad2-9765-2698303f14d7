---
title: "Parameterized & Typed Tests"
description: "Details on authoring and instantiating value- and type-parameterized tests, including available macros, generators, and lifecycle. Ideal for users needing extensive input coverage in tests."
---

# Parameterized & Typed Tests

GoogleTest extends your testing capabilities by allowing you to write *parameterized* and *typed* tests. These powerful features let you reuse a single test logic across multiple input values or types, enabling exhaustive and systematic coverage without duplication of code. This page details how to author and instantiate these tests, the macros involved, and the lifecycle considerations.

---

## Overview

When you want to test a set of values, or multiple types that need the same testing logic, parameterized and typed tests are your best tools:

- **Value-Parameterized Tests**: Run the same test logic with different *values* as input parameters.
- **Typed Tests**: Run the same test logic repeated for each type in a predefined list.
- **Type-Parameterized Tests**: Define a generic test pattern once, then instantiate it on different type lists later, even multiple times.

These testing strategies help you ensure your code behaves correctly across a range of scenarios and type variants without redundant test code.

---

## Value-Parameterized Tests

### Writing Value-Parameterized Tests

1. **Define a test fixture class** that inherits from `::testing::TestWithParam<T>` where `T` is the parameter type.

    ```cpp
    class FooTest : public ::testing::TestWithParam<int> {
      // Optional fixture setup goes here
    };
    ```

2. **Write test patterns using the `TEST_P` macro.** Inside the test, access the parameter via `GetParam()`.

    ```cpp
    TEST_P(FooTest, TestBehavior) {
      int value = GetParam();
      EXPECT_TRUE(CheckFunction(value));
    }
    ```

3. **Instantiate test suites** with a parameter value generator using `INSTANTIATE_TEST_SUITE_P`.

    GoogleTest provides useful generators such as `Values()`, `Range()`, `ValuesIn()`, etc.

    ```cpp
    INSTANTIATE_TEST_SUITE_P(
        ValidInts, FooTest, ::testing::Values(1, 2, 3, 42));
    ```

4. **Optionally provide a custom name generator for test parameters.**

    This enables more descriptive test names based on parameter values.

    ```cpp
    INSTANTIATE_TEST_SUITE_P(
        ValidInts, FooTest, ::testing::Values(1, 2, 3),
        [](const ::testing::TestParamInfo<int>& info) {
          return "Value" + std::to_string(info.param);
        });
    ```

---

### Available Parameter Generators

| Generator              | Description                                                |
|-----------------------|------------------------------------------------------------|
| `Range(begin, end[, step])` | Generates a sequence from `begin` to just before `end`, stepping by `step`. Default step is 1. |
| `Values(val1, val2, ..., valN)` | Yield the listed values directly.                    |
| `ValuesIn(container)`  | Yield values from a container, array, or iterator range.   |
| `Bool()`              | Yields `false` and `true`.                                 |
| `Combine(g1, g2, ..., gN)` | Yields the Cartesian product of multiple generators as tuples. |
| `ConvertGenerator<T>(g)` or `ConvertGenerator(g, func)` | Allows converting generated values before passing as parameters. |

---

### Best Practices and Tips

- Define your fixture class's `SetUpTestSuite()` and `TearDownTestSuite()` methods as **public** to avoid issues with `TEST_P`.
- Use `INSTANTIATE_TEST_SUITE_P` outside of any function scope; it must be at global or namespace scope.
- Parameter generators are lazy-evaluated during test initialization, so avoid mutable state dependencies.
- Choose descriptive instantiation names unique within a translation unit to avoid clashes.
- Avoid underscores in test suite and test names to preserve compatibility.

---

## Typed Tests

Typed tests allow you to write test logic to run across a fixed list of types known at compile time.

### Writing Typed Tests

1. Define a fixture template class parameterized on type `T` deriving from `::testing::Test`:

    ```cpp
    template <typename T>
    class MyTypedTest : public ::testing::Test {
    public:
      T value_{};
    };
    ```

2. Associate a type list with the fixture using `TYPED_TEST_SUITE`:

    ```cpp
    using MyTypes = ::testing::Types<int, double, bool>;
    TYPED_TEST_SUITE(MyTypedTest, MyTypes);
    ```

3. Define tests using the `TYPED_TEST` macro:

    ```cpp
    TYPED_TEST(MyTypedTest, DefaultValueIsZero) {
      TypeParam value = this->value_;
      EXPECT_EQ(value, TypeParam{});
    }
    ```

---

## Type-Parameterized Tests

Type-parameterized tests provide more flexibility by defining tests without concrete types upfront and instantiating them later with different type sets.

### Steps to Write Type-Parameterized Tests

1. Define a template fixture derived from `::testing::Test`.

    ```cpp
    template <typename T>
    class MyTypeParamTest : public ::testing::Test {};
    ```

2. Declare the test suite as type-parameterized using `TYPED_TEST_SUITE_P`.

    ```cpp
    TYPED_TEST_SUITE_P(MyTypeParamTest);
    ```

3. Write tests for this suite using `TYPED_TEST_P`.

    ```cpp
    TYPED_TEST_P(MyTypeParamTest, CheckZero) {
      TypeParam zero{};
      EXPECT_EQ(zero, zero);
    }
    ```

4. Register all the tests in the suite using `REGISTER_TYPED_TEST_SUITE_P`.

    ```cpp
    REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, CheckZero);
    ```

5. Instantiate the suite with concrete types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

    ```cpp
    using MyTypes = ::testing::Types<int, double>;
    INSTANTIATE_TYPED_TEST_SUITE_P(
        MyInstantiation, MyTypeParamTest, MyTypes);
    ```

---

## Lifecycle and Execution

- GoogleTest creates a **new test fixture instance** for each individual test run with the given parameter or type.
- For **value-parameterized tests**, different parameter values result in separate test instances.
- For **typed tests**, the test logic is repeated for each type in the list.
- For **type-parameterized tests**, the test logic is written once and instantiated with any number of type lists.

This model ensures **independence and isolation** of tests, simplifying debugging and parallelization.

---

## Common Pitfalls & Troubleshooting

- **Missed Instantiation:** Complaining about tests never running may indicate missing `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`.
- **Name clashes:** Test suite or test names with underscores may cause ambiguous qualified class names.
- **Accessing Parameters:** Only use `GetParam()` inside `TEST_P` methods; it is not available elsewhere.
- **Unexpected test naming:** Use custom name generators if parameter names are unreadable or collide.
- **Inheritance:** Typed and type-parameterized test fixture classes must inherit directly from `::testing::Test`.

---

## Code Examples

### Value-Parameterized Test Example
```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEvenness) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers,
                         IsEvenTest,
                         ::testing::Values(2, 4, 6, 8, 10),
                         [](const ::testing::TestParamInfo<int>& info) {
                           return "Value" + std::to_string(info.param);
                         });
```

### Typed Test Example
```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {
  // Can include common helper methods / members here
};

using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsPositive) {
  TypeParam zero = TypeParam{};
  EXPECT_GE(std::numeric_limits<TypeParam>::min(), zero);
}
```

### Type-Parameterized Test Example
```cpp
template <typename T>
class ContainerTest : public ::testing::Test {
 public:
  void SetupContainer() {
    data_.push_back(T{});
  }
 protected:
  std::vector<T> data_;
};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, StartsEmpty) {
  EXPECT_TRUE(this->data_.empty());
}

TYPED_TEST_P(ContainerTest, HasOneElement) {
  this->SetupContainer();
  EXPECT_EQ(this->data_.size(), 1);
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, StartsEmpty, HasOneElement);

using TestTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, ContainerTest, TestTypes);
```

---

## Further Reading & Related Documentation

- [GoogleTest Primer](primer.md) — introductory tutorial.
- [Advanced Topics on Parameterized Tests](advanced.md#value-parameterized-tests) — deep dive.
- [Testing Reference - Macros](reference/testing.md) — comprehensive API reference.
- [Writing Effective Assertions](guides/core-testing-workflows/writing-effective-assertions.mdx) — pairing with test logic.

---

With parameterized and typed tests, GoogleTest empowers you to write concise, expressive, and scalable tests that cover broad input spaces and type variants efficiently, reinforcing confidence in your code quality with ease.
