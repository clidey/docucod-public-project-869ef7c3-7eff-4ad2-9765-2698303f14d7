---
title: "Parameterized and Typed Tests"
description: "API guide to value- and type-parameterized testing, including macros and interfaces for defining tests that run over multiple values or types. Provides entry points for test parameter registration and utilities for managing parameterized suites."
---

# Parameterized and Typed Tests

GoogleTest provides powerful mechanisms to write tests that run across multiple inputs or data types without duplicating code. These mechanisms are:

- **Value-Parameterized Tests** (using `TEST_P` and related macros)
- **Type-Parameterized Tests and Typed Tests** (using `TYPED_TEST` and related macros)

They help you write concise, maintainable tests that cover broad scenarios.

---

## Value-Parameterized Tests

Value-parameterized tests allow you to run the same test logic with different parameter values, increasing coverage while reducing redundancy.

### Defining Value-Parameterized Test Fixtures

Create a test fixture class derived from `::testing::TestWithParam<T>`, where `T` is the parameter type. `TestWithParam` combines `Test` and `WithParamInterface<T>`, providing a `GetParam()` method to access the parameter value.

```cpp
class MyTestFixture : public ::testing::TestWithParam<int> {
  // You can define setup and teardown here.
};
```

### Writing Parameterized Tests with `TEST_P`

Use `TEST_P` instead of `TEST` or `TEST_F` to define tests inside the fixture. Inside the test body, access the parameter via `GetParam()`.

```cpp
TEST_P(MyTestFixture, HandlesValue) {
  int param = GetParam();
  EXPECT_TRUE(Process(param));
}
```

### Instantiating Parameterized Test Suites with `INSTANTIATE_TEST_SUITE_P`

Use this macro to generate instances of your test suite for multiple parameter values or sequences.

```cpp
INSTANTIATE_TEST_SUITE_P(
    ValueTests,           // Instantiation name prefix
    MyTestFixture,        // Test suite name
    ::testing::Values(1, 2, 3)  // Parameter generator
);
```

### Parameter Generators

GoogleTest provides a collection of generator functions to supply parameter values:

| Generator          | Description                                                                                  |
|--------------------|----------------------------------------------------------------------------------------------|
| `Range(begin,end[,step])` | Generates values from `begin` to `end - 1` stepping by `step` (default 1).                 |
| `Values(v1,v2,...,vN)`    | Generates the explicitly specified values.                                              |
| `ValuesIn(container)` or `ValuesIn(begin,end)` | Generate values from a container or iterator range.                              |
| `Bool()`                  | Generates `false, true` values — useful for testing Boolean flags.                        |
| `Combine(g1, g2, ..., gN)`| Generates the Cartesian product of multiple generators producing tuples of parameter values. |
| `ConvertGenerator<T>(gen)`| Converts a generator’s produced types to a target type `T` — optionally using a conversion functor.|


### Customizing Parameterized Test Names

You can specify a custom naming function for parameter instances by passing a last parameter to `INSTANTIATE_TEST_SUITE_P`. This function takes a `TestParamInfo<ParamType>` object and returns a string suffix for the test name. The suffix must be unique and only contain alphanumeric characters or underscores.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyTestFixture, Values(10, 20),
    [](const testing::TestParamInfo<MyTestFixture::ParamType>& info) {
      return "Value" + std::to_string(info.param);
    });
```

### Using `ConvertGenerator`

If the generated parameter type differs from your fixture’s parameter type and they are not implicitly convertible, use `ConvertGenerator` with an optional conversion function.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite,
    ConvertGenerator<std::tuple<int, bool>>(
      Combine(Values(0, 1), Bool()),
      [](std::tuple<int, bool> t) {
        return MyParam(std::get<0>(t), std::get<1>(t));
      }
    ));
```

This enables complex parameter translation while maintaining strong typing.

### Best Practices and Common Pitfalls

- Always define the test fixture class parameterized by the parameter type.
- Use `INSTANTIATE_TEST_SUITE_P` in a source file, not a header, to avoid multiple definitions.
- The `InstantiationName` prefix in `INSTANTIATE_TEST_SUITE_P` must be unique per instantiation.
- Avoid parameter names with spaces or special symbols.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors for uninstantiated parameterized tests.

---

## Typed Tests and Type-Parameterized Tests

Typed tests run the same test logic over multiple **types**.

### Typed Tests

Use typed tests when the types are known at the point of writing tests.

#### Define a Typed Test Fixture Template

```cpp
template <typename T>
class MyTypedTest : public ::testing::Test {
 public:
  T value_;
};
```

#### Associate a List of Types

Define a type list using `Types<>` and associate it with your fixture:

```cpp
using MyTypes = ::testing::Types<int, char, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

#### Define Typed Tests Using `TYPED_TEST`

Inside the test body, use `TypeParam` as the current type:

```cpp
TYPED_TEST(MyTypedTest, CanBeInitialized) {
  TypeParam v{};  // default construct
  EXPECT_EQ(0, static_cast<int>(v));  // Example assertion
}
```

### Type-Parameterized Tests

Type-parameterized tests define abstract test patterns instantiated later; useful for verifying interface requirements across implementations.

#### Define Type-Parameterized Test Suite and Tests

```cpp
template <typename T>
class MyTypeParamTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, BehavesAsExpected) {
  TypeParam instance;
  EXPECT_TRUE(instance.IsValid());
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, BehavesAsExpected);
```

#### Instantiate With Concrete Types

Use `INSTANTIATE_TYPED_TEST_SUITE_P` with a `Types<>` list:

```cpp
using MyConcreteTypes = ::testing::Types<MyClass1, MyClass2>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyTypeParamTest, MyConcreteTypes);
```

### Naming Customization

Custom name suffixes can be specified for type-instantiations by providing a class with a templated static `GetName(int)` function when defining or instantiating.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, char>) return "Char";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Best Practices and Pitfalls

- Use `TYPED_TEST_SUITE` and `TYPED_TEST` for typed tests.
- Use `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, and `INSTANTIATE_TYPED_TEST_SUITE_P` for type-parameterized tests.
- Do not instantiate type-parameterized test suites in multiple translation units unless intended.
- Avoid empty or duplicated test names — GoogleTest enforces uniqueness.

---

## Summary Workflow Example for Value-Parameterized Tests

<Steps>
  <Step title="Define Test Fixture">
    Derive a class from `TestWithParam<T>` where `T` is your parameter type.
  </Step>
  <Step title="Write Parameterized Tests">
    Use the `TEST_P` macro to write tests accessing `GetParam()`.
  </Step>
  <Step title="Instantiate Test Suite">
    Use `INSTANTIATE_TEST_SUITE_P` to generate test instances with parameter generators.
  </Step>
  <Step title="Run the Tests">
    Call `RUN_ALL_TESTS()` after initializing GoogleTest; your tests run with all parameters.
  </Step>
</Steps>

---

### Example: Value-Parameterized Test with Multiple Parameters

```cpp
class MyParamTest : public ::testing::TestWithParam<std::tuple<int, bool>> {};

TEST_P(MyParamTest, WorksCorrectly) {
  int num = std::get<0>(GetParam());
  bool flag = std::get<1>(GetParam());
  EXPECT_TRUE(Process(num, flag));
}

INSTANTIATE_TEST_SUITE_P(
    CombinedParams,
    MyParamTest,
    ::testing::Combine(::testing::Values(1, 2), ::testing::Bool()));
```

---

### Example: Typed Test

```cpp
template <typename T>
class StackTest : public ::testing::Test {
 protected:
  Stack<T> stack_;
};

using MyTypes = ::testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack_.empty());
}
```

---

### Troubleshooting

- **Uninstantiated Tests Error:** Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FixtureName)` if a parameterized test is used but not instantiated.
- **Duplicate Test Names:** Ensure test names and parameter suffixes are unique.
- **Invalid Parameter Names:** Parameter name suffixes must only contain alphanumeric characters and underscores.
- **Lifetime Issues With ConvertGenerator Lambdas:** Avoid dangling references by specifying types explicitly when converting.

---

For more detailed guidance, see the [Testing Reference - Parameterized Tests](../testing.md#TEST_P) and [Typed Tests](../testing.md#TYPED_TEST) sections.

---

**Source and Examples:**
- Value-parameterized tests examples in `googletest/test/gtest_list_output_unittest_.cc`
- Parameter generators and conversion utilities in `googletest/include/gtest/gtest-param-test.h` and `googletest/include/gtest/internal/gtest-param-util.h`

<Source url="https://github.com/google/googletest" branch="main" path="googletest/include/gtest/gtest-param-test.h" range="1-400" />
<Source url="https://github.com/google/googletest" branch="main" path="googletest/test/googletest-param-test-test.cc" range="1-450" />