---
title: "Parameterized and Typed Tests"
description: "Unlock advanced reuse by running the same test logic against multiple input values or data types. Explore the APIs for value-parameterized and type-parameterized tests, including generator functions, registration macros, and type utilities."
---

# Parameterized and Typed Tests

Unlock advanced reuse by running the same test logic against multiple input values or data types. This page explores the APIs for value-parameterized and type-parameterized tests, including generator functions, registration macros, and type utilities.

---

## Overview

Parameterized and typed tests in GoogleTest empower you to write concise, maintainable, and scalable tests across many values or types without duplicating code. By parameterizing test logic, you can ensure coverage over a range of inputs or implementations efficiently.

- **Value-Parameterized Tests** test the same logic over various data instances.
- **Typed Tests** run identical tests for a fixed list of types.
- **Type-Parameterized Tests** define abstract test suites instantiated with types later.

This page details how to define, register, instantiate, and customize these tests with practical examples and tips.

---

## Value-Parameterized Tests

### Concept
Value-parameterized tests let you reuse test logic across different input parameters. Instead of writing the test multiple times for each input, define a single test pattern and supply the parameter set.

### Defining a Value-Parameterized Test

1. Derive a test fixture class from `testing::TestWithParam<T>` where `T` is the test parameter type.
2. Use the `TEST_P` macro to define test methods that access the parameter via `GetParam()`.

```cpp
class FooTest : public testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  int val = GetParam();
  EXPECT_EQ(val % 2, 0);
}
```

### Instantiating Value-Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to instantiate the test suite with a set of parameters. GoogleTest provides parameter generators:

| Generator           | Behavior                                            |
|---------------------|----------------------------------------------------|
| `Range(begin, end [, step])` | Generates values starting from `begin` up to but not including `end`, stepping by `step` (default 1). |
| `Values(v1, v2, ..., vN)`    | Enumerates explicit values.                       |
| `ValuesIn(container_or_array)` | Iterates over containers, arrays, or iterator pairs. |
| `Bool()`                     | Generates `false` and `true`.                      |
| `Combine(g1, g2, ..., gN)`   | Cartesian product of generators, producing tuples. |
| `ConvertGenerator<T>(g)`     | Converts generated values to type `T` or via a provided callable. |

Example instantiation:

```cpp
INSTANTIATE_TEST_SUITE_P(MyInts, FooTest, testing::Values(2, 4, 6, 8));
```

### Naming Parameterized Tests

By default, test instances are named with an index suffix (e.g., `/0`, `/1`). You can provide a custom name generator that produces descriptive suffixes.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, testing::Values(2, 4),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Abstract Value-Parameterized Tests

You can define value-parameterized tests in a header and implement them separately, allowing other users to instantiate them with their own parameters. This facilitates sharing common test logic.

### Tips and Best Practices

- Ensure `SetUpTestSuite()` and `TearDownTestSuite()` are declared `public` when used with `TEST_P` fixtures.
- Avoid memory leaks in parameter types, especially with pointers.
- Use descriptive parameter names for easier debugging.

---

## Typed Tests

Typed tests allow you to run the same test code against a fixed list of types.

### Defining Typed Tests

1. Create a test fixture class template derived from `testing::Test`.
2. Define the type list with `testing::Types<T1, T2, ..., TN>`.
3. Use `TYPED_TEST_SUITE` to associate the types with the fixture.
4. Define tests using `TYPED_TEST`, referring to the `TypeParam` within tests.

Example:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_ = T();
};

using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam());
}
```

### Optional Type Name Generators

Provide custom class for generating type name suffixes:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    if constexpr (std::is_same_v<T, std::string>) return "String";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Uses

Typed tests are ideal when you:

- Have different types that should satisfy the same interface or contract.
- Want to validate behavior across variants of a class or type.

---

## Type-Parameterized Tests

Type-parameterized tests define an abstract test pattern without knowing the types ahead of time. They are instantiated by users later, potentially multiple times, with different type lists.

### Defining Type-Parameterized Tests

1. Define a template fixture class derived from `testing::Test`.
2. Declare the test suite as type-parameterized using `TYPED_TEST_SUITE_P`.
3. Use `TYPED_TEST_P` to define the individual tests.
4. Register the tests with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, DoesSomething) {
  TypeParam value = TypeParam();
  EXPECT_TRUE(SomeCheck(value));
}

TYPED_TEST_P(MyTypeParamTest, AnotherTest) {
  ...
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, DoesSomething, AnotherTest);
```

### Instantiating Type-Parameterized Tests

Use `INSTANTIATE_TYPED_TEST_SUITE_P` to instantiate with type lists.

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, MyTypeParamTest, MyTypes);
```

### Multiple Instantiations

You can instantiate the same type-parameterized test suite multiple times with different type sets, distinguished by the unique prefix.

---

## Programmatic Test Registration

For advanced dynamic scenarios, you can register tests at runtime using `testing::RegisterTest`.

```cpp
TestInfo* RegisterTest(
    const char* test_suite_name, const char* test_name,
    const char* type_param, const char* value_param,
    const char* file, int line, std::function<Fixture*()> factory);
```

This allows generating tests for arbitrary parameter sets using custom factory objects. This must be done before calling `RUN_ALL_TESTS()`.

---

## Retrieving Test Information

You can access the current test's info at runtime:

```cpp
const testing::TestInfo* info = testing::UnitTest::GetInstance()->current_test_info();
std::cout << "Running test " << info->test_suite_name() << "." << info->name() << std::endl;
```

This helps in logging, custom parameter naming, or conditional behaviors inside tests.

---

## Common Pitfalls & Troubleshooting

- **No default constructor in fixtures:** `TEST_F` fixtures must have a default constructor.
- **No instantiations for parameterized tests:** Make sure every `TEST_P` has a matching `INSTANTIATE_TEST_SUITE_P`, or use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- **Name restrictions:** Avoid underscores in test suite and test names to prevent macro expansion conflicts.
- **Lifetime management:** For pointer parameters, ensure proper object lifetime.
- **Custom naming rules:** Returned test name suffixes must be valid identifiers.

---

## Summary

GoogleTest provides powerful APIs for value-parameterized, typed, and type-parameterized tests. These features maximize test reuse, improve coverage, and simplify maintenance when testing across multiple data values and types. The ability to programmatically register tests and generate custom names further enhances flexibility.

Refer to [Value-Parameterized Tests](../advanced.md#value-parameterized-tests), [Typed Tests](../advanced.md#typed-tests), and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for in-depth conceptual explanations and more examples.

---

## References

- [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md)
- [Advanced GoogleTest Topics: Parameterized Tests](https://github.com/google/googletest/blob/main/docs/advanced.md#value-parameterized-tests)
- [Testing Reference: TEST_P, INSTANTIATE_TEST_SUITE_P](https://github.com/google/googletest/blob/main/docs/reference/testing.md#TEST_P)
- [gtest Typed Test Implementation](https://github.com/google/googletest/blob/main/googletest/include/gtest/gtest-typed-test.h)

---

## Code Sample: Value-Parameterized Test with Custom Name Generator

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, CheckEvenness) {
  int value = GetParam();
  EXPECT_EQ(value % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(
    EvenValues, IsEvenTest, testing::Values(2, 4, 6, 8),
    [](const testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });

// Generated test names:
// EvenValues/IsEvenTest.CheckEvenness/Val2
// EvenValues/IsEvenTest.CheckEvenness/Val4
// etc.
```

## Code Sample: Typed Test

```cpp
template <typename T>
class MathTest : public testing::Test {
 public:
  T value = T();
};

using MyTypes = testing::Types<int, float, double>;
TYPED_TEST_SUITE(MathTest, MyTypes);

TYPED_TEST(MathTest, DefaultConstructedIsZero) {
  EXPECT_EQ(this->value, TypeParam());
}
```

## Code Sample: Type-Parameterized Test

```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, HasSizeZeroInitially) {
  TypeParam container;
  EXPECT_EQ(container.size(), 0);
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, HasSizeZeroInitially);

using ContainerTypes = testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainers, ContainerTest, ContainerTypes);
```
