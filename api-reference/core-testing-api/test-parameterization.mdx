---
title: "Test Parameterization"
description: "Details the mechanisms for value-parameterized and type-parameterized tests, including code patterns to create test fixtures that run across multiple data values or types. Discusses the supporting macros, registration utilities, and practical examples to maximize test coverage."
---

# Test Parameterization

GoogleTest empowers you to write tests that flexibly run across multiple data values or types without duplicative code. This page details the mechanisms for creating parameterized tests, focusing on both value-parameterized and type-parameterized testing paradigms. You will find practical instructions, supporting macros, registration utilities, and concrete examples demonstrating how to maximize test coverage and maintain clean test logic.

---

## Value-Parameterized Tests

Value-parameterized tests enable running the same test logic repeatedly with different input values. This approach saves effort by eliminating the need to write multiple similar tests.

### Writing a Value-Parameterized Test Fixture

1. **Define a Fixture Class:** Create a class derived from `::testing::TestWithParam<T>`, where `T` is the type of your test parameter. You can use other inheritance schemes if necessary, but `TestWithParam` is the standard.

```cpp
class FooTest : public ::testing::TestWithParam<int> {
  // Implement fixture members as needed.
};
```

2. **Define Tests Using `TEST_P`:** Use the `TEST_P` macro to write test cases that access the parameter via `GetParam()`.

```cpp
TEST_P(FooTest, DoesBehavior) {
  int param = GetParam();
  EXPECT_TRUE(MyFunction(param));
}
```

3. **Instantiate the Test Suite:** Use `INSTANTIATE_TEST_SUITE_P` to specify all parameter values or use generators that create sequences.

```cpp
INSTANTIATE_TEST_SUITE_P(
    SampleInstantiation, FooTest,
    ::testing::Values(1, 2, 3));
```

### Supported Parameter Generators

GoogleTest offers a variety of parameter generator functions to create sequences for value-parameterized tests:

| Generator                   | Description                                                                                  |
|-----------------------------|----------------------------------------------------------------------------------------------|
| `Values(v1, v2, ...)`       | Explicitly specified list of values.                                                        |
| `Range(start, end [, step])`| Yields a sequence from start up to but not including end, incremented by step.               |
| `ValuesIn(container)`        | Generates values from a container or iterator range.                                        |
| `Bool()`                    | Yields `false` and `true`.                                                                   |
| `Combine(g1, g2, ..., gN)`  | Creates Cartesian product of multiple parameter sequences, yielding tuples of parameters.    |
| `ConvertGenerator<T>(gen)`  | Converts generated parameters to a custom type or via a user-provided callable.             |

### Example: Using a Custom Name Generator

You can customize test names generated from parameters to improve readability.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, 
    ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<FooTest::ParamType>& info) {
      return "Param_" + std::to_string(info.index);
    });
```

This generates tests named `CustomNames/FooTest.DoesBehavior/Param_0`, etc.

### Important Notes
- The fixture class should declare `SetUpTestSuite()` and `TearDownTestSuite()` as **public** if using `TEST_P`.
- `INSTANTIATE_TEST_SUITE_P` statements are evaluated during GoogleTest initialization (after `InitGoogleTest()`), ensuring dynamic parameters can be used.
- Every test defined with `TEST_P` **must** be instantiated to avoid runtime errors. If a suite is intentionally not instantiated, mark it using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.

---

## Typed Tests

Typed tests allow running the same test logic across a predefined list of types, enabling compile-time verification of interface conformance or conceptual correctness over multiple types.

### Writing Typed Tests

1. **Define a Fixture Class Template:** Parameterized by a type `T` and derived from `::testing::Test`.

```cpp
template <typename T>
class TypedTestFixture : public ::testing::Test {
 public:
  T value_ = T();
  using List = std::list<T>;
  static T shared_;
};

template <typename T>
T TypedTestFixture<T>::shared_ = T();
```

2. **Associate Types with the Test Suite:** Use `TYPED_TEST_SUITE` with a type list.

```cpp
using Types = ::testing::Types<int, char>;
TYPED_TEST_SUITE(TypedTestFixture, Types);
```

3. **Define Typed Tests with `TYPED_TEST`:** Use the `TypeParam` keyword inside tests to refer to the current type.

```cpp
TYPED_TEST(TypedTestFixture, TestValueInitialization) {
  TypeParam x = this->value_;
  EXPECT_EQ(x, TypeParam());
}
```

### Custom Type Names
You can define a name generator class with a static template `GetName(int)` function to provide custom suffixes for each type.

```cpp
class CustomNameGen {
 public:
   template <typename T>
   static std::string GetName(int) {
     if constexpr (std::is_same_v<T, int>) return "Int";
     if constexpr (std::is_same_v<T, char>) return "Char";
   }
};

TYPED_TEST_SUITE(TypedTestFixture, Types, CustomNameGen);
```

### Key Points
- Typed tests require you to know the list of types upfront.
- The `TypeParam` keyword always refers to the current test type.
- You cannot instantiate typed tests multiple times; the suite is tied to the specified type list.

---

## Type-Parameterized Tests

Type-parameterized tests are similar to typed tests but allow defining the test pattern independently from the list of types. You can then instantiate the test pattern with different type lists multiple times.

### Defining Type-Parameterized Tests

1. **Define a Fixture Template:** Like typed tests.
2. **Declare Test Suite Pattern:** Use `TYPED_TEST_SUITE_P`.
3. **Define Tests:** Use `TYPED_TEST_P` instead of `TYPED_TEST`.
4. **Register Tests:** Use `REGISTER_TYPED_TEST_SUITE_P` with the test names.

```cpp
template <typename T>
class PatternTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(PatternTest);

TYPED_TEST_P(PatternTest, TestA) {
  TypeParam val = 0;
  EXPECT_EQ(val, 0);
}

TYPED_TEST_P(PatternTest, TestB) {
  EXPECT_TRUE(true);
}

REGISTER_TYPED_TEST_SUITE_P(PatternTest, TestA, TestB);
```

5. **Instantiate the Test Suite:** Multiple times, optionally with different type lists.

```cpp
using MyTypes = ::testing::Types<int, long>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstance, PatternTest, MyTypes);
```

### Benefits
- Allows defining reusable, generic test patterns.
- Enables multiple instantiations with different type lists.
- Facilitates large-scale testing across implementations or concepts.

### Notes
- Use `this->` to refer to members of the fixture inside `TYPED_TEST_P` bodies.
- The registration must occur before instantiation.

---

## Common Macros and Utilities

| Macro/Function                      | Description                                          |
|-----------------------------------|-----------------------------------------------------|
| `TEST_P(TestSuite, TestName)`      | Defines an individual value-parameterized test.     |
| `INSTANTIATE_TEST_SUITE_P`         | Instantiates the value-parameterized test suite.    |
| `TYPED_TEST_SUITE(Fixture, Types)` | Associates a list of types to a typed test fixture. |
| `TYPED_TEST(Fixture, TestName)`    | Defines an individual typed test.                    |
| `TYPED_TEST_SUITE_P(Fixture)`      | Declares a type-parameterized test suite pattern.   |
| `TYPED_TEST_P(Fixture, TestName)`  | Defines an individual type-parameterized test.      |
| `REGISTER_TYPED_TEST_SUITE_P`      | Registers type-parameterized test names.             |
| `INSTANTIATE_TYPED_TEST_SUITE_P`  | Instantiates a type-parameterized test suite.        |
| `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` | Suppresses instantiation error for value-param test suites.

---

## Practical Examples

### Value-Parameterized Test with `Range`

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, ComputesCorrectly) {
  int n = GetParam();
  EXPECT_GE(Factorial(n), 1);
}

INSTANTIATE_TEST_SUITE_P(
    ValuesOneToFive, FactorialTest,
    ::testing::Range(1, 6));  // generates tests with params 1..5
```

### Typed Test Example

```cpp
template <typename T>
class NumericTest : public ::testing::Test {
 public:
  T zero = T();
};

using NumericTypes = ::testing::Types<int, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(this->zero, TypeParam(0));
}
```

### Type-Parameterized Test Example

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, IsEmptyInitially) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, IsEmptyInitially);

using MyTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, ContainerTest, MyTypes);
```

---

## Troubleshooting and Best Practices

- **Uninstantiated `TEST_P` Suites:** Every `TEST_P` must be instantiated with `INSTANTIATE_TEST_SUITE_P` or marked with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if intentional.
- **Avoid Underscores in Test/Fixture Names:** Underscores complicate generated names; avoid them.
- **Use Custom Name Generators:** To get meaningful test names, provide custom name functors when needed.
- **SetUpTestSuite Accessibility:** For parameterized tests, `SetUpTestSuite` and `TearDownTestSuite` should be public to be recognized properly.
- **Type Safety in Generators:** Use `ConvertGenerator` if your parameter type requires explicit or custom conversions.

---

## Additional Resources

- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for conceptual details and examples
- [Typed Tests](../advanced.md#typed-tests) and [Type-Parameterized Tests](../advanced.md#type-parameterized-tests) for deep dives with code
- [Testing Reference](reference/testing.md#TEST_P) covering related macros and classes
- [Advanced GoogleTest Topics](advanced.md) for hints on sharing resources and skipping tests

---

By adopting parameterized and typed testing effectively, you achieve comprehensive test coverage while keeping your code DRY and maintainable.
