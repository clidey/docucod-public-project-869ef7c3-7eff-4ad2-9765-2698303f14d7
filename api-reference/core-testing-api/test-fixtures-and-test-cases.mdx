---
title: "Test Fixtures and Test Cases"
description: "Details the core workflow for defining and managing tests and test suites. Includes API macros for declaring tests, test environments, and fixtures, with code patterns and lifecycle control. Helps users get started rapidly and architect maintainable test suites."
---

# Test Fixtures and Test Cases

This document details the core workflow for defining and managing tests and test suites in GoogleTest. It explains how to declare tests, test environments, and fixtures using the provided API macros, illustrates common code patterns, and clarifies control of test lifecycle and execution. Designed to help you start quickly and build maintainable test suites, this guide walks you through fundamental concepts and practical usage.

---

## Defining Basic Tests with `TEST`

The fundamental unit of testing in GoogleTest is the **test**, declared using the `TEST` macro:

```cpp
TEST(TestSuiteName, TestName) {
  // Test code and assertions here.
}
```

- **`TestSuiteName`** groups related tests together. It should be a valid C++ identifier without underscores.
- **`TestName`** uniquely identifies the test within the suite and also should avoid underscores.

Each `TEST` defines a freely named function where you place your test code and use assertions to verify behavior. Separate tests within the same suite share no common state.

> *Example: Testing a Factorial Function*

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(4), 24);
}
```

---

## Sharing Setup with Test Fixtures using `TEST_F`

When multiple tests share common objects, resources, or setup logic, **test fixtures** help avoid duplication and make tests easier to maintain.

### Creating a Test Fixture

1. Define a class deriving from `::testing::Test`.
2. Declare any shared objects and helper methods as protected members.
3. Optionally override the `SetUp()` and `TearDown()` methods to initialize and clean up per-test state.

```cpp
class MyFixture : public testing::Test {
 protected:
  MyFixture() {
    // Initialize shared objects here.
  }

  void SetUp() override {
    // This runs before each test.
  }

  void TearDown() override {
    // This runs after each test.
  }

  // Shared objects or helpers.
  Database db_;
};
```

### Writing Tests Using The Fixture

Use the `TEST_F` macro, specifying your fixture class name. Each test runs on a fresh instance of the fixture.

```cpp
TEST_F(MyFixture, BasicTest) {
  EXPECT_TRUE(db_.Connect());
}

TEST_F(MyFixture, AnotherTest) {
  EXPECT_FALSE(db_.IsEmpty());
}
```

> **Important:** GoogleTest creates a new test fixture object for each test. This ensures
> each test is independent, preventing side-effects from leaking between tests.

---

## Sharing Expensive Resources Across Tests with `SetUpTestSuite` and `TearDownTestSuite`

Sometimes, setting up a resource is expensive. GoogleTest supports **per-test-suite** setup and teardown via static methods on the fixture class.

Declare these methods as static within your fixture class:

```cpp
class ExpensiveFixture : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    shared_resource_ = new Resource();
  }

  static void TearDownTestSuite() {
    delete shared_resource_;
    shared_resource_ = nullptr;
  }

  static Resource* shared_resource_;
};

Resource* ExpensiveFixture::shared_resource_ = nullptr;
```

- `SetUpTestSuite()` runs once before any tests in the suite run.
- `TearDownTestSuite()` runs once after all tests in the suite finish.

Tests can access `shared_resource_` for their needs, but it must not be modified without proper synchronization because it's shared.

> **Tip:** The test order is undefined. Tests should not depend on the order in which they run or on side effects of other tests.

---

## Value-Parameterized Tests with `TEST_P` and `INSTANTIATE_TEST_SUITE_P`

Value-parameterized tests enable running the same test logic against multiple input values.

### Defining a Parameterized Test Fixture

Inherit from `testing::TestWithParam<T>`, where `T` is the parameter type.

```cpp
class FooTest : public testing::TestWithParam<int> {
  // Fixture implementations...
};
```

### Writing Parameterized Tests

Use `TEST_P` in place of `TEST_F` and access the parameter with `GetParam()`:

```cpp
TEST_P(FooTest, HandlesVariousInputs) {
  int param = GetParam();
  EXPECT_GT(param, 0);
}
```

### Instantiating the Test Suite with Parameters

Use `INSTANTIATE_TEST_SUITE_P` with a generator like `Values()` or `Range()`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    PositiveNumbers,  // Instantiation name
    FooTest,         // Test suite name
    testing::Values(1, 2, 3, 5, 8));
```

This creates tests named `PositiveNumbers/FooTest.HandlesVariousInputs/0`, etc., with the indexed parameter.

> You can also create parameters using `Combine()`, `Bool()`, `ValuesIn()`, etc., for advanced scenarios.

---

## Typed Tests with `TYPED_TEST_SUITE` and `TYPED_TEST`

Typed tests allow you to run the same tests against multiple types.

### Declare a Test Fixture Template

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_{};
};
```

### Define the Types to Test

```cpp
using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

### Write Typed Tests

Use `TYPED_TEST()` and the `TypeParam` alias to refer to the instantiated type:

```cpp
TYPED_TEST(MyTypedTest, HasDefaultValue) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam{});
}
```

This test runs once per type in `MyTypes`.

---

## Type-Parameterized Tests with `TYPED_TEST_SUITE_P` and `REGISTER_TYPED_TEST_SUITE_P`

Type-parameterized tests offer even more flexibility by allowing test logic to be defined separately from their type lists.

### Defining a Type-Parameterized Test Suite

Declare the suite as a template and then use `TYPED_TEST_SUITE_P`:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {
  // Fixture implementation
};

TYPED_TEST_SUITE_P(MyTypeParamTest);
```

### Define Type-Parameterized Tests

Write tests with `TYPED_TEST_P`:

```cpp
TYPED_TEST_P(MyTypeParamTest, TestName) {
  TypeParam val{};
  EXPECT_TRUE(SomeCheck(val));
}
```

### Register Test Names

Register all test names before instantiating:

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, TestName /*, OtherTests */);
```

### Instantiate the Suite with Types

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInst, MyTypeParamTest, MyTypes);
```

---

## Registering Tests Programmatically

In advanced use cases, you can register tests dynamically at runtime using `testing::RegisterTest`. This function requires a factory that returns a fixture pointer:

```cpp
TestInfo* RegisterTest(
    const char* test_suite_name,
    const char* test_name,
    const char* type_param,
    const char* value_param,
    const char* file,
    int line,
    Factory factory);
```

This allows creation of tests based on runtime information, which is useful for parameterizing tests from external data.

---

## Accessing Test Information During Execution

- Use `testing::UnitTest::GetInstance()->current_test_info()` to get the currently running test's `TestInfo` object.
- `TestInfo` provides suite and test names, source file and line location, parameter information, and results.

Example:

```cpp
const testing::TestInfo* info = testing::UnitTest::GetInstance()->current_test_info();
if (info != nullptr) {
  std::cout << "Running test " << info->test_suite_name() << "." << info->name() << std::endl;
}
```

---

## Best Practices & Common Pitfalls

- **Avoid underscores** in test suite and test names because GoogleTest internally generates class names that could cause collisions or compilation issues.
- Use `SetUp()` and `TearDown()` for any test initialization and cleanup that may fail or require virtual dispatch; reserve constructors and destructors for simple object lifetime management.
- Do not share mutable state across tests unless carefully synchronized.
- Use `GTEST_SKIP()` to conditionally skip tests at runtime with meaningful messages.
- When testing private or protected classes or methods, prefer friend test declarations or refactor code for testability.

---

## Summary

GoogleTest provides a robust and consistent API to manage and organize tests ranging from simple single-function tests to complex parameterized and typed tests. Utilizing test fixtures maximizes reuse and clarity, while GoogleTestâ€™s flexible macros empower you to design expressive and maintainable test suites with precise control over test lifecycle and parameterization.

For detailed examples and further guidance, explore related documentation on assertions, parameterized tests, typed tests, and test running mechanisms.

---

## See Also

- [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md) for beginner-friendly tutorials and examples.
- [Parameterized And Type-Parameterized Tests](https://github.com/google/googletest/blob/main/docs/advanced.md#value-parameterized-tests) guide for advanced test patterns.
- [Mocking with GoogleMock](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md) for interaction-based testing.
- [Test Fixtures Reference](https://github.com/google/googletest/blob/main/docs/reference/testing.md#TEST_F) for API details.

<Source url="https://github.com/google/googletest" paths={[{"path": "googletest/docs/reference/testing.md", "range": "12-165"}]} />
