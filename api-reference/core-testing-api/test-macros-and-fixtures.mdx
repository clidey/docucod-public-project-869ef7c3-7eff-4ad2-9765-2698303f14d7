---
title: "Test Macros and Fixtures"
description: "Describes the main macros and class structures for defining and organizing test cases and test suites, including test fixtures for shared setup and teardown. Includes usage of TEST, TEST_F, and custom test event listeners for efficient test code structure."
---

# Test Macros and Fixtures

This document describes the foundational macros and class structures provided by GoogleTest for defining, organizing, and managing test cases and suites. It focuses on key constructs such as `TEST`, `TEST_F`, and custom test event listeners. It also covers test fixtures allowing shared setup and teardown to enable efficient and maintainable test code.

---

## Overview of Test Macros

GoogleTest offers macros to define unit tests in a straightforward manner with minimal boilerplate. These macros enable you to write modular tests with clear intent and scalable structure.

### `TEST` Macro

The simplest form of a test is created with the `TEST` macro, which defines an independent test case and test name.

```cpp
TEST(TestCaseName, TestName) {
  // Test code here
}
```

- **TestCaseName** groups related tests.
- **TestName** uniquely identifies the test within the test case.

This macro generates a test function that GoogleTest automatically discovers and runs. The test body contains test logic and assertions.

#### Example

```cpp
TEST(SquareRootTests, PositiveNumbers) {
  EXPECT_DOUBLE_EQ(sqrt(9), 3);
}
```

### Use Case

Use `TEST` for simple, standalone tests that do not require shared setup or teardown.

---

## Test Fixtures: The `TEST_F` Macro

For test cases needing common resources, use test fixtures to share setup and teardown code. `TEST_F` declares tests using a fixture class.

### Defining a Test Fixture

A test fixture is a class deriving from `::testing::Test` that encapsulates shared state and setup/teardown logic.

```cpp
class MyTestFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Code here runs before every test
  }

  void TearDown() override {
    // Code here runs after every test
  }

  // Shared test data members
  int shared_value_;
};
```

### Writing Tests with `TEST_F`

Each test declared with `TEST_F(FixtureClass, TestName)` has access to the fixture's members.

```cpp
TEST_F(MyTestFixture, Test1) {
  shared_value_ = 42;
  EXPECT_EQ(shared_value_, 42);
}
```

### Advantages

- Avoids duplication of setup/cleanup code.
- Keeps related tests organized by sharing fixture context.
- More maintainable and scalable testing patterns.

### Best Practices

- Keep fixtures lightweight.
- Only share state necessary for tests.
- Use `SetUp()` and `TearDown()` for setup and cleanup, not constructors or destructors.

---

## Custom Test Event Listeners

GoogleTest allows extension by implementing and registering custom event listeners to react to various stages of test execution.

### Purpose

- Customize reporting
- Integrate with external test frameworks or logging
- Perform additional actions on test start, end, failure, etc.

### How to Implement

Derive from `::testing::TestEventListener` and override methods such as:

- `OnTestProgramStart`
- `OnTestStart`
- `OnTestPartResult`
- `OnTestEnd`

### Example Skeleton

```cpp
class MyListener : public ::testing::TestEventListener {
 public:
  void OnTestProgramStart(const ::testing::UnitTest& unit_test) override {
    // Do something
  }
  void OnTestStart(const ::testing::TestInfo& test_info) override {
    // Do something
  }
  void OnTestPartResult(const ::testing::TestPartResult& result) override {
    // Do something
  }
  void OnTestEnd(const ::testing::TestInfo& test_info) override {
    // Do something
  }
  // Other overrides ...
};

// To register:
::testing::TestEventListeners& listeners =
    ::testing::UnitTest::GetInstance()->listeners();
listeners.Append(new MyListener);
```

### Use Case

Use custom listeners when you need to influence the test reporting or hook into test lifecycle events for custom behavior.

---

## Summary: Typical User Flow to Structure Tests

1. Use `TEST` for simple, independent test cases.
2. Use `TEST_F` when you have multiple tests sharing setup/teardown logic via fixtures.
3. Define test fixtures by subclassing `::testing::Test` and overriding `SetUp` and `TearDown`.
4. If needed, extend test execution behavior by creating custom test event listeners.

---

## Practical Tips and Common Pitfalls

- **Always ensure fixture resources are properly managed.** Use `SetUp()` / `TearDown()` for dynamic resources.
- **Avoid putting test logic into fixture constructors or destructors** to prevent hiding exceptions and difficult debugging.
- **Name tests clearly** to describe their behavior and intent for easier maintenance.
- **Don't overuse `TEST_F`** if simple `TEST` macros suffice - keep tests simple and focused.
- **Use custom listeners sparingly**; start only when built-in reporting or hooks are insufficient.

---

## Related Documentation

- [Assertions Reference](../core-testing-api/assertions) — for in-depth coverage of GoogleTest assertions
- [Parameterized and Typed Tests](./parameterized-and-typed-tests) — for scaling test logic
- [Custom Event Listeners & Test Environment Hooks](../advanced-and-internal-utilities/custom-test-event-listeners) — for extending test reporting and lifecycle
- [GoogleMock for Dummies](../../guides/getting-started/using-googlemock) — complementary guide for using mocks in tests

---

## Source Code References

For examples and tests illustrating these concepts, you can explore:
- `googlemock/test/gmock_output_test_.cc` — shows GoogleMock tests usage, illustrating test macros
- `googlemock/test/gmock-nice-strict_test.cc` — shows mocks and testing fixture usage

<Source url="https://github.com/google/googletest" branch="main" paths='[{"path": "googlemock/test/gmock_output_test_.cc", "range": "1-220"}, {"path": "googlemock/test/gmock-nice-strict_test.cc", "range": "1-345"}]' />

---

**By mastering these core test macros and structures, you can effectively write, organize, and maintain robust C++ tests with GoogleTest, ensuring high code quality and maintainability.**