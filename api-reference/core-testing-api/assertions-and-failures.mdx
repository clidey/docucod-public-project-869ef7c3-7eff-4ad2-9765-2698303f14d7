---
title: "Assertions and Failure Handling"
description: "Master the wide array of assertion macros to validate your code, including success/failure, equality comparisons, custom predicates, and exception handling. This page details assertion results, fatal vs. non-fatal errors, and best practices for communicating intent in your tests."
---

# Assertions and Failure Handling

Master the wide array of assertion macros to validate your code, including success/failure, equality comparisons, custom predicates, and exception handling. This guide demystifies assertion results, clarifies fatal versus non-fatal errors, and offers best practices for expressing test intent with clear and actionable validation.

---

## Understanding Assertions

At the heart of GoogleTest lies a rich collection of assertions designed to validate code behavior effectively. Assertions communicate clear test expectations and provide precise diagnostic information when conditions are not met.

### Assertion Types

GoogleTest assertions are primarily divided into **fatal** and **non-fatal** categories:

| Type          | Macro Prefix | Behavior                                                           |
|---------------|--------------|--------------------------------------------------------------------|
| Fatal         | `ASSERT_`    | On failure, immediately aborts the current function’s execution.  |
| Non-fatal     | `EXPECT_`    | On failure, records the failure but continues execution.          |

This distinction empowers fine control over test flow. Use `ASSERT_` when continued execution would be meaningless or harmful. Use `EXPECT_` when you want to check multiple conditions and collect all failures in one test.

### Streaming Failure Messages

All assertion macros support streaming extra failure information using `<<`. This enables you to add custom, descriptive messages to aid debugging. For example:

```cpp
EXPECT_TRUE(my_condition) << "Expected my_condition to be true, but it was false";
```

### Explicit Success and Failure

GoogleTest provides explicit macros to indicate success or failure independently of condition checks:

- `SUCCEED()` generates a success. It is primarily documentary and does not make a test pass if previous failures occurred.
- `FAIL()` generates a fatal failure and aborts the current function.
- `ADD_FAILURE()` generates a non-fatal failure and allows the test to continue.
- `ADD_FAILURE_AT(file, line)` generates a non-fatal failure at a specified location.

---

## Common Assertion Macros

Below are categories of core assertions with typical usage:

### Boolean Conditions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)` — Succeeds if `condition` is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)` — Succeeds if `condition` is false.

### Binary Comparisons

Use these to compare two values with the respective comparison operator:

- Equality: `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
- Inequality: `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`
- Less Than: `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
- Less or Equal: `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
- Greater Than: `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
- Greater or Equal: `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

> **Tip:** Use `EXPECT_STREQ` and `EXPECT_STRNE` when comparing C strings rather than these, which only compare pointer addresses.

### String Comparisons

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)` — Verifies C strings have the same content.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)` — Verifies C strings have different content.
- Case-insensitive variants: `EXPECT_STRCASEEQ`, `EXPECT_STRCASENE`

### Floating-Point Comparisons

Due to rounding, use specialized macros:

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)` — Approximately equal floats.
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)` — Approximately equal doubles.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)` — Difference within absolute error.

### Exception Assertions

You can assert exception throwing behavior, if built with exceptions enabled:

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)` — Expects `statement` to throw `exception_type`.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)` — Expects `statement` to throw any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)` — Expects `statement` not to throw.

---

## Predicate Assertions

Checking complex logical expressions can be hard with basic assertions because failure messages may be uninformative.

### Using Predicate Macros

GoogleTest provides predicate assertions for functions or functors that return a boolean:

```cpp
EXPECT_PRED1(pred, val1);
EXPECT_PRED2(pred, val1, val2);
...
```

If the predicate returns `false`, the failure message will include the values of the arguments.

### Using AssertionResult for Rich Messages

For enhanced diagnostic messages, predicates can return `::testing::AssertionResult`:

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  else return testing::AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(3));  // Will print detailed failure info
```

### Predicate-Formatter Assertions

If you need full control over error formatting or your predicates cannot stream values directly, use predicate-formatter macros:

```cpp
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, val1, val2);
```

The predicate-formatter function receives expressions as strings and the argument values to compose custom failure messages.

---

## Fatal vs Non-Fatal Failures

When an assertion fails, it can be either fatal or non-fatal:

- **Fatal failures** immediately abort the current function (using `ASSERT_` and `FAIL()`). 
- **Non-fatal failures** log the failure but continue execution (`EXPECT_` and `ADD_FAILURE()`).

### Why This Matters

When writing helper functions that perform assertions, note that `ASSERT_*` only aborts the helper itself, but **not** the entire test. This can cause your test to continue in an undefined state.

To detect if your helper function caused fatal failures, you can use `HasFatalFailure()` after the call, and return early if it returns true:

```cpp
void Helper() {
  ASSERT_EQ(1, foo());
}

TEST(MyTest, Example) {
  Helper();
  if (HasFatalFailure()) return;
  ... // safe to continue
}
```

Alternatively, use `EXPECT_NO_FATAL_FAILURE()` / `ASSERT_NO_FATAL_FAILURE()` to check a statement does not generate fatal failures.

### Make Fatal Failures Behave Like Exceptions

GoogleTest can be configured to throw exceptions on fatal assertion failures by adding a special event listener. This allows easier propagation of fatal failures through helper functions but requires exception support.

---

## Adding Trace Information

When assertions fail inside helper functions, it can be hard to identify the call context.

GoogleTest provides the `SCOPED_TRACE(message)` macro, which adds the provided message to all failure messages in the enclosing lexical scope.

Example:

```cpp
void Sub(int n) {
  EXPECT_EQ(1, n);
  ASSERT_EQ(2, n);
}

TEST(Foo, Bar) {
  SCOPED_TRACE("First call");
  Sub(2);  // Failure messages here include "First call"

  Sub(3);  // No trace added here.
}
```

You can package loop indices or other context info into the message to clarify which iteration or call triggered the failure.

Also, multiple `SCOPED_TRACE`s can be nested and their messages will be combined in reverse order.

If you want to attach a trace at a specific file and line, use the `ScopedTrace` utility.

---

## Logging Additional Information

You can attach key-value properties to your tests or test suites with `RecordProperty(key, value)` to emit additional context in XML or JSON reports.

- `RecordProperty()` can be called inside tests, test suite setup/teardown, or even outside tests.
- Keys must not conflict with reserved XML attributes such as `name`, `status`, `time`, `classname`, etc.
- The last value recorded for a given key wins.

Example:

```cpp
TEST_F(WidgetUsageTest, MinMax) {
  RecordProperty("MaximumWidgets", ComputeMaxWidgets());
  RecordProperty("MinimumWidgets", ComputeMinWidgets());
}
```

This produces:

```xml
<testcase name="MinMax" classname="WidgetUsageTest" MaximumWidgets="12" MinimumWidgets="3" ... />
```

---

## Best Practices for Assertions

- Use `EXPECT_` macros if you want your test to continue after failure; use `ASSERT_` macros if continuing may cause harm or lead to confusing errors.
- Provide meaningful streamed messages with `<<` to clarify the cause of failure.
- Use predicate macros or functions returning `AssertionResult` for complex conditions to get better diagnostic messages.
- Use `SCOPED_TRACE` to add context to failures inside helper functions or loops.
- Avoid mixing fatal assertions within constructors or destructors; instead, use `SetUp()` and `TearDown()`.
- Check for fatal failures after subroutine calls with `HasFatalFailure()` when necessary.
- Use `RecordProperty()` to annotate tests for richer reporting.

---

For full API details and examples, see the [Assertions Reference](reference/assertions.md).

For advanced usage, see the [Advanced GoogleTest Topics](advanced.md#more-assertions).

For help writing death tests and handling exceptions, see [Death Tests and Errors](guides/beyond-basics/death-tests-and-errors.mdx).

---

### Additional Notes

- On platforms with exceptions enabled, GoogleTest can use exceptions to propagate fatal failures.
- Comparing floating-point values uses specialized macros to avoid pitfalls of exact equality.
- GoogleTest supports assertions testing thrown exceptions, including their types.
- `EXPECT_FATAL_FAILURE` and `EXPECT_NONFATAL_FAILURE` macros help in verifying expected failure outcomes within test utilities.

---