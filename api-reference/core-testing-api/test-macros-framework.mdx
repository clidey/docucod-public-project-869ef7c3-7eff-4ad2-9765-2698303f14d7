---
title: "Test Macros and Suite Framework"
description: "Introduces macros and structures to define and organize tests and test suites, including the TEST, TEST_F, and TEST_P macros. Covers the lifecycle of test execution, test discovery, and the fundamental classes (Test, TestSuite, UnitTest) that manage test logic and reporting. Clarifies integration entrypoints in user code."
---

# Test Macros and Suite Framework

GoogleTest provides a robust set of macros and classes designed to define, organize, and execute tests and test suites in a structured manner. This page introduces the primary macros — `TEST`, `TEST_F`, and `TEST_P` — that enable you to write tests, describe test lifecycle management through core classes, and integrate your test executable with the GoogleTest framework.

---

## Core Test Macros

### `TEST` - Defining Simple Tests

The `TEST` macro creates an individual test function that belongs to a named test suite. It is ideal for simple tests that do not share common setup or teardown logic.

```cpp
TEST(TestSuiteName, TestName) {
  // Your test code goes here
  ... 
}
```

- **TestSuiteName**: Groups related tests.
- **TestName**: The specific test case within the suite.

**Important:** Both arguments must be valid C++ identifiers without underscores (`_`). Tests with identical `TestName` can exist in different suites.


### `TEST_F` - Tests With Fixtures

Use `TEST_F` when multiple tests need to share setup, teardown, or common data objects through a test fixture class.

```cpp
class MyFixture : public ::testing::Test {
 protected:
  void SetUp() override {
    // Setup code shared across tests
  }
  void TearDown() override {
    // Cleanup code
  }
  // Members for use by tests
  int shared_resource_;
};

TEST_F(MyFixture, Test1) {
  // Test using shared fixture
  EXPECT_EQ(shared_resource_, expected_value);
}

TEST_F(MyFixture, Test2) {
  // Another test using the same fixture
}
```

- The first argument: the fixture class name, which **also** becomes the test suite name.
- Ensures a fresh fixture object is created for each test, isolating tests from each other.

### `TEST_P` - Value-Parameterized Tests

This macro supports tests that run repeatedly with different input parameters, enabling powerful data-driven test patterns.

```cpp
class MyParamTest : public ::testing::TestWithParam<int> {
  // Fixture with parameter type
};

TEST_P(MyParamTest, DoesSomething) {
  int value = GetParam();
  EXPECT_TRUE(IsValid(value));
}

INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyParamTest,
    ::testing::Values(1, 2, 3));
```

- Test code can access parameters via `GetParam()`.
- Use `INSTANTIATE_TEST_SUITE_P` to provide different parameter sets.
- Useful for testing varied inputs without duplicating code.


### Instantiating Parameterized Tests

Use `INSTANTIATE_TEST_SUITE_P` to generate concrete test instances from a parameterized test suite.

```cpp
INSTANTIATE_TEST_SUITE_P(InstantiationName, TestSuiteName, ParamGenerator);
```

- The first argument is a unique prefix identifying this instantiation.
- `ParamGenerator` can produce a sequence of values using GoogleTest facilities like:
  - `Range(start, end [, step])`
  - `Values(v1, v2, ..., vN)`
  - `ValuesIn(container)`
  - `Bool()`
  - `Combine(g1, g2, ...)`
- A custom name generator lambda or function can be given to create clearer test instance names.


### Typed Tests and Type-Parameterized Tests

GoogleTest also supports testing the same logic against multiple types (not just values) using `TYPED_TEST_SUITE` and `TYPED_TEST`. Type-parameterized tests (`TYPED_TEST_SUITE_P` and `TYPED_TEST_P`) extend this capability for defining abstract test suites instantiated later with concrete types.


### `FRIEND_TEST` - Testing Private Code

Use within a class to declare a test as a friend, giving the test access to private members.

```cpp
class MyClass {
  friend class MyClassTest;
  FRIEND_TEST(MyClassTest, PrivateMethodTest);
  // ...
};

TEST_F(MyClassTest, PrivateMethodTest) {
  // Can access MyClass private members
}
```

---

## Test Lifecycle and Core Classes

GoogleTest manages test execution and reporting via fundamental classes:

### `testing::Test`

- Base class for all tests.
- Defines lifecycle hooks:
  - `SetUpTestSuite()`: static method to prepare resources before first test in suite.
  - `TearDownTestSuite()`: static method to cleanup after suite finishes.
  - `SetUp()`: called before each test method.
  - `TearDown()`: called after each test method.

Tests are executed by creating a new instance of the test fixture (or `Test` for `TEST`), running `SetUp()`, then `TestBody()`, followed by `TearDown()`, and finally deleting the fixture.

### `testing::TestSuite`

- Represents a test suite (collection of related tests).
- Provides methods to query test counts, failures, elapsed time, etc.
- Tracks test execution and results at suite level.

### `testing::TestInfo`

- Contains metadata about an individual test, including:
  - Test suite name
  - Test name
  - File and line number
  - Type or value parameters (for parameterized/typed tests)
  - Test result (success, failure, skip)

### `testing::UnitTest`

- Singleton representing the entire test program.
- Provides aggregate statistics and runtime state.
- Facilitates access to currently running test and test suite.


---

## Test Discovery and Execution Entrypoints

To run tests, your program typically should:

1. Initialize GoogleTest with command-line arguments using `testing::InitGoogleTest(&argc, argv);`.
2. Call `RUN_ALL_TESTS()` in your `main()` function.

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

- `InitGoogleTest` performs flag parsing and library initialization.
- `RUN_ALL_TESTS` automatically executes all registered tests and returns 0 if all pass or 1 otherwise.
- GoogleTest automatically registers all tests defined with macros.

---

## Best Practices and Caveats

- Avoid underscores in test suite and test names. Underscores interfere with internal GoogleTest machinery due to generated class names.
- For complex fixtures that share expensive resources, implement `SetUpTestSuite` and `TearDownTestSuite` static methods.
- Each test runs with a fresh fixture instance to ensure independence; do not rely on state being preserved between tests.
- When defining parameterized tests, ensure you instantiate them appropriately or suppress instantiation warnings with `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`.
- Use `SCOPED_TRACE` to aid debugging by adding contextual traces.

---

## Summary of Important Macros

| Macro                                  | Purpose                                       |
|---------------------------------------|-----------------------------------------------|
| `TEST(TestSuiteName, TestName)`       | Defines a simple test function                 |
| `TEST_F(FixtureName, TestName)`       | Defines a test using a fixture class           |
| `TEST_P(FixtureName, TestName)`       | Defines a value-parameterized test              |
| `INSTANTIATE_TEST_SUITE_P(...)`       | Instantiates parameterized tests with values   |
| `TYPED_TEST_SUITE(Fixture, Types)`    | Defines typed tests for multiple types          |
| `TYPED_TEST(Fixture, TestName)`       | Defines a typed test function                    |
| `FRIEND_TEST(TestSuite, TestName)`   | Declares a test as friend to access private code|
| `GTEST_SKIP()`                        | Skips executing the current test at runtime     |

---

## Sample Usage

```cpp
#include <gtest/gtest.h>

// Simple test
TEST(MathTest, Addition) {
  EXPECT_EQ(2 + 2, 4);
}

// Test fixture
class QueueTest : public testing::Test {
 protected:
  void SetUp() override {
    queue_.Enqueue(1);
  }

  Queue<int> queue_;
};

TEST_F(QueueTest, IsNotEmpty) {
  EXPECT_FALSE(queue_.IsEmpty());
}

// Parameterized test
class PrimeTest : public testing::TestWithParam<int> {};

TEST_P(PrimeTest, IsPrime) {
  int n = GetParam();
  EXPECT_TRUE(IsPrime(n));
}

INSTANTIATE_TEST_SUITE_P(
    PrimeTests, PrimeTest,
    testing::Values(2, 3, 5, 7, 11));

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

## Troubleshooting

- **Error: no matching function for call to `FooTest::FooTest()`**
  - GoogleTest requires a default constructor in your fixture. Define one explicitly if you have other constructors.

- **Tests not running or filtered out**
  - Check for typos and ensure you do not prefix names with underscores.
  - Validate command line filters or environment variables.

- **Parameterized tests not being instantiated**
  - Ensure calls to `INSTANTIATE_TEST_SUITE_P` are present.
  - Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings if intentional.

- **Private member access denied**
  - Use `FRIEND_TEST` inside the class to declare the test as a friend.

- **Failure to detect tests**
  - Ensure `InitGoogleTest` and `RUN_ALL_TESTS` are called properly from `main()`.


---

## Event Listener API

For advanced users, GoogleTest exposes an **event listener interface** via `TestEventListener` and `TestEventListeners` classes, enabling monitoring and customization of test execution flow, results, and reporting.

### Basic usage

Extend `TestEventListener` or subclass `EmptyTestEventListener` to override only needed events:

```cpp
class MyListener : public ::testing::EmptyTestEventListener {
  void OnTestStart(const ::testing::TestInfo& info) override {
    // Custom behavior at test start
  }
  void OnTestPartResult(const ::testing::TestPartResult& result) override {
    // Respond to assertion failures or success
  }
};

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  auto& listeners = ::testing::UnitTest::GetInstance()->listeners();
  listeners.Append(new MyListener());
  return RUN_ALL_TESTS();
}
```

### Supported events include:

- Test program, iteration, environment setup and teardown
- Test suite start and end
- Individual test start, end, and assertion results

---

## Exploring Test Metadata at Runtime

GoogleTest exposes APIs to query the current test and suite information at runtime:

```cpp
const ::testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();
if (test_info) {
  std::cout << "Running test: " << test_info->test_suite_name()
            << "." << test_info->name() << std::endl;
}
```

This allows dynamic behaviors based on active test context (e.g., adjusting logging or data paths).

---

For detailed guidelines, advanced usage, and specific examples, refer to the related [GoogleTest Primer](../primer.md), [Assertions Reference](../reference/assertions.md), and [Advanced Topics](../advanced.md) documentation.

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "googletest/include/gtest/gtest.h", "range": "10-525"},{"path": "googletest/include/gtest/gtest-param-test.h", "range": "25-300"}]} />