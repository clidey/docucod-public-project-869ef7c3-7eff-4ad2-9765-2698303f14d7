---
title: "Value- and Type-Parameterized Tests"
description: "A practical reference for leveraging GoogleTest's parameterized testing APIs. Explore tools for running tests over multiple values or types, including key macros, registration patterns, and usage scenarios."
---

# Value- and Type-Parameterized Tests

Explore how to leverage GoogleTest's powerful APIs to write tests that run over multiple values or types, enabling broad, maintainable coverage with less code duplication. This page presents practical guidance on defining parameterized test fixtures, writing test cases that use parameters, registering test instances, and employing the key macros and idioms critical to unlock parameterized testing.

---

## Introduction to Parameterized Tests

Parameterized tests in GoogleTest let you write a test logic once and run it against different inputs or types. This approach encourages DRY (Don't Repeat Yourself) principles in tests and exposes a wide range of cases with minimal boilerplate.

There are two primary classes of parameterized tests offered by GoogleTest:

- **Value-Parameterized Tests:** Execute the same test logic repeatedly with different values, such as integers, strings, or custom structs.
- **Type-Parameterized Tests:** Run tests over a list of types, useful for template-based code testing.

Together, these enable comprehensive validation of code that behaves differently depending on input data or template types.

## Value-Parameterized Tests

### Defining a Value-Parameterized Test Fixture

To create a value-parameterized test:

1. Derive a test fixture from `::testing::TestWithParam<T>`, where `T` is the parameter type.
2. Use the `TEST_P` macro to write one or more test cases that access the parameter via `GetParam()`.

Example:

```cpp
#include <gtest/gtest.h>

// Define a test fixture with int as parameter.
class FactorialTest : public ::testing::TestWithParam<int> {};

// Write a test that uses the parameter.
TEST_P(FactorialTest, ComputesFactorial) {
  int n = GetParam();
  // Example assertion - implement factorial and test
  EXPECT_GE(n, 0);
  // ... actual factorial checks
}
```

### Instantiating Parameter Sets

After defining `TEST_P` tests, you must instantiate them using `INSTANTIATE_TEST_SUITE_P`.

This macro binds a unique instantiation name and a parameter generator to your test suite:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NonNegativeNumbers,     // Instantiation name
    FactorialTest,          // Test fixture name
    ::testing::Values(0, 1, 2, 3, 10));  // Parameter values
```

You can use many built-in generators:

- `Values(...)`: specify explicit values.
- `ValuesIn(container)`: use a container of values.
- `Range(begin, end, step)`: generate numeric ranges.
- `Bool()`: yields {false, true}.

With this, the `ComputesFactorial` test runs multiple times with each parameter value.

### Accessing Parameters

Within `TEST_P`, parameters are accessed via `GetParam()`. It returns a const reference to the parameter type passed in `TestWithParam<T>`.

For multiple parameters, you can use tuples or structs as the parameter type.

Example with tuple:

```cpp
using ::testing::TestWithParam;
using ::testing::Combine;

class MyTest : public TestWithParam<std::tuple<int, std::string>> {};

TEST_P(MyTest, Works) {
  int n = std::get<0>(GetParam());
  std::string str = std::get<1>(GetParam());
  // Test using n and str
}

INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTest,
    Combine(::testing::Range(1, 3), ::testing::Values("foo", "bar")));
```

### Naming Parameterized Tests

By default, GoogleTest generates readable test names by appending parameter values. For more control, you can supply a custom name generator functor or lambda as the fourth argument to `INSTANTIATE_TEST_SUITE_P`. The name generator accepts a `TestParamInfo` and returns a string, which is then used as a test suffix.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTest,
    ::testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<int>& info) {
      return "Param_" + std::to_string(info.param);
    });
```

### Using `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`

If you declare a `TEST_P` but do not instantiate it, GoogleTest considers this an error by default. To suppress this, use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(FixtureName)` to permit uninstantiated parameterized suites, which is useful for templated test fixtures or external instantiations.

## Type-Parameterized Tests

Type-parameterized tests run the same test logic over different types, ideal for templated classes or functions.

### Defining a Typed Test Suite

1. Define a test fixture class template:

```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
  // Type-specific setup...
};
```

2. Register the type list:

```cpp
using Implementations = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(FooTest, Implementations);
```

3. Write typed tests using `TYPED_TEST`:

```cpp
TYPED_TEST(FooTest, DoesSomething) {
  using T = TypeParam;  // Current test's type parameter
  // Test logic using T
}
```

### Type-Parameterized Test Parallel to Value-Parameterized

Typed tests operate on types rather than values. They run differently but offer similar reuse benefits. 

### Type-Parameterized Tests with `TYPED_TEST_SUITE_P` (Advanced)

`TYPED_TEST_SUITE_P` allows type-parameterized test suites to be defined without specifying the type list upfront. Type lists and tests can be registered separately and instantiated later. See [Typed Tests](../advanced.md#typed-tests) for detailed usage.

## Macro Summary

| Macro                            | Purpose                                   |
|---------------------------------|-------------------------------------------|
| `TEST_P(TestSuite, TestName)`    | Defines a parameterized test case         |
| `INSTANTIATE_TEST_SUITE_P(Name, TestSuite, Generator)` | Instantiate parameter set for a test suite |
| `TYPED_TEST_SUITE(Fixture, Types)` | Declares a type-parameterized test suite   |
| `TYPED_TEST(Fixture, TestName)` | Defines a typed test case                   |
| `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(Fixture)` | Suppresses uninstantiated parameter suite error |

## Practical User Flow: Adding Parameterized Tests

1. Identify test cases with repeated logic but varied input data or types.
2. Create a test fixture deriving from `TestWithParam<T>` for value param or a template for typed tests.
3. Write parameterized tests using `TEST_P` or `TYPED_TEST` accessing parameters via `GetParam()` or `TypeParam`.
4. Instantiate parameter sets using `INSTANTIATE_TEST_SUITE_P` or register type lists with `TYPED_TEST_SUITE`.
5. Execute tests and verify results over all parameters.

## Best Practices and Tips

- **Minimize boilerplate** by grouping related parameter scenarios in value-param tests.
- **Use tuples or structs** to bundle multiple parameters neatly.
- **Leverage type-param tests** for templated code testing over variants.
- **Name your instantiations clearly** to differentiate test runs in reports.
- **Combine with test fixtures** to share setup across tests with parameterized input.
- **Avoid overly complex parameter generation**; use generators thoughtfully to keep test maintainability.
- **Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`** for templated test fixtures used in external instantiations.

## Common Pitfalls

- Forgetting to instantiate parameterized tests with `INSTANTIATE_TEST_SUITE_P` results in no tests run.
- Omitting `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` when defining templated fixtures without immediate instantiations causes errors.
- Misusing `GetParam()` outside of `TEST_P` context or using `TypeParam` outside typed tests leads to compilation errors.
- Writing parameter names with underscores violates macro argument requirements; use valid identifiers.

## Example: Full Value-Parameterized Test

```cpp
#include <gtest/gtest.h>

// Test fixture with int parameter.
class IsEvenTest : public ::testing::TestWithParam<int> {};

// Test checks if parameter is even.
TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

// Instantiate tests with multiple values.
INSTANTIATE_TEST_SUITE_P(
    Evens, IsEvenTest,
    ::testing::Values(2, 4, 6, 8));
```

## Example: Full Type-Parameterized Test

```cpp
#include <gtest/gtest.h>

template <typename T>
class NumericLimitsTest : public ::testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, HasNonNegativeMin) {
  EXPECT_GE(std::numeric_limits<TypeParam>::min(), 0);
}
```

---

## Related Documentation

- [Test Fixtures and Test Cases](/api-reference/core-testing-api/test-fixtures-api) for background on writing tests in GoogleTest
- [Testing Reference](reference/testing.md) for details on the test macros like `TEST`, `TEST_F`, and `TEST_P`
- [Mocking Cookbook](gmock_cook_book.md) to integrate mocking with parameterized tests
- [Assertions Reference](reference/assertions.md) to verify test outcomes
- [Core Concepts and Terminology](/overview/core-concepts-architecture/core-concepts-terminology) for an overview of GoogleTest features

<Tip>
To get started quickly, define your parameterized fixture with `TestWithParam<T>`, write tests using `TEST_P`, and instantiate parameters with `INSTANTIATE_TEST_SUITE_P`. This simple pattern yields powerful, data-driven test coverage.
</Tip>

<Warning>
Parameter types must be copyable or movable. If your test parameter is complex or non-copyable, consider wrapping it in a shared pointer or using simplified surrogate data.
</Warning>

---

## Troubleshooting

### No Tests Run

- Confirm that you have instantiated your parameterized tests using `INSTANTIATE_TEST_SUITE_P`.
- Verify that the parameter generator is correctly defined and produces values.

### Compilation Errors with `GetParam()` or `TypeParam`

- Ensure `GetParam()` is only used within `TEST_P` or test fixture classes deriving from `TestWithParam`.
- Ensure `TypeParam` is only used within `TYPED_TEST` bodies, where a typed test suite is properly registered.

### Naming Conflicts or Invalid Test Names

- Do not include underscores or invalid characters in instantiation or test names.
- Use a name generator function if your parameter names require formatting.

### Uninstantiated Parameterized Test Warning

- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress this warning for templated test fixtures.

---

## Summary

Value- and type-parameterized tests are essential tools for writing reusable, scalable, and maintainable C++ tests with GoogleTest. By writing your tests to consume varying parameters or types, you expand test coverage with minimal effort and improve clarity.

Harness these APIs by defining parameterized fixtures, writing parameterized test cases, and registering your tests with appropriate instantiations.

For advanced usages like multiple parameters, custom naming, or mixed types and values, refer to the detailed GoogleTest documentation and guides.

---

## Additional Resources

- [GoogleTest Primer](../primer.md) for fundamentals
- [Value-Parameterized Tests](../advanced.md#value-parameterized-tests) for deeper insights
- [Typed Tests](../advanced.md#typed-tests) for advanced type parameterization
- [GoogleMock for Dummies](gmock_for_dummies.md) to mock alongside parameterized tests
- [gMock Cookbook](gmock_cook_book.md) for recipes combining parameterized tests with mocks


