---
title: "Matchers API"
description: "Explains the core and advanced matchers available for expressive assertions, including standard, custom, and composite matchers. Includes practical code snippets for validating container contents, ranges, and user-defined types."
---

# Matchers API

GoogleTest's Matchers API empowers you to write expressive and readable assertions by leveraging a rich collection of core, custom, and composite matchers. This documentation page unpacks the use of these matchers to validate a wide variety of objects including primitive types, containers, numeric ranges, and user-defined types. Through practical examples, discover how to assert intricate conditions effortlessly, enhancing the clarity and robustness of your tests.

---

## Table of Contents

- [Overview of Matchers](#overview-of-matchers)
- [Core Matchers](#core-matchers)
- [Custom Matchers](#custom-matchers)
- [Composite Matchers](#composite-matchers)
- [Matchers for Containers](#matchers-for-containers)
- [Matchers for Numeric Ranges](#matchers-for-numeric-ranges)
- [Validating User-Defined Types](#validating-user-defined-types)
- [Practical Usage Examples](#practical-usage-examples)
- [Best Practices](#best-practices)
- [Troubleshooting Common Issues](#troubleshooting-common-issues)

---

## Overview of Matchers

Matchers provide a declarative way to specify the expected properties of function arguments or values in assertions. Instead of testing raw values or Boolean expressions, matchers allow your tests to state intent in a readable, flexible, and maintainable manner.

Matchers can be:

- **Standard Matchers**: Built-in matchers covering common checks like equality, inequalities, null pointers, and strings.
- **Custom Matchers**: User-defined matchers tailored to domain-specific properties or invariants.
- **Composite Matchers**: Composed matchers built from simpler ones, to express complex logical predicates.

Matchers always play well with GoogleTest assertions such as `EXPECT_THAT` and `ASSERT_THAT`, providing clear failure messages that explain precisely where expectations were unmet.

---

## Core Matchers

Core matchers cover basic predicates and checks common in most tests:

- **Wildcard matcher:** `_` accepts any value.
- **Equality matchers:** `Eq(value)`, `Ne(value)` for equality and inequality.
- **Comparison matchers:** `Lt()`, `Le()`, `Gt()`, `Ge()` for less than, less or equal, greater than, and greater or equal.
- **Boolean condition matchers:** `IsTrue()`, `IsFalse()`.
- **Null pointer matchers:** `IsNull()` and `NotNull()`.
- **String matchers:** `StartsWith(prefix)`, `EndsWith(suffix)`, `HasSubstr(substring)`.
- **Floating-point comparators:** `DoubleEq()`, `FloatEq()`, `NanSensitiveDoubleEq()`, and related variants for approximate comparisons.

### Example

```cpp
EXPECT_THAT(value, Eq(42));
EXPECT_THAT(ptr, NotNull());
EXPECT_THAT(text, StartsWith("Hello"));
```

---

## Custom Matchers

When built-in matchers cannot express your test's intent, defining custom matchers is straightforward with GoogleTest's `MATCHER` macros or by implementing matcher classes.

### Creating a Basic Custom Matcher

```cpp
MATCHER(IsEven, "checks if a number is even") {
  return (arg % 2) == 0;
}
```

Using it:

```cpp
EXPECT_THAT(num, IsEven());
```

### Parameterized Matchers

You can add parameters for flexibility:

```cpp
MATCHER_P(InRange, range, "value in range") {
  return arg >= range.first && arg <= range.second;
}

// Usage
EXPECT_THAT(x, InRange(std::make_pair(1, 10)));
```

### Defining Matcher Classes

For advanced cases, implement `MatchAndExplain`, `DescribeTo`, and `DescribeNegationTo`. This method gives complete control over matching logic and error messages.

---

## Composite Matchers

Combine simple matchers into complex assertions:

- **Logical AND:** `AllOf(m1, m2, ...)` succeeds if all sub-matchers do.
- **Logical OR:** `AnyOf(m1, m2, ...)` succeeds if any sub-matcher does.
- **Negation:** `Not(matcher)` succeeds if the matcher does not.
- **Conditional:** `Conditional(condition, m_true, m_false)` chooses matcher based on a Boolean.

### Example

```cpp
EXPECT_THAT(value, AllOf(Ge(0), Le(100), Not(Eq(50))));
```

---

## Matchers for Containers

Matchers excel when validating STL containers or other iterable types.

- **ElementsAre(...)**: Requires exact element sequence matching.
- **UnorderedElementsAre(...)**: Matches elements regardless of order.
- **ElementsAreArray(container_or_array)**: Matches elements like `ElementsAre` but from a container or array.
- **UnorderedElementsAreArray(...)**: Unordered variant of `ElementsAreArray`.
- **Contains(matcher)**: Checks if container has an element matching the matcher.
- **Each(matcher)**: Checks if *all* elements match.
- **SizeIs(matcher)**: Checks container size.
- **Pointwise(pair_matcher, container)**: Matches each element against a pair matcher combined with elements in another container.
- **IsSubsetOf(...) / IsSupersetOf(...)**: Assert subset or superset relations with unordered matchers.

### Pair Matchers for Maps

- **Key(matcher)**: Matches the `first` element of a pair.
- **Pair(key_matcher, value_matcher)**: Matches both `first` and `second` elements.

### Example

```cpp
EXPECT_THAT(vec, ElementsAre(1, Ge(5), _));
EXPECT_THAT(set, UnorderedElementsAre(1, 3, 2));
EXPECT_THAT(map, Contains(Pair(Eq("foo"), Gt(10))));
```

---

## Matchers for Numeric Ranges

GoogleTest provides matchers for robust numeric condition checks:

- `InRange(low, high)` - matches values within a range (parametrized matcher).
- `DistanceFrom(target, matcher)` - matches valueâ€™s distance from `target` as per the provided matcher.
- Built-in comparison predicates: `Ge()`, `Gt()`, `Le()`, `Lt()`, etc.

### Example

```cpp
EXPECT_THAT(num, InRange(10, 20));
EXPECT_THAT(value, DistanceFrom(5, Le(2)));  // value within 2 units of 5
```

---

## Validating User-Defined Types

For structs, classes, and complex objects, GoogleTest allows matching on members or properties using:

- **Field(&Class::member, matcher)**: Matches specific member variables.
- **Property(&Class::getter, matcher)**: Matches return values from getters.
- **FieldsAre(m1, m2, ...)**: Matches tuple-like fields of aggregates or tuples, in order.
- **ResultOf(callable, matcher)**: Matches the result of a function or functor applied to the value.

These enable precise, readable validation of object state within expectations.

### Example

```cpp
struct Point { int x; int y; };
EXPECT_THAT(p, Field(&Point::x, Eq(10)));
EXPECT_THAT(p, FieldsAre(Ge(0), Le(5)));
```

---

## Practical Usage Examples

### 1. Validating Container Contents

```cpp
using ::testing::ElementsAre;

std::vector<int> v = {1, 2, 3};
EXPECT_THAT(v, ElementsAre(1, 2, 3));
```

### 2. Matching Elements Unordered

```cpp
using ::testing::UnorderedElementsAre;

std::set<int> s = {3, 1, 2};
EXPECT_THAT(s, UnorderedElementsAre(1, 2, 3));
```

### 3. Validating Map Keys and Values

```cpp
using ::testing::Contains;
using ::testing::Pair;

std::map<std::string, int> m = {{"a", 1}, {"b", 2}};
EXPECT_THAT(m, Contains(Pair("a", 1)));
```

### 4. Using Composite Matchers

```cpp
using ::testing::AllOf;
using ::testing::Gt;
using ::testing::Lt;

EXPECT_THAT(7, AllOf(Gt(5), Lt(10)));
```

### 5. Custom Matcher Example

```cpp
MATCHER_P(IsMultipleOf, factor, "is multiple of factor") {
  return arg % factor == 0;
}

EXPECT_THAT(10, IsMultipleOf(5));
```

---

## Best Practices

- Use `_` (wildcard) matcher sparingly to avoid overly broad tests.
- Prefer specifying only the necessary matchers that matter for the test.
- Use `ON_CALL` to define default mock behaviors, and `EXPECT_CALL` for setting actual invocation expectations.
- Compose matchers with `AllOf` and `AnyOf` for clear intention expression.
- When matching containers, choose `ElementsAre` if order matters, else `UnorderedElementsAre`.
- Use `RetiresOnSaturation()` for expectations that should disable after they have completed their expected calls to avoid confusion.
- Create custom matchers for reusable domain-specific logic, improving legibility and error diagnostics.

---

## Troubleshooting Common Issues

### Comma in Types when Using `MOCK_METHOD`

If your method signature involves types with unprotected commas (e.g., `std::pair<bool,int>`), enclose the type in parentheses or use `using` aliases:

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());

// or
using BoolInt = std::pair<bool, int>;
MOCK_METHOD(BoolInt, GetPair, ());
```

### Unexpected Uninteresting Call Warnings

Use `NiceMock<YourMock>` to suppress warnings on uninteresting calls when you intentionally don't care about certain mock interactions.

### Failure When Not Setting Default Actions

Ensure every `ON_CALL` has a `.WillByDefault(...)` clause; otherwise, calls without expectations trigger runtime errors.

### Handling Overloaded Methods

Use `Const()` or explicit cast to disambiguate overloaded methods in expectations.

### Too Many or Too Few Actions vs Times

Remember the number of `WillOnce` clauses and `Times()` must align. Use `RetiresOnSaturation()` to retire expectations after saturation.

---

For detailed usage, error patterns, and advanced matcher creation, refer to the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) and the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html).

---