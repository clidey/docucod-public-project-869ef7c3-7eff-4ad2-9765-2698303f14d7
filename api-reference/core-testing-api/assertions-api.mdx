---
title: "Assertions and Predicates"
description: "Reference for all built-in assertions provided by GoogleTest, including equality, inequality, exception, floating-point, and predicate assertions. Details assertion macros, result handling (fatal vs. non-fatal), and guides users on defining custom assertions for greater flexibility."
---

# Assertions and Predicates Reference

This documentation provides a comprehensive reference to all built-in assertions available in GoogleTest. These assertions help you verify your C++ code behavior effectively, covering equality, inequality, exceptions, floating-point comparisons, predicate assertions, and more.

---

## Overview of Assertions

GoogleTest assertions come in pairs: `EXPECT_` macros produce non-fatal failures that allow test execution to continue, while `ASSERT_` macros produce fatal failures and abort the current test function immediately. You can append custom failure messages to any assertion using streaming with `<<`.

Assertions evaluate their arguments exactly once and provide rich failure reporting, including values and contextual information.

---

## Explicit Success and Failure

### `SUCCEED()`

Generate an explicit success. Useful for documenting that a particular code path was reached. Does not affect test outcome by itself.

```cpp
SUCCEED();
SUCCEED() << "Step completed successfully.";
```

### `FAIL()`

Generate a fatal failure causing the current function to return immediately.

```cpp
if (value == 0) {
  FAIL() << "Value must not be zero.";
}
```

### `ADD_FAILURE()`

Generate a non-fatal failure allowing test continuation.

```cpp
if (x < 0) {
  ADD_FAILURE() << "Negative values are not allowed.";
}
```

### `ADD_FAILURE_AT(file, line)`

Generate a non-fatal failure at a specific file and line.

---

## Boolean Condition Assertions

Verify conditions that evaluate to true or false.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

Example:

```cpp
EXPECT_TRUE(IsValid(input)) << "Input is invalid.";
ASSERT_FALSE(has_error) << "Unexpected error occurred.";
```

For better failure diagnostics with predicates, see the Predicate Assertions section.

---

## Binary Comparison Assertions

Compare two values using relational operators and print detailed failure messages.
All arguments must be comparable by the operator used.

| Macro           | Description                |
|-----------------|----------------------------|
| `EXPECT_EQ(a,b)` / `ASSERT_EQ(a,b)` | `a == b` |
| `EXPECT_NE(a,b)` / `ASSERT_NE(a,b)` | `a != b` |
| `EXPECT_LT(a,b)` / `ASSERT_LT(a,b)` | `a < b`  |
| `EXPECT_LE(a,b)` / `ASSERT_LE(a,b)` | `a <= b` |
| `EXPECT_GT(a,b)` / `ASSERT_GT(a,b)` | `a > b`  |
| `EXPECT_GE(a,b)` / `ASSERT_GE(a,b)` | `a >= b` |

Notes:
- Pointer arguments perform pointer equality for `EQ`/`NE`.
- For C strings, use string comparison assertions instead.

Example:

```cpp
EXPECT_EQ(Size(), expected_size) << "Size mismatch.";
ASSERT_LT(value, max_value) << "Value exceeded maximum.";
```

---

## String Comparison Assertions

Compare C-style strings or wide strings by content, not pointer.

| Macro               | Description                                    |
|---------------------|------------------------------------------------|
| `EXPECT_STREQ(a,b)` / `ASSERT_STREQ(a,b)` | C strings equal                          |
| `EXPECT_STRNE(a,b)` / `ASSERT_STRNE(a,b)` | C strings not equal                      |
| `EXPECT_STRCASEEQ(a,b)` / `ASSERT_STRCASEEQ(a,b)` | C strings equal, ignoring case   |
| `EXPECT_STRCASENE(a,b)` / `ASSERT_STRCASENE(a,b)` | C strings not equal, ignoring case |

Example:

```cpp
EXPECT_STREQ(GetName(), "default") << "Name is incorrect.";
ASSERT_STRCASEEQ(user_input, "YES") << "Input should be YES or yes.";
```

Wide strings (`wchar_t*`) are supported equivalently and printed as UTF-8.

---

## Floating-Point Comparison Assertions

Because floating-point equality is tricky due to rounding, GoogleTest supports approximate comparisons:

### `EXPECT_FLOAT_EQ(a,b)` / `ASSERT_FLOAT_EQ(a,b)`

Asserts float results are approximately equal within 4 ULPs.

### `EXPECT_DOUBLE_EQ(a,b)` / `ASSERT_DOUBLE_EQ(a,b)`

Asserts double results are approximately equal within 4 ULPs.

### `EXPECT_NEAR(a,b,abs_error)` / `ASSERT_NEAR(a,b,abs_error)`

Asserts the difference between `a` and `b` does not exceed `abs_error`.

Example:

```cpp
EXPECT_FLOAT_EQ(ComputePi(), 3.14159f);
ASSERT_NEAR(CalculateValue(), expected, 0.001);
```


---

## Exception Assertions

Require exceptions to be enabled in your build. You can test that code throws or does not throw exceptions.

| Macro                | Description                         |
|----------------------|-----------------------------------|
| `EXPECT_THROW(stmt, exc_type)` / `ASSERT_THROW(stmt, exc_type)` | Assert that statement throws exception of type. |
| `EXPECT_NO_THROW(stmt)` / `ASSERT_NO_THROW(stmt)` | Assert that statement throws no exception. |
| `EXPECT_ANY_THROW(stmt)` / `ASSERT_ANY_THROW(stmt)` | Assert statement throws any exception. |

Example:

```cpp
EXPECT_THROW(DoWork(), std::runtime_error);
ASSERT_NO_THROW(Initialize());
```


---

## Predicate Assertions

Use when you need to check complex conditions and want better diagnostic output than a simple `EXPECT_TRUE()`.

### Basic Predicate Assertions

Macros:

- `EXPECT_PRED1(pred, val1)` ... `EXPECT_PRED5(pred, val1, val2, ..., val5)`
- Corresponding `ASSERT_PRED*` variants

`pred` is a function or functor returning `bool`. Arguments are printed on failure.

Example:

```cpp
bool IsPositive(int x) { return x > 0; }
EXPECT_PRED1(IsPositive, value);
```

If `pred` is overloaded, cast to the precise function pointer type.

### Predicate Formatter Assertions

Macros:

- `EXPECT_PRED_FORMAT1(pred_func, val1)` ... `EXPECT_PRED_FORMAT5(pred_func, val1, ..., val5)`
- Corresponding `ASSERT_PRED_FORMAT*`

`pred_func` returns `testing::AssertionResult` and takes argument expressions as strings plus values, allowing customized failure messages.

Example:

```cpp
testing::AssertionResult AssertMutuallyPrime(const char* a_expr,
                                             const char* b_expr,
                                             int a, int b) {
  if (MutuallyPrime(a, b)) return testing::AssertionSuccess();
  return testing::AssertionFailure() << a_expr << " and " << b_expr
         << " are not mutually prime.";
}
EXPECT_PRED_FORMAT2(AssertMutuallyPrime, x, y);
```

---

## Generalized Assertion: Matchers

Use `EXPECT_THAT(value, matcher)` and `ASSERT_THAT(value, matcher)` to perform advanced matching with [GoogleMock matchers](../gmock/README.md).

Example:

```cpp
EXPECT_THAT(str, StartsWith("Hello"));
EXPECT_THAT(num, AllOf(Gt(0), Lt(10)));
```

---

## Windows HRESULT Assertions

On Windows, verify HRESULT success or failure with helpful message formatting.

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)`
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)`

---

## Skipping Test Execution

Use `GTEST_SKIP()` to skip tests or entire fixtures at runtime with custom messages.

```cpp
TEST(SkipTest, Skips) {
  GTEST_SKIP() << "Skipping test.";
}

class SkipFixture : public testing::Test {
 protected:
  void SetUp() override {
    GTEST_SKIP() << "Skipping all tests in this fixture.";
  }
};

TEST_F(SkipFixture, TestWillNotRun) {
  FAIL();  // Not reached
}
```

---

## Adding Traces to Assertions

Use `SCOPED_TRACE(message)` or `testing::ScopedTrace` to append contextual traces to failure messages for easier debugging, especially in helper functions or loops.

Example:

```cpp
SCOPED_TRACE("Loop iteration " << i);
EXPECT_EQ(DoSomething(i), expected);
```

---

## Propagating Fatal Failures

Fatal assertions abort the current function only. To detect fatal failures in subroutines:

- Use `ASSERT_NO_FATAL_FAILURE(statement)` / `EXPECT_NO_FATAL_FAILURE(statement)` to verify no fatal failure occurred in `statement`.
- Use `testing::Test::HasFatalFailure()` to check if any fatal failure occurred so far.

Example:

```cpp
void Subroutine() {
  ASSERT_EQ(foo, bar);
}

TEST(FooTest, Bar) {
  Subroutine();
  if (testing::Test::HasFatalFailure()) return;  // Abort test if Subroutine failed
  ...
}
```

---

## Using Assertions Outside `TEST` Functions

- Assertions that cause fatal failures (`ASSERT_*`, `FAIL()`) require void-returning contexts.

- Use non-fatal assertions (`EXPECT_*`, `ADD_FAILURE`) in constructors and destructors.

- To make fatal failures propagate through exceptions, add a failure listener that throws exceptions (advanced usage).

---

## Teaching GoogleTest How to Print Your Values

For custom types, GoogleTest prints values using `operator<<` or optionally:

- Define a friend `void PrintTo(const T& value, std::ostream* os)` in the same namespace.
- Define an `AbslStringify` overload.

Example:

```cpp
class Point {
  int x, y;
  template <typename Sink>
  friend void AbslStringify(Sink& sink, const Point& p) {
    absl::Format(&sink, "(%d, %d)", p.x, p.y);
  }
  friend void PrintTo(const Point& p, std::ostream* os) {
    *os << "(" << p.x << ", " << p.y << ")";
  }
};
```

Call `testing::PrintToString(value)` to print any value.

---

## Regular Expression Syntax in Death Tests

GoogleTest supports different regex dialects depending on platform:

- RE2 syntax when built with Bazel + Abseil.
- POSIX extended regex on most POSIX systems.
- Simplified regex on Windows.

Supported constructs include character classes, quantifiers (*, +, ?), anchors (^, $), and wildcards (.).

---

## Summary

This reference equips you with the knowledge to leverage assertions effectively in GoogleTest, customize diagnostics, and extend printing capabilities to fit your testing scenarios.

For comprehensive understanding, also refer to the [Assertions Reference](reference/assertions.md), [GoogleTest Primer](primer.md), and related guides on [Writing Your First Test](guides/core_workflows/writing_first_test.md) and [Using Assertions Effectively](guides/core_workflows/using_assertions_effectively.md).

---

## Example: Combining Assertion Types

```cpp
#include <gtest/gtest.h>

// Basic condition
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

// String comparison
TEST(NameTest, IsDefault) {
  const char* name = GetName();
  EXPECT_STREQ(name, "default") << "Name is incorrect.";
}

// Predicate assertion
bool IsPositive(int x) { return x > 0; }
TEST(CheckPositive, ValuePositive) {
  EXPECT_PRED1(IsPositive, value);
}

// Exception assertion
TEST(ExceptionTest, ThrowsRuntimeError) {
  EXPECT_THROW(DoSomethingBad(), std::runtime_error);
}

// Floating-point comparison
TEST(MathTest, ApproximatePi) {
  EXPECT_NEAR(ComputePi(), 3.14159, 0.0001);
}

// Skip example
TEST(SkipExample, SkipTest) {
  GTEST_SKIP() << "Not supported on this platform.";
  FAIL();  // Not executed
}
```
