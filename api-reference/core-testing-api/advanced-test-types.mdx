---
title: "Parameterized and Typed Tests"
description: "Describes the APIs for writing value-parameterized and type-parameterized tests, enabling users to run the same test logic with a variety of inputs or types. Covers relevant macros, test instantiation, and utilities for comprehensive, DRY testing."
---

# Parameterized and Typed Tests

GoogleTest provides powerful facilities to write tests that run the same logic with a variety of input data and types. This enables you to avoid duplicating test code while ensuring comprehensive coverage across different scenarios, configurations, or implementations.

This page explains how to use **value-parameterized tests** and **typed tests**, as well as **type-parameterized tests**, guiding you through the macros, test organization, and instantiation patterns.

---

## Value-Parameterized Tests

Value-parameterized tests let you run the same test code multiple times with different input values. This is helpful when you want to verify behavior across a range of inputs without writing multiple test functions.

### Creating a Value-Parameterized Test Fixture

1. Define a test fixture class derived from `testing::TestWithParam<T>`, where `T` is the type of your test parameter.

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // Define optional SetUp, TearDown, and any helper functions
};
```

2. Use the `TEST_P` macro to define test(s) that use this fixture. Access the parameter with `GetParam()`.

```cpp
TEST_P(MyParamTest, IsEven) {
  int param = GetParam();
  EXPECT_EQ(param % 2, 0);
}
```

### Instantiating Value-Parameterized Tests

Use the `INSTANTIATE_TEST_SUITE_P` macro to instantiate your test suite with a set of parameter values.

**Syntax:**

```cpp
INSTANTIATE_TEST_SUITE_P(
    InstantiationName, TestSuiteName, param_generator [, name_generator]);
```

- `InstantiationName` is an arbitrary unique name for this instantiation.
- `TestSuiteName` is the name of the test fixture class.
- `param_generator` is one of GoogleTest's parameter generator functions, such as `Values()`, `Range()`, `ValuesIn()`, or combined generators.
- `name_generator` (optional) is a callable to generate custom test names based on parameters.

### Parameter Generators (Examples)

| Generator | Description |
| --- | --- |
| `Values(v1, v2, ..., vN)` | Explicit values to test with. |
| `Range(start, end [, step])` | Sequence of values starting from `start` up to but not including `end`, stepping by `step`. |
| `ValuesIn(container)` | Parameters from a container or iterator range. |
| `Bool()` | Generates `false` and `true` values, handy for flags. |
| `Combine(g1, g2, ..., gN)` | Cartesian product of multiple generators producing tuples of parameter sets. |

### Example

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

TEST_P(FactorialTest, HandlesVariousInputs) {
  int n = GetParam();
  EXPECT_GE(Factorial(n), 1);
}

INSTANTIATE_TEST_SUITE_P(
    BasicTests, FactorialTest,
    testing::Values(0, 1, 2, 5, 10));
```

This will run the `HandlesVariousInputs` test for each value in `Values`.

---

## Typed Tests

Typed tests allow running the same test logic for multiple types. This is especially useful for testing template classes or generic interfaces.

### Defining Typed Tests

1. Define a fixture template by deriving from `testing::Test` and parameterizing it on a type `T`.

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```

2. Define a list of types to test with, using `testing::Types`.

```cpp
using MyTypes = testing::Types<int, char, double>;
```

3. Associate the fixture with the types using `TYPED_TEST_SUITE`.

```cpp
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

4. Define typed tests with `TYPED_TEST`, which can access the type under test via the symbolic name `TypeParam`.

```cpp
TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam n{};
  (void)n;  // Silence unused variable warning
  SUCCEED();
}
```

### Example

```cpp
template <typename T>
class StackTest : public testing::Test {
 protected:
  Stack<T> stack;
};

using MyStackTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(StackTest, MyStackTypes);

TYPED_TEST(StackTest, IsEmptyInitially) {
  EXPECT_TRUE(this->stack.empty());
}
```

### Custom Type Names

You can specify a type name generator class as a third argument to `TYPED_TEST_SUITE` that provides names for the types for more readable test names.

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "Int";
    if constexpr (std::is_same_v<T, double>) return "Double";
    return "Unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

---

## Type-Parameterized Tests

Type-parameterized tests complement typed tests by allowing the test suite to be defined without knowing the exact types it will run on, which can be instantiated later with various type lists.

### Defining Type-Parameterized Test Suites

1. Define your fixture template type, inheriting from `testing::Test`:

```cpp
template <typename T>
class MyParametrizedTest : public testing::Test {};
```

2. Declare a type-parameterized test suite with `TYPED_TEST_SUITE_P`.

```cpp
TYPED_TEST_SUITE_P(MyParametrizedTest);
```

3. Define tests with `TYPED_TEST_P` using `TypeParam` to refer to the parameter type.

```cpp
TYPED_TEST_P(MyParametrizedTest, TestSomething) {
  TypeParam val{};
  SUCCEED();
}
```

4. Register test names with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
REGISTER_TYPED_TEST_SUITE_P(MyParametrizedTest, TestSomething);
```

5. Instantiate the suite with types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyParametrizedTest, MyTypes);
```

### Example

```cpp
template <typename T>
class ContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) {
  TypeParam container;
  SUCCEED();
}

TYPED_TEST_P(ContainerTest, IsInitiallyEmpty) {
  TypeParam container;
  EXPECT_EQ(container.size(), 0u);
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed, IsInitiallyEmpty);

using MyContainers = testing::Types<std::vector<int>, std::list<double>>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyContainerTests, ContainerTest, MyContainers);
```

---

## Best Practices and Tips

- **Avoid underscores (`_`) in test suite and test names**: GoogleTestâ€™s macro expansions generate class names using these identifiers, so underscores can create naming conflicts and undefined behavior.

- **Use `EXPECT_` vs `ASSERT_` carefully**: `EXPECT_` macros allow a test to continue after failure, `ASSERT_` macros abort the current test function.

- **Name tests clearly and consistently**, reflecting the tested conditions or behaviors.

- **Group related tests into suites or fixtures** for reusable setup, teardown, and shared utility functions.

- **Prefer typed tests when testing multiple types with the same logic**, and parameterized tests when testing the same logic with multiple values.

- **For complex parameters in parameterized tests**, use `Combine()` to generate Cartesian products of multiple parameters.

- **Use custom name generators** for parameterized and typed test instantiations to produce meaningful and readable test names.

- Return the result of `RUN_ALL_TESTS()` from your `main()` function and call `testing::InitGoogleTest()` beforehand to initialize testing flags properly.

---

## Troubleshooting

### Tests Not Running As Expected

- Confirm that test fixture and test names do not contain disallowed underscores.

- Verify that `INSTANTIATE_TEST_SUITE_P` is called for all parameterized tests, otherwise tests may not instantiate or will cause failures.

- Ensure `RUN_ALL_TESTS()` return value is handled correctly to reflect test results.

### Error: No Matching Constructor for Fixture

- Ensure your test fixture has a default constructor. If you define a non-default constructor, explicitly add a default constructor.

- For fixtures that inherit from parameterized test interfaces, ensure the inheritance is consistent.

### Custom Parameters Not Passing Through

- Use `ConvertGenerator` when your test parameter types are not directly constructible from provided parameter generator values.

- Be cautious with parameter lifetimes, especially when using lambdas or functors that capture references. Prefer passing by value or using explicit type annotations.

---

## Additional Resources

- [Value-Parameterized Tests Guide](../advanced.md#value-parameterized-tests)
- [Typed Tests Guide](../advanced.md#typed-tests)
- [GoogleTest Primer](primer.md)
- [Testing Reference](testing.md)
- [FAQ about Naming Conventions and Test Best Practices](faq.md)
- [Examples and Samples in Official Repository](https://github.com/google/googletest/tree/main/googletest/samples)

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "googletest/include/gtest/gtest-param-test.h", "range": "1-266"}, {"path": "googletest/include/gtest/gtest-typed-test.h", "range": "1-144"}]} />