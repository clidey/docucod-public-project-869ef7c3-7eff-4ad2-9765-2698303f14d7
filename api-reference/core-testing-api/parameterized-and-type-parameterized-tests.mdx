---
title: "Parameterized and Type-Parameterized Tests"
description: "Explains how to write and instantiate parameterized test cases to improve coverage and DRYness. Offers comprehensive API documentation for value- and type-parameterized test macros, registration, and instantiation."
---

# Parameterized and Type-Parameterized Tests

GoogleTest empowers you to write parameterized test cases that scale test coverage efficiently while keeping your test code clean and maintainable. This page dives deep into how to define, register, and instantiate both value-parameterized and type-parameterized tests using GoogleTest's macros and utilities. You'll learn how to harness parameter generators for flexible test inputs and master the associated API, making your tests DRY (Donâ€™t Repeat Yourself) and expressive.

---

## Value-Parameterized Tests

Value-parameterized tests allow the execution of the same test logic with multiple different input values. This technique dramatically increases test coverage without repeating test code.

### 1. Writing Value-Parameterized Tests

- Define a test fixture class derived from `testing::TestWithParam<T>`, where `T` represents your parameter type.

```cpp
class FooTest : public ::testing::TestWithParam<const char*> {
  // Implement fixture members if needed.
};
```

- Within this fixture, write tests using the `TEST_P` macro. Use `GetParam()` to access the parameter value.

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(SomeFunction(GetParam()));
}
```

### 2. Instantiating Parameterized Tests

You instantiate the tests using `INSTANTIATE_TEST_SUITE_P`, specifying:

- A unique instantiation name.
- The test suite name.
- A parameter generator that yields the parameter values.

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, FooTest,
    testing::Values("meeny", "miny", "moe")
);
```

This creates tests with names like `MyInstantiation/FooTest.DoesBlah/0`, each running `DoesBlah` with a different parameter value.

### 3. Parameter Generators

GoogleTest provides flexible parameter generators in the `testing` namespace to produce sequences or sets of parameter values:

| Generator                   | Description                                                                                      |
|-----------------------------|------------------------------------------------------------------------------------------------|
| `Range(begin, end [, step])`| Generates a sequence including `begin` but excluding `end`. `step` defaults to 1.               |
| `Values(v1, v2, ..., vN)`   | Enumerates specific values explicitly.                                                       |
| `ValuesIn(container)` or `ValuesIn(begin, end)` | Generates values from C-style arrays, STL containers, or iterator ranges.          |
| `Bool()`                   | Generates the boolean sequence `{false, true}`.                                               |
| `Combine(g1, g2, ..., gN)` | Produces the Cartesian product of values from multiple generators, yielding tuples.           |
| `ConvertGenerator<T>(g)` or `ConvertGenerator(g, func)` | Converts generated values to a target type `T` or via a conversion function.       |

### 4. Customizing Test Names

Optionally, you can specify a custom name generator function or functor that takes a `testing::TestParamInfo<T>` and returns a string suffix used in test names. This is helpful when default names (like indices) aren't descriptive enough.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomName, MyTestSuite, testing::Values(1, 2, 3),
    [](const testing::TestParamInfo<MyTestSuite::ParamType>& info) {
      return "Param_" + std::to_string(info.index);
    });
```

### 5. Important Macros and Utilities

- **`TEST_P(fixture, test_name)`**: Defines a parameterized test using the given fixture.
- **`INSTANTIATE_TEST_SUITE_P(instantiation_name, fixture, param_generator, [name_generator])`**: Instantiates the parameterized test suite with generated parameters and optional custom names.
- **`GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TestSuiteName)`**: Suppresses failure if a parameterized test suite is defined but never instantiated.

### 6. Example: Simple Parameterized Test

```cpp
class IntTest : public ::testing::TestWithParam<int> {};

TEST_P(IntTest, IsPositive) {
  EXPECT_GT(GetParam(), 0);
}

INSTANTIATE_TEST_SUITE_P(PositiveNumbers, IntTest, testing::Values(1, 2, 3));
```

This will run `IsPositive` three times with parameters 1, 2, and 3.

---

## Type-Parameterized Tests

Type-parameterized tests enable running the same test logic over a list of types instead of values. This approach is ideal for verifying generics, concepts, or interface conformance across implementations.

### 1. Writing Typed Tests

- Define a class template fixture derived from `testing::Test`, parameterized by a type `T`.

```cpp
template <typename T>
class MyFixture : public testing::Test {
 public:
  // Fixture members referencing T
  T value_;
};
```

- Declare the list of types to test using `testing::Types<>` and associate them to the fixture using `TYPED_TEST_SUITE`.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(MyFixture, MyTypes);
```

- Write tests with the `TYPED_TEST` macro. The special name `TypeParam` in the test refers to the type parameter.

```cpp
TYPED_TEST(MyFixture, HasDefaultValue) {
  TypeParam val{};  // Default construct
  EXPECT_EQ(val, TypeParam{});
}
```

### 2. Type-Parameterized Tests vs Typed Tests

- *Typed tests* require knowing all testing types upfront where the type list is declared alongside test definitions.
- *Type-parameterized tests* allow defining tests independently of specific types and instantiating later. This enables sharing test patterns across libraries and consumers.

### 3. Declaring Type-Parameterized Tests

- Use `TYPED_TEST_SUITE_P` to declare a test suite template.
- Define individual `TYPED_TEST_P` tests in the suite.
- Register tests with `REGISTER_TYPED_TEST_SUITE_P`.

```cpp
template <typename T>
class MyGenericTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyGenericTest);

TYPED_TEST_P(MyGenericTest, Test1) {
  TypeParam val;
  // test logic
}

TYPED_TEST_P(MyGenericTest, Test2) { ... }

REGISTER_TYPED_TEST_SUITE_P(MyGenericTest, Test1, Test2);
```

### 4. Instantiating Type-Parameterized Tests

- Use `INSTANTIATE_TYPED_TEST_SUITE_P` with an instantiation name, test suite name, and types list.

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, MyGenericTest, MyTypes);
```

### 5. Customizing Type Names

You can supply a third optional parameter to `TYPED_TEST_SUITE` or `INSTANTIATE_TYPED_TEST_SUITE_P` which is a class with a templated static `GetName(int)` method returning strings to customize test suite names for each type.

```cpp
class NameGen {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, char>) return "char";
    if constexpr (std::is_same_v<T, int>) return "int";
    // ...
  }
};

TYPED_TEST_SUITE(MyFixture, MyTypes, NameGen);
```

### 6. Example: Typed Test

```cpp
template <typename T>
class NumericTest : public testing::Test {
 public:
  T value_ = T();
};

using NumericTypes = testing::Types<int, double>;
TYPED_TEST_SUITE(NumericTest, NumericTypes);

TYPED_TEST(NumericTest, DefaultIsZero) {
  EXPECT_EQ(this->value_, TypeParam{});
}
```

### 7. Example: Type-Parameterized Test

```cpp
template <typename T>
class MyInterfaceTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyInterfaceTest);

TYPED_TEST_P(MyInterfaceTest, DoesSomething) {
  // test using TypeParam
}

REGISTER_TYPED_TEST_SUITE_P(MyInterfaceTest, DoesSomething);

using MyTypes = testing::Types<int, float, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyInstances, MyInterfaceTest, MyTypes);
```

### 8. Additional Macros

- `TYPED_TEST_SUITE`, `TYPED_TEST` for typed tests.
- `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, `REGISTER_TYPED_TEST_SUITE_P`, and `INSTANTIATE_TYPED_TEST_SUITE_P` for type-parameterized tests.

---

## Best Practices and Troubleshooting

### Best Practices

- Use parameterized tests to simplify repetitive test logic across multiple values or types.
- Provide informative custom names for parameterized test instances to improve test output clarity.
- For complex parameters, use `ConvertGenerator` to convert generated parameter types properly.
- Declare `SetUpTestSuite()` and `TearDownTestSuite()` **public** if you use `TEST_P` or typed tests to avoid access errors.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress errors for parameterized test suites intentionally uninstantiated.

### Common Pitfalls

- Forgetting to instantiate parameterized test suites will cause test failures.
- Using underscores in test suite or test names is disallowed; names must be valid C++ identifiers without underscores.
- Test name suffixes generated for parameterized tests must be alphanumeric and underscore only.
- Parameter generators are evaluated during `InitGoogleTest()`, not at instantiation or run-time.

### Troubleshooting Tips

- If tests seem missing, confirm corresponding `INSTANTIATE_TEST_SUITE_P` macros exist and are correctly written.
- Use `--gtest_list_tests` command-line flag to list all tests and verify parameterized tests are instantiated.
- Review custom name generator logic when seeing invalid or duplicate test names.
- Ensure your parameter types are copyable and printable or provide custom printer overloads.

---

## Summary

This page walked you through writing and instantiating parameterized and type-parameterized tests with GoogleTest. Whether your goal is to test behavior across sets of values or types, these macros and utilities give you the flexibility to craft maintainable and scalable test suites.

For hands-on examples and more detailed guidance, refer to the [GoogleTest Primer](../../docs/primer.md), the [Advanced Testing Strategies Guide](../../guides/advanced-testing-strategies/parameterized-and-typed-tests.mdx), and the detailed [Testing Reference](../reference/testing.md).

---

# References

- [TEST_P Macro and Parameterized Tests](../reference/testing.md#TEST_P)
- [INSTANTIATE_TEST_SUITE_P Macro](../reference/testing.md#INSTANTIATE_TEST_SUITE_P)
- [Typed Tests and Type-Parameterized Tests](../reference/testing.md#TYPED_TEST_SUITE)
- [REGISTER_TYPED_TEST_SUITE_P and INSTANTIATE_TYPED_TEST_SUITE_P](../reference/testing.md#REGISTER_TYPED_TEST_SUITE_P)
- [Value-Parameterized Tests Guide](../../guides/advanced-testing-strategies/parameterized-and-typed-tests.mdx)
- [Typed Tests Guide](../../docs/advanced.md#typed-tests)

---

# Code Example: Value-Parameterized Test with Custom Names

```cpp
#include <gtest/gtest.h>

class MyTest : public ::testing::TestWithParam<int> {};

TEST_P(MyTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

// Custom name generator
std::string CustomNameGenerator(
    const ::testing::TestParamInfo<MyTest::ParamType>& info) {
  return "Value" + std::to_string(info.param);
}

INSTANTIATE_TEST_SUITE_P(MyValues, MyTest, testing::Values(2, 4, 6), CustomNameGenerator);
```

This produces tests named `MyValues/MyTest.IsEven/Value2`, etc., providing clear output.

# Code Example: Type-Parameterized Test

```cpp
#include <gtest/gtest.h>

template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T val_ = T();
};

using MyTypes = testing::Types<int, double>;

TYPED_TEST_SUITE(MyTypedTest, MyTypes);

TYPED_TEST(MyTypedTest, IsDefaultConstructible) {
  TypeParam val = this->val_;
  EXPECT_EQ(val, TypeParam{});
}
```

---