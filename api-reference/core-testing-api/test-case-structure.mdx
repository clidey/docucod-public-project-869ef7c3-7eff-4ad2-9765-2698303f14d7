---
title: "Test Case and Test Suite Structure"
description: "Defines how to declare and register test cases and suites, including macro usage, test discovery, and test execution entry points. Covers the life cycle of a test, grouping strategies, and base fixtures support to help users structure robust and maintainable tests."
---

# Test Case and Test Suite Structure

GoogleTest provides a structured approach to writing tests by organizing them into *test cases* and *test suites*. This page details how to correctly declare and register test cases and suites, explaining the life cycle of tests, grouping strategies, and support for base fixtures. Understanding this structure is essential to build robust, maintainable, and scalable test programs.

---

## 1. Understanding Test Cases and Test Suites

### Terminology Clarity

The terms *test case* and *test suite* have evolved in GoogleTest:

- **Test**: An individual test function that checks a specific behavior.
- **Test Suite** (formerly called *Test Case*): A group of related tests sharing a context or fixture.

GoogleTest is moving towards using *Test Suite* as the preferred term. The naming scheme used in macros aligns with this:

```cpp
TEST(TestSuiteName, TestName) { ... }
```

Here, `TestSuiteName` groups multiple `TestName`s logically.

### What is a Test Fixture?

A *test fixture* is a C++ class derived from `testing::Test` that establishes a common environment for multiple tests within a test suite. It allows sharing setup and teardown code, as well as common data members and helper functions.

### Why Organize Tests?

Proper grouping improves:

- **Maintainability**: Related tests are easy to locate and modify.
- **Isolation**: Each test gets a fresh fixture instance, ensuring independence.
- **Efficiency**: Shared setup/teardown for tests using fixtures avoids repetition.

---

## 2. Declaring Tests

### Simple Tests with `TEST`

Use the `TEST` macro to define standalone tests without fixtures:

```cpp
TEST(MyTestSuite, TestName) {
  // test body
}
```

- The *first* argument is the test suite name.
- The *second* argument is the test name.
- Both must be valid C++ identifiers without underscores (`_`).
- Each test is independent and GoogleTest creates a fresh environment for each.

Example:

```cpp
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}
```

### Tests Using Fixtures with `TEST_F`

When tests require shared setup or common data, define a fixture class and use `TEST_F`:

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override {
    // Setup code here
  }

  void TearDown() override {
    // Cleanup code here
  }

  // Common data members here
};

TEST_F(MyFixture, TestName) {
  // test body able to access fixture members
}
```

Key points:

- Fixture creating a fresh instance per test ensures isolation.
- `SetUp()` and `TearDown()` run before and after each test respectively.
- Common mistake: misspelling `SetUp()`; case-sensitive.

---

## 3. Test Life Cycle

For each test defined via `TEST_F()`, GoogleTest performs:

1. Construct the fixture object (calls the constructor).
2. Call `SetUp()` to prepare the environment.
3. Execute the test body.
4. Call `TearDown()` to clean up test-specific resources.
5. Destroy the fixture object.

Each test runs with a fresh fixture instance, so there's no state leakage between tests.

<Info>
If you need shared expensive setup across multiple tests, consider `SetUpTestSuite()` and `TearDownTestSuite()` static methods on the fixture class.
</Info>

---

## 4. Grouping Strategies

### Logical Grouping into Suites

Grouping tests into suites that mirror code structure or functionality aids navigation and debugging. For example, tests for a `Queue` class can be under `QueueTest` suite.

### Shared Fixtures Within a Suite

Multiple related tests can reuse the same fixture class, reducing boilerplate and ensuring consistent setup:

```cpp
class QueueTest : public testing::Test {
 protected:
  Queue<int> q_;

  void SetUp() override {
    q_.Enqueue(1);
    q_.Enqueue(2);
  }
};

TEST_F(QueueTest, SizeIsTwo) {
  EXPECT_EQ(q_.size(), 2);
}

TEST_F(QueueTest, DequeueGivesFirstElement) {
  int* n = q_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  delete n;
}
```

---

## 5. Base Fixtures and Fixture Inheritance

To share setup code across different test suites, use normal C++ inheritance for your fixture classes:

```cpp
class BaseTest : public testing::Test {
 protected:
  void CommonSetup() { ... }
};

class DerivedTest : public BaseTest {
 protected:
  void SetUp() override {
    BaseTest::SetUp();
    CommonSetup();
  }
};

TEST_F(DerivedTest, TestName) {
  ...
}
```

Benefits:

- Facilitates reusing common setup logic.
- Allows specialization in derived fixtures.

<Warning>
Always ensure base `SetUp()` and `TearDown()` invocations are properly chained to avoid resource leaks.
</Warning>

---

## 6. Test Discovery and Registration

### Automatic Registration

Tests defined via `TEST()`, `TEST_F()`, and related macros are automatically registered with GoogleTest during static initialization. Therefore, you need not manually list or register tests.

### Running Tests

Once your test binary is ready, calling `RUN_ALL_TESTS()` runs all registered tests:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This will:

- Initialize GoogleTest’s internal structures.
- Run each registered test suite and their tests one by one.
- Report results and return appropriate exit code.

<Note>
`RUN_ALL_TESTS()` returns 0 on success, 1 on any failure. Your `main()` should forward this return value.
</Note>

---

## 7. Base Fixture Support and Life Cycle Hooks

### Base Fixture SetUp and TearDown

GoogleTest supports static methods on fixture classes that execute once per suite:

- `SetUpTestSuite()` — called once before the first test in the suite.
- `TearDownTestSuite()` — called once after the last test in the suite.

Example:

```cpp
class ExpensiveResourceTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    resource_ = new ExpensiveResource();
  }

  static void TearDownTestSuite() {
    delete resource_;
    resource_ = nullptr;
  }

  static ExpensiveResource* resource_;
};

ExpensiveResource* ExpensiveResourceTest::resource_ = nullptr;
```

This optimizes performance by avoiding redundant setup/teardown in each test.

### Per-Test SetUp and TearDown

Use `SetUp()` and `TearDown()` methods for preparation and cleanup that must be repeated for every test.

<Check>
Ensure that `SetUpTestSuite()` and `TearDownTestSuite()` do not depend on test order or external state.
</Check>

---

## 8. Test Suite and Test Information Access

GoogleTest provides APIs to access information about currently running tests:

```cpp
const testing::TestInfo* test_info =
    testing::UnitTest::GetInstance()->current_test_info();

if (test_info != nullptr) {
  printf("Running test %s in suite %s\n",
     test_info->name(), test_info->test_suite_name());
}
```

This can be useful for dynamically adjusting test behavior based on context.

---

## 9. Common Pitfalls and Best Practices

### Naming Conventions

- Avoid underscores (`_`) in test suite and test names to prevent macro and name mangling issues.
- Use PascalCase or CamelCase for suite names and test names.

### Isolation of Tests

- Each test should be independent; do not share mutable state across tests unless managed carefully via fixtures.

### Fixture Use

- Prefer fixture classes (`TEST_F`) over global variables.
- Use base fixtures for shared setup logic.

### Registration

- Do not manually register tests; use provided macros.
- Ensure fixtures have default constructors to allow TestRunner to instantiate them.

<Warning>
Using fatal assertions (`ASSERT_*`) inside constructors or destructors is disallowed; use `SetUp()`/`TearDown()` for fatal checks.
</Warning>

---

## 10. Advanced: Value-Parameterized and Typed Tests

GoogleTest supports advanced test structures:

- **Value-Parameterized Tests (`TEST_P`)**: Run the same test logic with different data.
- **Typed Tests**: Run the same test logic with different types.

Though these are covered in detail elsewhere, understanding your base test suites fully enables effective use of these features.

---

## 11. Example: Defining a Test Suite with Fixture

```cpp
#include <gtest/gtest.h>

// Fixture class
class QueueTest : public ::testing::Test {
 protected:
  QueueTest() {
    // Setup initial queue
    q_.Enqueue(1);
    q_.Enqueue(3);
  }

  ~QueueTest() override = default;

  void SetUp() override {}
  void TearDown() override {}

  Queue<int> q_;
};

// Test within the suite
TEST_F(QueueTest, SizeIsTwo) {
  EXPECT_EQ(q_.size(), 2);
}

TEST_F(QueueTest, DequeueGivesFirstElement) {
  int* val = q_.Dequeue();
  ASSERT_NE(val, nullptr);
  EXPECT_EQ(*val, 1);
  delete val;
}
```

---

## 12. Troubleshooting

### Missing Default Constructor

If you get errors like "no matching function for call to `FixtureName::FixtureName()`", define or ensure a default constructor for your fixture class.

### SetUp() Not Called

Check the method name spelling and signature; it must be exactly `void SetUp()` with correct casing and no parameters.

### Test Name Collisions

Avoid underscores and ensure unique suite and test names to prevent macro conflicts.

### Ignoring Return Value of `RUN_ALL_TESTS()`

Always return the result of `RUN_ALL_TESTS()` from `main()` to ensure proper test result propagation.

---

## 13. Additional Resources and Next Steps

- [GoogleTest Primer](primer.md): Learn the basics of writing tests.
- [Testing Reference](docs/reference/testing.md): Complete listing of test APIs.
- [Advanced GoogleTest Topics](docs/advanced.md): Learn about parameterized and typed tests.
- [Organizing Test Suites and Fixtures](guides/core_workflows/organizing_test_suites.mdx): Best practices for grouping tests.

For mocking dependencies and complex interactions, consult the [Mocking Reference](docs/reference/mocking.md) and [gMock Cookbook](docs/gmock_cook_book.md).

---

## 14. Diagram: Basic Test Suite Structure

```mermaid
flowchart TD
  A[Test Suite (Fixture Class)] --> B[Test 1 (Uses Fixture)]
  A --> C[Test 2 (Uses Fixture)]
  A --> D[Test 3 (Uses Fixture)]
  subgraph Test Life Cycle
    Init[Test Fixture Constructed]
    Setup[SetUp() Called]
    Run[Test Body Executed]
    TearDown[TearDown() Called]
    Destroy[Test Fixture Destroyed]
  end

  B --> Init; Init --> Setup; Setup --> Run; Run --> TearDown; TearDown --> Destroy;
  C --> Init; C --> Setup; Setup --> Run; Run --> TearDown; TearDown --> Destroy;
  D --> Init; D --> Setup; Setup --> Run; Run --> TearDown; TearDown --> Destroy;

  classDef lifecycle fill:#f9f,stroke:#333,stroke-width:1px;
  class Init,Setup,Run,TearDown,Destroy lifecycle;
```
