---
title: "Death Test APIs"
description: "Documents the specialized API for death tests, which verify code that is intended to terminate unexpectedly. Explains usage patterns, limitations, and best practices for writing robust death tests."
---

# Death Test APIs

This documentation page covers the specialized API provided by GoogleTest for *death tests* — tests designed to verify that code terminates unexpectedly under certain conditions. It explains how to write death tests, the available macros and predicates, important usage patterns, limitations, and best practices to write robust and reliable death tests.

---

## What Are Death Tests?

*Death tests* verify cases where code results in process termination, for example due to failed assertions, explicit calls to abort functions, or signals such as `SIGABRT` or `SIGSEGV`. Unlike ordinary tests, death tests check that a statement causes abnormal termination, often combined with checking the process exit code and error output.

Death tests are crucial for validating defensive programming checks, guard clauses, and other invariants that terminate the program in an expected way to avoid further damage.

> Note: Exceptions are *not* considered death for these tests, since they can be caught and handled. See exception assertions for testing exceptions.

## How Death Tests Work

When a death test is encountered, GoogleTest forks or clones a subprocess in which the death test statement runs:

- **Thread Safety Styles:**
  - **Fast style:** The subprocess runs the death test immediately after forking.
  - **Threadsafe style:** The subprocess re-executes the entire test binary, running only the targeted death test.

- **Platform Differences:**
  - On POSIX systems, either `fork()` (with optional `clone()`) is used.
  - On Windows, `CreateProcess()` is used with re-execution (equivalent to the threadsafe style).

The parent waits for the subprocess to terminate, then verifies:

1. The process died (or exited) with the expected exit status or signal.
2. The error output matches a user-supplied regular expression or matcher.

## Writing Death Tests

GoogleTest provides macros to write death tests conveniently. Use them inside your test functions or fixtures.

### Macros for Death Tests

| Macro                       | Description                                                                                      |
|-----------------------------|------------------------------------------------------------------------------------------------|
| `ASSERT_DEATH(statement, matcher)`  | Asserts that the `statement` causes process termination and `stderr` output matches `matcher`.  |
| `EXPECT_DEATH(statement, matcher)`  | Like `ASSERT_DEATH`, but test continues on failure.                                             |
| `ASSERT_EXIT(statement, predicate, matcher)` | Asserts process terminates with exit code matching `predicate` and `stderr` matching `matcher`. |
| `EXPECT_EXIT(statement, predicate, matcher)` | Like `ASSERT_EXIT` but non-fatal failure.                                                      |
| `EXPECT_DEATH_IF_SUPPORTED(statement, matcher)` | Conditional death test, runs only if supported on the current platform.                         |
| `ASSERT_DEATH_IF_SUPPORTED(statement, matcher)` | Conditional death test with fatal assertion.                                                   |

> Example:
```cpp
TEST(MyDeathTest, Foo) {
  ASSERT_DEATH({ int n = 5; FunctionUnderTest(&n); }, "error message regex");
}

TEST(MyDeathTest, NormalExit) {
  EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
}

TEST(MyDeathTest, KilledBySignal) {
  EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "signal message");
}
```

### Predicates for Exit Codes

GoogleTest provides predicates to check exit status in a platform-independent way:

- `::testing::ExitedWithCode(int exit_code)`: Checks for normal exit with specific code.
- `::testing::KilledBySignal(int signal_number)`: Checks that process was terminated by a given signal (POSIX only).

You can also provide your own predicate functor or lambda accepting an `int` exit code.

### Matchers for Error Output

Death tests expect the subprocess to emit error messages on `stderr`. The `matcher` parameter can be:

- A GoogleMock matcher for `const std::string&`.
- A string interpreted as a regular expression matching the error output.

For compatibility, passing a bare string interprets it as a `ContainsRegex` matcher.

### Debug Mode Death Tests

- `EXPECT_DEBUG_DEATH()` and `ASSERT_DEBUG_DEATH()` behave like death tests in debug builds.
- In release builds (`NDEBUG` defined), they just execute the statement without death checking.

## Best Practices and Usage Tips

### Naming Conventions

- **Test Suite Name:** When creating a suite containing death tests, follow the convention of ending the test suite's name with `DeathTest`. This enforces that death tests are run before other tests, minimizing threading safety issues.

```cpp
class FooDeathTest : public ::testing::Test { ... };

TEST_F(FooDeathTest, Basic) {
  ASSERT_DEATH(CrashFunction(), "expected message");
}
```

### Thread Safety

- Death tests are performed by forking/subprocesses, which are not always safe with multiple threads.
- A warning is emitted if multiple threads exist at the time a death test runs.
- Prefer the "threadsafe" death test style when your tests involve threads. You can set this globally or per-test:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

### Statement Restrictions

- The death test statement can be any valid C++ statement or compound statement.
- Avoid statements that use `return` or throw exceptions directly; these cause the death test to fail.
- Because the death test runs in a subprocess, all side-effects are local to the subprocess and not observable in the parent.

### Using Mocks in Death Tests

- If your death test uses GoogleMock objects that expect destruction, you may need to use `Mock::AllowLeak` on those mocks to avoid false leak detection failures.

### One Death Test per Line

- You cannot place multiple `EXPECT_DEATH` or `ASSERT_DEATH` assertions on the same source line; this causes compilation errors.

### Error Message Regular Expressions

- Regular expressions in death tests follow platform-dependent rules:
  - POSIX systems support POSIX Extended Regular Expression syntax.
  - Windows uses a simpler subset that supports literals, character classes (`\d`, `\w`, etc.), repetition (`*`, `+`, `?`), anchors (`^`, `$`), and concatenation.
- Use only supported constructs to avoid runtime failures.

## Dealing with Failures and Troubleshooting

### Common Failure Scenarios

- **Death test does not cause process termination:** Test will fail with a message stating it "failed to die".
- **Mismatch in error output:** If the error output does not match the expected matcher or regex, the test fails with a detailed message showing expected and actual outputs.
- **Unexpected return in statement:** If the statement returns instead of terminating, the death test fails.
- **Exception thrown:** Death tests consider exceptions as failure. Enable or disable exception catching using the `catch_exceptions` flag.
- **Multiple threads at death test time:** A warning is issued. Use the threadsafe death test style to mitigate.

### Debugging Tips

- Use `--gtest_death_test_style=threadsafe` for safer debug, despite slower execution.
- Use `--gtest_break_on_failure` to drop into debugger right at failure.
- Increase detail of failure message by providing descriptive regex or custom matchers.

### Understanding Output

On failure, death tests print:

- The statement executed.
- Outcome (failed to die, died with wrong code, etc.).
- The actual stderr output from the subprocess with a `[  DEATH   ]` prefix on each line.
- Expected regex or matcher description.

## Death Test Macros in Detail

### ASSERT_DEATH and EXPECT_DEATH

```cpp
ASSERT_DEATH(statement, matcher);
EXPECT_DEATH(statement, matcher);
```

- *statement*: code expected to abort.
- *matcher*: string regex or matcher matching the error output on `stderr`.

**Example:**
```cpp
ASSERT_DEATH(myFunc(), "expected error message");
```

### ASSERT_EXIT and EXPECT_EXIT

```cpp
ASSERT_EXIT(statement, predicate, matcher);
EXPECT_EXIT(statement, predicate, matcher);
```

- *predicate*: a function or functor taking `int` exit status and returning bool.
- Checks both exit status and error output.

**Use case:**
```cpp
EXPECT_EXIT(NormalExitFunction(), testing::ExitedWithCode(0), "Success");
EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "Killed");
```

### EXPECT_DEATH_IF_SUPPORTED & ASSERT_DEATH_IF_SUPPORTED

- Compile and run death tests only if the platform supports them.
- Disable on platforms without death test support without breaking compilation.

## Supported Platforms and Limitations

- Death test support depends on platform capabilities:
  - POSIX systems support fork or clone-based death tests.
  - Windows supports re-exec using CreateProcess.
- Not all death test styles supported on all platforms. GoogleTest chooses the default behavior accordingly.
- Thread safety style recommended when dealing with multiple threads.

## Summary

Death tests are powerful checks ensuring your code fails early and predictably when encountering fatal errors. GoogleTest’s APIs give you flexible, expressive macros to assert process death, exit codes, and error outputs robustly, while managing complex details of subprocess handling internally.

Keep in mind the threading nuances and subprocess nature of death tests. Follow naming conventions, use supported regexes, and be cautious with side effects for reliable and maintainable tests.

---

## Additional References & Next Steps

- [Death Assertions in GoogleTest Assertions Reference](../reference/assertions.md#death)
- [Advanced GoogleTest Topics — Death Tests Section](../advanced.md#death-tests)
- [Writing Your First Test](../../getting-started/configuration-first-run/write-first-test)
- [Test Case and Test Suite Structure](../../api-reference/core-testing-api/test-case-structure)
- [Matchers Reference](../../api-reference/mocking-and-matchers/matchers-reference)
- [Regular Expression Syntax](../advanced.md#regular-expression-syntax)
- [Handling Exceptions](../reference/assertions.md#exceptions)

---

## Example: Writing a Simple Death Test

```cpp
TEST(MyDeathTest, DiesOnInvalidInput) {
  EXPECT_DEATH(ProcessInput(nullptr), "Invalid input provided");
}
```

This verifies that `ProcessInput(nullptr)` causes the process to terminate, and that the error output contains "Invalid input provided".

## Example: Using ASSERT_EXIT with a Predicate

```cpp
TEST(MyDeathTest, ExitsWithZero) {
  ASSERT_EXIT(ExitNow(), testing::ExitedWithCode(0), "Success");
}
```

Checks that `ExitNow()` returns normally with exit code zero and the output matches "Success".

## Example: Setting Death Test Style

Set the death test style globally for the suite:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  GTEST_FLAG_SET(death_test_style, "threadsafe");
  return RUN_ALL_TESTS();
}
```

Or set per test:

```cpp
TEST(MyDeathTest, FastDeath) {
  GTEST_FLAG_SET(death_test_style, "fast");
  ASSERT_DEATH(DoCrash(), "expected message");
}
```

---

### Troubleshooting Quick Checklist

- Ensure the death test statement causes process termination, not just assertion failure.
- Avoid returning or throwing exceptions inside death test statements.
- Use proper regular expressions supported on your platform.
- Follow the test suite naming convention ending with `DeathTest`.
- Avoid multiple death test assertions on the same line.
- Consider the death test style when multithreading is involved.
- Remember side effects inside death tests don’t affect the main process.

---