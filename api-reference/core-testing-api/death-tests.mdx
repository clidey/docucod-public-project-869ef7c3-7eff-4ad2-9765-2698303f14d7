---
title: "Death Tests"
description: "Details APIs and mechanisms for writing and managing death tests, which verify that code fails or aborts as expected. Includes usage guidance, caveats, and links to underlying utilities."
---

# Death Tests

Death tests in GoogleTest verify that your code terminates or fails as expected when encountering fatal conditions. They are crucial for testing assertions, error handling, and program termination paths, ensuring your software behaves safely under invalid or unexpected inputs.

This page details how to write and manage death tests using GoogleTest APIs, explains the mechanisms and caveats of death tests, and provides practical guidance for robust usage.

---

## Understanding Death Tests

Programs often terminate intentionally when encountering a critical error or invariant violation (e.g., failed assertions). Death tests validate that such conditions cause your program to abort or exit with a specific error and message.

Unlike regular tests, death tests run the tested statement inside a subprocess that is expected to exit ("die"). The parent process then verifies:

1. The tested statement caused the subprocess to terminate (exit or crash).
2. The exit code or termination signal matches expectations.
3. The subprocess's standard error output matches a matcher or regular expression.

Because the tested statement runs in a subprocess, any side effects it produces in memory are lost—death tests only confirm the termination behavior and message.

### When to Use Death Tests

Use death tests to verify:

- Assertions and sanity checks trigger as expected.
- Code aborts or exits on invalid states.
- Error handling code logs the correct messages before termination.
- Critical failures cause termination with the correct exit code or signal.

## Key Macros for Death Tests

GoogleTest provides several macros to write death tests inside `TEST()` or `TEST_F()` functions.

| Macro                          | Description                                      |
|-------------------------------|------------------------------------------------|
| `ASSERT_DEATH(statement, matcher)`  | Verifies `statement` aborts with output matching `matcher`; aborts current function on failure. |
| `EXPECT_DEATH(statement, matcher)`  | Same as `ASSERT_DEATH` but continues test on failure. |
| `ASSERT_EXIT(statement, predicate, matcher)` | Verifies `statement` aborts, exit status satisfies `predicate`, and output matches `matcher`; aborts on failure. |
| `EXPECT_EXIT(statement, predicate, matcher)` | Same as `ASSERT_EXIT` but continues on failure. |
| `EXPECT_DEATH_IF_SUPPORTED` / `ASSERT_DEATH_IF_SUPPORTED` | Use death tests if supported, otherwise do nothing. |
| `EXPECT_DEBUG_DEATH` / `ASSERT_DEBUG_DEATH` | Death tests that run only in debug mode; in opt mode the statement executes normally. |

### Examples

```cpp
TEST(MyDeathTest, DiesCorrectly) {
  ASSERT_DEATH({
    int n = 5;
    Foo(&n);  // Should abort.
  }, "Error on line .* of Foo()",);
}

TEST(MyDeathTest, ExitsWithCodeZero) {
  EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
}

TEST(MyDeathTest, KilledBySignal) {
  EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "Hanging up!");
}
```

## How Death Tests Work Internally

When a death test runs:

1. If the program has multiple threads, a warning is issued (forking multithreaded programs is unsafe).
2. The test framework forks a subprocess (or creates a new process on Windows and Fuchsia).
3. Depending on the death test style (`fast` or `threadsafe`):
   - **Fast style:** The subprocess immediately executes the test code.
   - **Threadsafe style:** The subprocess re-executes the whole test binary but only runs the specified death test.
4. The parent process waits for the subprocess to terminate.
5. It then evaluates exit status and matches the subprocess’s stderr output against the expected matcher.
6. If the subprocess doesn't abort as expected, or output does not match, the death test fails.

### Death Test Styles

- **Threadsafe** (default recommended): Runs the child process by re-executing the test binary with a command line flag limiting it to the specified death test. Safer in multithreaded scenarios but slower.
- **Fast:** Executes the test code immediately after fork() in the child. Faster but unsafe with threads.

You can set the style globally in `main()`:

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

or per test.

### Platform Differences

- **POSIX systems (Linux, Mac):** Use fork() or clone().
- **Windows:** Always threadsafe using CreateProcess().
- **Fuchsia:** Spawn child processes with supported APIs, always threadsafe.

## Writing Effective Death Tests

### Matcher Argument

The matcher parameter can be:

- A regular expression string (interpreted as a `ContainsRegex` matcher).
- A [gMock matcher](../matchers.md) that matches `const std::string&`.

Use matchers to check that error messages or logs produced by the code under test contain expected substrings or patterns.

### Avoiding Side Effects

Because the death test’s statement runs in a subprocess, any state mutation is lost after it terminates. Do not rely on side effects of death test statements.

### Multiple Death Tests on One Line

Placing multiple death tests on the same source code line is not allowed and leads to compilation errors due to macro expansions. Place them on separate lines.

### Fatal Failures and Returns

Death test code that executes a `return` or throws exceptions is considered a failure of the death test. Avoid `return` statements inside death test statements.

### Handling Mocks

If using mocks in death tests expecting a specific exit code, you must call `Mock::AllowLeak` for mock objects to circumvent mock leak detection causing false failures.

### Debug-Only Death Tests

Use `EXPECT_DEBUG_DEATH` or `ASSERT_DEBUG_DEATH` to test code that should die only in debug builds, allowing side effects in release builds.

## Advanced Usage

### Predicates on Exit Status

GoogleTest provides these predicates to use with `ASSERT_EXIT` and `EXPECT_EXIT`:

- `ExitedWithCode(int code)`: Verifies the process exited normally with a specific exit code.
- `KilledBySignal(int signum)`: Verifies the process was terminated by a signal (POSIX only).

Example:

```cpp
EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
EXPECT_EXIT(KillProcess(), testing::KilledBySignal(SIGKILL), "kill signal");
```

### Inspecting Current Test Information

Inside death tests you can still access information about the current test via

```cpp
auto* info = testing::UnitTest::GetInstance()->current_test_info();
std::cout << "Running death test: " << info->test_suite_name() << "." << info->name();
```

## Common Pitfalls & Troubleshooting

<Warning>
**Avoid running death tests with multiple active threads.** Forking multi-threaded processes is unsafe and may cause hangs or undefined behavior. Use the "threadsafe" style in these cases.
</Warning>

<Warning>
**Do not place multiple death test macros on the same source line.** This will cause compile errors.
</Warning>

<Warning>
**Be cautious using assertions that return from the current function (`ASSERT_*`) within death test statements.** Such usage might cause unexpected behavior or premature test failure.
</Warning>

<Tip>
Use `SCOPED_TRACE` to add trace information to failures inside subroutines called by death tests to simplify debugging.
</Tip>

### Handling Exceptions in Death Tests

By default, exceptions thrown within death tests are treated as failures and captured without escaping the death test macro. You can verify this behavior with supported exception assertion macros.


## Full Example

```cpp
#include <gtest/gtest.h>

void FunctionThatDies() {
  // Code that aborts, crashes, or exits.
  abort();
}

TEST(MyDeathTest, HandlesAbort) {
  // Verify that FunctionThatDies terminates and outputs "abort"
  EXPECT_DEATH(FunctionThatDies(), "abort");
}

TEST(MyDeathTest, ExitsWithCode1) {
  EXPECT_EXIT(_Exit(1), testing::ExitedWithCode(1), "");
}

TEST(MyDeathTest, DebugOnlyDeath) {
  EXPECT_DEBUG_DEATH({
    // Debug only code that triggers death
    abort();
  }, "");
}
```

## Related Flags

- `--gtest_death_test_style`: Set death test style (`threadsafe`, `fast`).
- `--gtest_repeat`: Repeat tests multiple times.
- `--gtest_filter`: Run a subset of tests.

## Links to Related Documentation

- [Assertions Reference](../reference/assertions.md#death)
- [Advanced Guide: Death Tests](../advanced.md#death-tests)
- [Writing Custom Assertions](../guides/advanced-testing-patterns/custom-assertions-matchers.md)
- [Test Macros and Assertions](../api-reference/core-testing-api/test-macros-assertions.md)

---

For deeper understanding, also explore the [Death Tests: Testing for Program Termination](../../concepts/testing-paradigms/death-tests.md) conceptual page which elaborates the theoretical underpinnings and threading considerations around death tests.

Additionally, review the [Death Test Guide](../guides/advanced-testing-patterns/death-test-guide.md) for practical tips and robust pattern implementations.



