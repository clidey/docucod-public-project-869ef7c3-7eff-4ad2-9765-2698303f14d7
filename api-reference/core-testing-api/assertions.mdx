---
title: "Assertions"
description: "A detailed walkthrough of assertion macros (EXPECT_*, ASSERT_*) with parameters, expected behaviors, and examples. Covers standard assertions, fatal vs non-fatal assertions, and user-defined assertions for expressing expected outcomes in tests."
---

# Assertions

This page provides an in-depth walkthrough of GoogleTest's assertion macros that let you express the expected outcomes in your tests clearly and precisely. Assertions validate conditions during tests and produce either success, non-fatal failure (test continues), or fatal failure (test aborts).

Assertions come in pairs: `EXPECT_*` for non-fatal checks and `ASSERT_*` for fatal checks. This distinction empowers you to decide whether a failure should stop test execution immediately or let the test continue to report multiple failures.

All assertion macros accept user messages via streaming (`<<`) for added clarity in test failures.

---

## 1. Explicit Success and Failure

These macros control the flow of a test unconditionally and are useful when logical branches determine outcomes.

- **SUCCEED()**
  - Marks an explicit success at a point in the test.
  - Does not override previous failures.
  - Mostly documentary.
  
  ```cpp
  SUCCEED() << "Reached this point without errors";
  ```

- **FAIL()**
  - Generates a fatal failure and aborts the current function.
  - Use when continuing after failure is nonsensical.
  
  ```cpp
  if (unexpected_condition) {
    FAIL() << "Unexpected condition met";
  }
  ```

- **ADD_FAILURE()**
  - Generates a non-fatal failure.
  - Useful for reporting additional checks without aborting.
  
  ```cpp
  if (some_check_fails) {
    ADD_FAILURE() << "Check did not pass";
  }
  ```

- **ADD_FAILURE_AT(file, line)**
  - Reports a non-fatal failure at a specific file and line.

---

## 2. Boolean Conditions

Validate Boolean expressions directly:

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
  - Pass if `condition` evaluates to `true`.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`
  - Pass if `condition` evaluates to `false`.

These macros provide clear failure messages printing the expression and actual value.

```cpp
EXPECT_TRUE(ptr != nullptr) << "Pointer should not be null";
ASSERT_FALSE(error_occurred) << "Error should not occur";
```

---

## 3. Binary Comparisons

For comparing two values based on relational operators, these macros help you express expectations with detailed failures:

| Macro         | Meaning              |
|---------------|----------------------|
| EXPECT_EQ(a,b)/ASSERT_EQ(a,b) | Checks `a == b`       |
| EXPECT_NE(a,b)/ASSERT_NE(a,b) | Checks `a != b`       |
| EXPECT_LT(a,b)/ASSERT_LT(a,b) | Checks `a < b`        |
| EXPECT_LE(a,b)/ASSERT_LE(a,b) | Checks `a <= b`       |
| EXPECT_GT(a,b)/ASSERT_GT(a,b) | Checks `a > b`        |
| EXPECT_GE(a,b)/ASSERT_GE(a,b) | Checks `a >= b`       |

Pointers are compared for pointer equality, not content. For C strings use string-specific macros (below).

```cpp
EXPECT_EQ(result, 42) << "Result must be 42";
ASSERT_LT(value, max) << "Value exceeds max";
```

---

## 4. String Comparisons

Special handling is provided for C strings (`const char*`) and wide strings:

| Macro                 | Meaning                                                  |
|-----------------------|----------------------------------------------------------|
| EXPECT_STREQ(a, b) / ASSERT_STREQ(a, b)           | C-strings are equal by content                                 |
| EXPECT_STRNE(a, b) / ASSERT_STRNE(a, b)           | C-strings are *not* equal by content                            |
| EXPECT_STRCASEEQ(a, b) / ASSERT_STRCASEEQ(a, b)   | Equal ignoring case                                            |
| EXPECT_STRCASENE(a, b) / ASSERT_STRCASENE(a, b)   | Not equal ignoring case                                        |

All accept wide strings as well. Null C strings are handled gracefully.

```cpp
EXPECT_STREQ(expected_cstr, actual_cstr);
ASSERT_STRCASEEQ("Hello", "hello");
```

---

## 5. Floating-Point Comparisons

Regular equality is insufficient for floating-point due to rounding errors.

- `EXPECT_FLOAT_EQ(a,b)` / `ASSERT_FLOAT_EQ(a,b)`
  - Checks `float` equality with tolerance (~4 ULPs).
- `EXPECT_DOUBLE_EQ(a,b)` / `ASSERT_DOUBLE_EQ(a,b)`
  - Checks `double` equality similarly.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`
  - Checks if difference between `val1` and `val2` is within `abs_error`.

```cpp
EXPECT_NEAR(computed_value, expected_value, 1e-5);
ASSERT_FLOAT_EQ(3.14159f, computed_float_value);
```

If the floating-point values are `NaN`, comparisons fail. Infinity is treated specially.

---

## 6. Exception Assertions

Check whether code throws exceptions as expected.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`
  - Verify that `statement` throws `exception_type`.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`
  - Verify that `statement` throws any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`
  - Verify that `statement` does not throw any exception.

```cpp
EXPECT_THROW(DangerousOperation(), std::runtime_error);
ASSERT_NO_THROW(SafeOperation());
```

---

## 7. Predicate Assertions

Enable more complex conditions with informative messages:

### 7.1 EXPECT_PRED/n

Macros like `EXPECT_PRED2(pred, val1, val2)` check if `pred(val1, val2)` returns `true`.

They print each argument's value if the assertion fails.

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, 4);  // Passes
EXPECT_PRED1(IsEven, 3);  // Fails and prints values
```

### 7.2 EXPECT_PRED_FORMAT/n

Allow writing custom formatting of failure messages.

The predicate formatter must return a `testing::AssertionResult` and accept source expressions and their values.

```cpp
AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << expr << " (" << n << ") is not even.";
}
EXPECT_PRED_FORMAT1(AssertIsEven, 3);  // Will print custom message
```

This provides users full control over failure diagnostics.

---

## 8. Windows HRESULT Assertions

Windows-specific macros to verify `HRESULT` values:

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)`
  - Verify that `expr` succeeded.
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)`
  - Verify that `expr` failed.

Failure output includes human-readable error messages from the system.

---

## 9. Catching Failures in Utility Code

GoogleTest provides macros to test whether a function generates fatal or non-fatal failures:

- `EXPECT_FATAL_FAILURE(statement, substring)`
- `EXPECT_NONFATAL_FAILURE(statement, substring)`

These help when writing tests of test utilities or verifying that code fails as expected.

---

## 10. Additional Notes and Best Practices

- Use `EXPECT_*` macros to continue running tests after failure and gather more error info.
- Use `ASSERT_*` macros when continuing after failure is meaningless or unsafe.
- Avoid placing `ASSERT_*` macros in constructors or destructors due to their fatal behavior.
- You can stream custom messages into assertions to clarify failure contexts.

---

## 11. Examples

```cpp
// Basic equality assertion
TEST(MathTest, Equal) {
  EXPECT_EQ(2 + 2, 4) << "Simple math failure";
}

// Using ASSERT to abort on failure
TEST(VectorTest, Access) {
  std::vector<int> vec = {1, 2, 3};
  ASSERT_FALSE(vec.empty());  // Test aborts if empty
  EXPECT_EQ(vec[0], 1);
}

// Predicate assertion with custom message
bool IsPositive(int n) { return n > 0; }

TEST(FooTest, Positivity) {
  EXPECT_PRED1(IsPositive, 5);
  EXPECT_PRED1(IsPositive, -1) << "Number should be positive";
}

// Using EXPECT_DEATH to assert crashing behavior
TEST(FooDeathTest, CrashOnBadInput) {
  ASSERT_DEATH(Foo(-1), "Invalid input");
}

// Exception assertion
TEST(FooTest, ThrowsOnError) {
  EXPECT_THROW(Foo(-1), std::invalid_argument);
}

// Floating point near equality
TEST(FooTest, ApproxEqual) {
  EXPECT_NEAR(1.0, 1.00001, 0.0001);
}
```

---

## 12. Troubleshooting Common Issues

- **Assertion in non-void function:** `ASSERT_*` macros cause fatal failures that abort the current function, which must be `void`. Use `EXPECT_*` in functions with return types.
- **Streaming messages:** If streaming messages (`<<`) cause issues in macros, check for non-streamable types.
- **Death test hangs or unexpected failures:** Death tests run in child processes; any side effects occur only in the child.
  Use explicit naming of death test suites ending in `DeathTest` to ensure proper test ordering.
- **Comparison of C strings:** Use `EXPECT_STREQ` and related macros to compare string content; `EXPECT_EQ` compares pointers.
- **Handling floating-point precision:** Use `EXPECT_FLOAT_EQ` or `EXPECT_DOUBLE_EQ` instead of `EXPECT_EQ`.

---

For complete specification and all assertion macros, consult the [Assertions Reference](reference/assertions.md).


<AccordionGroup title="Assertion Categories and Examples">
<Accordion title="Explicit Success and Failure">

- `SUCCEED()` — Explicitly records a success
- `FAIL()` — Records a fatal failure and aborts function
- `ADD_FAILURE()` — Records a non-fatal failure

Example:

```cpp
if (unexpected_path) {
  FAIL() << "Unreachable code path hit";
}
```
</Accordion>
<Accordion title="Boolean Assertions">

- `EXPECT_TRUE(condition) / ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition) / ASSERT_FALSE(condition)`

Example:

```cpp
EXPECT_TRUE(IsValid(input)) << "Input should be valid";
```
</Accordion>
<Accordion title="Binary Comparisons">

- `EXPECT_EQ(a, b) / ASSERT_EQ(a, b)` — equal
- `EXPECT_NE(a, b) / ASSERT_NE(a, b)` — not equal
- `EXPECT_LT(a, b) / ASSERT_LT(a, b)` — less than
- `EXPECT_LE(a, b) / ASSERT_LE(a, b)` — less or equal
- `EXPECT_GT(a, b) / ASSERT_GT(a, b)` — greater than
- `EXPECT_GE(a, b) / ASSERT_GE(a, b)` — greater or equal

Example:

```cpp
ASSERT_LE(result, max_value) << "Result exceeds maximum";
```
</Accordion>
<Accordion title="String Comparisons">

- `EXPECT_STREQ(a, b)` — C-string equality
- `EXPECT_STRNE(a, b)` — C-string inequality
- `EXPECT_STRCASEEQ(a, b)` — Case-insensitive equality
- `EXPECT_STRCASENE(a, b)` — Case-insensitive inequality

Example:

```cpp
EXPECT_STRCASEEQ(actual, "expected") << "Strings differ ignoring case";
```
</Accordion>
<Accordion title="Floating-Point Comparisons">

- `EXPECT_FLOAT_EQ(a, b) / ASSERT_FLOAT_EQ(a, b)` — float approx equal
- `EXPECT_DOUBLE_EQ(a, b) / ASSERT_DOUBLE_EQ(a, b)` — double approx equal
- `EXPECT_NEAR(a, b, error)` — within absolute error

Example:

```cpp
EXPECT_NEAR(calculated, expected, 1e-5);
```
</Accordion>
<Accordion title="Exception Assertions">

- `EXPECT_THROW(stmt, ExceptionType)`
- `EXPECT_ANY_THROW(stmt)`
- `EXPECT_NO_THROW(stmt)`

Example:

```cpp
ASSERT_THROW(Foo(), std::runtime_error);
```
</Accordion>
<Accordion title="Predicate Assertions">

- `EXPECT_PREDn(pred, ...)` — predicate returning bool
- `EXPECT_PRED_FORMATn(pred_fmt, ...)` — predicate returning `AssertionResult`

Example:

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, 4);
```
</Accordion>
<Accordion title="Windows HRESULT Assertions">

- `EXPECT_HRESULT_SUCCEEDED(expr)`
- `EXPECT_HRESULT_FAILED(expr)`

Example:

```cpp
EXPECT_HRESULT_SUCCEEDED(CoCreateInstance(...));
```
</Accordion>
</AccordionGroup>

---

[View the full Assertions Reference](reference/assertions.md)

---

