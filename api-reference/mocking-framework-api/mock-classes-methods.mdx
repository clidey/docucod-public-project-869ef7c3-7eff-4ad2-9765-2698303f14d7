---
title: "Mock Classes and MOCK_METHOD Macros"
description: "Documents how to declare mock classes and methods, leveraging the MOCK_METHOD macros for different signatures and qualifiers. Covers creation of mock objects, call tracking, and integration with test fixtures."
---

# Mock Classes and `MOCK_METHOD` Macros

This page details how to declare mock classes and methods using GoogleMock's `MOCK_METHOD` macros. It explains the syntax, usage patterns, and best practices for creating mock objects, tracking calls, and integrating mocks with test fixtures. By mastering these macros, you will be able to effectively simulate and verify interactions with C++ interfaces in your unit tests.

---

## Defining Mock Classes

### Basic Usage

To create a mock class in GoogleMock, derive from an interface or base class you want to mock and define mock methods using the `MOCK_METHOD` macro in the `public:` section. Each `MOCK_METHOD` corresponds to a method you want to mock, with its signature expressed across macro parameters.

```cpp
#include <gmock/gmock.h>

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};
```

**Key points:**

- `MOCK_METHOD` takes 3 or 4 parameters:
  1. Return type
  2. Method name
  3. Argument types (enclosed in parentheses)
  4. Optional specifiers (such as `const`, `override`, `noexcept`)

- Mock methods **must** be declared in the `public:` section regardless of the original access level.
- Use the specifiers to correctly match the original methodâ€™s qualifiers.

<Note>
Using public mock methods even for protected or private originals enables `EXPECT_CALL` and `ON_CALL` to properly access and intercept calls.
</Note>

### Handling Commas in Template Types

Template types with commas can confuse the macro parser. To handle this:

- Wrap the return or argument type with extra parentheses.
- Or define alias types to simplify the macro usage.

Example:

```cpp
class MyMock {
 public:
  // Will **not** compile due to commas.
  // MOCK_METHOD(std::pair<bool, int>, GetPair, ());
  // MOCK_METHOD(bool, CheckMap, (std::map<int, double>, bool));

  // Working solution: wrap types in parentheses.
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));

  // Alternative: use type aliases.
  using BoolAndInt = std::pair<bool, int>;
  MOCK_METHOD(BoolAndInt, GetPair, ());
  using MapIntDouble = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));
};
```

### Mocking Overloaded Methods

Simply declare separate `MOCK_METHOD` entries matching each overload, including different qualifiers such as `const` if required:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (Element x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));
  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

If only mocking a subset of overloads, add `using` declarations to avoid hiding other base class methods.

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;
  MOCK_METHOD(int, Add, (Element x), (override));
  // Intentionally not mocking other overloads.
};
```

### Mocking Class Templates

Mocking class templates follows the same pattern using template syntax:

```cpp
template <typename Elem>
class MockStack : public StackInterface<Elem> {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(void, Push, (const Elem& x), (override));
};
```

### Mocking Non-Virtual Methods

Though rare, mocking non-virtual methods is possible for dependency injection. Your mock class doesn't inherit but matches method signatures using `MOCK_METHOD` without `override`:

```cpp
class ConcretePacketStream {
 public:
  void AppendPacket(Packet* new_packet);
  const Packet* GetPacket(size_t packet_number) const;
  size_t NumberOfPackets() const;
};

class MockPacketStream {
 public:
  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));
  MOCK_METHOD(size_t, NumberOfPackets, (), (const));
};
```

Use templates or compile-time polymorphism to swap real and mock classes.

### Mocking Private or Protected Methods

Always declare mocks for even private and protected methods as `public:` mock methods. This allows Google's `EXPECT_CALL` and `ON_CALL` macros to work properly.

```cpp
class Foo {
 protected:
  virtual void Resume();
 private:
  virtual int GetTimeOut();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(void, Resume, (), (override));
  MOCK_METHOD(int, GetTimeOut, (), (override));
};
```

## Using Mock Objects

Once you have declared a mock class, the typical workflow in tests is:

1. Include the GoogleMock namespace, e.g., `using ::testing::...;` for convenience.
2. Construct mock objects.
3. Use `ON_CALL` to set default method behaviors (optional).
4. Use `EXPECT_CALL` to define expectations on how methods will be called.
5. Exercise your code with the mocks.
6. On destruction of mocks, GoogleMock verifies whether expectations were met.

Example:

```cpp
using ::testing::Return;  // Step 1

TEST(ExampleTest, DemonstratesMockUsage) {
  MockFoo mock;           // Step 2

  ON_CALL(mock, GetSize())  // Step 3
      .WillByDefault(Return(1));

  EXPECT_CALL(mock, Process).Times(2);  // Step 4

  // Step 5: code that calls mock.Process()
  DoSomethingWithMock(&mock);
}
// Step 6: verification automatic on 'mock' destruction.
```

<Note>
Always set expectations **before** exercising the code that uses the mock.
Setting expectations after the fact results in undefined behavior.
</Note>

## The `MOCK_METHOD` Macro Details

### Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (Specs...));
```

- `ReturnType`: The method's return type.
- `MethodName`: The mocked method's name.
- `ArgTypes`: A parenthesized list of argument types.
- `Specs`: Optional qualifiers in parentheses such as `const`, `override`, `noexcept`, `Calltype(...)`, or reference qualifiers `ref(&)`.

### Specifiers and Their Meaning

| Specifier          | Meaning                                                                                     |
|--------------------|---------------------------------------------------------------------------------------------|
| `const`            | Marks the method as a `const` member function. Required to match `const` methods.           |
| `override`         | Marks the method as overriding a `virtual` base method. Recommended for clarity.            |
| `noexcept`         | Marks the method as `noexcept`. Required if the base method is `noexcept`.                   |
| `Calltype(...)`    | Sets the calling convention (e.g., `Calltype(STDMETHODCALLTYPE)`). Useful on Windows.        |
| `ref(&)` or `ref(&&)` | Specifies reference qualifiers (`&` for lvalue refs, `&&` for rvalue refs).                    |

### Important Rules

- Mock methods must be declared **public**.
- When mocking overloaded methods, match the signature including qualifiers.
- If the argument or return type is complex and contains commas, wrap the entire type in parentheses or create a type alias.

<Warning>
Failing to correctly specify method qualifiers will cause compilation errors or subtle bugs.
</Warning>

## Creating Specialized Mocks: NiceMock, NaggyMock, and StrictMock

- Use `NiceMock<MockClass>` to suppress warnings on uninteresting calls.
- Use `NaggyMock<MockClass>` (default) to get warnings on uninteresting calls.
- Use `StrictMock<MockClass>` to cause test failures on uninteresting calls.

Example:

```cpp
using ::testing::NiceMock;
using ::testing::NaggyMock;
using ::testing::StrictMock;

NiceMock<MockFoo> nice_foo;
NaggyMock<MockFoo> naggy_foo;
StrictMock<MockFoo> strict_foo;
```

<Note>
`NiceMock` and `StrictMock` only affect uninteresting calls (no expectations), not unexpected calls.
Also, they only work with mock methods defined with `MOCK_METHOD` macro **directly** in the mock class.
</Note>

## Verifying and Managing Mock Expectations

GoogleMock automatically verifies expectations when a mock object is destroyed. You can also manually verify/clear expectations:

```cpp
bool success = ::testing::Mock::VerifyAndClearExpectations(&mock_obj);
```

- Returns `true` if all expectations are fulfilled.
- Do **not** set new expectations after verification.

To explicitly allow leaking a mock (suppress verification):

```cpp
::testing::Mock::AllowLeak(&mock_obj);
```

## Troubleshooting and Best Practices

- Ensure all virtual methods you want to mock have a virtual destructor in the base class.
- Prefer using type aliases or wrapping complex template types in parentheses when using `MOCK_METHOD`.
- Set expectations before exercising code.
- Use `RetiresOnSaturation()` to make expectations non-sticky when needed.
- Use `InSequence` or `After` to specify call ordering.
- Use appropriate specifiers to match the original method exactly.

## Additional Resources

- [gMock Cheat Sheet](../../docs/gmock_cheat_sheet.md) for quick references and examples.
- [Mocking Reference](../../docs/reference/mocking.md) for detailed macro and class descriptions.
- [gMock Cookbook](../../docs/gmock_cook_book.md) for recipes and best practices.
- [Actions Reference](../../docs/reference/actions.md) for built-in mock actions.

---