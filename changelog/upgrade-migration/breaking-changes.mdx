---
title: "Breaking Changes & Required Actions"
description: "Documents backward-incompatible changes introduced in new versions, outlining required code or configuration updates and the rationale for each change. Users will understand which legacy usage is affected and gain clear steps to resolve issues."
---

# Breaking Changes & Required Actions

The **Breaking Changes & Required Actions** page details backward-incompatible changes introduced in new versions of the product. It helps users understand which legacy usage patterns are affected and presents clear, actionable steps to update their code or configuration accordingly. Each change is explained with the rationale behind it, enabling users to make informed decisions and smoothly adapt to updated versions.

---

## Purpose of This Page

This documentation serves as your guide through the key breaking changes introduced between versions. It specifically targets scenarios where existing code or configurations that relied on older behaviors no longer work as expected and must be updated. The page provides clarity on what changed, why it changed, and how you can resolve issues introduced by these changes.


---

## Understanding Breaking Changes

Breaking changes are alterations that cause forward-incompatible effects, such as

- Removal or modification of existing functions, classes, or methods
- Signature changes to APIs or functions that existing clients depend upon
- Behavioral changes that alter output or side effects in incompatible ways
- Adjustment of default behaviors to correct previous inconsistencies

These changes often require you to update your codebase, tests, or configurations to maintain compatibility.


## How to Use This Guide

Each breaking change section is structured to answer your needs efficiently:

- **What changed?** — Clearly states the backward-incompatible update.
- **Why was it changed?** — Explains the rationale to help you understand the necessity.
- **Who is affected?** — Describes legacy usage patterns that encounter issues.
- **Required actions** — Step-by-step instructions to modify your code or configuration to work with the new version.
- **Tips & pitfalls** — Additional insights to avoid common mistakes during transition.


---

## Example Breaking Changes

### Change 1: `MOCK_METHOD` Macro Argument Parsing Updates

**What changed?**

The `MOCK_METHOD` macro now enforces stricter parsing rules regarding commas in argument types. Previously, some complex types containing commas (e.g., `std::pair<bool, int>`) could cause compilation errors if not properly handled.

**Why was it changed?**

Improved parsing accuracy ensures reliable mock declarations and prevents subtle bugs caused by incorrect macro expansion.

**Who is affected?**

Users mocking functions with argument or return types involving templates that contain commas.

**Required actions:**

1. Wrap complex return or argument types with parentheses in `MOCK_METHOD`. For example:

```cpp
MOCK_METHOD((std::pair<bool, int>), GetPair, ());
```

2. Alternatively, define type aliases for complex types and use these aliases in `MOCK_METHOD`:

```cpp
using BoolAndInt = std::pair<bool, int>;
MOCK_METHOD(BoolAndInt, GetPair, ());
```

**Tips:** Avoid embedding complex comma-containing types directly without proper parentheses or aliases.


### Change 2: Mocking Non-Virtual Methods

**What changed?**

Support for mocking non-virtual methods via compile-time dependency injection using templates has been extended and formalized.

**Why was it changed?**

To support high-performance dependency injection patterns and broaden the scope of possible mocks.

**Who is affected?**

Users mocking concrete classes without virtual methods who want to test against non-virtual APIs.

**Required actions:**

- Adopt the template-based approach where your dependent code is templated on the class to inject `MockClass` or real `ConcreteClass`.

- Write mock classes unrelated to the concrete class with matching method signatures.


### Change 3: Strictness Modes Default Behavior

**What changed?**

The default behavior for uninteresting mock calls (calls to methods without explicit `EXPECT_CALL`) remains naggy (warnings), and explicit use of `NiceMock` or `StrictMock` wrappers is encouraged to control verbosity.

**Why was it changed?**

To promote clearer intent in tests and reduce brittle tests caused by over-strictness.

**Who is affected?**

All test authors using mocks potentially seeing warnings or test failures unexpectedly.

**Required actions:**

- Use `NiceMock<T>` to suppress warnings on uninteresting calls where appropriate.

- Use `StrictMock<T>` to enforce that uninteresting calls cause test failures only when needed.

- Understand the difference between uninteresting and unexpected calls before applying modifications.


### Change 4: Mock Method Qualifiers Enhanced

**What changed?**

The `MOCK_METHOD` macro accepts new qualifiers such as `noexcept`, `ref(&)`, and `Calltype(...)` to specify method call conventions and qualifiers.

**Why was it changed?**

To support a wider range of C++ method signatures accurately, including those with `noexcept` and special calling conventions.

**Who is affected?**

Users mocking methods with specific qualifiers, such as Windows COM `STDMETHODCALLTYPE` or noexcept methods.

**Required actions:**

- When mocking such methods, specify qualifiers explicitly, for example:

```cpp
MOCK_METHOD(bool, Foo, (int n), (noexcept, override));
MOCK_METHOD(void, Bar, (), (Calltype(STDMETHODCALLTYPE), override));
```


---

## Troubleshooting Tips

If you encounter compilation errors or test failures after upgrading:

1. Consult this page for known breaking changes relevant to your code usage.
2. Check that all `MOCK_METHOD` declarations conform to updated syntax and expectations.
3. Ensure you use `NiceMock` or `StrictMock` wrappers deliberately rather than assuming default behaviors.
4. Search error messages for deprecated or removed API usage shown in this page’s sections.
5. Consider refactoring code to use interfaces instead of concrete classes to future-proof mocking.

For further information, consult [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) and [Mocking Reference](https://google.github.io/googletest/reference/mocking.html).

---

## Summary

This page is your essential resource for understanding and reacting to backward-incompatible changes in the product. By following the required action steps listed, you will minimize disruptions and maintain the correctness of your tests and mocks across versions.


---

## Additional Resources

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html): Recipes for using GoogleMock effectively.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html): API details for mocks.
- [Mock Strictness Best Practices](https://google.github.io/googletest/guides/mocking-scenarios/mock-strictness-best-practices.html): Choosing and using mock strictness modes.
- [Breaking Changes & Upgrade Instructions Overview](https://google.github.io/googletest/changelog/upgrade-migration/)


<Tip>
Keeping expectations current and specifying the minimum necessary calls and behaviors will make your tests more maintainable and less brittle to API changes.
</Tip>

<Warning>
Do not overlook the importance of reading and understanding breaking changes before upgrading your codebase to a new version. Failure to update mock declarations and usages may cause unexpected compilation errors or test failures.
</Warning>

<Check>
Always run your full test suite after upgrading and consult this page first if any failures arise.
</Check>
