---
title: "Breaking Changes"
description: "Details major breaking changes introduced in recent versions, including API removals, behavioral shifts, and supported platform adjustments. Users receive clear information about the impact on existing tests and dependencies."
---

# Breaking Changes

This documentation page provides detailed information on the major breaking changes introduced in recent GoogleTest and GoogleMock versions. It highlights API removals, behavioral shifts, and adjustments in supported platforms that affect existing tests and dependencies. Users will gain clear guidance on the impact of these changes and how to adapt their test infrastructure accordingly.

---

## Understanding Breaking Changes

Breaking changes refer to modifications in the framework that are not backward compatible. These changes may cause previously working tests to fail or require updates in mock definitions, expectations, or test setups. This page focuses on those critical changes so that developers can anticipate, identify, and update their tests proactively.


## Major API Removals and Behavioral Adjustments

### Mocking Interface Updates
GoogleMockâ€™s API for defining mocks and setting expectations has been refined, which may require changes:

- **MOCK_METHOD Syntax Standardization:** The modern `MOCK_METHOD` macro is now the primary mechanism for defining mock methods. Legacy macros such as `MOCK_METHODn` and related variants have been deprecated. Users must update mock class definitions to use the unified `MOCK_METHOD` syntax, supporting qualifiers such as `(const, override)` and call type specifications like `(Calltype(STDMETHODCALLTYPE))` where required.

- **Strictness Modifiers Clarification:** The default strictness for mocks remains as "naggy" (warnings on uninteresting calls), but a future default shift to "nice" mocks is planned. Users should explicitly specify `NiceMock` or `StrictMock` wrappers to control uninteresting call behaviors and avoid unexpected warnings or failures.

- **Expectation Ordering and Cardinalities:** Expectation matching order continues to be reverse chronological, meaning the latest matching expectation takes precedence. Usage of `.RetiresOnSaturation()` is recommended when expectations should no longer be active after being saturated to avoid upper-bound violation failures.

### Default Actions and ON_CALL Behavior

- The behavior of default actions specified via `ON_CALL` remains consistent; however, a reminder that uninteresting calls without expectations generate warnings unless suppressed by using `NiceMock`.

- `ON_CALL` requires exactly one `WillByDefault` clause. Users attempting to chain `.With()` multiple times or missing `WillByDefault` will see errors.

### Support for Move-Only Types

- Improved support for mocking methods which accept or return move-only types (like `std::unique_ptr`), allowing clean and idiomatic `MOCK_METHOD` declarations.

- Legacy workarounds that redirected move-only arguments to pointer-based mock methods should be phased out in favor of the direct approach.

### Mock Verification and Lifetime

- Automatic verification on mock destruction remains in place, but users can force verification explicitly with `Mock::VerifyAndClearExpectations(&mock_object)`, especially useful when mock lifetime may not be deterministic.

- Calling verification functions disables further expectation settings on that mock to avoid undefined behavior.

### Obsolete or Removed APIs

- Old `MOCK_METHODn` macros (
`MOCK_METHOD0`, `MOCK_CONST_METHOD1`, etc.) and similar older mock APIs are phased out.

- Renamed or reorganized classes in internal mock handling or expectation APIs must be checked and updated if directly referenced.


## Impact on Existing Tests and Dependencies

- Tests relying on deprecated mocking macros or unspecified default mock behaviors may fail, triggering warnings or errors at runtime.

- Changing expectations order, cardinalities, or strictness modifiers can alter which expectations match calls, possibly producing unexpected failures or false positives.

- Mock destructors must be virtual for `NiceMock` and `StrictMock` to work correctly; non-virtual destructors can cause silent verification omissions and test inconsistencies.

- Overloaded mock methods require explicit disambiguation using `Const()` or specifying parameter matchers to avoid ambiguity or compiler errors.


## Migration Strategies and Best Practices

### Migrating to the New Mocking Macros

1. Replace all legacy mock macros (`MOCK_METHODn`, `MOCK_CONST_METHODn`) with the modern `MOCK_METHOD` macro.

2. Use the fourth parameter of `MOCK_METHOD` to specify qualifiers such as `const`, `override`, or `Calltype` as needed.

3. Ensure `MOCK_METHOD` declarations are in the `public:` section of mock classes to allow proper mocking access.


### Managing Uninteresting Calls

- Wrap mocks with `NiceMock` if you want to suppress warnings on uninteresting calls.

- Use a catch-all expectation (`EXPECT_CALL(mock, Method(_)).Times(AnyNumber())`) to explicitly allow calls to specific mocks.


### Controlling Expectation Lifetimes

- Use `.RetiresOnSaturation()` on expectations that should be deactivated after fulfilling the call count limit.

- Specify call order using sequences (`Sequence`) or `.After()` clauses for partial ordering.


### Delegating Calls

Use delegation to fakes or real objects where appropriate via `ON_CALL` with lambdas.


### Verifying Mocks Early

Call `Mock::VerifyAndClearExpectations` to enforce verification before test teardown when mock deletion timing is uncertain.


## Troubleshooting Common Issues

### Unexpected or Uninteresting Calls

- Unexpected calls occur when no matching expectation exists for the mock method with the given arguments. These cause test failures.

- Uninteresting calls occur when a mock method with no explicit expectations is called. These generate warnings by default but can be suppressed via `NiceMock`.


### Compiler Errors on Mock Method Definitions

- Check for commas in argument types; wrap return/argument types with parentheses or use type aliases to avoid parsing errors.

- Ensure virtual destructors exist on classes you mock.

### Ambiguous Overloaded Methods

- Disambiguate using `Const()` or explicit matchers in `EXPECT_CALL` and `ON_CALL`.


## Reference and Resources

- [gMock Cheat Sheet](https://github.com/google/googletest/blob/main/docs/gmock_cheat_sheet.md): Quick overview of mocking macros and concepts.

- [gMock for Dummies](https://github.com/google/googletest/blob/main/docs/gmock_for_dummies.md): Beginner-friendly guide to mocking.

- [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md): Recipes for mocking techniques.

- [Mocking Reference](https://github.com/google/googletest/blob/main/docs/reference/mocking.md): Detailed reference for mocking APIs.

- [Legacy gMock FAQ](https://github.com/google/googletest/blob/main/docs/gmock_faq.md): Historical questions and migration insights.

- [GoogleTest Assertions Reference](https://github.com/google/googletest/blob/main/docs/reference/assertions.md): For understanding assertion macros.


## Summary

This page is an essential resource outlining breaking changes that influence how users define and interact with mocks in GoogleTest and GoogleMock. By addressing major API transitions, clarifying expected behaviors, and providing migration advice, it empowers users to maintain reliable, up-to-date test suites.


---

<Check>
Ensure your mock classes use modern `MOCK_METHOD` syntax for future compatibility.
Use `NiceMock` and `StrictMock` consciously to manage uninteresting call behavior.
Explicitly disambiguate overloaded methods in expectations.
Utilize `.RetiresOnSaturation()` for managing expectation lifetimes.
Verify mocks explicitly if their lifetimes are uncertain.
</Check>


---

## Example: Migrating a Mock Class from Legacy to Modern Syntax

```cpp
// Legacy style
class MockFoo : public Foo {
 public:
  MOCK_CONST_METHOD1(FooMethod, int(int));
  MOCK_METHOD2(BarMethod, void(int, const std::string&));
};

// Modern replacement
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, FooMethod, (int), (const, override));
  MOCK_METHOD(void, BarMethod, (int, const std::string&), (override));
};
```


## Example: Controlling Mock Strictness

```cpp
using ::testing::NiceMock;
using ::testing::StrictMock;

// A nice mock suppresses warnings on uninteresting calls
NiceMock<MockFoo> nice_mock;

// A strict mock treats uninteresting calls as errors
StrictMock<MockFoo> strict_mock;
```

---

## Frequently Asked Questions

### Q: What happens if I set expectations after a mock is verified and cleared?
A: Setting new expectations after calling `VerifyAndClearExpectations` leads to undefined behavior. Always set expectations before exercising the mock.

### Q: Are uninteresting calls always warnings?
A: By default, yes. You can suppress warnings with `NiceMock` or treat uninteresting calls as errors with `StrictMock`.

### Q: Why do I get ambiguous mock method errors with overloaded methods?
A: Overloaded methods must be disambiguated using `Const()` or explicit matcher types in your expectations.

---

For further assistance or to report issues, visit the [GoogleTest GitHub repository](https://github.com/google/googletest).

---

[Back to Changelog Overview](../release-history/version-overview)
