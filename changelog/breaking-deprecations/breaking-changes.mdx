---
title: "Breaking Changes & Migration Notes"
description: "Clearly lists all breaking changes introduced in significant releases, with guidance on how to adapt existing tests and projects. Helps maintainers plan safe migrations in advance."
---

# Breaking Changes & Migration Notes

This page clearly lists all breaking changes introduced in significant releases of GoogleMock. It provides detailed guidance on adapting existing tests and projects, empowering maintainers to plan safe migrations in advance and ensure smooth upgrades.

---

## 1. Introduction

When upgrading GoogleMock to a new major or notable minor version, it is critical to understand any breaking changes that may impact your tests. This guide highlights these changes and provides actionable migration instructions to minimize test disruptions and maintain test reliability.

---

## 2. Key Breaking Changes by Version

### 2.1 Migration from Legacy MOCK_METHODn Macros to MOCK_METHOD

**Description:**
- The legacy family of macros `MOCK_METHODn`, `MOCK_CONST_METHODn`, and their variants with `_T` and `_WITH_CALLTYPE` suffixes have been superseded by the unified `MOCK_METHOD` macro.
- The newer `MOCK_METHOD` macro standardizes mock method declarations and supports additional qualifiers robustly.

**Impact:**
- Existing mocks using legacy macros might fail to compile in newer GoogleMock versions.
- Method signatures requiring `const`, `override`, `noexcept`, or reference qualifiers should be updated to use the correct `MOCK_METHOD` syntax.

**Migration Guide:**
- Replace legacy macros with `MOCK_METHOD` according to the new syntax:

```cpp
// Old:
MOCK_METHOD1(Foo, bool(int));
MOCK_CONST_METHOD1(Foo, bool(int));

// New:
MOCK_METHOD(bool, Foo, (int), (override));
MOCK_METHOD(bool, Foo, (int), (const, override));
```

- Parentheses are required around parameter lists in the new macro.
- Use `(const)`, `(override)`, or other qualifiers as needed in the fourth parameter.
- For methods with commas in return or parameter types, wrap the type in parentheses.


### 2.2 Strict Enforcement of EXPECT_CALL Clause Order and Syntax

**Description:**
- `EXPECT_CALL` clauses must follow a strict order for chained modifiers (e.g., `.With()`, `.Times()`, `.InSequence()`, `.After()`, `.WillOnce()`, `.WillRepeatedly()`, `.RetiresOnSaturation()`).
- The `.With()` clause is now required to be the first modifier and can appear at most once.
- `.Times()` must appear before `.InSequence()`, `.After()`, `.WillOnce()`, `.WillRepeatedly()`, `.RetiresOnSaturation()`.
- Using modifiers out of order will cause runtime errors/assertions.

**Impact:**
- Tests using incorrect chaining or ordering of these clauses will fail during execution.

**Migration Guide:**
- Review your `EXPECT_CALL` statements and ensure modifiers are chained in the prescribed order.
- Place `.With()` immediately after `EXPECT_CALL(...)` if used.
- Place `.Times()` before `.InSequence()`, `.After()`, and action clauses.

Example corrected usage:

```cpp
EXPECT_CALL(mock_obj, Method(_))
  .With(SomeMatcher())
  .Times(3)
  .InSequence(seq)
  .WillOnce(Return(true))
  .WillRepeatedly(Return(false))
  .RetiresOnSaturation();
```


### 2.3 Default Cardinality Inference Changes

**Description:**
- Cardinality (i.e., number of expected calls) inference rules when `.Times()` is omitted have been clarified and standardized.

**Impact:**
- Tests that omit `.Times()` may behave differently if multiple `.WillOnce()` or `.WillRepeatedly()` clauses are used.

**Migration Guide:**
- Explicitly specify `.Times()` clauses when you want strict control.
- Know that:
  - With no `.WillOnce()` or `.WillRepeatedly()`, `.Times(1)` is inferred.
  - With *n* `WillOnce()` and no `WillRepeatedly()`, `.Times(n)` is inferred.
  - With *n* `WillOnce()` and one `WillRepeatedly()`, `.Times(AtLeast(n))` is inferred.


### 2.4 Enforcement of `.WillRepeatedly()` Usage

**Description:**
- `.WillRepeatedly()` can only be used at most once per expectation and must appear after all `.WillOnce()` clauses.

**Impact:**
- Tests that specify multiple `.WillRepeatedly()` clauses or out-of-order calls will fail.

**Migration Guide:**
- Refactor chained actions to have a single `.WillRepeatedly()` clause last.
- All `.WillOnce()` clauses must come before `.WillRepeatedly()`.


### 2.5 Macros Handle Commas in Types More Robustly

**Description:**
- `MOCK_METHOD` now requires wrapping return types or argument types that have commas (e.g., `std::pair<int, int>`) in parentheses or using type aliases to avoid macro parsing errors.

**Impact:**
- Code failing to wrap such types in parentheses will not compile.

**Migration Guide:**
- Wrap complex types with parentheses when used as return or parameter types:

```cpp
MOCK_METHOD((std::pair<int, int>), GetPair, ());
```

- Alternatively, define type aliases:

```cpp
using PairInt = std::pair<int, int>;
MOCK_METHOD(PairInt, GetPair, ());
```


### 2.6 StrictMock, NiceMock, NaggyMock Limitations

**Description:**
- These wrappers only work correctly for mock methods defined directly with `MOCK_METHOD` in the mock class itself.
- Wrapping mocks that contain methods mocked in base classes may cause uninteresting calls not to be detected or suppressed.
- Virtual destructors are required for these wrappers to function correctly.

**Impact:**
- Tests wrapping mocks without virtual destructors or with base-class-defined mocks may experience inconsistent behavior regarding uninteresting call handling.

**Migration Guide:**
- Ensure all mocked methods are declared with `MOCK_METHOD` directly in the actual mock class.
- Add virtual destructors to mock classes where missing.
- Avoid nesting these wrappers (e.g., `NiceMock<StrictMock<MockFoo>>`).


### 2.7 Handling of Uninteresting Calls and Warnings

**Description:**
- By default, uninteresting calls (mock method calls with no `EXPECT_CALL` expectations) produce warnings.
- The verbosity and strictness of warnings can be controlled with `NiceMock` (suppress warnings), `NaggyMock` (default, show warnings), and `StrictMock` (fail on uninteresting calls).

**Impact:**
- Tests relying on uninteresting calls without proper expectation setup may receive warnings or failures unexpectedly after upgrading.

**Migration Guide:**
- If warnings are unwanted, wrap mocks in `NiceMock<>`.
- Explicitly specify `EXPECT_CALL` with `Times(AnyNumber())` for methods you expect but do not want to verify.


### 2.8 Calling Conventions Support

**Description:**
- Support for specifying calling conventions in mocked methods using `Calltype(...)` syntax.

**Impact:**
- Previously, calltype needed legacy macro variants; now, `MOCK_METHOD` supports it via qualifiers.

**Migration Guide:**
- Update mocks to use the `MOCK_METHOD` macro with `Calltype` qualifier:

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE)));
```


### 2.9 Ref-Qualified Methods Support

**Description:**
- Support for mocking methods with `&` and `&&` reference qualifiers using the `ref(...)` specifier.

**Impact:**
- Newly introduced or previously unsupported ref-qualified methods require qualifier syntax.

**Migration Guide:**
- Add `ref(&)` or `ref(&&)` qualifiers as applicable:

```cpp
MOCK_METHOD(int, RefQualifiedMethod, (), (const, ref(&), override));
```


### 2.10 Verifying and Clearing Expectations and Default Actions

**Description:**
- APIs `Mock::VerifyAndClearExpectations()` and `Mock::VerifyAndClear()` provide programmatic verification and clearing of expectations and default actions.

**Impact:**
- Helps in tests managing mock lifetimes manually, ensuring timely verification.

**Migration Guide:**
- Use these APIs to verify mocks before destruction when the lifetime is not fully controlled.


## 3. Common Migration Pitfalls

- Setting expectations (`EXPECT_CALL`) after exercising the mock leads to undefined behavior.
- Mixing legacy and new macros inconsistently may cause compile errors.
- Failing to wrap complex types with parentheses in `MOCK_METHOD` usage breaks the build.
- Violating the order of expectation modifier chaining causes run-time assertions.
- Attempting nested `NiceMock`/`StrictMock` wrappers or wrapping mocks with base-class mocks breaks strictness policies.


## 4. Practical Migration Tips

- Start by updating all `MOCK_METHODn` macros to modern `MOCK_METHOD` with proper qualifiers.
- Audit `EXPECT_CALL` chains for modifier order compliance.
- Use `NiceMock` or `StrictMock` wrappers wisely to control uninteresting call reporting.
- Check that destructors in mocked classes are virtual.
- Use type aliases and parentheses to guard against macro parsing problems with complex types.
- Run your test suite with `--gmock_verbose=info` to inspect call matching and diagnose expectation issues.


## 5. Further Resources

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) – for recipes on migrating and writing expectations
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) – detailed API documentation
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) – a quick reference
- [Nice, Strict, and Naggy Mocks](https://google.github.io/googletest/gmock_nice_strict.html) – control mock call policies
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) – beginner-friendly guide

---

By carefully reviewing these breaking changes and following the migration instructions, you can ensure your tests remain stable and effective as you upgrade GoogleMock.

