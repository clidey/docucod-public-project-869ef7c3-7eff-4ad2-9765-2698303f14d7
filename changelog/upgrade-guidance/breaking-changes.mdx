---
title: "Breaking Changes & Migrations"
description: "Catalogs major breaking changes, migration requirements, and incompatible behaviors introduced in each release. Includes step-by-step instructions and example code for adapting existing tests and build systems to new expectations."
---

# Breaking Changes & Migrations

This page catalogs major breaking changes, migration requirements, and incompatible behaviors introduced in each GoogleTest release. It provides you with detailed guidance on adapting your existing tests and build systems to new expectations, including step-by-step migration instructions and example code snippets.

---

## Understanding Breaking Changes

Breaking changes in GoogleTest occur when a new release introduces behavior or API modifications that are incompatible with previous releases. Such changes may cause existing tests, test suites, or build configurations to fail or behave unexpectedly.

This section helps you anticipate and navigate these changes to ensure a smooth upgrade.

### Why Breaking Changes Matter

Upgrading GoogleTest without accounting for breaking changes may result in:

- Compilation errors due to changed APIs or deprecated macros
- Runtime test failures caused by stricter assertions or altered semantics
- Unexpected test skips or altered test flows

Properly managing these changes preserves test reliability, saves debugging time, and leverages improvements effectively.

## Migration Requirements by Release

Each release may introduce its own set of breaking changes. Below, discover notable changes from recent versions along with concrete migration steps to update your codebase.

### Sample Migration: Using Predicate Assertions for Better Error Messages

GoogleTest enhanced its assertion model by encouraging users to prefer predicate assertions over `EXPECT_TRUE()` with complex expressions. This change helps surface clearer failure diagnostics.

**Migration Steps:**

1. Replace instances like:

   ```cpp
   EXPECT_TRUE(complex_condition);
   ```

2. With a predicate function returning `testing::AssertionResult`, for example:

   ```cpp
   testing::AssertionResult IsEven(int n) {
     if ((n % 2) == 0)
       return testing::AssertionSuccess();
     else
       return testing::AssertionFailure() << n << " is odd";
   }
   ```

3. Then use:

   ```cpp
   EXPECT_TRUE(IsEven(value));
   ```

This yields failure messages detailing why a condition failed, greatly aiding debugging.

### Adapting Assertion Placement in Functions

A breaking change addresses the use of fatal assertion macros (`ASSERT_*` and `FAIL`) inside non-void-returning functions, constructors, or destructors, which caused confusing compiler errors. Now, fatal assertions should only be used in functions returning `void`.

**Migration Tips:**

- Change your function to return `void` if possible.
- Alternatively, refactor your logic to return values through out parameters.
- Use non-fatal assertions like `EXPECT_*` if changing the function signature is impractical.

### Handling Death Tests in Multithreaded Contexts

To mitigate issues with death tests running in multithreaded environments, GoogleTest offers the "threadsafe" death test style.

**Migration: Set death test style programmatically or via command line:**

```cpp
GTEST_FLAG_SET(death_test_style, "threadsafe");
```

Or during initialization:

```cpp
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  GTEST_FLAG_SET(death_test_style, "threadsafe");
  return RUN_ALL_TESTS();
}
```

This change enhances safety at the cost of test runtime.

### Deprecation of Underscore in Test and Test Suite Names

To avoid compiler and runtime conflicts, GoogleTest disallows test suite and test names with underscores `_` at the beginning or end, or double underscores internally. This breaking change improves compatibility and future-proofs your tests.

**Migration Suggestion:** Rename test suites and test names to avoid leading, trailing, or consecutive underscores.

## Step-by-Step Migration Instructions

### Example: Migrating ASSERT_* Usage in Constructors

1. **Identify fatal assertions in constructors or destructors.**

2. **Refactor them into `SetUp()` or `TearDown()` methods:**

   ```cpp
   class FooTest : public testing::Test {
    protected:
     FooTest() {
       // No ASSERT here
     }

     void SetUp() override {
       ASSERT_TRUE(Initialize());
     }
   };
   ```

3. **If `void` return is not an option for helper functions, switch to non-fatal assertions or change return type.**

### Example: Moving Toward Predicate-Formatter Assertions for Complex Conditions

1. Define a predicate-formatter function with signature:

   ```cpp
   testing::AssertionResult PredicateFormatter(const char* expr1, const char* expr2, /*...*/, T1 val1, T2 val2, ...);
   ```

2. Use the `EXPECT_PRED_FORMAT*` macros:

   ```cpp
   EXPECT_PRED_FORMAT2(PredicateFormatter, arg1, arg2);
   ```

3. This provides precise control over failure messages.

## Code Examples for Migration

### Using Predicate-Formatter Assertions

```cpp
// Predicate-formatter that checks if two integers sum to an even number.
testing::AssertionResult AssertSumIsEven(const char* e1, const char* e2, int n1, int n2) {
  if (((n1 + n2) % 2) == 0) {
    return testing::AssertionSuccess();
  }
  return testing::AssertionFailure() << e1 << " + " << e2 << " (" << n1 << " + " << n2 << ") is not even.";
}

// Usage in test:
EXPECT_PRED_FORMAT2(AssertSumIsEven, a, b);
```

### Refactoring Fatal Assertions in Non-Void Functions

```cpp
// Old brittle code:
int Foo() {
  ASSERT_TRUE(doSomething());  // Causes compilation error
  return 42;
}

// New preferred code:
void Foo(int* result) {
  ASSERT_TRUE(doSomething());
  *result = 42;
}

TEST(MyTest, TestFoo) {
  int result = 0;
  Foo(&result);
  ASSERT_EQ(result, 42);
}
```

## Common Pitfalls and Troubleshooting

- **Using fatal assertions in constructors or destructors:** Compilation will fail. Refactor to `SetUp()`/`TearDown()`.
- **Multiple death test assertions on the same line:** Leads to compilation errors. Separate death test statements.
- **Thread-unsafe death tests:** Can cause hangs or flaky tests. Use `death_test_style = "threadsafe"`.
- **Underscores in test names:** May cause naming collisions and are disallowed.

## Best Practices

- Stay informed of breaking changes for each release before upgrading.
- Use the GoogleTest flags (e.g., `--gtest_death_test_style`, `--gtest_break_on_failure`) to control runtime behavior.
- Refactor complex predicate logic into dedicated predicate or predicate-formatter functions.
- For testing private or internal code, prefer design patterns that avoid breaking changes affecting client tests.

## Additional Resources and Links

- [GoogleTest Assertions Reference](reference/assertions.md): Detailed description of all assertions, including predicate format assertions.
- [Advanced GoogleTest Topics](docs/advanced.md): In-depth guide on assertions, death tests, and test design.
- [Breaking Changes & Migrations (Changelog Section)](/changelog/upgrade-guidance/breaking-changes): Continuous updates on release-specific breaking changes.
- [FAQ: Test Naming Conventions](docs/faq.md#why-should-test-suite-names-and-test-names-not-contain-underscore): Guidance on test and test suite naming to avoid conflicts.
- [Death Tests](reference/gtest-core-api/death-tests.md): Comprehensive Death Test API documentation.

---

This page is an essential reference to understand and adapt your test code whenever upgrading GoogleTest. Plan your migrations carefully using the instructions provided here to maintain test stability and capitalize on new features.
