---
title: "User-Defined Assertions"
description: "Covers the mechanisms and best practices for creating custom assertions tailored to project-specific needs, ensuring more readable and maintainable tests."
---

# User-Defined Assertions

GoogleTest provides a rich set of built-in assertion macros to verify program behavior, but there are times when your tests require assertions tailored to specific project needs or complex conditions. This guide covers how to create custom assertions in GoogleTest, enabling you to write more expressive, readable, and maintainable tests.

---

## Why Create User-Defined Assertions?

While GoogleTest includes many assertions to check conditions like equality, throws, floating-point comparisons, and string matches, your projects will often involve domain-specific logic that simple built-in assertions cannot cleanly express. User-defined assertions allow you to:

- Encapsulate complex verification logic into reusable components.
- Produce clearer test failure messages.
- Reduce boilerplate and duplicate code.
- Seamlessly integrate with GoogleTest's reporting.


<Check>
Creating custom assertions ensures your tests communicate intent clearly and provide useful feedback when tests fail.
</Check>

---

## Fundamental Concepts of Custom Assertions

GoogleTest supports two main approaches to write custom assertions:

### 1. Predicate Assertions

These assertions verify that arbitrary predicates or functions return `true` for the test values. They come with two macro families:

- `EXPECT_PREDn` and `ASSERT_PREDn`: where `n` is the number of arguments (from 1 to 5). You pass a predicate function and its arguments.

- `EXPECT_PRED_FORMATn` and `ASSERT_PRED_FORMATn`: similar but allow writing predicate-formatters that produce human-friendly failure messages.

**Example:** Using a simple predicate to check that two values are mutually prime:

```cpp
bool MutuallyPrime(int m, int n) { ... }
...
EXPECT_PRED2(MutuallyPrime, a, b);  // a and b are int variables
```

If the assertion fails, GoogleTest prints the predicate's name and the argument values.

### 2. Writing Predicate-Formatters

Predicate-formatters are functions or functors with the signature:

```cpp
testing::AssertionResult PredicateFormatter(const char* expr1, const char* expr2, ..., T1 val1, T2 val2, ...);
```

They return `testing::AssertionSuccess()` for success or `testing::AssertionFailure()` with a detailed message for failure.

**Example:**

```cpp
testing::AssertionResult AssertMutuallyPrime(
    const char* m_expr, const char* n_expr, int m, int n) {
  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();

  return testing::AssertionFailure() << m_expr << " and " << n_expr
      << " (" << m << " and " << n << ") are not mutually prime.";
}

EXPECT_PRED_FORMAT2(AssertMutuallyPrime, x, y); // use in tests
```

This produces clear failure messages specifying which expression failed and why.

---

## Step-by-Step Guide to Creating a Custom Assertion

### Step 1: Identify the Verification Logic

Think about the condition you want to check frequently. For example, you might want to verify that a value lies within a certain range or that two objects meet a custom equality criterion.

### Step 2: Choose the Assertion Type

- Use simple predicate functions with `EXPECT_PREDn` for straightforward true/false checks.
- Use predicate-formatters with `EXPECT_PRED_FORMATn` to deliver custom failure messages.

### Step 3: Implement the Predicate or Predicate-Formatter

- For predicates:
  ```cpp
  bool IsInRange(int value, int low, int high) {
    return low <= value && value <= high;
  }
  ```

- For predicate-formatters:
  ```cpp
  testing::AssertionResult AssertInRange(const char* val_expr, const char* low_expr, const char* high_expr, int val, int low, int high) {
    if (low <= val && val <= high) return testing::AssertionSuccess();

    return testing::AssertionFailure() << val_expr << " is not in range [" << low << ", " << high << "]";
  }
  ```

### Step 4: Use the Custom Assertion in Tests

- Predicate example:
  ```cpp
  EXPECT_PRED3(IsInRange, value, 10, 20);
  ```

- Predicate-formatter example:
  ```cpp
  EXPECT_PRED_FORMAT3(AssertInRange, value, 10, 20);
  ```


---

## Best Practices for Creating User-Defined Assertions

- **Design for clarity:** Make failure messages informative so users can quickly identify the cause of a failure.
- **Keep side effects out:** Predicate functions and matchers must be pure, without side effects, since GoogleTest may call them multiple times.
- **Use streaming for details:** Leverage `<<` streaming to append failure context in predicate-formatters.
- **Define reusable components:** Place your predicates and predicate-formatters in shared headers to promote reuse.
- **Document expected behavior:** Clearly describe what the assertion checks and how to use it.

<Info>
Avoid complex logic inside assertions that might confuse users or obscure the actual test failure reasons.
</Info>

---

## Practical Examples

### Custom Predicate Assertion

```cpp
bool IsEven(int n) {
  return (n % 2) == 0;
}

TEST(NumberTest, EvenCheck) {
  int value = 3;
  EXPECT_PRED1(IsEven, value) << "Value should be even.";
}
```

If `value` is odd, the test fails and outputs the predicate name and the value.

### Custom Predicate-Formatter for Range Check

```cpp
testing::AssertionResult AssertInRange(const char* val_expr, const char* low_expr, const char* high_expr,
                                       int val, int low, int high) {
  if (low <= val && val <= high) return testing::AssertionSuccess();
  return testing::AssertionFailure() << val_expr << " (= " << val << ") is not in the range ["
                                   << low << ", " << high << "]";
}

TEST(RangeTest, ValueCheck) {
  int x = 5;
  EXPECT_PRED_FORMAT3(AssertInRange, x, 0, 3);
}
```

This produces a failure message such as:

```
x (= 5) is not in the range [0, 3]
```

### Integrating Custom Assertions into Test Suites

Place your user-defined assertion functions and predicate-formatters in dedicated utility headers, such as `custom_assertions.h`. Import them in your test files for consistent use.

```cpp
#include "custom_assertions.h"

TEST(MyComponentTest, CustomCheck) {
  ...
  EXPECT_PRED_FORMAT2(CustomAssertion, val1, val2);
}
```

---

## Troubleshooting

### Assertion Not Printing Expected Messages

- Ensure your predicate-formatter returns `testing::AssertionSuccess()` or `testing::AssertionFailure()` correctly.
- Use streaming (`<<`) inside predicate-formatters only when returning failure to append diagnostics.

### Unexpected Multiple Invocations

- Remember that matchers and predicates may be called multiple times; keep them free of side effects.

### Compiler Errors

- Signature mismatches in predicate-formatters or predicates cause errors; verify the parameter types and count.

### Handling Complex Types

- For custom types, implement `operator<<` for `std::ostream` to get meaningful output from assertions.

---

## Related GoogleTest Features

- **Built-in Assertions:** Explore `EXPECT_EQ`, `EXPECT_TRUE`, `EXPECT_THROW`, and `EXPECT_THAT` for common checks.
- **Matchers:** Use [GoogleMock matchers](matchers.md) with `EXPECT_THAT` for expressive value comparisons.
- **Mocking:** For testing interactions, see [GoogleMock for Dummies](gmock_for_dummies.md).

---

## Summary

User-defined assertions enhance your ability to validate domain-specific conditions and produce meaningful failure messages. Utilizing predicate and predicate-formatter APIs provides flexibility and integrates smoothly with GoogleTest's existing assertion framework.

For more examples and advanced assertion techniques, consider exploring the [gMock Cookbook - Custom Actions and Matchers](core-concepts-googletest/extensibility-behavior/custom-actions-matchers) and [Assertions Reference](docs/reference/assertions.md).

---