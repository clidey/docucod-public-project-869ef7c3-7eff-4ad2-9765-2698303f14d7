---
title: "Writing Custom Assertions and Matchers"
description: "Extend GoogleTest and GoogleMock with your own assertions and matchers. Understand core APIs and best practices to enhance expressiveness and reusability in your tests."
---

# Writing Custom Assertions and Matchers

Extend the expressiveness and precision of your tests by creating your own assertions and matchers in GoogleTest and GoogleMock. This page guides you through the APIs, techniques, and best practices for writing reusable, clear, and efficient custom matchers and assertions.

---

## 1. Understanding the Role of Assertions and Matchers

Before diving into custom implementation, recall that:

- **Assertions** are statements in your tests that verify if a condition holds, e.g., `EXPECT_EQ`, `ASSERT_TRUE`.
- **Matchers** are predicates that describe conditions on values or arguments, used within assertions such as `EXPECT_THAT(actual, matcher)`. They provide readable failure messages and composability.

GoogleTest and GoogleMock provide a broad set of built-in assertions and matchers, but writing your own lets you encapsulate complex validation logic suited to your domain.

---

## 2. Creating Lightweight Matchers With the `MATCHER` Macros

### 2.1 Basic Matcher Definition

Use `MATCHER(name, description)` to define simple unary matchers:

```cpp
MATCHER(IsEven, "checks if a number is even") {
  return (arg % 2) == 0;
}
```

Use it as:

```cpp
EXPECT_THAT(value, IsEven());
```

If you provide an empty string for the description, GoogleMock derives it from the matcher name.

### 2.2 Adding Detailed Failure Messages

You can write custom failure explanations by streaming into the `result_listener`:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if (arg % 7 == 0) {
    return true;
  }
  *result_listener << "where the remainder is " << (arg % 7);
  return false;
}
```

If the match fails, users see extra context:

```
Value of: value
Expected: is divisible by 7
  Actual: 27 (where the remainder is 6)
```

### 2.3 Parameterized Matchers With `MATCHER_P` and Variants

For matchers with parameters, use `MATCHER_P(name, param, description)` or `MATCHER_P2`, etc.:

```cpp
MATCHER_P(IsWithinRange, bound, "") {
  return arg >= -bound && arg <= bound;
}

// Usage
EXPECT_THAT(value, IsWithinRange(5));
```

You can add parameters to the description string referencing `param` for clarity.

---

## 3. Defining Matcher Classes for Advanced Control

When you need advanced control, detailed messages, or reusable types, define a matcher class:

```cpp
class DivisibleByMatcher {
 public:
  using is_gtest_matcher = void;  // Marker type

  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os) {
      *os << "which leaves a remainder of " << (n % divisor_);
    }
    return false;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by " << divisor_;
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by " << divisor_;
  }

 private:
  const int divisor_;
};

::testing::Matcher<int> IsDivisibleBy(int divisor) {
  return ::testing::MakePolymorphicMatcher(DivisibleByMatcher(divisor));
}
```

Use:

```cpp
EXPECT_THAT(x, IsDivisibleBy(3));
```

This approach supports polymorphic matching and rich diagnostics.

---

## 4. Combining Matchers

Leverage existing matcher combinators to build complex semantics:

- `AllOf(m1, m2, ...)` — all conditions true
- `AnyOf(m1, m2, ...)` — any condition true
- `Not(m)` — negation
- `Field(&Class::member, m)` — match member fields
- `Property(&Class::method, m)` — match results of getter methods

Example:

```cpp
EXPECT_THAT(foo, AllOf(Field(&Foo::bar, Ge(10)), Property(&Foo::IsValid, IsTrue())));
```

---

## 5. Using Matchers in Assertions

Use the powerful `EXPECT_THAT(value, matcher)` and `ASSERT_THAT(value, matcher)` macros to make full use of matchers.

Example:

```cpp
EXPECT_THAT(result, StartsWith("Hello") );
ASSERT_THAT(container, ElementsAre(1, _, 3));
```

These provide descriptive failure messages highlighting the mismatch.

---

## 6. Writing Custom Assertions

While matchers test properties of values, custom assertions help define complex pass/fail criteria with clear failure messages.

GoogleTest assertions are based on macros like `EXPECT_*` and `ASSERT_*`. You can write a custom assertion function returning `::testing::AssertionResult`:

```cpp
::testing::AssertionResult IsPositive(int n) {
  if (n > 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << "value " << n << " is not positive";
}
```

Use it in tests:

```cpp
EXPECT_TRUE(IsPositive(value)) << "Additional failure context";
```

For predicate assertions with arguments, your function signature should accept the values and expression strings.

Alternatively, use `EXPECT_PRED_FORMAT*` macros to integrate assertion formatters.

---

## 7. Best Practices and Tips

- **Keep matchers pure and side-effect free:** They may be evaluated multiple times.
- **Provide informative failure messages:** They should clarify why matching failed.
- **Use polymorphic matchers for flexibility:** Support multiple types where appropriate.
- **Share matcher objects:** Matchers are cheap to copy and can be reused for clarity and performance.
- **Avoid over-specification:** Define only the constraints that matter to avoid brittle tests.
- **Combine matchers smartly:** Compose small matchers into complex logic for readability.
- **Use custom assertions when testing complex conditions:** They complement matchers by handling logic and failure reporting.

---

## 8. Troubleshooting

### Common Issues

- **Implicit conversions causing unintended matches:** Always use explicit matchers like `Eq()` rather than relying on automatic conversions.
- **Matcher evaluation side effects:** Never modify external state in matcher code.
- **Ambiguous overloads in matchers:** Use typed matchers (`TypedEq<>`) or `SafeMatcherCast` to resolve ambiguity.

### Tips

- Test your matcher independently to ensure correct behavior.
- Use `--gmock_verbose=info` to debug mock matching and verify flows.

---

## 9. Next Steps & Resources

- Explore the [Matchers Reference](reference/matchers.md) for a comprehensive list of built-in matchers.
- Learn about [Defining New Actions](gmock_cook_book.md#QuickNewActions) to customize mock behavior.
- Review [Writing Your First Test](gtest-guides/getting-started/write_first_test) to see matchers in action.
- Consult the [gMock Cookbook](docs/gmock_cook_book.md) for practical recipes and idioms.

---

# Summary
This guide thoroughly empowers you to extend GoogleTest and GoogleMock by crafting custom assertions and matchers, enhancing the precision, clarity, and maintainability of your tests. It covers practical macro-based definitions, advanced class-based matchers, combining existing matchers, writing custom assertions, best practices, and troubleshooting. Key links direct you to the matchers reference, assertions reference, and the gMock Cookbook for deeper learning and applied examples.

# Related Documentation
- [Matchers Reference](reference/matchers.md)
- [Assertions Reference](reference/assertions.md)
- [Mocking Reference and Cookbook](docs/gmock_cook_book.md)
- [Writing Your First Test](gtest-guides/getting-started/write_first_test)

# Key Action Items
- Start by creating simple custom matchers with the `MATCHER` macro.
- Move to class-based matchers for complex logic.
- Use `EXPECT_THAT` and `ASSERT_THAT` with custom matchers in your tests.
- Write custom assertions returning `AssertionResult` for advanced conditions.
- Leverage matcher combinators to compose and refine conditions.
- Always write pure matchers and provide descriptive failure output.
