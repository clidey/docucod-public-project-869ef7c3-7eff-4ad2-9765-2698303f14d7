---
title: "User-Defined Assertions"
description: "Instructions and best practices for defining your own assertion macros and results to enable project-specific validation logic. Explains required interfaces, result types, and integration with GoogleTest’s reporting mechanism."
---

# User-Defined Assertions

This page guides you through creating your own assertion macros and assertion results to extend GoogleTest with project-specific validation logic. By defining user assertions, you can customize how conditions are verified, how failures and successes are reported, and integrate deeply with GoogleTest's test reporting infrastructure.

## Overview

GoogleTest offers a rich set of built-in assertions, but there are cases where your domain or project requires specialized validation logic that's not covered by the defaults. User-defined assertions enable you to write reusable, expressive checks that seamlessly integrate with the test framework’s rich failure messages and test result tracking.

This page explains the interfaces and mechanisms needed to create user-defined assertion macros and the types of results they produce.

---

## What Are User-Defined Assertions?

User-defined assertions are custom test checks implemented by you as macros or functions. They achieve the following:

- Encapsulate project-specific checks in one place.
- Provide detailed and customized failure messages.
- Integrate with GoogleTest’s test reporting and filtering mechanisms.

GoogleTest supports these assertions mainly in two forms:

1. **Boolean Assertions**: Macros or functions that verify a condition and generate success or failure.
2. **Predicate Assertions**: More advanced form where helper functions return an `AssertionResult` describing success or failure, allowing detailed custom messages.

## Defining User Assertions

### The Basic Structure of an Assertion

A user-defined assertion typically:

- Evaluates one or more expressions.
- Returns either success or failure along with an informative message in case of failure.
- Works with streaming `<<` operators to append custom messages.

### Using `testing::AssertionResult`

The class `testing::AssertionResult` encapsulates the success or failure state of an assertion along with an optional message. It is the preferred return type for user-defined predicate assertions.

You can create an `AssertionResult` by using the factory functions:

```cpp
namespace testing {

// Indicates a successful assertion.
AssertionResult AssertionSuccess();

// Indicates a failed assertion.
AssertionResult AssertionFailure();

}
```

You can append textual messages using stream operators:

```cpp
testing::AssertionResult AssertIsPositive(int n) {
  if (n > 0) {
    return testing::AssertionSuccess()
           << n << " is positive";  // Optional success message.
  } else {
    return testing::AssertionFailure()
           << n << " is not positive";  // Failure message.
  }
}
```

### Using an Assertion in Your Tests

Once you have such a predicate-formatter, use it inside assertions like so:

```cpp
EXPECT_TRUE(AssertIsPositive(value));
ASSERT_TRUE(AssertIsPositive(value));
```

GoogleTest will use the message embedded in the `AssertionResult` when the assertion fails or unexpectedly succeeds.

---

## Predicate Assertions

GoogleTest provides a family of predicate assertion macros to facilitate calling your predicate-formatter functions. These include:

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)`, `ASSERT_PRED_FORMAT1(pred_formatter, val1)`,
- `EXPECT_PRED_FORMAT2(pred_formatter, val1, val2)`, ..., up to 5 parameters.

These macros:

- Forward the expressions and values to your formatter.
- Automatically print formatted failure messages.

Example:

```cpp
// Predicate formatter that checks if two integers are mutually prime.
testing::AssertionResult AssertMutuallyPrime(const char* a_expr,
                                             const char* b_expr,
                                             int a,
                                             int b) {
  if (std::gcd(a, b) == 1) return testing::AssertionSuccess();

  return testing::AssertionFailure() << a_expr << " and " << b_expr
                                   << " are not mutually prime";
}

TEST(NumberTheoryTest, MutuallyPrime) {
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, 3, 4);  // Succeeds
  EXPECT_PRED_FORMAT2(AssertMutuallyPrime, 6, 9);  // Fails with message
}
```

### Standard Predicate Assertions

Besides the predicate-formatter macros, GoogleTest supports simpler predicate macros like `EXPECT_PRED1`, `EXPECT_PRED2`, etc., for predicates returning bool. However, they generate simpler failure messages.

For richer error feedback, prefer predicate-format macros.

---

## Writing Assertion Macros

You can simplify using your user-defined assertions by wrapping them into macros, which behave like GoogleTest's built-in assertions.

Example:

```cpp
#define EXPECT_IS_POSITIVE(val) \
  EXPECT_PRED_FORMAT1(AssertIsPositive, val)

#define ASSERT_IS_POSITIVE(val) \
  ASSERT_PRED_FORMAT1(AssertIsPositive, val)
```

Use these macros in tests like:

```cpp
EXPECT_IS_POSITIVE(x);
ASSERT_IS_POSITIVE(y);
```

---

## Integrating User Assertions with GoogleTest Reporting

GoogleTest’s reporting mechanisms automatically recognize failures generated through `AssertionResult` and assertion macros.

Additionally, user assertions that generate fatal failures will stop the current function execution, preserving test flow like built-in assertions.

---

## Detailed API Overview

### Key Types

| Type                  | Description                                         |
|-----------------------|-----------------------------------------------------|
| `testing::AssertionResult` | Represents the result of an assertion; success or failure with message. |
| `testing::Message`     | Supports streaming data in assertion messages.    |
| `testing::TestPartResult` | Represents results of individual assertion failures or skips. |

### Key Functions

- `AssertionSuccess()`: Returns a successful AssertionResult.
- `AssertionFailure()`: Returns a failure AssertionResult.
- `StaticAssertTypeEq<T1, T2>()`: Compile-time assertion for type equality.

### Recommended Usage Pattern

Write a predicate-formatter function:

```cpp
testing::AssertionResult IsValidFoo(const char* expr, const Foo& foo) {
  if (foo.IsValid()) {
    return testing::AssertionSuccess();
  }
  return testing::AssertionFailure() << expr << " is not valid";
}
```

Invoke using:

```cpp
EXPECT_PRED_FORMAT1(IsValidFoo, foo_instance);
```

---

## Best Practices

- Use predicate-formatters (`AssertionResult`-returning functions) for detailed failure reporting.
- Provide meaningful messages in failures, including the expressions and values.
- Use macro wrappers for convenient usage and consistent syntax.
- Avoid side effects in expressions passed to assertions as arguments are evaluated exactly once but order is undefined.
- Use `StaticAssertTypeEq` to check template type correctness during compilation.
- Record properties related to custom assertions using `Test::RecordProperty()` when needed for XML/report outputs.

---

## Common Pitfalls and Troubleshooting

- Ensure your assertion macros are only used in `void`-returning functions if they produce fatal failures.
- Avoid undefined behavior or side effects in expressions supplied to assertions.
- When writing predicate-formatters for pointer or custom object types, provide suitable streaming operators or `PrintTo()`/`AbslStringify()` overloads for readable messages.
- Do not use fatal assertions in constructors or destructors.
- Be mindful that `EXPECT_*` macros continue test execution after failure, while `ASSERT_*` macros abort the current function.
- For wide strings in messages, GoogleTest converts them to UTF-8.

---

## Examples

### Creating a Simple User Assertion

```cpp
// Checks if a number is prime.
testing::AssertionResult IsPrime(const char* expr, int n) {
  if (n <= 1) return testing::AssertionFailure() << expr << " is not prime";
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) {
      return testing::AssertionFailure() << expr << " is not prime (divisible by " << i << ")";
    }
  }
  return testing::AssertionSuccess();
}

// Macro wrapper.
#define EXPECT_PRIME(val) EXPECT_PRED_FORMAT1(IsPrime, val)
#define ASSERT_PRIME(val) ASSERT_PRED_FORMAT1(IsPrime, val)

// Usage in tests.
TEST(MathTest, PrimeCheck) {
  EXPECT_PRIME(5);   // Succeeds.
  EXPECT_PRIME(6);   // Failure with detailed message.
}
```

### Using `RecordProperty` in User Assertions

```cpp
TEST(MyTestSuite, TestWithProperty) {
  int value = 42;
  // Record a property using a reserved key will add a nonfatal failure.
  ::testing::Test::RecordProperty("CustomKey", "CustomValue");
  EXPECT_EQ(value, 42);
}
```

Note: Avoid using reserved keys in properties: `classname`, `name`, `status`, `time`, `type_param`, `value_param`, `file`, `line`.

---

## See Also

- [Assertions Reference](reference/assertions.md) for built-in and user-define assertions.
- [Using Assertions Effectively](guides/core-workflows/using-assertions) for best practices.
- [Predicate Assertions](reference/assertions.md#predicates) for advanced assertion strategies.
- [ScopedTrace](reference/testing.md#ScopedTrace) and [SCOPED_TRACE](reference/testing.md#SCOPED_TRACE) for adding rich context to failures.
- [Test::RecordProperty()](reference/testing.md#Test::RecordProperty) for recording test properties.

---

## Notes

- User-defined assertions fully integrate with test results, allowing upstream tools and XML/JSON outputs to reflect their success or failure.
- Defining type assertions with `StaticAssertTypeEq` leads to compile-time validation of template types.
- Predicate-formatters enable the cleanest, most informative failure reporting and are the recommended approach for custom check implementations.

---

By implementing user-defined assertions as described, you empower your team to write clearer, domain-relevant tests that seamlessly behave as native parts of the GoogleTest framework, improving test readability, maintainability, and diagnostics.
