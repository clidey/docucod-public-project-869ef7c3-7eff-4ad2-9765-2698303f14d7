---
title: "Mock Object & Method Definitions"
description: "API reference for defining mock classes and methods using MOCK_METHOD and related macros. Explains signature specification, constness, overloading, and template support, with hands-on code examples for typical mock scenarios."
---

# Mock Object & Method Definitions

This page presents the definitive API reference for defining mock classes and methods in GoogleMock. It focuses on `MOCK_METHOD` and related macros that enable defining mocked methods with precise control over signatures, qualifiers, and overloading. Through hands-on examples, you will learn how to specify method signatures, handle const or noexcept qualifiers, support overloaded and templated methods, and write clean, maintainable mocks.

---

## Defining Mock Methods with `MOCK_METHOD`

The primary mechanism for defining mock methods is the `MOCK_METHOD` macro. It encapsulates the method’s return type, name, parameter types, and optional qualifiers such as `const`, `override`, or `noexcept`.

### Syntax
```cpp
MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (OptionalSpecs...));
```

- **ReturnType**: The method’s return type.
- **MethodName**: The exact name of the method you're mocking.
- **(ArgTypes...)**: A parenthesis-wrapped list of argument types matching the method signature.
- **(OptionalSpecs...)**: Optional comma-separated qualifiers to match the original declaration.

### Supported Qualifiers
- `const`: Makes the mock method a `const` method, required if mocking a `const` method.
- `override`: Recommended when overriding a virtual method.
- `noexcept`: Required when overriding a `noexcept` method.
- `Calltype(...)`: Sets the calling convention (e.g., for Windows `STDMETHODCALLTYPE`).
- `ref(&)` or `ref(&&)`: For methods with reference qualifiers.

### Important Notes
- Always place `MOCK_METHOD` declarations in the `public:` section, even if the original method is protected or private.
- Argument and return types containing commas (e.g., templates like `std::pair<bool, int>`) must be wrapped in extra parentheses or aliased with `using`.

### Example
```cpp
class MockExample {
 public:
  MOCK_METHOD(void, Foo, (int x), (override));
  MOCK_METHOD(int, Bar, (const std::string& s, bool flag), (const, override));
  
  // Handling types containing commas - solution 1: parentheses
  MOCK_METHOD((std::pair<bool, int>), GetPair, (), (override));
  
  // Solution 2: type alias
  using BoolIntPair = std::pair<bool, int>;
  MOCK_METHOD(BoolIntPair, GetOtherPair, (), (override));
};
```

---

## Mocking Overloaded Methods

Overloaded methods can be mocked by declaring each version individually with the full signature and qualifiers.

### Example
```cpp
class Foo {
 public:
  virtual int Add(int x);
  virtual int Add(int times, int x);
  virtual const std::string& GetName() const;
  virtual std::string& GetName();
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
  MOCK_METHOD(const std::string&, GetName, (), (const, override));
  MOCK_METHOD(std::string&, GetName, (), (override));
};
```

### Avoid hiding base class overloads

If you do not mock all overloads, visibility of the omitted ones can be hidden. Use `using` declarations to bring base class overloads into scope:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add; // Bring other overloads into scope
  MOCK_METHOD(int, Add, (int x), (override));
};
```

---

## Mocking Class Templates

Templates can be mocked just like normal classes. Place the mock methods inside the template mock class.

### Example
```cpp
template<typename T>
class Stack {
 public:
  virtual ~Stack();
  virtual void Push(const T& elem) = 0;
  virtual int Size() const = 0;
};

template<typename T>
class MockStack : public Stack<T> {
 public:
  MOCK_METHOD(void, Push, (const T& elem), (override));
  MOCK_METHOD(int, Size, (), (const, override));
};
```

---

## Special Cases and Techniques

### Mocking Non-virtual Methods

GoogleMock allows mocking non-virtual methods when your mock does not inherit from the real class but provides methods with matching signatures. Specify method behavior as usual but without the `override` qualifier.

```cpp
class RealClass {
 public:
  void DoSomething(int x);
};

class MockClass {
 public:
  MOCK_METHOD(void, DoSomething, (int x));
};
```

Use template-based dependency injection or direct instantiation in tests to swap implementations.

### Mocking Private or Protected Methods

Mock methods should always be declared in the `public:` section of the mock class, regardless of original method access level.

### Mocking Free Functions

Free functions can’t be mocked directly. Instead, refactor your code to use an interface with virtual methods, then mock the interface.

---

## Handling Method Signatures with Commas

Argument and return types that have commas (e.g. templates like `std::map<int, double>`) need special treatment because the macro argument parsing breaks otherwise.

**Solutions:**
1. Wrap such types in extra parentheses.
2. Use a `using` alias to provide a simple identifier.

Example:
```cpp
// Wrong: compiler errors due to commas
MOCK_METHOD(std::pair<bool, int>, GetSomething, ());
MOCK_METHOD(bool, CheckMap, (std::map<int, double>, bool));

// Correct approaches
MOCK_METHOD((std::pair<bool, int>), GetSomething, ());
MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));

using BoolIntPair = std::pair<bool, int>;
using IntDoubleMap = std::map<int, double>;
MOCK_METHOD(BoolIntPair, GetSomething, ());
MOCK_METHOD(bool, CheckMap, (IntDoubleMap, bool));
```

---

## Using `NiceMock`, `NaggyMock`, and `StrictMock`

GoogleMock provides wrappers to control how uninteresting calls (calls without expectations) are treated:

- **`NiceMock<T>`**: suppresses warnings on uninteresting calls.
- **`NaggyMock<T>`**: (default behavior) prints warnings on uninteresting calls.
- **`StrictMock<T>`**: treats uninteresting calls as failures.

All three are subclasses of `T` and can be constructed with the same arguments.

### Example:
```cpp
using ::testing::NiceMock;

NiceMock<MockFoo> nice_mock;  // Warnings are suppressed.
EXPECT_CALL(nice_mock, DoSomething());
nice_mock.DoSomething();
```

### Limitations
- Only affects methods directly mocked in `T` via `MOCK_METHOD`.
- Nested strictness wrappers (e.g., `NiceMock<StrictMock<T>>`) are not supported.
- Requires `T` to have a virtual destructor.

---

## Best Practices

- Always place `MOCK_METHOD` inside public sections.
- Use `override` for clarity and correctness when overriding virtual methods.
- Alias complex types with `using` to improve readability and avoid macro parsing issues.
- Prefer `NiceMock` to suppress noisy warnings in large tests.
- Use `StrictMock` sparingly for strict enforcement of call expectations.
- Mock overloaded and template methods explicitly, and maintain visibility with `using` if needed.

---

## Troubleshooting Common Pitfalls

- **Unprotected commas cause compile errors**: surround types containing commas with parentheses or define `using` aliases.
- **Missing `override` on virtual methods**: can cause subtle bugs and compilation warnings.
- **Mocking private/protected methods outside public block**: leads to errors; place mocks in `public:`
- **Ambiguity in overloaded methods**: use full signatures and `using` declarations.
- **Uninteresting call warnings**: use `NiceMock` or explicit `EXPECT_CALL(...).Times(AnyNumber())` to suppress.

---

## Sample Full Mock Class

```cpp
#include <gmock/gmock.h>

class MyInterface {
 public:
  virtual ~MyInterface() {}
  virtual int GetValue() const = 0;
  virtual void SetValue(int v) = 0;
  virtual std::string Describe(const std::string& name) = 0;
  virtual std::pair<int, bool> GetPair() = 0;
};

class MockMyInterface : public MyInterface {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(void, SetValue, (int v), (override));
  MOCK_METHOD(std::string, Describe, ((const std::string& name)), (override));
  MOCK_METHOD((std::pair<int, bool>), GetPair, (), (override));
};

// Usage in a test:
// MockMyInterface mock;
// EXPECT_CALL(mock, GetValue()).WillOnce(Return(42));
```

---

For further mastery, explore the following related resources in this documentation:
- [Expectations and Actions](../api_reference/mocking_api/expectations_and_actions)
- [Matchers Reference](../api_reference/mocking_api/matchers_reference)
- [Mock Behavior Modes](../api_reference/mocking_api/mock_behaviors_and_strategies)
- [gMock Cookbook](../../guides/advanced-usage-patterns/custom-matchers-actions)

Use this page as your go-to guide for creating and defining mock objects with GoogleMock with confidence and precision.
