---
title: "Defining and Using Mocks"
description: "How to declare mock classes and methods using GoogleMock. Explains the MOCK_METHOD macros, inheritance from interfaces, and practical use cases across test scenarios."
---

# Defining and Using Mocks

This documentation explains how to declare mock classes and methods using GoogleMock. It covers the use of the `MOCK_METHOD` macros for mocking member functions, inheriting from interfaces for mock definitions, and demonstrates practical use cases across diverse test scenarios. Whether you are mocking simple virtual methods or dealing with complex overloads and qualifiers, this guide empowers you to create effective and maintainable mocks.

---

## Overview of Mocking with GoogleMock

Mocks are objects that simulate the behavior of real classes or interfaces in controlled ways for testing. GoogleMock lets you declare mock classes easily via macros and set expectations and behaviors on their methods.

### Why Use Mocks?

* Isolate the code under test from dependencies.
* Control and verify interactions with collaborators.
* Simulate complex behavior, error conditions, or edge cases.

### High-level Workflow

1. Define a mock class inheriting the interface you want to mock.
2. Use the `MOCK_METHOD` macro to declare mocked methods.
3. Create mock instances in tests and use `EXPECT_CALL` or `ON_CALL` to set expectations or default behaviors.
4. Exercise your code, triggering calls on mocks.
5. GoogleMock automatically verifies expectations on mock destruction.

---

## Defining Mock Classes

### Basic Mock Class Definition

To declare a mock class:

- Derive from the interface or base class to mock.
- Use `MOCK_METHOD` in the public section to declare mock methods.

```cpp
#include <gmock/gmock.h>

class Interface {
 public:
  virtual ~Interface() = default;
  virtual int Foo(int x) = 0;
  virtual void Bar() const = 0;
};

class MockInterface : public Interface {
 public:
  MOCK_METHOD(int, Foo, (int x), (override));        // Mock non-const method
  MOCK_METHOD(void, Bar, (), (const, override));    // Mock const method
};
```

GoogleMock generates implementations for these methods behind the scenes.


### Important Notes

- `MOCK_METHOD` must be declared in the `public:` section even if the base method is protected or private to ensure `EXPECT_CALL` and `ON_CALL` have access.
- The method signature in `MOCK_METHOD` mirrors the real method: return type, method name, argument types, and optional qualifiers like `const` or `override`.
- The `override` qualifier is strongly recommended to prevent signature mismatches.

### Handling Complex Return and Argument Types

Types containing commas (e.g., `std::pair<int, int>`) need special treatment due to macro parsing:

```cpp
// Wrapping types containing commas in parentheses:
MOCK_METHOD((std::pair<int, int>), GetPair, ());

// Or use type aliases:
using IntPair = std::pair<int, int>;
MOCK_METHOD(IntPair, GetPair, ());
```

### Mocking Overloaded Methods

You can mock all overloads by specifying their full signatures:

```cpp
class Interface {
 public:
  virtual void Func(int x) = 0;
  virtual void Func(double x) const = 0;
};

class MockInterface : public Interface {
 public:
  MOCK_METHOD(void, Func, (int x), (override));
  MOCK_METHOD(void, Func, (double x), (const, override));
};
```

If you don’t mock an overload, avoid hiding it by using `using`:

```cpp
class MockInterface : public Interface {
 public:
  using Interface::Func;  // Bring other overloads into scope
  MOCK_METHOD(void, Func, (int x), (override));
};
```

### Mocking Templates

Mocking class templates works just like regular classes:

```cpp
template <typename T>
class Interface {
 public:
  virtual ~Interface() {}
  virtual int Size() const = 0;
  virtual void Add(const T& elem) = 0;
};

template <typename T>
class MockInterface : public Interface<T> {
 public:
  MOCK_METHOD(int, Size, (), (const, override));
  MOCK_METHOD(void, Add, (const T& elem), (override));
};
```

### Mocking Non-Virtual Methods

GoogleMock supports mocking non-virtual methods using template-based dependency injection.
You define a mock class unrelated to the production class but with the same methods.

```cpp
class RealClass {
 public:
  void Foo(int x);
  int Bar() const;
};

class MockClass {
 public:
  MOCK_METHOD(void, Foo, (int x));
  MOCK_METHOD(int, Bar, (), (const));
};
```

Use templates or compile-time polymorphism in your code to switch between the real and mock classes.

### Mocking Private or Protected Methods

Place the `MOCK_METHOD` declarations in the `public:` section of your mock class regardless of original access level:

```cpp
class Base {
 protected:
  virtual void ProtectedMethod() = 0;
 private:
  virtual int PrivateMethod() = 0;
};

class MockBase : public Base {
 public:
  MOCK_METHOD(void, ProtectedMethod, (), (override));
  MOCK_METHOD(int, PrivateMethod, (), (override));
};
```

---

## Using Mock Methods

### MOCK_METHOD Macro Syntax

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Qualifiers));
```

- `ReturnType`: method return type.
- `MethodName`: mocked method's name.
- `Args...`: parenthesized list of argument types.
- `Qualifiers`: optional traits such as `const`, `override`, `noexcept`.


### Common Qualifiers and Their Use

| Qualifier            | Effect                                   |
|----------------------|------------------------------------------|
| `const`              | For mocking `const` methods               |
| `override`           | Marks method as override, recommended     |
| `noexcept`           | Use if the original method is `noexcept` |
| `Calltype(...)`      | Specifies calling convention (e.g. on Windows) |
| `ref(&)` or `ref(&&)`| For mocking reference-qualified methods  |


### Examples

Mocking a `const` method with an override qualifier:

```cpp
MOCK_METHOD(int, GetValue, (), (const, override));
```

Mocking a `noexcept` method:

```cpp
MOCK_METHOD(void, Reset, (), (noexcept, override));
```

Mocking a reference-qualified method:

```cpp
MOCK_METHOD(void, Process, (), (ref(&), override));
```

### Practical Recommendations

- Always use `override` to catch mismatches early.
- Wrap complex return or argument types containing commas with parentheses or use type aliases.
- Declare all mock methods in the `public:` section.

---

## Common Use Cases & Patterns

### Simple Mock Example

```cpp
class Turtle {
 public:
  virtual void PenUp() = 0;
  virtual void Forward(int distance) = 0;
  virtual int GetX() const = 0;
  virtual ~Turtle() {}
};

class MockTurtle : public Turtle {
 public:
  MOCK_METHOD(void, PenUp, (), (override));
  MOCK_METHOD(void, Forward, (int distance), (override));
  MOCK_METHOD(int, GetX, (), (const, override));
};

// Usage in test:
MockTurtle mock_turtle;
EXPECT_CALL(mock_turtle, Forward(100)).Times(1);
my_function_that_moves_turtle(&mock_turtle);
```


### Overloaded Methods

You can mock overloaded methods by defining `MOCK_METHOD` for each signature:

```cpp
class Logger {
 public:
  virtual void Log(const std::string& message) = 0;
  virtual void Log(int severity, const std::string& message) = 0;
  virtual ~Logger() {}
};

class MockLogger : public Logger {
 public:
  MOCK_METHOD(void, Log, (const std::string& message), (override));
  MOCK_METHOD(void, Log, (int severity, const std::string& message), (override));
};
```

---

## Best Practices and Tips

### Use `EXPECT_CALL` and `ON_CALL` Appropriately

- Use `EXPECT_CALL` to specify expectations about which interactions should occur and with what arguments.
- Use `ON_CALL` to set default behaviors without enforcing call counts.

### Ordering and Sequencing

- Control call order using `InSequence` or `Sequence` objects.
- Remember the default matching behavior picks the most recent matching expectation.

### Avoid Over-Specifying

Only specify the expectations necessary to convey the intent, to avoid brittle tests.

### Typedefs to Simplify Complex Signatures

Use type aliases to clean up the `MOCK_METHOD` macro invocation when dealing with types containing commas.

### Testing Move-Only Types

GoogleMock supports mocking methods with move-only types like `std::unique_ptr`. Define them normally with `MOCK_METHOD` and use appropriate actions like lambdas for returning new objects.

---

## Troubleshooting Common Issues

### Methods Not Mocked (Real Method Called)

Verify methods are virtual and properly overridden with `MOCK_METHOD`.

### Compilation Errors Due to Commas

Wrap complex return or argument types with extra parentheses or use type aliases.

### Warnings About Const on Parameters

The const modifier on parameters is ignored by C++ and may raise warnings in MSVC; remove the top-level const on parameters in mocked methods.

### Uninteresting Call Warnings

If your mock methods produce warnings about uninteresting calls, consider:

- Adding `EXPECT_CALL(mock_obj, Method(_)).Times(AnyNumber());` as a catch-all.
- Using `NiceMock` to suppress uninteresting warnings,
- Or reviewing if the calls are unexpected and need explicit expectations.

### Debugging Expectations

Run tests with `--gmock_verbose=info` to trace mock calls and verify expectation matching.

---

## Additional Resources

* [GoogleMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) – Beginner-friendly introduction
* [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) – Detailed macro and class documentation
* [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) – Recipes and advanced techniques
* [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) – Argument matching details
* [Actions and Return Values](https://google.github.io/googletest/reference/actions.html) – Control mock behavior

---