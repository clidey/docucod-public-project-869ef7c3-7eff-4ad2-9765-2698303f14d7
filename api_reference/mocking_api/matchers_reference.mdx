---
title: "Matchers Reference"
description: "Comprehensive guide to built-in matchers, their usage, and customization. Covers common matchers, logical composition, and how to write custom matchers for advanced verification needs."
---

# Matchers Reference

Comprehensive guide to built-in matchers, their usage, and customization. Covers common matchers, logical composition, and how to write custom matchers for advanced verification needs.

---

## Introduction to Matchers

Matchers form the core of GoogleMock's verification power. They define **what** you expect a mock method's arguments to look like when called, enabling highly expressive and flexible testing.

Your tests use matchers to specify argument constraints, from simple exact matches to complex composite criteria or entirely custom verification logic.

This page will take you through:

- Common built-in matchers for values, containers, pointers, and objects
- Combining matchers logically for sophisticated argument validation
- Writing your own custom matchers for advanced needs

---

## Common Built-in Matchers

### Exact Value Matching

The simplest matcher is an exact value match, like:

```cpp
EXPECT_CALL(foo, Bar(42));  // Matches when argument is equal to 42
```

All literal or copyable values used as arguments in `EXPECT_CALL` act as implicit `Eq()` matchers.

### Wildcard Matcher `_`

Use `_` when the argument value doesn't matter:

```cpp
EXPECT_CALL(foo, Bar(_, 10));  // First argument can be anything, second must be 10
```

### Relational Matchers

Matchers like `Gt()`, `Ge()`, `Lt()`, `Le()`, `Eq()`, and `Ne()` support comparison-based matching:

```cpp
EXPECT_CALL(foo, Process(Gt(5)));  // Argument > 5
```

### Pointer Matchers

- `IsNull()` matches null pointers.
- `NotNull()` matches non-null pointers.
- `Pointee(m)` matches when the pointee value matches matcher `m`.

Example:

```cpp
EXPECT_CALL(foo, HandleData(Pointee(Eq(42))));
```

### Reference Matcher

`Ref(variable)` matches an argument that refers exactly to the given variable:

```cpp
int x = 42;
EXPECT_CALL(foo, SetValue(Ref(x)));
```

### String Matchers

There are specialized matchers for strings:

- `StrEq(str)`: exact string equality
- `StrNe(str)`: not equal
- `StrCaseEq(str)`, `StrCaseNe(str)`: case-insensitive
- `HasSubstr(sub)`: substring containment
- `StartsWith(prefix)`, `EndsWith(suffix)`

Strings can be matched flexibly even with embedded nulls or wide strings.

### Container Matchers

Matchers to validate STL containers:

- `ElementsAre(...)`: checks container elements in order against matchers
- `UnorderedElementsAre(...)`: checks that container elements match unordered
- `Contains(m)`: ensures at least one element matches matcher `m`
- `Each(m)`: all elements match matcher `m`

You can also use `ElementsAreArray` and `UnorderedElementsAreArray` with arrays or ranges.

### Tuple and Pair Matchers

- `Pair(m1, m2)` matches an std::pair whose first field matches `m1` and second field matches `m2`.
- `FieldsAre(m1, m2, ...)` matches aggregate types or tuples by fields.
- `Key(m)` matches a pair whose key (`first`) matches `m`.

### Logical Composition Matchers

Combine matchers with:

- `AllOf(m1, m2, ...)`: all must match
- `AnyOf(m1, m2, ...)`: any must match
- `Not(m)`: negates matcher

Example:

```cpp
EXPECT_CALL(foo, Bar(AllOf(Gt(10), Lt(20))));  // Argument >10 and <20
```

### Specialized Matchers

- `WhenDynamicCastTo<T>(m)`: for RTTI checks, matches if dynamic_cast to T succeeds and inner matcher matches
- `Truly(predicate)`: custom unary predicate matcher
- `Optional(m)`: matches optional values whose value matches `m`

---

## Combining Matchers for Advanced Use Cases

Matchers are composable and can form complex validation logic:

- **Multi-argument matchers** via `.With(matcher)` that matches all args as a tuple
- Matching fields or properties of objects
- Complex container conditions, including subsets and supersets

Example: Expect a call with two ints `x` and `y` where `x < y`:

```cpp
EXPECT_CALL(mock, Func(_, _))
  .With(Lt());  // Matches when first arg < second arg
```

---

## Writing Custom Matchers

GoogleMock lets you extend the matcher language with your own custom matcher classes or via convenient macros.

### Using MATCHER Macros

The simplest way to define a custom matcher is with the `MATCHER` macros:

```cpp
MATCHER(IsEven, "") { return (arg % 2) == 0; }
```

Usage:

```cpp
EXPECT_CALL(mock, Foo(IsEven()));
```

### Parameterized Matchers

You can add parameters with `MATCHER_P`, `MATCHER_P2`, etc:

```cpp
MATCHER_P(IsDivisibleBy, divisor, "") { return (arg % divisor) == 0; }
```

### Custom Matcher Classes

Implement the matcher interface:

- `bool MatchAndExplain(const T& value, std::ostream* listener) const`
- `void DescribeTo(std::ostream* os) const`
- `void DescribeNegationTo(std::ostream* os) const`

and expose a factory function that returns a matcher instance.

Example:

```cpp
class DivisibleByMatcher {
 public:
  explicit DivisibleByMatcher(int divisor) : divisor_(divisor) {}

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % divisor_ == 0) return true;
    if (os != nullptr) *os << "which has remainder " << (n % divisor_);
    return false;
  }

  void DescribeTo(std::ostream* os) const { *os << "is divisible by " << divisor_; }
  void DescribeNegationTo(std::ostream* os) const { *os << "is not divisible by " << divisor_; }

 private:
  const int divisor_;
};

inline testing::Matcher<int> DivisibleBy(int divisor) {
  return testing::MakeMatcher(new DivisibleByMatcher(divisor));
}
```

---

## Best Practices & Tips

- Prefer built-in matchers whenever possible to keep test code clean.
- Use `_` or omit argument matchers if not interested in argument values.
- Combine matchers with `AllOf()`, `AnyOf()` and `Not()` for expressive checks.
- Write meaningful `DescribeTo` messages in custom matchers to improve test failure clarity.
- Use `Truly()` for quick predicate-based matchers; write full custom matcher classes for reusable or complex logic.
- Remember matchers must be pure functions with no side-effects.

---

## Troubleshooting Matchers

- **Matcher failures**: Failed assertions show detailed messages explaining why arguments did not match.
- **Type mismatches**: Use `SafeMatcherCast<T>(m)` to cast matchers when needing to match compatible but different types.
- **Overloaded methods**: Use matchers with correct argument counts/types and `Const()` wrapper to disambiguate overloads.
- **Complex argument tuples**: Use `.With()` multi-argument matchers to specify constraints on combinations of arguments.

---

## Summary

Matchers in GoogleMock offer a powerful declarative way to specify argument expectations. From simple value equality to highly sophisticated composite and custom matchers, you have tools to make your expectations precise and expressive, improving both correctness and maintainability of your tests.

Mastering built-in matchers and the ability to craft custom ones will enable you to accurately describe your code's expected behavior and smoothly identify deviations in testing.

---

## See Also

- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#Using-Matchers)
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html)
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html)
- [EXPECT_THAT Assertions](https://google.github.io/googletest/reference/assertions.html#EXPECT_THAT)

---