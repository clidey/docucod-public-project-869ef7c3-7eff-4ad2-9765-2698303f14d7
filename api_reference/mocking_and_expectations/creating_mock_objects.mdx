---
title: "Creating Mock Objects"
description: "Explains how to declare mock classes and methods using key macros, with examples for class hierarchies and static/virtual method mocking. Addresses critical setup required to enable effective mocking."
---

# Creating Mock Objects

This page guides you through declaring and defining mock classes and methods using GoogleTest's mocking facilities. You will learn how to use key macros to mock virtual and non-virtual functions, handle class hierarchies with inheritance, manage method qualifiers, and work around common challenges such as comma parsing issues. Additionally, we'll cover critical setup remarks needed to enable effective mocking in your tests.

---

## Introduction to Mock Classes

Mock classes simulate the behavior of real classes in your tests, enabling you to specify call expectations, argument matchers, and return behaviors. GoogleTest uses the `MOCK_METHOD` macro inside your mock class to define mocked methods that can be expected and controlled during tests.

### Basic Mock Class Declaration

To mock a class, derive a mock class from your original class and replace the virtual methods with `MOCK_METHOD` declarations:

```cpp
#include <gmock/gmock.h>

class OriginalClass {
 public:
  virtual ~OriginalClass() = default;
  virtual int GetValue() const = 0;
  virtual void SetValue(int x) = 0;
};

class MockClass : public OriginalClass {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(void, SetValue, (int x), (override));
};
```

**Key points:**
- Use the `MOCK_METHOD` macro in the `public:` section.
- The macro parameters are: return type, method name, argument tuple, and (optional) method qualifiers.
- Common qualifiers include `const` and `override`.

---

## MOCK_METHOD Macro Details

The macro defines a mocked method with specified signature:

```cpp
MOCK_METHOD(ReturnType, MethodName, (ArgTypes...), (OptionalQualifiers));
```

- **ReturnType**: The return type of the mocked function.
- **MethodName**: The name of the mocked method.
- **(ArgTypes...)**: Parenthesized list of argument types.
- **(OptionalQualifiers)**: Parenthesized list of method qualifiers like `const`, `override`, or `noexcept`.

### Handling Commas in Types

Types containing commas (e.g., template types like `std::pair<int, int>`) need extra care. Example:

```cpp
class MockFoo {
 public:
  // This WILL NOT compile:
  // MOCK_METHOD(std::pair<int, int>, GetPair, ());

  // Solution 1: Wrap the type in extra parentheses:
  MOCK_METHOD((std::pair<int, int>), GetPair, ());

  // Solution 2: Create a type alias:
  using IntPair = std::pair<int, int>;
  MOCK_METHOD(IntPair, GetPair, ());
};
```

Note that while wrapping with parentheses may be invalid C++ in normal contexts, `MOCK_METHOD` removes these internally.

### Qualifiers List

You can add a comma-separated list of qualifiers as the 4th parameter to `MOCK_METHOD`. Supported qualifiers include:
- `const` for const methods.
- `override` to mark override.
- `noexcept` to match noexcept methods.
- `Calltype(...)` to specify custom calling conventions (Windows specific).
- `ref(&)` or `ref(&&)` to mark reference qualifiers.

Example:

```cpp
MOCK_METHOD(void, ExampleMethod, (int x), (const, override, noexcept));
```

---

## Mocking Overloaded Methods

Simply declare each overload with a separate `MOCK_METHOD`:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, Element x), (override));
  MOCK_METHOD(Bar&, GetBar, (), (override));
  MOCK_METHOD(const Bar&, GetBar, (), (const, override));
};
```

### Resolving Overload Ambiguity

If you don't want to mock all overloads, bring the unmocked base versions into scope to avoid compiler warnings:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring the base overloads into scope
  MOCK_METHOD(int, Add, (int x), (override));
};
```

---

## Mocking Class Templates

You can mock class templates similarly:

```cpp
template <typename T>
class StackInterface {
 public:
  virtual ~StackInterface() = default;
  virtual void Push(const T& elem) = 0;
  virtual int GetSize() const = 0;
};

template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(void, Push, (const T& elem), (override));
  MOCK_METHOD(int, GetSize, (), (const, override));
};
```

---

## Mocking Non-Virtual Methods

GoogleMock can mock non-virtual methods for high-performance dependency injection by mocking methods with the same signature in an unrelated mock class:

```cpp
class RealClass {
 public:
  void AppendData(const Data& d);
  int GetSize() const;
  // No virtual methods.
};

class MockClass {
 public:
  MOCK_METHOD(void, AppendData, (const Data& d), ());
  MOCK_METHOD(int, GetSize, (), (const));
};
```

Since `MockClass` is unrelated, your code must use templates or switch types at compile time to utilize mocks in place of real classes.

---

## Mocking Static or Free Functions

Direct mocking of static or free functions is not supported. Instead, refactor your code to use interfaces:

```cpp
class FileInterface {
 public:
  virtual bool Open(const char* path, const char* mode) = 0;
};

class File : public FileInterface {
 public:
  bool Open(const char* path, const char* mode) override {
    return ::OpenFile(path, mode);
  }
};
```

Your code should depend on `FileInterface`, which can be mocked.

---

## Creating Mocks for Methods with Move-Only Types

You can mock methods accepting or returning move-only types (e.g., `std::unique_ptr`) using `MOCK_METHOD` as usual:

```cpp
class Buzz {}; // user defined

class Buzzer {
 public:
  virtual std::unique_ptr<Buzz> MakeBuzz(std::string text) = 0;
  virtual bool ShareBuzz(std::unique_ptr<Buzz> buzz, int64_t timestamp) = 0;
};

class MockBuzzer : public Buzzer {
 public:
  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (std::string text), (override));
  MOCK_METHOD(bool, ShareBuzz, (std::unique_ptr<Buzz> buzz, int64_t timestamp), (override));
};
```

* To return move-only values repeatedly, prefer lambdas or callables over `Return(...)`.
* To specify expectations on methods with move-only arguments, you may use lambdas as actions.

---

## Mocking Destructors

Since destructors cannot be mocked directly, add a mock method like `Die()` and call it from your destructor:

```cpp
class MockFoo {
 public:
  MOCK_METHOD(void, Die, ());
  ~MockFoo() { Die(); }
};
```

You can set expectations on `Die` to verify destruction order.

---

## Example: Complete Mock Class

```cpp
#include <gmock/gmock.h>

class Foo {
 public:
  virtual ~Foo() {}
  virtual int GetSize() const = 0;
  virtual std::string Describe(const char* name) = 0;
  virtual std::string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetSize, (), (const, override));
  MOCK_METHOD(std::string, Describe, (const char* name), (override));
  MOCK_METHOD(std::string, Describe, (int type), (override));
  MOCK_METHOD(bool, Process, (Bar elem, int count), (override));
};

// Using mocks in tests

using ::testing::Return;
using ::testing::_;

TEST(FooTest, Example) {
  MockFoo mock;
  ON_CALL(mock, GetSize()).WillByDefault(Return(1));
  EXPECT_CALL(mock, Describe(5)).Times(3).WillRepeatedly(Return("Category 5"));
  EXPECT_EQ(MyFuncUsingFoo(&mock), "good");
}
```

---

## Important Setup Considerations

- Include `<gmock/gmock.h>` in your mock class header.
- Use `MOCK_METHOD` in the public section, even for private or protected methods in the base class â€” this is necessary for expectations to work.
- Ensure destructors of base classes are **virtual** to avoid undefined behavior and leaks.

## Tips and Best Practices

- Use type aliases or parentheses to handle argument or return types with commas.
- Use `Const()` to disambiguate const overloads in expectations.
- Avoid writing expectations (`EXPECT_CALL`) after exercising the mocks.
- Use `ON_CALL` to specify default behaviors without setting call expectations.
- Use `NiceMock`, `NaggyMock`, or `StrictMock` wrappers to control warnings and test behavior for uninteresting calls.
- To simplify interfaces, consider delegating calls to another mock method with a trimmed signature.

## Troubleshooting

- If you encounter unexpected calls, verify your expectations cover all cases.
- If warnings about uninteresting calls overload you, consider using `NiceMock`.
- When mocking methods with move-only types, beware that `Return()` with move-only values works correctly only with `WillOnce()`, not `WillRepeatedly()`.
- If the compiler complains about virtual destructor issues, check that your base classes have virtual destructors.

---

## Additional Resources

- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) for quick patterns.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for recipes.
- [Mocking Techniques Guide](https://google.github.io/googletest/guides/core-workflows/mocking-techniques.html) for detailed use.
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) for argument matching.
- [Actions Reference](https://google.github.io/googletest/reference/actions.html) for controlling mock behavior.

---

<Source url="https://github.com/google/googletest" paths={[{"path": "docs/gmock_cook_book.md", "range": "1-374"},{"path": "docs/reference/mocking.md", "range": "1-200"}]} branch="main" />
