---
title: "Advanced Test Features"
description: "Details advanced capabilities such as parameterized tests, type-parameterized tests, and death tests. Helps users unlock complex testing workflows and maximize coverage in their C++ projects."
---

# Advanced Test Features

Unlock the full power of GoogleTest with its advanced testing capabilities. This page covers key features like parameterized tests, type-parameterized tests, and death tests that enable you to write expressive, maintainable, and thorough tests for complex C++ codebases. These features help you maximize coverage and introduce flexibility in test definitions, making it easier to validate different inputs and behaviors systematically.

---

## Parameterized Tests

Parameterized tests allow you to run the same test logic repeatedly using different input values. This approach eliminates code duplication and ensures diverse test coverage.

### Why Use Parameterized Tests?
- Validate functionality over a range of inputs without writing multiple tests.
- Maintain a single test implementation while systematically varying test data.
- Achieve cleaner and more scalable test code.

### How to Write Parameterized Tests

1. **Define a fixture class** inheriting from `::testing::TestWithParam<T>` where `T` is the type of the parameter.
2. **Write test cases** inside this fixture using `TEST_P` instead of `TEST`.
3. **Instantiate the test suite** using `INSTANTIATE_TEST_SUITE_P`, providing a name and the values to test with.

### Example

```cpp
#include <gtest/gtest.h>

class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```

> This example runs the same `ReturnsTrueForEvenNumbers` test 4 times with the values 2, 4, 6, and 8.

### Best Practices
- Choose parameter types and values meaningful for your domain.
- Use descriptive prefixes in `INSTANTIATE_TEST_SUITE_P` to help identify failed tests.
- Combine with matchers and assertions for flexible verification.

---

## Type-Parameterized Tests

Type-parameterized tests enable writing tests that can run with multiple types to validate type-generic code.

### Use Cases
- Testing templates or generic functions/classes with different types.
- Ensuring that different data types behave correctly with the same test logic.

### How to Write Type-Parameterized Tests

1. Define a test fixture template templated on the test type.
2. Use `TYPED_TEST_SUITE` (or the legacy `TYPED_TEST_CASE`) to specify the types.
3. Write your tests using `TYPED_TEST` macros.

### Example

```cpp
#include <gtest/gtest.h>

template <typename T>
class NumericLimitsTest : public ::testing::Test {};

typedef ::testing::Types<int, float, double> MyTypes;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsNonZero) {
  EXPECT_GT(std::numeric_limits<TypeParam>::min(), 0);
}
```

> This runs `IsNonZero` for `int`, `float`, and `double` types.

### Things to Note
- Use `TypeParam` inside tests to refer to the current test type.
- This style supports deep cross-type testing with strong compile-time checks.

---

## Death Tests

Death tests verify that your program terminates as expected under certain conditions, such as fatal errors or unsatisfied assertions.

### When to Use Death Tests
- Assert that invalid inputs or states cause your code to terminate appropriately.
- Confirm safety mechanisms like assertions, exceptions leading to termination, or fatal signals.

### Writing Death Tests
- Use `ASSERT_DEATH(statement, regex)` or `EXPECT_DEATH(statement, regex)` macros.
- The `statement` is the code expected to cause termination.
- The `regex` is a regex pattern matched against the death output.

### Example

```cpp
TEST(FooDeathTest, CrashesOnNullPointer) {
  Foo* foo = nullptr;
  ASSERT_DEATH(foo->Bar(), "null pointer");
}
```

### Important Considerations
- Death tests are run in a subprocess to isolate crashes.
- They add overhead; use them selectively to validate critical failure points.
- Avoid shared state affecting other tests.
- If the regex in `ASSERT_DEATH` is empty, it matches any output.

---

## Practical Tips and Pitfalls

- **Combine parameterized tests with type-parameterized tests** for exhaustive coverage of inputs and types.
- **Use death tests sparingly**—focus on critical failure conditions.
- **Naming matters:** provide clear and descriptive names for instantiated tests; this aids in diagnosing failures.
- **Expect mocks and stubs to integrate smoothly:** when using mocks in advanced tests, ensure expectations reflect varying scenarios.
- **Debugging failure messages from death tests** can be difficult—inspect subprocess output carefully.

---

## Related Features

- Integrate with [Assertions Reference](/api_reference/core_test_apis/assertions_reference) to leverage the rich assert macros alongside advanced tests.
- Learn more about [Test Declaration & Lifecycle](/api_reference/core_test_apis/test_declaration_lifecycle) to organize tests effectively.
- Leverage [GoogleMock APIs](/api_reference/mocking_apis/mock_object_basics) when combining mocks with advanced test features.

---

## Summary
This page empowers you to unlock advanced GoogleTest capabilities including parameterized tests for efficient data-driven testing, type-parameterized tests for generic code validation, and death tests for verifying program termination behavior. Mastery of these features helps you build robust, maintainable, and comprehensive test suites tailored to complex C++ projects.

---

## Learn More
- [GoogleTest Primer](primer.md) — Basic testing guidance
- [gMock Cookbook](gmock_cook_book.md) — Advanced mocking techniques
- [GoogleMock Reference](docs/reference/mocking.md) — Full mock API details
- [Test Declaration & Lifecycle](api_reference/core_test_apis/test_declaration_lifecycle.md) — Organization of tests
- [Assertions Reference](api_reference/core_test_apis/assertions_reference.md) — Powerful assertions and macros

<Tip>
Use parameterized and type-parameterized tests early in your testing process to economize test code and maximize coverage.
</Tip>

<Warning>
Death tests should be used judiciously; excessive use may slow down test execution and complicate debugging.
</Warning>

<AccordionGroup title="Advanced Test Features Examples">
<Accordion title="Parameterized Test Example">
```cpp
class IsEvenTest : public ::testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest, ::testing::Values(2, 4, 6, 8));
```
</Accordion>
<Accordion title="Type-Parameterized Test Example">
```cpp
template <typename T>
class NumericLimitsTest : public ::testing::Test {};

typedef ::testing::Types<int, float, double> MyTypes;
TYPED_TEST_SUITE(NumericLimitsTest, MyTypes);

TYPED_TEST(NumericLimitsTest, IsNonZero) {
  EXPECT_GT(std::numeric_limits<TypeParam>::min(), 0);
}
```
</Accordion>
<Accordion title="Death Test Example">
```cpp
TEST(FooDeathTest, CrashesOnNullPointer) {
  Foo* foo = nullptr;
  ASSERT_DEATH(foo->Bar(), "null pointer");
}
```
</Accordion>
</AccordionGroup>
