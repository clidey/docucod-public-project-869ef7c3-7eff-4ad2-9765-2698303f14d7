---
title: "Assertions Reference"
description: "Comprehensive overview of all GoogleTest assertion macros, including equality, inequality, exception, floating-point, and custom assertions. Shows usage patterns and behaviors for both fatal and non-fatal assertions with practical examples."
---

# Assertions Reference

This page provides a comprehensive overview of all GoogleTest assertion macros you can use to verify behavior in your C++ tests. These macros come in **fatal** (`ASSERT_`) and **non-fatal** (`EXPECT_`) variants, allowing you to choose whether a failure aborts the current function or allows it to continue.

To use these assertions, include GoogleTest's header:

```cpp
#include <gtest/gtest.h>
```

---

## Fatal vs Non-Fatal Assertions

- `EXPECT_*` macros generate **non-fatal failures**: they report an assertion failure but continue executing the current function.
- `ASSERT_*` macros generate **fatal failures**: they report a failure and immediately abort the current function.

Both types support streaming custom failure messages with the `<<` operator:

```cpp
EXPECT_TRUE(condition) << "Custom failure explanation";
```

Anything streamable to an `ostream` (including wide strings) can be used in these messages.

---

## Categories of Assertions

This documentation is structured by assertion types, with explanations and practical examples.

### 1. Explicit Success and Failure

These macros do not test any condition, but directly indicate success or failure.

- `SUCCEED()`: Generate a success explicitly. Does not make the overall test succeed if other assertions fail. Useful for documenting that a certain point in the code was reached.

- `FAIL()`: Generates a fatal failure.

- `ADD_FAILURE()`: Generates a non-fatal failure.

- `ADD_FAILURE_AT(file, line)`: Generates a non-fatal failure at a specified file and line number.

**Example:**

```cpp
switch(value) {
  case 1:
    // ... some checks ...
    break;
  default:
    FAIL() << "Unexpected value: " << value;
}
```

---

### 2. Generalized Assertions with Matchers

- `EXPECT_THAT(value, matcher)` / `ASSERT_THAT(value, matcher)`: Use GoogleMock matchers to verify that a `value` satisfies a matcher expression.

This enables expressive, readable, and powerful validations.

**Example:**

```cpp
#include <gmock/gmock.h>
using ::testing::StartsWith;
...
EXPECT_THAT(name, StartsWith("Hello"));
```

Matchers provide detailed failure messages explaining what was expected and what was actually received.

See full details in the [Matchers Reference](matchers.md).

---

### 3. Boolean Condition Assertions

Test Boolean expressions directly.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Verify that `condition` is true.

- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Verify that `condition` is false.

Failure messages show the evaluated expression and its actual value.

---

### 4. Binary Comparison Assertions

Compare two values using standard comparison operators.

These macros require the values to be comparable with the respective operator.

- Equality/Inequality:
  - `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)` -- checks `val1 == val2`
  - `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)` -- checks `val1 != val2`

- Ordering:
  - `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)` -- checks `val1 < val2`
  - `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)` -- checks `val1 <= val2`
  - `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)` -- checks `val1 > val2`
  - `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)` -- checks `val1 >= val2`

> **Important:** 
> - These assertions compare pointers by address, not content. Use string-specific assertions for string content.
> - Arguments are evaluated exactly once.

**Example:**

```cpp
EXPECT_EQ(expected_value, actual_value) << "Value mismatch";
```

---

### 5. String Comparison Assertions

For C strings (`const char*`) and wide C strings (`const wchar_t*`), use these to compare by content rather than pointer value.

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`: Expect strings to be equal.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`: Expect strings to be not equal.
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`: Expect strings to be equal ignoring case.
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`: Expect strings to be not equal ignoring case.

Failing assertions will report differences including case mismatches.

---

### 6. Floating-Point Comparison Assertions

Due to rounding errors, comparing floating-point numbers requires special consideration.

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`: Checks if two `float`s are approximately equal, within 4 ULPs.

- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`: Same as above for `double`s.

- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`: Checks that the absolute difference between the two values does not exceed `abs_error`.

These macros handle infinity and NaN gracefully and provide detailed failure messages.

---

### 7. Exception Assertions

Verify if code throws or does not throw exceptions.

Requires exceptions enabled in the build.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`: Expects `statement` to throw exception of type `exception_type`.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`: Expects `statement` to throw any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`: Expects `statement` not to throw.

Use compound statements if necessary:

```cpp
EXPECT_NO_THROW({ int x = Foo(); });
```

---

### 8. Predicate Assertions

When testing complex expressions, you can use:

#### a) Predicate Assertions

- `EXPECT_PRED1(pred, val1)`, `EXPECT_PRED2(pred, val1, val2)`, ... 
- `ASSERT_PRED1(pred, val1)`, ...

Where `pred` is a function or functor returning `bool`. On failure, the values of arguments are printed.

##### Example:

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, x);
```

#### b) Predicate Formatter Assertions

- `EXPECT_PRED_FORMAT1(pred_formatter, val1)`, ...
- `ASSERT_PRED_FORMAT1(pred_formatter, val1)`, ...

Where `pred_formatter` returns a `testing::AssertionResult` with full control over the failure message.

##### Signature:

```cpp
testing::AssertionResult PredicateFormatter(const char* expr1, T1 val1);
```

##### Example:

```cpp
testing::AssertionResult AssertIsEven(const char* expr, int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << expr << " is not even";
}
EXPECT_PRED_FORMAT1(AssertIsEven, x);
```

---

### 9. Windows HRESULT Assertions

On Windows, you can check COM/WinAPI success or failure HRESULT codes:

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)`: Checks if `expr` is a success HRESULT.
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)`: Checks if `expr` is a failure HRESULT.

Failure messages include the HRESULT code and associated system error message where available.

---

### 10. Death Assertions

Verify that a piece of code causes program termination.

These spawn a new process and execute the code under test within it.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH(statement, matcher)`: Expects `statement` to terminate with nonzero status and output matching `matcher`.
- `EXPECT_DEATH_IF_SUPPORTED(statement, matcher)` / `ASSERT_DEATH_IF_SUPPORTED(...)`: Same but no failure if death tests are unsupported.
- `EXPECT_DEBUG_DEATH(statement, matcher)` / `ASSERT_DEBUG_DEATH(...)`: Runs death test only in debug mode.
- `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT(...)`: Verifies termination with exit status satisfying `predicate` and output matching `matcher`.

> **Important:** Place only death test assertions on a single line.

For more info, see [Death Tests Guide](../advanced.md#death-tests).

---

### Notes and Best Practices

- Use `EXPECT_` when possible to see multiple failures in one test invocation.
- Use `ASSERT_` to abort early when continuing makes no sense.
- Use `SCOPED_TRACE(message)` for adding contextual trace info, especially from helper functions.
- Never use `ASSERT_*` in constructors or destructors as they require `void` return type.
- Use `RecordProperty(key, value)` to log extra info that appears in XML/JSON test output.
- For comparing complex objects, consider implementing or using custom matchers instead of boolean assertions.

---

### Examples

```cpp
TEST(FooTest, BasicAssertions) {
  int x = 5;
  EXPECT_EQ(5, x) << "x should be 5";
  ASSERT_TRUE(x > 0) << "x must be positive";
}

TEST(StringTest, CStringComparison) {
  const char* s1 = "hello";
  const char* s2 = "hello";
  EXPECT_STREQ(s1, s2) << "C strings must match";
}

TEST(FloatTest, NearEquals) {
  float a = 0.1f + 0.2f;
  float b = 0.3f;
  EXPECT_FLOAT_EQ(a, b);
}

TEST(ExceptionTest, Throws) {
  EXPECT_THROW(throw std::runtime_error("error"), std::runtime_error);
}

TEST(DeathTest, Dies) {
  EXPECT_DEATH({ exit(1); }, "");
}

// Using predicate-formatter

AssertionResult IsEven(const char* expr, int n) {
  if (n % 2 == 0) return AssertionSuccess();
  return AssertionFailure() << expr << " is not even";
}

TEST(PredicateTest, EvenCheck) {
  EXPECT_PRED_FORMAT1(IsEven, 4);
  EXPECT_PRED_FORMAT1(IsEven, 5); // will fail with message
}
```

---

### Related APIs

- [Matchers Reference](matchers.md) for powerful validation with `EXPECT_THAT`
- [Value-Parameterized Tests](reference/testing.md#INSTANTIATE_TEST_SUITE_P) for test parameterization
- [Death Tests](../advanced.md#death-tests)
- [Event Listeners](reference/testing.md#TestEventListener) to extend and customize test reporting

---