---
title: "Parameterized and Typed Tests"
description: "Reference and code patterns for creating value- and type-parameterized tests. Explains the parameter generators, test case instantiation macros (TEST_P, TYPED_TEST), combining parameters, and how to name and retrieve parameter values, enabling broader test coverage with less code."
---

# Parameterized and Typed Tests

This reference page guides you through writing and using value-parameterized and type-parameterized tests in GoogleTest. These advanced test patterns enable you to test the same logic against multiple values or multiple types efficiently, expanding your test coverage while reducing redundant code.

You will learn the general usage patterns for parameter generators, test case instantiation macros (`TEST_P`, `TYPED_TEST`, `TYPED_TEST_P`), how to combine parameters, and methods for naming and retrieving parameter values during test execution.

---

## 1. Overview

### What Are Parameterized and Typed Tests?

- **Value-Parameterized Tests** let you write tests that are executed multiple times, each with a different **value** parameter. This enables you to verify behavior across various input values without writing multiple test functions.

- **Typed Tests** and **Type-Parameterized Tests** focus on repeating the same test logic for multiple **types**, useful when testing generic or templated code against different type instantiations.

Both testing approaches dramatically increase test coverage with minimal code duplication.

### Why Use Parameterized and Typed Tests?

- **Efficiency**: Write test logic once and run it multiple times with different inputs or types.
- **Maintainability**: Centralize test logic, simplifying updates and bug fixes.
- **Extensibility**: Easily add new values or types to cover without modifying test code.
- **Better Coverage**: Catch edge cases or type-specific issues reliably.

---

## 2. Value-Parameterized Tests

These tests focus on varying input **values** for test executions.

### How to Write Value-Parameterized Tests

1. **Define the Fixture Class**
   
   Derive your fixture class from `testing::TestWithParam<T>`, where `T` is the parameter type. This class enables access to parameters via `GetParam()`.

```cpp
class FooTest : public testing::TestWithParam<const char*> {
  // Fixture members and setup.
};
```

2. **Write Parameterized Tests Using `TEST_P`**

Define each test case with `TEST_P`, which allows accessing the parameter value with `GetParam()`:

```cpp
TEST_P(FooTest, DoesBlah) {
  EXPECT_TRUE(foo.Blah(GetParam()));
}

TEST_P(FooTest, HasBlahBlah) {
  // Additional tests...
}
```

3. **Instantiate the Test Suite with Parameters**

Use `INSTANTIATE_TEST_SUITE_P` with a name prefix, the test suite type, and a **parameter generator** function:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MeenyMinyMoe, FooTest,
    testing::Values("meeny", "miny", "moe")
);
```

This creates instantiations named like `MeenyMinyMoe/FooTest.DoesBlah/0` for the value "meeny".

### Available Parameter Generators

| Generator             | Description                                                           |
| --------------------- | --------------------------------------------------------------------- |
| `Range(begin, end[, step])` | Generates values from `begin` up to but not including `end` by `step` (default 1) |
| `Values(v1, v2, ..., vN)`   | Explicitly specifies discrete values                                 |
| `ValuesIn(container)`        | Uses values from an array, container, or iterator range             |
| `Bool()`                    | Generates `false` and `true`                                        |
| `Combine(g1, g2, ..., gN)`  | Produces Cartesian product from multiple generators producing tuples |


### Example: Combining Multiple Parameters

You can combine multiple parameter generators to test all combinations:

```cpp
INSTANTIATE_TEST_SUITE_P(
    TwoFlagsTest, FlagDependentTest,
    testing::Combine(testing::Bool(), testing::Bool())
);
```

In your fixture, the parameter type will be a tuple, e.g. `std::tuple<bool, bool>`, accessible via `GetParam()`.

### Naming Your Parameterized Tests

By default, test instances get numeric suffixes based on parameter index. You can provide a **custom name generator** for human-readable names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyGroup, MyTestSuite, testing::Values(...),
    [](const testing::TestParamInfo<MyTestSuite::ParamType>& info) {
      std::string name = std::to_string(info.param);
      return name;
    });
```

Name suffixes must be non-empty, unique, and contain only alphanumeric characters.

---

## 3. Typed Tests

Typed tests allow repeating the same test code for a list of types.

### How to Write Typed Tests

1. **Write a Fixture Class Template**

```cpp
template <typename T>
class FooTest : public testing::Test {
 public:
  // Fixture members, typedefs, static variables
  using List = std::list<T>;
  static T shared_;
  T value_;
};
```

2. **Associate a List of Types With the Suite**

Use a `typedef` or `using` to give a list of types, then `TYPED_TEST_SUITE`:

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

You can specify custom suffixes with an optional third argument (a name generator class).

3. **Define Typed Tests Using `TYPED_TEST`**

Inside each typed test, refer to the current type via the `TypeParam` alias, and to static fixture members via `TestFixture::` prefix:

```cpp
TYPED_TEST(FooTest, DoesBlah) {
  TypeParam n = this->value_;
  n += TestFixture::shared_;
  typename TestFixture::List values;
  values.push_back(n);
  // Test logic...
}

TYPED_TEST(FooTest, HasPropertyA) {
  // Another test
}
```

---

## 4. Type-Parameterized Tests

Type-parameterized tests are similar to typed tests but allow defining test logic **without knowing the types up front**. This supports defining abstract test patterns that can be instantiated multiple times later.

### How to Write Type-Parameterized Tests

1. **Define a Template Fixture Class**

```cpp
template <typename T>
class FooTest : public testing::Test {
  // Test members...
};
```

2. **Declare the Fixture as Type-Parameterized**

```cpp
TYPED_TEST_SUITE_P(FooTest);
```

3. **Define Tests Using `TYPED_TEST_P`**

```cpp
TYPED_TEST_P(FooTest, DoesBlah) {
  TypeParam n = 0;
  // Test logic using TypeParam
}

TYPED_TEST_P(FooTest, HasPropertyA) {
  // More tests
}
```

4. **Register Test Patterns**

```cpp
REGISTER_TYPED_TEST_SUITE_P(FooTest, DoesBlah, HasPropertyA);
```

5. **Instantiate the Suite With Types**

```cpp
using MyTypes = ::testing::Types<char, int, unsigned int>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
```

You can also use a custom name generator as the optional fourth macro argument.

---

## 5. Accessing Parameter Values and Test Information

- **For Value-Parameterized Tests:** Use `GetParam()` within a test to access the current parameter value.

- **For Typed and Type-Parameterized Tests:** Use the alias `TypeParam` to refer to the current type.

- **Retrieving Test Names:** You can obtain the test suite and test name via GoogleTest's reflection API, e.g.,

```cpp
const testing::TestInfo* test_info = testing::UnitTest::GetInstance()->current_test_info();
auto suite_name = test_info->test_suite_name();
auto test_name = test_info->name();
```

- **Value and Type Parameter Names:**
  - Use `->value_param()` on `TestInfo` to get the string representation of a value-parameter.
  - Use `->type_param()` to get the type parameter name for typed/type-parameterized tests.

---

## 6. Best Practices and Common Pitfalls

- Always declare your parameterized test fixture classes with `public` inheritance from `TestWithParam<T>` or `testing::Test` and `WithParamInterface<T>`.
- When combining multiple parameters, your parameter type becomes a `std::tuple` of the component types.
- Provide meaningful custom test names for parameterized tests to improve test log readability.
- Avoid defining `SetUpTestSuite()` or `TearDownTestSuite()` as `protected` if you intend to use `TEST_P` with that fixture; they must be `public`.
- Typed tests require knowing the type list at test definition time, while type-parameterized tests can be instantiated multiple times with different type lists.
- Register all type-parameterized tests before instantiations using `REGISTER_TYPED_TEST_SUITE_P()`.
- Do not forget to instantiate parameterized test suites using `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P` macros, or the tests won't run.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` to suppress warnings/errors for uninstantiated parameterized tests when appropriate.

---

## 7. Troubleshooting

- **No tests run after instantiation:** Check if you called the instantiation macros correctly and placed them at global namespace scope.
- **Test names appear mangled or confusing:** Use custom name generators to produce cleaner test names.
- **Compilation errors related to macro usage:** Ensure that type aliases for type lists are defined properly and macros are used with correct arguments.
- **Parameter values have unexpected types or conversion issues:** Use `ConvertGenerator` to explicitly control how parameter values get cast or converted.

---

## 8. Further Reading and Examples

- See the **GoogleTest Primer** for an introductory explanation and basics of writing tests.
- The **Advanced Topics** guide contains detailed coverage of parameterized tests, type-parameterized tests, and related testing techniques.
- The **Testing Reference** includes in-depth API documentation for macros like `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, and their counterparts.
- Samples `sample6_unittest.cc`, `sample7_unittest.cc`, and `sample8_unittest.cc` in the repository illustrate these patterns.

---

## 9. Diagram: Test Instantiation Flow

```mermaid
flowchart TD
  A[Define Fixture Class (Template or WithParamInterface)] --> B[Define Parameterized Tests (TEST_P, TYPED_TEST, TYPED_TEST_P)]
  B --> C{Is it Typed or Value-Parameterized?}
  C -- Value-Parameterized --> D[Instantiate Test Suite with parameter values via INSTANTIATE_TEST_SUITE_P]
  C -- Typed or Type-Parameterized --> E[Associate Types and/or Register Test Patterns]
  E --> F[Instantiate Typed/Test-Parameterized Suite with Types via TYPED_TEST_SUITE or INSTANTIATE_TYPED_TEST_SUITE_P]
  D & F --> G[GoogleTest Creates Test Cases for each Parameter/Type]
  G --> H[Tests Execute each Instance with associated value or type]
```

---

## 10. Summary

This page focuses exclusively on the patterns, macros, and best practices for setting up and running GoogleTest parameterized and typed tests. By harnessing value generators, type lists, and the multiple instantiation macros, you can write concise, scalable tests targeting many inputs and types efficiently.

---

## Example: Simple Value-Parameterized Test

```cpp
class IsEvenTest : public testing::TestWithParam<int> {};

TEST_P(IsEvenTest, ReturnsTrueForEvenNumbers) {
  int n = GetParam();
  EXPECT_EQ(n % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, IsEvenTest,
                         testing::Values(2, 4, 6, 8));
```

## Example: Simple Typed Test

```cpp
template <typename T>
class NumericLimitsTest : public testing::Test {};

using NumericTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(NumericLimitsTest, NumericTypes);

TYPED_TEST(NumericLimitsTest, IsNonNegative) {
  EXPECT_GE(std::numeric_limits<TypeParam>::min(), 0);
}
```

## Example: Simple Type-Parameterized Test

```cpp
template <typename T>
class MyContainerTest : public testing::Test {};

TYPED_TEST_SUITE_P(MyContainerTest);

TYPED_TEST_P(MyContainerTest, IsEmptyInitially) {
  TypeParam container;
  EXPECT_EQ(container.size(), 0);
}

REGISTER_TYPED_TEST_SUITE_P(MyContainerTest, IsEmptyInitially);

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, MyContainerTest, ContainerTypes);
```

---
