---
title: "Assertions Reference"
description: "A practical catalog of assertion macros and their intended usage, including equality, comparison, exception, and custom assertions. Describes fatal vs. non-fatal behaviors and expected outcomes for each scenario."
---

# Assertions Reference

GoogleTest provides a robust set of assertion macros to verify the correctness of your C++ code during testing. This reference catalog presents the available assertion macros, their intended usage patterns, and guidance on their behavior regarding fatality and outcomes, enabling you to write expressive, reliable tests.

---

## Understanding Assertions in GoogleTest

Most assertions come in pairs:

- **`EXPECT_`** macros generate *non-fatal failures* allowing test execution to continue.
- **`ASSERT_`** macros generate *fatal failures* that abort the current function immediately.

All assertions support custom failure messages using the `<<` stream operator, offering flexible, detailed diagnostics in case of failures:

```cpp
EXPECT_TRUE(my_condition) << "Condition failed: my_condition was false";
```

You can stream any value that supports the `ostream` operator, including C-style strings and `std::string`. Wide strings (`wchar_t*`, `std::wstring`, etc.) are automatically converted to UTF-8 for output.

---

## Explicit Success and Failure

Sometimes your test logic flow requires you to explicitly mark success or failure unconditionally.

### SUCCEED()

```cpp
SUCCEED();
```
Generates a test success explicitly. This does **not** cause the overall test to succeed by itself; rather, it documents an intentional success point. Currently, SUCCEED does not produce visible output.

### FAIL()

```cpp
FAIL();
```
Generates a fatal failure in functions that return `void`, immediately terminating the function.

### ADD_FAILURE()

```cpp
ADD_FAILURE();
```
Generates a non-fatal failure but continues execution in the current function.

### ADD_FAILURE_AT(file, line)

```cpp
ADD_FAILURE_AT("foo.cc", 42);
```
Same as `ADD_FAILURE()`, but associates the failure with the specified file and line number.

---

## Boolean Condition Assertions

Test simple boolean expressions.

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`

Example:

```cpp
EXPECT_TRUE(IsReady()) << "System is not ready";
ASSERT_FALSE(IsError()) << "Unexpected error state";
```

---

## Binary Comparison Assertions

Compare two values using standard comparison operators. These cover integers, pointers, strings, and more.

- Equality: `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`
- Inequality: `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`
- Less than: `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`
- Less or equal: `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`
- Greater than: `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`
- Greater or equal: `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`

**Important:**

- For raw C-strings (e.g. `const char*`), pointer comparison is performed. Use string-specific assertions for content comparison.
- `EXPECT_STREQ` family macros should be used for C-string content comparisons.

Example:

```cpp
EXPECT_EQ(expected_count, actual_count) << "Counts differ";
ASSERT_LT(result, max_value) << "Result exceeds maximum allowed";
```

---

## String Comparison Assertions

For comparing C-style strings (null-terminated char arrays) by value:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`: equal content
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`: different content
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`: equal ignoring case
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`: different ignoring case

Wide strings (`wchar_t*` and `std::wstring`) are supported similarly. On failure, the actual values are printed as UTF-8.

Example:

```cpp
EXPECT_STREQ("hello", result.c_str());
ASSERT_STRCASEEQ(L"FoO", L"foo");
```

---

## Floating-Point Comparisons

Floating-point values require special care due to precision issues. GoogleTest offers dedicated assertions:

- **`EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`**: compares `float` values within 4 ULPs.
- **`EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`**: compares `double` values within 4 ULPs.
- **`EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`**: verifies absolute difference within `abs_error`.

Example:

```cpp
EXPECT_FLOAT_EQ(3.1415f, CalculatePiApprox());
ASSERT_NEAR(0.001, ComputeValue(), 0.01);
```

---

## Exception Assertions

Require exception support to be enabled in your build. These macros test whether a statement throws or does not throw exceptions.

- `EXPECT_THROW(statement, ExceptionType)` / `ASSERT_THROW(statement, ExceptionType)`: expect the exact exception type.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`: expect any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`: expect no exceptions thrown.

Example:

```cpp
EXPECT_THROW(FunctionThatThrows(), std::runtime_error);
ASSERT_NO_THROW(FunctionThatDoesNotThrow());
```

---

## Predicate Assertions

Use when simple boolean checks aren't expressive enough and you want better error messages with argument values.

- `EXPECT_PREDn(pred, val1, val2, ...)` / `ASSERT_PREDn(pred, val1, val2, ...)`: where `pred` is a function or functor returning `bool`.
- `EXPECT_PRED_FORMATn(pred_fmt, val1, ...)` / `ASSERT_PRED_FORMATn(pred_fmt, val1, ...)`: where `pred_fmt` returns an `AssertionResult` for richer failure descriptions.

Example:

```cpp
bool IsPrime(int n);
EXPECT_PRED1(IsPrime, value);

// More expressive:
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}
EXPECT_PRED_FORMAT1(IsEven, value);
```

---

## Windows HRESULT Assertions

Facilitate working with COM-style `HRESULT` values (Windows only).

- `EXPECT_HRESULT_SUCCEEDED(expr)` / `ASSERT_HRESULT_SUCCEEDED(expr)`: expect `expr` to be a success.
- `EXPECT_HRESULT_FAILED(expr)` / `ASSERT_HRESULT_FAILED(expr)`: expect `expr` to be a failure.

Example:

```cpp
CComPtr<IShellDispatch2> shell;
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
```

---

## Death Assertions

Verify that statements terminate the process as expected. Death tests run the statement in a child process and check the exit status and output.

- `EXPECT_DEATH(statement, matcher)` / `ASSERT_DEATH(statement, matcher)`: expect the statement to terminate with nonzero exit and `stderr` output matching `matcher`.
- `EXPECT_DEATH_IF_SUPPORTED`, `ASSERT_DEATH_IF_SUPPORTED`: like above but skip if death tests unsupported.
- `EXPECT_DEBUG_DEATH`, `ASSERT_DEBUG_DEATH`: death assertions executed only in debug builds.
- `EXPECT_EXIT(statement, predicate, matcher)` / `ASSERT_EXIT(statement, predicate, matcher)`: expect process termination with exit status satisfying `predicate` and output matching `matcher`.

Example:

```cpp
EXPECT_DEATH({ Foo(); }, "Error on line .* of Foo()");
EXPECT_EXIT(Cleanup(), testing::ExitedWithCode(0), "Success");
```

---

## Using Assertions with Custom Messages and in Sub-Routines

Assertions accept streaming of custom user messages to add context to failures.

Use the `SCOPED_TRACE` macro to add trace information on nested failures inside helper functions or loops.

---

## Skipping Tests

Use `GTEST_SKIP()` in tests or setup methods to skip test execution at runtime with an optional message:

```cpp
TEST(FooTest, SkipExample) {
  GTEST_SKIP() << "Skipping due to unmet precondition";
  FAIL();  // Will not be executed
}
```

---

## Best Practices

- Use `EXPECT_` for non-fatal checks allowing tests to continue.
- Use `ASSERT_` in situations where further execution is unsafe or meaningless.
- Provide informative failure messages to speed up debugging.
- For complex failure scenarios, consider predicate or predicate-format assertions.
- Use death assertions judiciously to verify fatal failure conditions.

---

## Examples

### Basic Equality Assertion

```cpp
TEST(SimpleTest, Equality) {
  int expected = 10;
  int actual = CalculateResult();
  EXPECT_EQ(expected, actual) << "Result does not match expected value";
}
```

### Floating Point Near Comparison

```cpp
TEST(MathTest, ApproximateComparison) {
  double val = ComputeApproxValue();
  ASSERT_NEAR(3.14, val, 0.01) << "Value is outside allowable range";
}
```

### Exception Testing

```cpp
TEST(ExceptionTest, ThrowsRuntimeError) {
  EXPECT_THROW({ DoSomethingDangerous(); }, std::runtime_error);
}
```

### Death Test Example

```cpp
TEST(MyDeathTest, Abort) {
  ASSERT_DEATH({ AbortFunction(); }, "Fatal error encountered");
}
```

### Predicate Assertion with Custom Formatter

```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  return testing::AssertionFailure() << n << " is odd";
}

TEST(PredicateTest, IsEvenCheck) {
  EXPECT_PRED_FORMAT1(IsEven, 3);
}
```

---

## Troubleshooting Tips

- Ensure that `ASSERT_` macros are only used in `void` functions.
- Remember `EXPECT_` macros allow continued execution after failure.
- Use string comparison macros (`EXPECT_STREQ`, etc.) for C strings.
- Handle floating-point imprecision with the dedicated floating-point asserts.
- For death tests, understand the underlying process model and output matching.

---

For a comprehensive guide on writing effective assertions, custom predicates, and handling complex test scenarios, see the [Writing Effective Assertions](../guides/core-workflows/rich-assertions) guide.

---

[Return to Core Testing API](../core_test_api/test_macros_and_classes.md)
[API: Assertion Macros](assertions.md)
[GoogleTest Primer](../primer.md)
[Matchers Reference](matchers.md)
[gMock Cookbook](../../gmock_cook_book.md)

---

<Callouts>
<Tip>
Use `EXPECT_` assertions for checks that allow your tests to proceed and collect multiple issues, reserving `ASSERT_` for critical conditions that necessitate stopping the current test.
</Tip>
<Note>
Assertion macros support streaming detailed failure messages using the `<<` operator, enabling rich context that assists debugging.
</Note>
<Warning>
Avoid putting `ASSERT_` assertions in constructors or destructors, as failing to abort the entire test can lead to undefined states.
</Warning>
</Callouts>
