---
title: "Parameterized and Typed Tests"
description: "Explains the mechanisms for value-parameterized and type-parameterized tests, enabling flexible and scalable test coverage across multiple data types and input values. Includes macros, configuration patterns, and sample code."
---

# Parameterized and Typed Tests

GoogleTest extends your testing capabilities by enabling you to write tests that can flexibly cover a wide range of input values and data types. This page dives into **value-parameterized** and **type-parameterized tests**â€”mechanisms designed to make your test coverage both scalable and maintainable.

Harnessing these mechanisms, you avoid duplicating similar test logic for multiple data inputs or types, ensuring your tests are both DRY (Don't Repeat Yourself) and expressive.

---

## 1. Value-Parameterized Tests

Value-parameterized tests let you run the same test logic over different input data values, driving variations from a parameter source. This is invaluable when your function or class must behave correctly for multiple concrete inputs.

### Writing Value-Parameterized Tests

1. **Create a Test Fixture Class**

   Derive from `testing::TestWithParam<T>`, where `T` is the parameter type.

   ```cpp
   class MyValueTest : public ::testing::TestWithParam<int> {
    protected:
      // Any shared setup.
   };
   ```

2. **Define Parameterized Test Cases (`TEST_P`)**

   Use `TEST_P()` instead of `TEST()`/`TEST_F()` to write test bodies that can access the parameter via `GetParam()`.

   ```cpp
   TEST_P(MyValueTest, HandlesMultipleValues) {
     int param = GetParam();
     EXPECT_TRUE(ProcessInput(param));
   }
   ```

3. **Instantiate Tests (`INSTANTIATE_TEST_SUITE_P`)**

   Supply parameter values or generators to instantiate the test suite.

   ```cpp
   INSTANTIATE_TEST_SUITE_P(
       PositiveInts, MyValueTest,
       ::testing::Values(1, 2, 3, 10));
   ```

### Parameter Generators

GoogleTest provides a rich set of generator functions to produce parameters:

| Generator                | Description                                                    |
|--------------------------|----------------------------------------------------------------|
| `Range(begin, end [,step])` | Generates a sequence of values starting at `begin` (inclusive) to `end` (exclusive) stepping by `step` (default 1). |
| `Values(v1, v2, ..., vN)`| Generates the specified values sequentially.                    |
| `ValuesIn(container)`     | Uses values from an STL container or C array.                  |
| `Bool()`                 | Generates `false` and `true`.                                  |
| `Combine(g1, ..., gN)`    | Creates the Cartesian product of multiple generators.          |
| `ConvertGenerator<T>(g)` | Converts the output from generator `g` to type `T`.             |


### Custom Test Names

For clearer test output, provide name generators to produce meaningful test suffixes by implementing a callable accepting `TestParamInfo`:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomName, MyValueTest,
    ::testing::Values(10, 2),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Val" + std::to_string(info.param);
    });
```

### Example: Verifying Factorial with Value-Parameterized Tests

```cpp
class FactorialTest : public ::testing::TestWithParam<int> {};

int Factorial(int n);  // Implemented elsewhere

TEST_P(FactorialTest, HandlesValidInput) {
  int n = GetParam();
  int expected = ...; // expected factorial for n
  EXPECT_EQ(Factorial(n), expected);
}

INSTANTIATE_TEST_SUITE_P(
    BasicCases, FactorialTest,
    ::testing::Values(0, 1, 2, 3, 5, 8));
```

### Advanced: Using `Combine` and `ConvertGenerator`

Combine multiple generators for multi-parameter tests, optionally converting:

```cpp
using ParamType = std::tuple<int, bool>;

INSTANTIATE_TEST_SUITE_P(
    CombinedParams, MyValueTest,
    ::testing::ConvertGenerator<ParamType>(
        ::testing::Combine(::testing::Values(1, 2), ::testing::Bool())));
```

> This runs tests over all pairs: (1, false), (1, true), (2, false), (2, true).


## 2. Type-Parameterized Tests

Type-parameterized tests run the same test logic for multiple types, helping you verify type-generic code or interface compliance across implementations.

### Writing Type-Parameterized Tests

1. **Define a Fixture Class Template**

   Your fixture is templated on the type to be tested and derives from `testing::Test`:

   ```cpp
   template <typename T>
   class MyTypedTest : public ::testing::Test {
    public:
      T value_;
      // Setup shared among tests, possibly using TypeParam.
   };
   ```

2. **Associate Types with Test Suite Using `TYPED_TEST_SUITE`**

   Specify the list of types the suite will run on.

   ```cpp
   using MyTypes = ::testing::Types<int, float, double>;
   TYPED_TEST_SUITE(MyTypedTest, MyTypes);
   ```

3. **Define Typed Tests with `TYPED_TEST`**

   Inside tests, refer to the type with `TypeParam`.

   ```cpp
   TYPED_TEST(MyTypedTest, BasicBehavior) {
     TypeParam val = this->value_;
     EXPECT_TRUE(IsValid(val));
   }
   ```

4. **Run Your Typed Tests**

   Each test will be instantiated for every type in the list.

### Support for Custom Naming

Provide a functor to generate names for types when instantiating:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, float>) return "float";
    if constexpr (std::is_same_v<T, double>) return "double";
    return "unknown";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Example: Testing Containers Using Type-Parameterized Tests

```cpp
template <typename Container>
class ContainerTest : public ::testing::Test {
 public:
  ContainerTest() {
    container_.push_back(1);
    container_.push_back(2);
  }
  Container container_;
};

using Containers = ::testing::Types<std::vector<int>, std::list<int>, std::deque<int>>;
TYPED_TEST_SUITE(ContainerTest, Containers);

TYPED_TEST(ContainerTest, CanInsert) {
  this->container_.push_back(3);
  EXPECT_TRUE(std::find(this->container_.begin(), this->container_.end(), 3) != this->container_.end());
}
```

## 3. Type-Parameterized (Pattern) Tests

Type-parameterized tests (_pattern_ tests) are a flexible alternative allowing test patterns to be defined *abstractly* without concrete types, to be instantiated later with any type list. This is especially useful for library interfaces and multiple implementations.

### Workflow

- Declare the pattern with `TYPED_TEST_SUITE_P`.
- Define test patterns with `TYPED_TEST_P`.
- Register the tests with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate with `INSTANTIATE_TYPED_TEST_SUITE_P`.

### Outline

```cpp
template <typename T>
class MyPatternTest : public ::testing::Test {
  // ...
};

TYPED_TEST_SUITE_P(MyPatternTest);

TYPED_TEST_P(MyPatternTest, TestA) {
  TypeParam value = ...;
  EXPECT_TRUE(Foo(value));
}

TYPED_TEST_P(MyPatternTest, TestB) { ... }

REGISTER_TYPED_TEST_SUITE_P(MyPatternTest, TestA, TestB);

using MyTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(Inst1, MyPatternTest, MyTypes);
```

## 4. Best Practices

- **Choose the right tool:** Use value-parameterized tests when focusing on varied inputs of a specific type. Choose type-parameterized tests when you want to verify behavior over various types.
- **Name suites and tests wisely:** Avoid underscores in test and suite names for compatibility and clarity.
- **Provide custom test names for clarity:** This is essential especially for complex parameters or types.
- **Use `Combine` carefully:** When combining multiple generators, expect tests to grow multiplicatively.
- **Use `ConvertGenerator` to handle type conversions:** This improves flexibility when parameters require explicit casting.

## 5. Troubleshooting

- **Tests not running:** Make sure you have instantiated your parameterized test properly.
- **Test names unclear:** Provide custom name generators using functors or lambdas.
- **Compile errors with unusual types:** Confirm your types support necessary operations like copying or streaming for diagnostics.
- **Parameters not converting as expected:** Use `ConvertGenerator` with explicit types or conversion lambdas.
- **Naming collisions in test suites:** Avoid underscores and duplicate test names across suites.

---

Explore more in the [Advanced Guide on Parameterized Tests](../advanced.md#value-parameterized-tests) and [Typed Tests](../advanced.md#typed-tests).

## 6. References

- [`TEST_P`](#TEST_P) and [`INSTANTIATE_TEST_SUITE_P`](#INSTANTIATE_TEST_SUITE_P)
- [`TYPED_TEST_SUITE`](#TYPED_TEST_SUITE) and [`TYPED_TEST`](#TYPED_TEST)
- [`TYPED_TEST_SUITE_P`](#TYPED_TEST_SUITE_P) and [`TYPED_TEST_P`](#TYPED_TEST_P)
- [`REGISTER_TYPED_TEST_SUITE_P`](#REGISTER_TYPED_TEST_SUITE_P)
- [`INSTANTIATE_TYPED_TEST_SUITE_P`](#INSTANTIATE_TYPED_TEST_SUITE_P)

For detailed code examples and macros, see the [GoogleTest Parameterized Testing Reference](reference/testing.md#macros).

---

##### Browse the wider documentation:

- [GoogleTest Primer](primer.md) - Learn test basics
- [Assertions Reference](reference/assertions.md) - Verify code behavior
- [Mocking Reference](reference/mocking.md) - For mock object usage
- [Running Tests and Configuration](guides/getting-started/test-organization-running.mdx)

<Source url="https://github.com/google/googletest" path="docs/reference/testing.md" range="40-292" branch="main" />