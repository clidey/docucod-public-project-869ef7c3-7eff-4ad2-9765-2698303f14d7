---
title: "Assertions and Failures"
description: "Explore GoogleTest's comprehensive assertion mechanism, including equality checks, exceptions, fatal and non-fatal failures, and custom assertion support. Users can reference usage patterns, macro documentation, and assertion result details."
---

# Assertions and Failures

Explore GoogleTest's comprehensive assertion mechanism, including equality checks, exceptions, fatal and non-fatal failures, and custom assertion support. This guide helps you master how to write expressive assertions, understand their outcomes, and handle assertion results effectively to achieve reliable and informative tests.

---

## Overview

GoogleTest assertions are the cornerstone of verifying program correctness in your tests. They allow you to confirm that values meet expectations, operations behave correctly under conditions, and error states occur where appropriate. Assertions come in two main flavors:

- **Fatal Assertions (`ASSERT_*`)**: Stop the current function immediately upon failure, preventing further execution.
- **Nonfatal Assertions (`EXPECT_*`)**: Record the failure but allow the current function to continue.

Both allow streaming of custom messages to add context when a test fails.

### Why Use Assertions?

Assertions help you write tests that:

- Clearly express expected outcomes and conditions
- Provide detailed feedback when expectations are not met
- Control test execution flow by distinguishing fatal vs non-fatal failures

Mastering assertions allows you to write robust tests that catch regressions quickly while delivering rich diagnostic information.

---

## Core Assertion Types

### Explicit Success and Failure

- `SUCCEED()`: Marks an explicit success (does not override test failures).
- `FAIL()`: Immediately generates a fatal failure and returns from the current function.
- `ADD_FAILURE()`: Generates a nonfatal failure but continues execution.

Example usage to fail on unexpected code paths:

```cpp
switch(expression) {
  case 1:
    // ...
    break;
  case 2:
    // ...
    break;
  default:
    FAIL() << "Unexpected case encountered.";
}
```


### Boolean Assertions

- `EXPECT_TRUE(condition)` / `ASSERT_TRUE(condition)`: Checks that condition is true.
- `EXPECT_FALSE(condition)` / `ASSERT_FALSE(condition)`: Checks that condition is false.

These are fundamental for simple truthy checks.

### Binary Comparison Assertions

Compare two values with equality and relational operators:

- `EXPECT_EQ(val1, val2)` / `ASSERT_EQ(val1, val2)`: Equality.
- `EXPECT_NE(val1, val2)` / `ASSERT_NE(val1, val2)`: Inequality.
- `EXPECT_LT(val1, val2)` / `ASSERT_LT(val1, val2)`: Less than.
- `EXPECT_LE(val1, val2)` / `ASSERT_LE(val1, val2)`: Less than or equal.
- `EXPECT_GT(val1, val2)` / `ASSERT_GT(val1, val2)`: Greater than.
- `EXPECT_GE(val1, val2)` / `ASSERT_GE(val1, val2)`: Greater than or equal.

Use `ASSERT_*` variants where continuing after failure might cause bugs or crashes!

### String Comparison Assertions

Specifically designed for C strings and wide strings:

- `EXPECT_STREQ(str1, str2)` / `ASSERT_STREQ(str1, str2)`: Equal strings.
- `EXPECT_STRNE(str1, str2)` / `ASSERT_STRNE(str1, str2)`: Not equal strings.
- `EXPECT_STRCASEEQ(str1, str2)` / `ASSERT_STRCASEEQ(str1, str2)`: Case-insensitive equal strings.
- `EXPECT_STRCASENE(str1, str2)` / `ASSERT_STRCASENE(str1, str2)`: Case-insensitive not equal strings.

> **Tip:** Use these instead of pointer comparisons for C strings to check content equality.

### Floating-Point Assertions

Floating-point comparisons require special care due to precision issues. Use:

- `EXPECT_FLOAT_EQ(val1, val2)` / `ASSERT_FLOAT_EQ(val1, val2)`: Approximately equal floats within 4 ULPs.
- `EXPECT_DOUBLE_EQ(val1, val2)` / `ASSERT_DOUBLE_EQ(val1, val2)`: Approximately equal doubles within 4 ULPs.
- `EXPECT_NEAR(val1, val2, abs_error)` / `ASSERT_NEAR(val1, val2, abs_error)`: Value difference within an absolute error.

Use these macros to avoid false negatives due to floating point rounding.

### Exception Assertions

Require exceptions enabled in your build.

- `EXPECT_THROW(statement, exception_type)` / `ASSERT_THROW(statement, exception_type)`: Expects specific exception type.
- `EXPECT_ANY_THROW(statement)` / `ASSERT_ANY_THROW(statement)`: Expects any exception.
- `EXPECT_NO_THROW(statement)` / `ASSERT_NO_THROW(statement)`: Expects no exceptions.

Example:

```cpp
EXPECT_THROW(Foo(), std::runtime_error);
ASSERT_NO_THROW(Bar());
```

### Predicate Assertions

For complex conditions where existing assertions don’t provide meaningful failure messages.

- `EXPECT_PRED*` / `ASSERT_PRED*`: Use predicate functions returning `bool` to assert conditions with arguments.

Example:

```cpp
bool IsEven(int n) { return n % 2 == 0; }
EXPECT_PRED1(IsEven, 4);  // Passes
EXPECT_PRED1(IsEven, 5);  // Fails
```

- `EXPECT_PRED_FORMAT*` / `ASSERT_PRED_FORMAT*`: Use predicate formatters that return `AssertionResult` for richer failure messages.

Example:

```cpp
::testing::AssertionResult IsEvenWithMsg(const char* expr, int n) {
  if (n % 2 == 0) return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << n << " is odd";
}
EXPECT_PRED_FORMAT1(IsEvenWithMsg, 5);
```

This prints:

```
Value of: IsEvenWithMsg(5)
  Actual: false (5 is odd)
Expected: true
```

---

## Using Assertions in Your Tests

### Supporting Streaming Custom Messages

All assertions support streaming custom messages using `<<`. This is invaluable when you want to add context for test failures.

Example:

```cpp
EXPECT_EQ(x, y) << "Mismatch at index " << i;
```

### Assertion Placement Rules

- Fatal assertions (like `ASSERT_*`, `FAIL()`) can only be used in `void` returning functions.
- Using fatal assertions in constructors or destructors is not allowed and will cause compilation errors.
- Use nonfatal assertions like `EXPECT_*` in non-void functions.

### Dealing with Assertion Failures in Sub-Routines

By default, a fatal assertion aborts the current function only, not the entire test. This leads to unexpected continuation if you don’t handle it, e.g.:

```cpp
void Sub() {
  ASSERT_EQ(1, 2);  // Fatal failure, but returning only from Sub()
  ...               // skipped
}

TEST(SomeTest, Test) {
  Sub();
  // Test continues despite Sub()'s failure
}
```

To catch such cases:

- Use `ASSERT_NO_FATAL_FAILURE(statement)` to check that a statement has no fatal failures.
- Check using `HasFatalFailure()` to abort when a sub-routine had fatal failures.
- Alternatively, convert fatal failures to exceptions using a custom listener.

### Adding Scoped Traces for Better Diagnostics

`SCOPED_TRACE(message)` adds the current file, line, and message as context to failure messages within the current scope and sub-calls, aiding debugging where assertions are nested or reused.

Example:

```cpp
void Helper(int n) {
  EXPECT_EQ(1, n);
}

TEST(MyTest, Bar) {
  {
    SCOPED_TRACE("n=5");
    Helper(5);
  }
  Helper(1);  // No trace here
}
```

---

## Inspecting Assertion Results

GoogleTest encapsulates assertion outcomes using classes like `AssertionResult` and maintains results per test in `TestResult` and `TestPartResult`.

- `TestPartResult` stores information about an individual assertion, including type (success, non-fatal failure, fatal failure, skipped), source file, line number, and messages.
- Access assertion results programmatically from the currently running test or via event listeners.

The testing framework aggregates these to determine test success, failure, or skip statuses.

---

## Skipping Tests at Runtime

Use `GTEST_SKIP()` to skip the current test or all tests in a fixture/environment conditionally at runtime.

This can be done in:
- Individual tests
- `SetUp()` method of test fixtures
- Global test environments

Example:

```cpp
TEST(MyTest, SkipExample) {
  GTEST_SKIP() << "Feature not implemented yet.";
  FAIL();  // Will not be executed
}
```

---

## Customizing Assertion Messages and Output

GoogleTest automatically prints values and messages for failed assertions in a readable format. For user-defined types, you can customize GoogleTest's value printing:

- Define `friend void AbslStringify(Sink& sink, const YourType& obj)` in the same namespace.
- Alternatively, define a `PrintTo(const YourType& obj, std::ostream* os)` function.

These allow meaningful, human-friendly failure messages and help debug complex types.

To explicitly print a value anytime, use:

```cpp
std::string s = ::testing::PrintToString(obj);
EXPECT_TRUE(Check(obj)) << "Value: " << s;
```

---

## Death Tests

Assertions related to death behavior verify that code crashes or exits under expected conditions,

- `ASSERT_DEATH(statement, matcher)` / `EXPECT_DEATH(statement, matcher)` verify the program terminates and outputs expected error patterns.
- Use predicates like `::testing::ExitedWithCode(code)` and `::testing::KilledBySignal(signal)` with `EXPECT_EXIT`.

These tests run the code in a subprocess.

See [GoogleTest Advanced Topics](../advanced.md#death-tests) for detailed usage.

---

## Common Troubleshooting & Best Practices

- **Avoid mixing `TEST` and `TEST_F` in the same test suite**: This causes fixture conflicts and test failures.
- **Always check `HasFatalFailure()` after subroutine calls** if the subroutine uses fatal assertions.
- **Use `SCOPED_TRACE` liberally** when writing helper functions called from multiple tests to clarify failure origins.
- **Stream custom failure messages** wherever possible to provide extra debug information.
- **Use non-fatal assertions for checks that should not abort the function.**
- **Disable or skip tests using `DISABLED_` prefix or `GTEST_SKIP()` instead of commenting out.**

---

## Summary

This page covers GoogleTest's assertion macros, failure reporting mechanisms, and how to handle complex assertion scenarios effectively. Understanding assertions deeply helps you write clearer, more reliable tests that offer meaningful diagnostics and control execution flow as needed.

For further mastery, consult the [Assertions Reference](reference/assertions.md) for detailed macro syntax, [Advanced GoogleTest Topics](../advanced.md) for predicate assertions and death tests, and [Test Fixtures and Suites](test_fixtures_and_suites.md) to organize your tests efficiently.

---

## Additional Resources

- [Assertions Reference](reference/assertions.md)
- [Advanced GoogleTest Topics](../advanced.md)
- [Core Concepts and Terminology](../architecture-concepts/core-terminology.md)
- [Mocking & Matchers](mock_object_creation.md)
- [Test Fixtures and Suites](test_fixtures_and_suites.md)
- [GoogleTest Primer](primer.md)

---

## Quick Example

```cpp
TEST(MathTest, BasicAssertions) {
  int x = 5;
  int y = 2 + 3;

  // Check equality; continue even if it fails
  EXPECT_EQ(x, y) << "x and y should be equal";

  // Check a condition; abort immediately if false
  ASSERT_TRUE(x > 0) << "x must be positive";
}

// Custom predicate with detailed message
::testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0)
    return ::testing::AssertionSuccess();
  else
    return ::testing::AssertionFailure() << n << " is odd";
}

TEST(NumberTest, CustomPredicate) {
  int value = 3;
  EXPECT_TRUE(IsEven(value));  // Prints '3 is odd' on failure
}

// Skipping test based on runtime condition
TEST(FeatureTest, SkipIfFeatureDisabled) {
  if (!IsFeatureEnabled()) {
    GTEST_SKIP() << "Feature disabled on this platform.";
  }
  // Rest of test runs only if feature is enabled
}
```
