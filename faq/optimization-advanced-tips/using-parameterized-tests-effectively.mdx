---
title: "Using Parameterized and Typed Tests Effectively"
description: "Explains how to use value- and type-parameterized tests to reduce code duplication and increase test coverage. Addresses common misunderstandings and edge cases with parameterization."
---

# Using Parameterized and Typed Tests Effectively

GoogleTest's parameterized and typed tests are powerful tools that allow you to write concise, scalable tests that cover a broad range of inputs and types without code duplication. This page explains best practices, common confusions, and practical guidance on how to use value-parameterized (`TEST_P`) and type-parameterized (`TYPED_TEST`) tests effectively.

---

## Why Use Parameterized and Typed Tests

Writing individual tests for each input value or type quickly leads to repetitive, hard-to-maintain code. Parameterized and typed tests simplify this by:

- Reusing the same test logic with different input values or types.
- Making test suites easier to extend as new cases or types arise.
- Improving test coverage systematically.

Value-parameterized tests vary the test data; typed tests vary the type under test.

---

## Value-Parameterized Tests (Using `TEST_P` and `INSTANTIATE_TEST_SUITE_P`)

### Overview

Value-parameterized tests allow you to write a test once and run it multiple times with different parameter values.

#### User Flow:
1. Create a test fixture class deriving from `::testing::TestWithParam<T>`, where `T` is the parameter type.
2. Define tests using `TEST_P` macros, accessing the current parameter via `GetParam()`.
3. Instantiate the test suite with specific parameters using `INSTANTIATE_TEST_SUITE_P` and parameter generators.

### Parameter Generators

GoogleTest provides generators to specify parameters:

- **Range(begin, end [, step])**: Generates values from `begin` (inclusive) to `end` (exclusive) with optional `step`.
- **Values(v1, v2, ..., vN)**: Enumerated values.
- **ValuesIn(container)**: Values from a container or iterator range.
- **Bool()**: Yields `{false, true}`.
- **Combine(gen1, gen2, ..., genN)**: Cartesian product of parameter sequences.
- **ConvertGenerator<T>(gen)**: Converts generated values using `static_cast` or a converter function.

#### Example

```cpp
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, FooTest, ::testing::Values(2, 4, 6));
```

### Customizing Test Names

The optional last argument in `INSTANTIATE_TEST_SUITE_P` allows a function/functor to generate readable custom test names from parameters. This aids in identifying tests when looking at results or filtering.

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, FooTest, ::testing::Values(1, 2, 3),
    [](const ::testing::TestParamInfo<int>& info) {
      return "Value_" + std::to_string(info.param);
    });
```

### Best Practices

- Ensure instantiated test names are unique and only contain alphanumeric characters and underscores.
- Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST()` if you have a parameterized fixture without instantiations to avoid failing tests.
- Place instantiations at global or namespace scope, not inside functions.

### Common Pitfalls

- The sequence of parameters is not evaluated until `InitGoogleTest()` runs, so parameters depending on runtime state should be initialized prior to that call in `main()`.
- Defining `SetUpTestSuite` or `TearDownTestSuite` in parameterized fixtures requires them to be `public` for `TEST_P` to work correctly.
- Each test instance runs with a *separate* test fixture object; there is no shared test fixture state between invocations unless explicitly done via `static` members.

---

## Typed and Type-Parameterized Tests

### Typed Tests (Using `TYPED_TEST_SUITE` and `TYPED_TEST`)

Typed tests allow testing the same code for a fixed, compile-time list of types.

#### User Flow:
1. Create a template test fixture parameterized by a type `T`.
2. Associate the test fixture with a list of types using `TYPED_TEST_SUITE`.
3. Define tests using `TYPED_TEST` macros that use `TypeParam` to refer to the current type.

#### Example

```cpp
template <typename T>
class FooTest : public ::testing::Test {
 public:
   T value_{};
};

using MyTypes = ::testing::Types<int, double, char>;
TYPED_TEST_SUITE(FooTest, MyTypes);

TYPED_TEST(FooTest, IsDefaultInitialized) {
  TypeParam val = this->value_;
  EXPECT_EQ(val, TypeParam{});
}
```

### Type-Parameterized Tests (Using `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, and `INSTANTIATE_TYPED_TEST_SUITE_P`)

Type-parameterized tests define an abstract test suite template that is instantiated with specific types later, even multiple times and across translation units.

#### User Flow:
1. Define test fixture template and mark it as type-parameterized with `TYPED_TEST_SUITE_P`.
2. Declare type-parameterized tests with `TYPED_TEST_P`.
3. Register the test names with `REGISTER_TYPED_TEST_SUITE_P`.
4. Instantiate with actual types using `INSTANTIATE_TYPED_TEST_SUITE_P`.

#### Example

```cpp
template <typename T>
class MyTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(MyTest);

TYPED_TEST_P(MyTest, DoesSomething) {
  TypeParam val{};
  EXPECT_TRUE(SomeCheck(val));
}

REGISTER_TYPED_TEST_SUITE_P(MyTest, DoesSomething);

using ImplTypes = ::testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyImpl, MyTest, ImplTypes);
```

### Best Practices

- Typed tests are ideal when test logic applies directly to type abstractions.
- Type-parameterized tests are useful for reusable test patterns across multiple type sets.
- Use the optional name generator argument to customize the type name suffixes.

### Common Pitfalls

- Always define type lists with `using` or `typedef` to ensure the macro parses correctly.
- Access fixture members within typed tests through `this->` to compile cleanly.

---

## Comparing Value-Parameterized and Typed Tests

| Feature                      | Value-Parameterized Tests (`TEST_P`)                  | Typed Tests (`TYPED_TEST`)                              |
| ----------------------------|------------------------------------------------------|---------------------------------------------------------|
| Parameterization over        | Run-time values                                      | Compile-time types                                      |
| When to prefer              | Varying input data, possibly complex objects         | Varying types but same test logic                      |
| Test parameter access       | `GetParam()`                                        | `TypeParam`                                             |
| Test suite definition       | Must instantiate with parameters                     | Types assigned at compile time via `TYPED_TEST_SUITE`  |
| Use for interface testing   | Wrapping implementation with parameters             | Testing multiple implementations by type                |
| Test output naming          | Parameter index or custom names via functors         | Type names (customizable by name generator)             |

You can mix both strategies depending on your testing needs.

---

## Advanced Concepts and Tips

### Combining Multiple Parameters

Use `Combine()` to create Cartesian products of parameters, enabling coverage of all combinations:

```cpp
INSTANTIATE_TEST_SUITE_P(
  ComboTest, MyTest,
  testing::Combine(testing::Values(1, 2), testing::Bool()));
```

Inside tests access the tuple via `GetParam()`.

### ConvertGenerator

When the generated parameter types do not exactly match the expected parameter type, use `ConvertGenerator` with a converter function or static cast. This is useful for adapting tuples to user-defined parameter classes.

### Naming Tests

- Use the built-in `PrintToStringParamName()` for simple readable names.
- Implement custom naming lambdas or functors for more descriptive test names.
- Replace non-alphanumeric characters in names with underscores to comply with naming rules.

### Handling Uninstantiated Parameterized Tests

If you define `TEST_P` but do not instantiate with `INSTANTIATE_TEST_SUITE_P`, GoogleTest emits warnings/errors by default. Suppress with:

```cpp
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MyTestSuite);
```

### Sharing Fixtures

For complex hierarchies, `TestWithParam` can be combined with other base fixtures or interfaces.

### Static Setup and Teardown

If using `SetUpTestSuite()` and `TearDownTestSuite()` in parameterized fixtures, mark them `public`.

---

## Troubleshooting Common Issues

### Tests Not Running

- Ensure you instantiate all parameterized tests with `INSTANTIATE_TEST_SUITE_P` unless explicitly allowed.

### Unexpected Test Names or Collisions

- Tests whose names contain underscores may cause collisions or invalid generated class names. Avoid underscores in test suite and test names.

### Parameter Type Conversion Issues

- If your test parameters require conversion from generated types, use `ConvertGenerator` with an explicit converter.

### Dangling References in ConvertGenerator

- When using lambdas in `ConvertGenerator`, beware of dangling references if generated types differ from lambda argument types. Pass by value or adjust argument types to prevent this.

### Custom Test Names Not Showing

- Verify your name generator returns valid, unique names with allowed characters.

---

## Example Use Cases

### Example: Testing with Multiple Input Values

```cpp
class MyAlgorithmTest : public ::testing::TestWithParam<int> {};

TEST_P(MyAlgorithmTest, HandlesInput) {
  int input = GetParam();
  EXPECT_TRUE(ProcessInput(input));
}

INSTANTIATE_TEST_SUITE_P(
    RangeTests, MyAlgorithmTest, testing::Range(0, 10));
```

### Example: Testing Different Types of Containers

```cpp
template <typename T>
class ContainerTest : public ::testing::Test {};

using ContainerTypes = ::testing::Types<std::vector<int>, std::list<int>>;

TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, EmptyInitially) {
  TypeParam container;
  EXPECT_TRUE(container.empty());
}
```

---

## Related Documentation

- [Value-Parameterized Tests Guide](/guides/core-workflows/value-and-type-param-tests)
- [Typed Tests Guide](/guides/core-workflows/using-typed-tests)
- [Testing Reference - Parameterized and Typed Tests](../docs/reference/testing.md#TEST_P)
- [FAQ: Using Parameterized Tests Effectively](/faq/optimization-advanced-tips/using-parameterized-tests-effectively)

---

## Summary

Use parameterized and typed tests to make your test code more maintainable, concise, and comprehensive. Start from simple `TEST_P` with `Values` or `Range`, then explore `Combine` or `ConvertGenerator` for advanced scenarios. Typed tests let you test across types with minimal repetition, and type-parameterized tests add flexibility for reusable test patterns. Customize naming for clarity and debug ease.

Always instantiate your tests properly, and be aware of common pitfalls such as parameter evaluation timing and naming conventions.

This page equips you to incorporate parameterized and typed tests effectively into your GoogleTest test suites, maximizing test coverage and test quality without redundant code.