---
title: "How can I improve test performance and reduce execution time?"
description: "Tips for diagnosing and speeding up slow tests, including recommendations on fixture design, parallelization, test filtering, and avoiding common performance pitfalls."
---

# How can I improve test performance and reduce execution time?

This guide helps you diagnose slow or inefficient tests and provides actionable tips on speeding up test execution with GoogleTest and GoogleMock. Focusing on the design of test fixtures, parallel test execution, selective test filtering, and avoiding common pitfalls, this page empowers you to write maintainable, fast tests that boost your development productivity.

---

## Understanding Why Tests Run Slowly

Before optimizing test performance, it is critical to diagnose root causes. Common factors include:

- **Expensive test fixtures or setup/teardown:** Heavy initialization can multiply across many test cases.
- **Overly broad mock expectations:** Excessive or complex expectations can cause overhead.
- **Running all tests unnecessarily:** Running the entire suite including unrelated tests wastes time.
- **Single-threaded test execution:** Tests that could safely run in parallel but don't.

Start by profiling the total test run time and identifying individual slow tests or fixtures.

---

## Tips for Designing Fast Test Fixtures

A well-designed test fixture minimizes unnecessary work and isolates dependencies. Here are recommended strategies:

### 1. Keep Fixture Setup Lightweight

Reduce expensive operations in `SetUp()` and `TearDown()` methods. For example, avoid heavy file I/O, network connections, or database initialization if not required.

### 2. Use `SetUpTestSuite()` and `TearDownTestSuite()` for Shared Resources

If multiple tests share the same immutable expensive resource:

```cpp
class FooTest : public ::testing::Test {
protected:
  static void SetUpTestSuite() {
    // Perform expensive, shared setup here.
  }

  static void TearDownTestSuite() {
    // Clean up shared resources.
  }

  void SetUp() override {
    // Lightweight setup.
  }
};
```

This ensures the expensive setup runs only once per test suite, not per test case.

### 3. Mock External Dependencies

Use GoogleMock to isolate tests from external dependencies like databases or services. This avoids slow I/O and makes tests faster and more deterministic.

Avoid mocking excessively complex interactions; focus only on the behavior relevant to the test.

---

## Running Tests in Parallel

Taking advantage of your hardware can reduce total test execution time substantially.

### Enable Parallel Test Execution

GoogleTest supports running tests in parallel through test runners:

- Use [gtest-parallel](https://github.com/google/gtest-parallel) utility external to GoogleTest.
- Integrate parallelism via your build system or continuous integration pipeline by launching multiple test jobs.

When parallelizing:

- Ensure tests are isolated and thread-safe.
- Avoid shared global state or serialize access to shared resources.

### Use `--gtest_repeat` and `--gtest_shuffle`

For flakiness detection, run tests repeatedly and in random order:

```bash
./your_test_binary --gtest_repeat=100 --gtest_shuffle
```

While this doesn't directly improve speed, it helps identify flaky tests that hurt overall test reliability.

---

## Selecting and Filtering Tests

You often don't need to run all tests every time. Running only a targeted subset improves speed.

### Use Test Filters

Run only tests matching specific patterns with `--gtest_filter`:

```bash
./your_test_binary --gtest_filter=MyTestSuite.*FastTest
```

Supports wildcards `*`, `?` and exclusion with `-`.

### Disable Slow or Expensive Tests Temporarily

Prefix slow tests with `DISABLED_` to exclude them from runs without deleting code:

```cpp
TEST(FooTest, DISABLED_LongRunningTest) {
  // Slow test code...
}
```

Or run disabled tests explicitly when needed:

```bash
./your_test_binary --gtest_also_run_disabled_tests
```

### Use Value-Parameterized or Typed Tests Wisely

When testing similar functionality over many inputs, value-parameterized tests save code but can multiply test count. Limit parameters to ranges relevant to your test goals.

---

## Avoiding Common Performance Pitfalls

- **Avoid excessive `EXPECT_CALL`s:** Each adds overhead to mock method call matching.
- **Use `NiceMock` for uninteresting calls:** This suppresses warnings and reduces logging overhead for calls you don't care about.
- **Prefer `ON_CALL` for default behavior:** Use `ON_CALL` to specify default mock behaviors without imposing expectations.
- **Minimize object construction inside tests:** Cache reusable objects where possible.
- **Be cautious with `EXPECT_CALL` in loops:** Setting expectations repeatedly at runtime duplicates work.

---

## Step-by-Step Workflow to Speed Up Tests

<Steps>
<Step title="Profile Your Tests">
Run your tests with timing flags or profilers to identify slow tests and fixtures.
</Step>
<Step title="Analyze and Simplify Test Fixtures">
Identify expensive setup and factor them into shared suite-level setup or mocks.
</Step>
<Step title="Minimize Mocks and Expectations">
Only mock what is necessary, use `ON_CALL` for default behaviors, and use `NiceMock` if warnings on uninteresting calls are distracting.
</Step>
<Step title="Run Tests Selectively">
Use `--gtest_filter` to run relevant tests during development.
</Step>
<Step title="Leverage Parallelism">
Use parallel test runners or split tests across machines in CI pipelines.
</Step>
<Step title="Iterate and Monitor">
Repeat profiling after changes and watch for regression in test times.
</Step>
</Steps>

---

## Troubleshooting Slow Tests

### Tests Hang or Take Too Long

- Check for deadlocks or synchronization issues if using threads.
- Use verbose logging (`--gmock_verbose=info`) to trace mock calls.
- Confirm mocks are not creating unnecessary delays (like heavy actions or complex matchers).

### Excessive Memory Usage Slowing Tests

- Cache shared state instead of recreating.
- Avoid large temporary objects in test setup.

### Mock Warnings and Verbosity

- Lower verbosity if output slows test runs: `--gmock_verbose=warning` or `error`.

---

## Best Practices Summary

- Isolate dependencies with mocks for precise testing.
- Use fixture suite-level setup for expensive preparation.
- Filter tests during development.
- Run tests in parallel where possible.
- Use `ON_CALL` for usual behaviors; reserve `EXPECT_CALL` for verifying important calls.
- Monitor test performance periodically.

---

## Additional Resources

- [Mock Object Definition](api-reference/gmock-mocking-apis/mock-object-definition)
- [Expectations and Behavior Specification](api-reference/gmock-mocking-apis/expectations-specification)
- [Writing and Managing Death Tests](guides/advanced-usage-and-optimization/death-tests)
- [Test Case Construction](api-reference/gtest-core-apis/test-case-construction)
- [Test Structure and Discovery](guides/getting-started/test-structure-and-discovery)
- [Mocking Best Practices](guides/real-world-patterns/mocking-best-practices)

---

<Check>
Regularly profile and review your tests for performance > Apply fixture sharing and mocks > Filter tests selectively > Use parallel test execution > Minimize mock overhead and verbosity for best results.
</Check>
