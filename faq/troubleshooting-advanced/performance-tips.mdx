---
title: "Performance Optimization Tips"
description: "Highlights strategies and best practices to speed up test execution, including parallel test runs, reducing test flakiness, and avoiding common pitfalls that slow down large test suites. Offers concrete suggestions for users with performance-critical workflows."
---

# Performance Optimization Tips

Efficient test execution is vital for maintaining swift feedback loops in development cycles, especially when working with large and complex test suites. This page focuses exclusively on strategies and best practices to accelerate test runs using GoogleTest and GoogleMock, addressing common bottlenecks, reducing test flakiness, and guiding users with performance-critical workflows towards actionable improvements.

---

## Why Optimize Test Performance?

In modern development workflows, running tests quickly enables developers to detect regressions early and iterate faster. However, as tests accumulate, slow execution can become a bottleneck causing frustration and discouraging frequent testing.

Optimizing test performance helps you:

- Reduce overall CI and local test execution times.
- Improve developer productivity and morale.
- Make tests more reliable and less flaky.
- Achieve better scalability as your test suite grows.

---

## Core Strategies for Faster Test Execution

### 1. Run Tests in Parallel

GoogleTest supports running multiple tests concurrently on different CPU cores, dramatically speeding up the total test run time.

#### How to Enable Parallel Test Runs

- Use the `--jobs` (or `-j`) flag with `ctest` or your build system that invokes tests in parallel.
- Alternatively, use `gtest-parallel` (a separate tool) to run tests concurrently when native parallelization is absent.

For example:

```bash
ctest -j8  # Run tests in parallel using 8 cores
```

#### Best Practices

- Ensure tests are independent and do not share state that causes race conditions.
- Configure thread-safe mocks and avoid global mutable states.
- If tests frequently access shared resources (files, databases), consider providing isolated environments per test or using mocks.

<Tip>
Parallel test execution can reduce your test suite running time by a factor close to the number of CPU cores, but only if your tests are well-isolated and thread-safe.
</Tip>

---

### 2. Minimize Test Flakiness

Flakiness causes tests to unpredictably pass or fail, leading to wasted time troubleshooting non-deterministic failures and repetitive test runs.

#### Common Causes

- Tests depending on external systems or resources (networks, file systems).
- Tests with timing or ordering assumptions.
- Over-mocking or improperly configured mocks.

#### Solutions Using GoogleMock

- Use proper mock expectations (`EXPECT_CALL`) and default behaviors (`ON_CALL`) to control dependencies.
- Leverage `NiceMock` to suppress warnings for uninteresting calls if you don’t want to verify certain calls strictly.
- Use `StrictMock` carefully to catch unexpected interactions but avoid over-strictness.
- Sequence and order expectations explicitly with `InSequence`, `Sequence`, and `After` clauses to avoid ordering flakiness.

<Tip>
Consistent use of `ON_CALL` and `EXPECT_CALL` improves the reliability of your tests and reduces the likelihood of flaky failures.
</Tip>

---

### 3. Avoid Over-Specification

Excessively rigid expectations or complicated sequences slow down tests and make them brittle.

#### How to Avoid

- Use argument matchers (e.g. `_`) to allow flexibility in inputs where only some arguments matter.
- Set the minimum effective expectations that validate the behavior you care about.
- Avoid chaining unnecessary `.Times()` or `.InSequence()` unless order and call count are essential.

---

### 4. Defer Complex Setup with Delegation

Instead of recreating complex mocks or test data in every test, delegate to fakes or real implementations when appropriate.

Example pattern:

```cpp
class FakeFoo : public Foo {
  // A partial, lightweight implementation.
};

class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, DoThing, (), (override));

  void DelegateToFake() {
    ON_CALL(*this, DoThing)
        .WillByDefault([this]() { return fake_.DoThing(); });
  }

 private:
  FakeFoo fake_;
};
```

This reduces test complexity and speeds up setup time.

---

### 5. Use `RetiresOnSaturation()` in Expectations

When using multiple `EXPECT_CALL`s on the same method with different argument matchers or behaviors, adding `.RetiresOnSaturation()` causes an expectation to retire after it reaches its maximal call count. This avoids unnecessarily checking saturated expectations repeatedly, reducing overhead.

Example:

```cpp
EXPECT_CALL(mock, Foo(0))
    .Times(2)
    .RetiresOnSaturation();
EXPECT_CALL(mock, Foo(_))
    .Times(AnyNumber());
```

The first expectation will deactivate after two calls, allowing faster resolution in subsequent calls.

---

### 6. Limit Use of `WillOnce()` Chains

Excessive chaining of `.WillOnce()` actions can increase memory usage and add overhead. Prefer `.WillRepeatedly()` for consistent behavior when suitable.

---

## Common Pitfalls Slowing Down Tests

- Long or unnecessary action sequences in expectations.
- Overuse of strict call ordering without necessity.
- Excessive console logging during test runs (reduce verbosity unless debugging).
- Leaked mocks preventing automatic verification and causing delays.

---

## Troubleshooting Performance Issues

### Test Suite Runs Slowly or Hangs

- Check for shared state or resource contention.
- Run tests with `--gmock_verbose=warning` or `--gmock_verbose=error` to reduce log noise.
- Use GoogleMock's `Mock::VerifyAndClearExpectations()` periodically if mocks live longer than expected.

### Excessive Mock Warnings About Uninteresting Calls

- Suppress uninteresting calls with `NiceMock<T>` where appropriate.
- Add catch-all expectations `EXPECT_CALL(mock, Method(_)).Times(AnyNumber());` to silence warnings.
  Avoid blindly adding expectations that do not serve verification purposes.

### Unexpected Test Failures Due to Order Constraints

- Reassess whether call order constraints (`InSequence`, `After`) are necessary.
- Replace with partial ordering or loosen constraints to improve test reliability and speed.

---

## Summary

Optimizing test performance requires a balance between test fidelity and efficiency. Applying parallel execution, controlling flakiness, judiciously using mock expectations, utilizing delegation patterns, and managing action lifecycles help keep test suites fast and reliable.

---

## Additional Resources

- [Mocking Reference](../reference/mocking.md) — For details on macros and expectation syntax.
- [gMock for Dummies](../gmock_for_dummies.md) — Introductory guide to mocking with GoogleMock.
- [gMock Cookbook](../gmock_cook_book.md) — Advanced recipes for effective mock usage.
- [gMock Cheat Sheet](../gmock_cheat_sheet.md) — Quick syntax reference.
- [Mock Class Behavior Modes](../mock-class-behavior-modes.md) — Details on `NiceMock`, `NaggyMock`, and `StrictMock`.

You can find these pages linked in the [Navigation Map](../../).

---

## Practical Example

Here's a practical workflow to speed up and stabilize your tests:

<Steps>
<Step title="Create Mock Classes">
Define mock classes using `MOCK_METHOD` macros, making sure to add `override` and `const` qualifiers correctly.
</Step>
<Step title="Set Default Behaviors with ON_CALL">
Use `ON_CALL` to specify default mock method behaviors shared across multiple tests.
</Step>
<Step title="Write Focused EXPECT_CALLs">
Add `EXPECT_CALL` only for interactions you want to verify. Avoid overly specific argument matching when unnecessary.
</Step>
<Step title="Use Sequences for Ordering Only When Needed">
Employ `InSequence` or `After` clauses sparingly to enforce call orders.
</Step>
<Step title="Run Tests in Parallel">
Leverage your build system or tools like `ctest -j` to run tests concurrently.
</Step>
<Step title="Profile and Refine">
Monitor test duration and flakiness, then adjust mocks, expectations, or test isolation strategies accordingly.
</Step>
</Steps>

<Tip>
Using profiler and verbose flags (`--gmock_verbose=info` during debugging) helps identify slow or flaky mocks.
</Tip>

---

## Troubleshooting Checklist

<AccordionGroup title="Performance Troubleshooting">
<Accordion title="Tests run slower after adding mocks">
Ensure your mocks are correctly specified with necessary `ON_CALL` for default behavior to avoid excessive overhead.
Verify no unnecessary `EXPECT_CALL`s exist that slow the matching process.
</Accordion>
<Accordion title="Flaky tests due to mock ordering">
Review and possibly relax ordering constraints (`InSequence` or `.After`).
Consider redesigning tests with partial ordering or no strict order.
</Accordion>
<Accordion title="Test output flooded with mock warnings">
Check if mocks are too strict by default.
Use `NiceMock` to reduce warnings or add generic `EXPECT_CALL(...).Times(AnyNumber())` for unimportant calls.
</Accordion>
<Accordion title="Parallel test execution causes failures">
Inspect shared resource usage between tests.
Mock or isolate any shared dependencies.
Avoid global or static state where possible.
</Accordion>
</AccordionGroup>

---

For any remaining issues or performance tuning questions, consult the broader [FAQ](../../faq/) and GoogleMock Cookbook.
