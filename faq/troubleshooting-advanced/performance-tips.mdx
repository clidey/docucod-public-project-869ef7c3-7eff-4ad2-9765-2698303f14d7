---
title: "Performance Optimization Tips"
description: "Presents optional techniques to speed up test suites, run tests in parallel, or optimize test and mock construction, with references to commonly used external tools and configurations."
---

# Performance Optimization Tips

GoogleTest and GoogleMock provide powerful and flexible tools for C++ unit testing and mocking, but running large test suites can sometimes be time-consuming. This page presents practical, optional techniques to optimize test performance, speed up test execution, and improve mock construction efficiency. These tips also reference commonly used external tools and configurations to help you maximize productivity.

---

## 1. Speeding Up Test Suites

### Parallel Test Execution

Running tests in parallel is one of the most effective ways to reduce overall test suite runtime. GoogleTest supports running tests concurrently using your platform’s native threads by leveraging the `--gtest_parallel` flag or external tools.

- Use `--gtest_parallel` option when supported to distribute tests across multiple CPU cores.
- For CI environments, consider parallelizing at the job level by splitting tests among agents.

**Example:**

```bash
./my_test_suite --gtest_parallel=4
```
This runs tests distributed over 4 parallel execution threads.

### Filtering Tests

Run only the subset of tests you need to validate:

- Use `--gtest_filter` to specify which tests to run.
- Combine with `--gtest_repeat` to iterate over selected tests.

**Example:**

```bash
./my_test_suite --gtest_filter=MyTestSuite.*
```

### Test Sharding

Divide test execution into shards for highly parallel CI execution:

- Use environment variables such as `GTEST_SHARD_INDEX` and `GTEST_TOTAL_SHARDS`.
- Each shard runs a partition of tests independently.


## 2. Optimizing Mock Construction and Mock Execution

Mock classes generated by GoogleMock can sometimes introduce compile-time and runtime overhead if not optimized.

### Minimize Unnecessary Mocks

- Avoid mocking classes you don’t own or do not really need to mock.
- Use fakes or stubs for simpler return values or side-effect behaviors.
- Mock only the relevant subset of virtual methods to reduce complexity.

### Use NiceMock and StrictMock Wisely

- Use `NiceMock<T>` to suppress warnings about uninteresting calls when you don't want to be notified of all mock method calls.
- Use `StrictMock<T>` to ensure all unexpected calls cause failures but be mindful of potential test brittleness.

### Move Mock Class Constructor/Destructor Definitions Out of Headers

If mock classes are included in many translation units, defining their constructors and destructors in `.cc` files rather than headers can significantly reduce compile time.

### Avoid Over-Specifying Expectations

Limiting the number and strictness of `EXPECT_CALL` clauses reduces verification and runtime overhead.

### Pre-Set Default Actions Using ON_CALL

Use `ON_CALL` statements to define default mock behaviors globally, avoiding repeated setup in multiple tests.

### Use Action Lambdas for Efficient Behavior

Action lambdas in `WillOnce` or `WillRepeatedly` clauses can encapsulate logic concisely and optimize runtime.


## 3. Using GoogleTest and GoogleMock Verbosity and Flags for Insight

- Use the flag `--gmock_verbose=[info|warning|error]` to control the amount of mock call output, which affects performance during debugging.
- In intensive debug scenarios, reducing verbosity from `info` to `warning` or `error` speeds tests.


## 4. Integrating External Tools

### Heap Checkers and Sanitizers

In some cases, performance issues arise from memory leaks or undefined behaviors in mocks. Combining GoogleTest with tools like AddressSanitizer or Valgrind can help detect such issues early.

### Continuous Integration (CI) Pipelines

Leverage CI to run tests and mocks efficiently with parallel jobs, caching, and selective runs. See the [Integrating with CI/CD Pipelines Guide](/gtest-guides/integration-scaling/ci_integration).


## 5. Troubleshooting Common Performance Problems

### Slow Mock Construction

If mock object creation seems slow:

- Confirm you are only mocking necessary methods.
- Consider consolidating or simplifying mocks.

### Excessive Test Runtime

- Narrow test scope with filters and shards.
- Use parallelism and caching strategies.

### Increased Compilation Time

- Use out-of-line definitions for constructors and destructors
- Reduce dependencies in test headers.


## 6. Best Practices

- **Write Small, Focused Tests:** Smaller tests that isolate features run faster and easier to optimize.
- **Run Tests Frequently with Filters:** During development, run a small targeted test set.
- **Profile Test Execution:** Identify slow-running tests or mocks and optimize them.
- **Use NiceMocks to Reduce Noise:** Avoid test flakiness caused by warnings about uninteresting calls.


## Additional Resources

- [Running and Configuring Tests](/api-reference/core-apis/running-tests) for test execution flags
- [Mocking Methods and Objects](/api-reference/mocking-apis/mocking-methods) to write efficient mocks
- [Defining Expectations and Behaviors](/api-reference/mocking-apis/defining-expectations) for optimizing mock interactions
- [Mocking Strategies and Common Pitfalls](/faq/troubleshooting-advanced/mocking-strategies-and-pitfalls)
- [Integrating with CI/CD Pipelines](/gtest-guides/integration-scaling/ci_integration)

---

### Quick Tip: How to Run Your Tests Faster

```bash
./run_tests --gtest_filter=*MyComponent* --gtest_parallel=8 --gtest_repeat=10
```
This command runs all tests matching "MyComponent" randomly distributed on 8 threads and repeated 10 times.

### Troubleshooting Mock Performance

If mock expectations seem slow or too strict:

- Relax mock strictness modes (`NiceMock` vs `StrictMock`).
- Use `.RetiresOnSaturation()` to avoid sticky expectations causing overhead.
- Prefer lambdas for actions over heavy custom functor classes.


---

This guidance helps you realize the full potential of GoogleTest and GoogleMock by making tests fast, scalable, and maintainable. Leveraging these tips ensures smoother developer feedback cycles and efficient continuous integration pipelines.


---

<Note>
Always profile before optimizing. Measure to locate bottlenecks rather than guessing.
</Note>