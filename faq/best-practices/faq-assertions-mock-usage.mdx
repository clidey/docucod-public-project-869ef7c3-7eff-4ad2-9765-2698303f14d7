---
title: "Assertions, Matchers, and Mocking: Common Pitfalls"
description: "Covers frequently misunderstood concepts in GoogleTest and GoogleMock, such as assertion usage, matcher composition, and writing robust mocks. Highlights best practices to avoid flaky or inaccurate tests."
---

# Assertions, Matchers, and Mocking: Common Pitfalls

This guide clarifies frequently misunderstood concepts in GoogleTest and GoogleMock, helping you avoid common mistakes and pitfalls when using assertions, matchers, and mocks. Understanding these pitfalls will empower you to write more robust and maintainable tests that verify correct behavior without brittleness or over-specification.

---

## 1. Correct Use of Assertions

### Pitfall: Misusing Fatal vs Non-Fatal Assertions

- **Problem**: Using fatal assertions (`ASSERT_*`) in code paths that don't terminate the test immediately can cause unexpected skips.
- **Solution**: Use non-fatal assertions (`EXPECT_*`) when you want the test to continue despite failures, especially in loops or multiple related checks. Reserve fatal assertions for conditions that must stop the test.

### Pitfall: Over-asserting Multiple Properties in a Single Test

- **Problem**: Checking many unrelated aspects within a single test makes diagnosing failures difficult.
- **Solution**: Write focused tests verifying one fact or state at a time. This leads to clearer failure messages and easier debugging.

### Example

```cpp
TEST(MyTestSuite, CheckValues) {
  int result = ComputeValue();
  EXPECT_EQ(result, 5);  // Non-fatal assertion
  EXPECT_GT(result, 0);  // If this fails, the previous assertion also fails but test continues
}
```

## 2. Matcher Usage Gotchas

### Pitfall: Unintended Over-Specification with Matchers

- **Problem**: Specifying too rigid or exact matchers causes brittle tests that break on refactoring or minor implementation changes.
- **Example**: Matching exact strings or container elements unnecessarily when only types or partial properties matter.
- **Solution**: Prefer flexible matchers (`_`, `NotNull()`, `HasSubstr()`, `ElementsAre()`) and avoid over-constraining.

### Pitfall: Matcher Type Mismatch

- **Problem**: Using matchers incompatible with the argument type causes compile errors or unexpected test failures.
- **Solution**: Use `SafeMatcherCast<T>(matcher)` to explicitly cast matchers with compatible underlying types if necessary.

### Pitfall: Forgetting to Handle Pointer Arguments Correctly

- **Problem**: Matching pointers without checking the pointed-to value or nullness can cause false positives or negatives.
- **Solution**: Use `Pointee(matcher)` to validate the value pointed to and `IsNull()` or `NotNull()` for pointer validity.

### Example

```cpp
EXPECT_CALL(mock, ProcessData(Pointee(Ge(10))));
EXPECT_CALL(mock, HandlePtr(NotNull()));
```

### Pitfall: Overloaded Functions Needing Disambiguation

- **Solution**: Use `Const()` wrapper for overloaded const methods or explicit matcher typing (`TypedEq<T>`, `An<T>()`) to resolve ambiguity.

## 3. Writing Robust Mocks

### Pitfall: Mocking Non-Virtual Methods Incorrectly

- **Problem**: Attempting to mock non-virtual methods naively leads to calls to the real method.
- **Solution**: Use interface-based mocking, or high-perf dependency injection with unrelated mock classes that share the same method signature (no `override`).

### Pitfall: Not Declaring Mock Methods in `public` Section

- **Solution**: Always declare mock methods in the `public:` part of the mock class, regardless of original access specifiers, so `ON_CALL` and `EXPECT_CALL` can access them.

### Pitfall: Ignoring Uninteresting Calls Leading to Warnings or Failures

- **Problem**: Calling mock methods without expectations can flood logs with warnings or cause failures.
- **Solution**: 
  - Use `NiceMock<T>` wrapper to suppress warnings.
  - Use `StrictMock<T>` wrapper to treat uninteresting calls as errors.
  - Use catch-all expectations like `EXPECT_CALL(mock, Foo(_)).Times(AnyNumber());` to explicitly allow calls with any argument.

### Pitfall: Writing Expectations Without Considering Call Order or Cardinality

- **Problem**: Not specifying call order or cardinality can cause unexpected test failures or false positives.
- **Solution**:
  - Use `.Times()`, `.InSequence()`, `.After()` clauses to express expected call counts and ordering precisely.
  - Use `.RetiresOnSaturation()` if an expectation should become inactive after its call count is reached.
  - Remember that expectations are sticky by default: they stay active even after saturation unless retired.

### Pitfall: Misunderstanding `EXPECT_CALL` vs `ON_CALL`

- **Explanation**: 
  - `ON_CALL` sets default behaviors **without** setting expectations. It's for specifying fallback behavior.
  - `EXPECT_CALL` sets both the expectation (i.e., the method _must_ be called as specified) and optionally the behavior.
- **Pitfall**: Using `ON_CALL` when you actually want to _verify_ a call.
- **Best Practice**: Use `ON_CALL` for convenience and setup, and `EXPECT_CALL` strictly to verify calls.

### Example

```cpp
class MockFoo : public Foo {
 public:
   MOCK_METHOD(void, DoSomething, (), (override));
};

TEST(TestCase, VerifiesCall) {
  NiceMock<MockFoo> mock;

  ON_CALL(mock, DoSomething()).WillByDefault(Return());  // Sets default behavior
  EXPECT_CALL(mock, DoSomething()).Times(1);            // Verifies it's called exactly once
  ... code that calls mock.DoSomething() ...
}
```

### Pitfall: Actions and Return Values in Move-Only Types

- **Problem**: Returning move-only objects (e.g., `std::unique_ptr`) directly in `Return()` can cause runtime errors because the value is moved-from after the first call.
- **Solution**: Use lambdas or functors inside `WillRepeatedly()` or `WillOnce()` that create a new object on each call.

### Example

```cpp
EXPECT_CALL(mock_buzzer_, MakeBuzz(_))
    .WillRepeatedly([](StringPiece text) {
        return std::make_unique<Buzz>(AccessLevel::kInternal);
    });
```

## 4. Best Practices

### 4.1 Use `ON_CALL` to Set Defaults, `EXPECT_CALL` to Set Expectations

Avoid overusing `EXPECT_CALL` which makes tests brittle. Use `ON_CALL` whenever you want to define behavior without assertion.

### 4.2 Use Matchers Judiciously

Only constrain arguments as much as needed. Over-specifying leads to fragile tests.

### 4.3 Use Sequences to Define Call Order

When call order matters, use `InSequence` or `.After()` to enforce partial or full ordering.

### 4.4 Use `NiceMock` or `StrictMock` Appropriately

- Use `NiceMock` to suppress uninteresting call warnings for less noisy tests.
- Use `StrictMock` only when you want to fail on any un-expected call and can handle strict verification.

### 4.5 Use `RetiresOnSaturation()` to Manage Sticky Expectations

Use `RetiresOnSaturation()` to make expectations retire after they have been matched their specified number of times, avoiding unexpected upper-bound failures.

### 4.6 Avoid Mocking Concrete Classes When Possible

Design interfaces to mock. Avoid injecting mocks in concrete classes as it couples tests to implementation details.

## 5. Troubleshooting Common Scenarios

### Scenario: Unexpected Calls

- Symptom: Test fails with "Unexpected mock function call" message.
- Check: Are you missing an `EXPECT_CALL` for the function?
- Fix: Add explicit expectations or add a catch-all `EXPECT_CALL(mock, Func(_)).Times(AnyNumber())`.

### Scenario: Uninteresting Call Warnings

- Symptom: Warnings about uninteresting calls appear.
- Check: Did you define any `EXPECT_CALL` for the method?
- Fix: Use `NiceMock` or add catch-all `EXPECT_CALL`s, or adjust verbosity with `--gmock_verbose`.

### Scenario: Compilation Fails with Commas in Types

- Symptom: `MOCK_METHOD` macro fails to compile when using return or argument types with commas (e.g., `std::pair`, `std::map`).
- Fix: Use type aliases or wrap the type in extra parentheses.

### Scenario: Mock Methods Not Called

- Check: Is the mock method virtual?
- Check: Is the mock method declared properly with `MOCK_METHOD` and `override` where necessary?

### Scenario: Mock Object Leaked

- Symptom: Heapcheck failure or leaked mock object detection.
- Fix: Ensure mock objects are deleted or use `Mock::AllowLeak(&mock)` if leak is intentional.

---

## 6. Useful References

- [gMock Cookbook - Detailed usage and best practices](https://google.github.io/googletest/gmock_cook_book.html)
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html)
- [Mocking Methods and Classes - API Reference](../api-reference/mocking-api/mock-methods)
- [Expectations and Actions - API Reference](../api-reference/mocking-api/expectations-actions)
- [Understanding ON_CALL vs EXPECT_CALL](https://google.github.io/googletest/gmock_cook_book.html#UseOnCall)

---

## 7. Summary of Common Do's and Don'ts

| Do                                        | Don't                                     |
|-------------------------------------------|------------------------------------------|
| Use `EXPECT_CALL` only to verify actual calls. | Clog tests with unnecessary EXPECT_CALLs for every method. |
| Use matchers to specify arguments flexibly when possible. | Over-specify argument matchers unnecessarily. |
| Use `NiceMock` to silence warnings on uninteresting calls in noisy mocks. | Ignore warnings/expectation failures thinking they are optional. |
| Use `.RetiresOnSaturation()` for retrying calls when expectations repeat. | Assume expectations retire automatically on saturation. |
| Write focused tests verifying one behavior at a time. | Verify multiple unrelated assertions in one test case. |
| Ensure mock methods are declared `virtual` in base classes and use `MOCK_METHOD` correctly. | Attempt to mock non-virtual methods without proper workarounds. |

<Tip>
Always remember that mocks are for testing interactions, not just substituting implementations. Use them to specify contracts of behavior, not internal state.
</Tip>

---