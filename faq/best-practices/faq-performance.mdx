---
title: "Boosting Test Performance"
description: "Shares strategies for keeping test execution fast and maintainable, including parallel test execution, test filtering, optimizing setup/teardown, and minimizing test flakiness."
---

# Boosting Test Performance

Keeping your test execution fast and maintainable is critical to developer productivity and continuous integration efficiency. This page shares proven strategies to achieve optimal test performance in GoogleTest and GoogleMock, focusing on parallel execution, selective test running, efficient setup/teardown, and minimizing flakiness.

---

## 1. Parallel Test Execution

Modern CPUs have multiple cores that can be leveraged to speed up test runs. GoogleTest and GoogleMock provide built-in support for running tests in parallel, which significantly reduces total test execution time.

### How to Enable Parallel Tests

- Use the `--jobs=N` flag (commonly with `ctest` or build tools) to run tests with `N` parallel jobs.
- Split your test binaries so tests can run independently in parallel.
- Use the `--gtest_shuffle` flag to randomize test order, minimizing hidden dependencies between tests that can cause serial bottlenecks.

### Best Practices

- Design tests to be fully isolated with no shared mutable state to avoid race conditions.
- Avoid heavy global setup that runs on every test if possible; instead, prefer test-scoped setup.
- Run tests in multiple test binaries rather than one monolithic binary.

### Example

```sh
ctest --parallel 8   # Runs tests using 8 parallel threads.
./my_test --gtest_shuffle   # Runs tests in a random order to detect order dependencies.
```

---

## 2. Test Filtering

Often you don’t want to run all tests every time, especially during development when focusing on specific test cases.

### Filtering by Name

GoogleTest supports filtering tests by name:

```sh
./my_test --gtest_filter=FooTest.*    # Runs all tests in FooTest suite
./my_test --gtest_filter=FooTest.Bar  # Runs only FooTest.Bar test
```

### Running Subsets

- Use wildcards to run multiple matching tests.
- Negative filters can exclude tests:

```sh
./my_test --gtest_filter=-SlowTest.*  # Excludes SlowTest suite
```

### Benefits

- Saves time by running only relevant tests
- Helps isolate failures quicker
- Enables iterative development without full-test overhead

---

## 3. Optimizing Setup and Teardown

Expensive setup or teardown in your tests can severely degrade test performance.

### Tips

- Use test fixtures properly: avoid unnecessary repeated initialization.
- Break large setups into smaller reusable components.
- Use `SetUpTestSuite()`/`TearDownTestSuite()` for global setup/teardown to run once per suite instead of per test.

### Practical Example

```cpp
class FooTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Runs once before all tests in FooTest
    ConnectToDatabase();
  }
  static void TearDownTestSuite() {
    // Runs once after all tests in FooTest
    DisconnectFromDatabase();
  }

  void SetUp() override {
    // Runs before each test
    ResetData();
  }
};
```

This pattern avoids reconnecting to the database on every single test
while still maintaining isolation.

---

## 4. Minimizing Test Flakiness

Flaky tests (intermittent failures) slow development and reduce trust. Minimizing flakiness improves perceived and actual test performance.

### Causes and Solutions

| Cause                          | Solution                                      |
|-------------------------------|-----------------------------------------------|
| Shared mutable state           | Isolate test data, avoid static/global vars   |
| Order dependencies             | Use `--gtest_shuffle` & fix ordering issues   |
| Timing issues (e.g. async code)| Use synchronization primitives or mocks       |
| External dependencies          | Mock or stub external resources (network/db) |

### Practical Tips

- Use GoogleMock to isolate dependencies and simulate edge cases reliably.
- Avoid sleeping/waiting for arbitrary durations.
- Use `InSequence` or sequences to enforce call ordering where necessary.

---

## 5. Leveraging GoogleMock for Performance

GoogleMock’s features can help make tests faster by mocking away expensive dependencies and providing precise control over mock behavior.

### Use `NiceMock` to suppress warnings on uninteresting calls

While NaggyMock (default) warns on unexpected calls, switching to `NiceMock<T>` reduces noisy warnings and speeds debugging.

### Efficient Expectation Definition

- Define expectations with precise matchers to avoid excess matcher overhead.
- Use `.RetiresOnSaturation()` on expectations that become irrelevant after usage to reduce matcher checks.

### Default Actions with `ON_CALL`

- Use `ON_CALL` to set default method behaviors, preventing unnecessary failures or verbose error reports.

### Example

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> mock;
ON_CALL(mock, ExpensiveMethod()).WillByDefault(Return(DefaultValue));
EXPECT_CALL(mock, ExpensiveMethod(SpecificArg)).Times(1).WillOnce(Return(SpecificResult));
```

This setup reduces overhead for calls that are not under test.

---

## 6. Summary and Best Practices

- **Parallelize tests** by splitting binaries and running jobs concurrently.
- **Filter tests** to run only relevant ones during development.
- **Optimize setup and teardown** with proper use of fixtures and suite-level initialization.
- **Mock slow or flaky dependencies** to speed up and stabilize tests.
- **Reduce expectation stickiness** with `.RetiresOnSaturation()` and sequences to clear completed expectations.
- **Use verbose flags intelligently** (`--gmock_verbose=warning` or `error`) to balance output noise and debugging.

<Tip>
Remember, the fastest test suite is one that reliably tells you the truth without unnecessary overhead or noise. Use mocks to isolate your tests and focus on verifying logic rather than setting up environment.
</Tip>

---

## 7. Troubleshooting

### Common Issues

- **Tests run serially despite parallel flags**: Check tests aren’t sharing global mutable state; verify test binary splitting.
- **Tests flaky when run in parallel**: Ensure thread safety and avoid static data.
- **Unnecessary warnings on uninteresting calls**: Use `NiceMock` to suppress or add catch-all `EXPECT_CALL(...).Times(AnyNumber())`.
- **Expensive setup slowing tests**: Move initialization to `SetUpTestSuite()`.

### Debugging Tips

- Run with `--gmock_verbose=info` to trace mock call matching and help identify unexpected calls.
- Use `--gtest_shuffle` to detect test order dependencies.
- Verify your mocks are correctly configured to avoid silent fallback to default behavior.

---

## 8. Further Learning & References

For deeper understanding and advanced techniques, see:

- [Performance Best Practices Guide](/guides/advanced-usage-and-integration/performance-best-practices)
- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html)
- [Mocking Basics](../getting-started/configuration-and-first-use/using-googlemock-basics)
- [Managing Mock Expectations](../api-reference/mocking-api/expectations-actions)
- [GoogleTest Parallel Testing](../concepts/integration-and-scalability/integration-patterns)

---

## 9. Related Documentation

- [Writing and Running Your First Test](/guides/getting-started/your-first-test)
- [Controlling Mock Behavior](/api-reference/mocking-api/mock-behavior-control)
- [Test Runner API Reference](/api-reference/core-api/test-runner)

---

For the overall system architecture and how mocking fits in, see [System Architecture (with Diagram)](/overview/features-architecture/architecture-diagram).

---

*This documentation is part of the GoogleTest and GoogleMock documentation suite, helping you build efficient and reliable C++ tests.*
