---
title: "How do I diagnose test flakiness and debugging issues?"
description: "Guidance for troubleshooting non-deterministic test failures, using mock diagnostics, assertion messages, test shuffling, and recommended practices for creating stable, reliable tests."
---

# How do I diagnose test flakiness and debugging issues?

Understanding and resolving flaky tests and debugging issues are essential to maintaining stable and reliable test suites when using GoogleTest and GoogleMock. This document provides practical guidance on identifying causes of non-deterministic failures, diagnosing intermittent issues, and tips for writing tests that are robust and easier to debug.

---

## 1. Understanding Test Flakiness

### What is Test Flakiness?

Test flakiness refers to tests that sometimes pass and sometimes fail without any changes to the code under test. These non-deterministic failures hinder continuous integration and reduce confidence in test results.

### Common Causes of Flaky Tests

- **Race Conditions and Timing Issues:** When tests or code under test involve concurrency, insufficient synchronization can cause intermittent failures.
- **Order Dependencies:** Tests depending on state left behind by other tests or running in a specific order.
- **Resource Contention:** Tests sharing external resources like files, network ports, databases.
- **Uninitialized or Shared State:** Globals or static states affecting test outcomes unpredictably.
- **Use of Randomness:** Tests depending on random data without proper control.
- **External Dependencies:** Relying on network, timing-based external systems, or system clocks.

### Why Does Flakiness Matter?

Flaky tests waste developer time retesting and investigating false failures, delay releases, and reduce trust in automated testing systems.

---

## 2. Diagnosing and Debugging Flaky Tests

To effectively address flaky tests, follow this investigative approach:

### Step 1: Identify Patterns in Failures

- Run the test repeatedly and observe failure frequency.
- Note any differences in environment (OS, compiler, hardware).
- Check if failures correlate with test order or parallel execution.

### Step 2: Isolate the Test

- Run the test individually with `--gtest_filter` to eliminate interference.
- Disable sharding or parallel test execution to see if timing affects it.

### Step 3: Examine Failure Output

- Review GoogleTest failure messages and stack traces.
- Use `--gmock_verbose=info` to increase mock call and expectation debug output.
- Look for warnings about uninteresting calls or unexpected calls from mocks.

### Step 4: Use Debugging Techniques

- Insert logging or breakpoints at critical points in the test and code.
- Employ tools like thread sanitizers, race detectors, and memory checkers.

### Step 5: Analyze Mock Expectations

- Verify that mock expectations (`EXPECT_CALL`) are set correctly and that no unexpected calls occur.
- Consider using `NiceMock` to suppress noisy warnings if unrelated to the failure.
- In complex call sequences, use `InSequence` or `After` clauses to enforce ordering and help locate mismatches.

### Step 6: Check for Non-Deterministic Data

- Ensure inputs, mock return values, and shared state are deterministic.
- Avoid relying on random number generators or current time unless properly mocked or controlled.

---

## 3. Techniques to Minimize Flakiness

Stable and deterministic tests not only improve reliability but also accelerate development. Employ the following practices:

### Use Mocking and Fakes Appropriately

- Use mocks to isolate tests from external dependencies.
- Delegate to fakes or actual implementations only when necessary and safe.

### Control Test Order and State

- Do not rely on test execution order or shared mutable state.
- Use test fixtures (`TEST_F`) to set up consistent states.
- Reset or isolate global/static state where applicable.

### Avoid Shared External Resources

- Use unique test-specific files, ports, or database schemas.
- Clean up resources in `TearDown` methods.

### Use Shuffling with Care

- GoogleTest supports test shuffling (`--gtest_shuffle`), which helps expose order-dependent issues.
- Investigate and fix any tests that fail intermittently during shuffled executions.

### Manage Time-Related Logic

- Mock time-dependent components if possible to prevent timing-related failures.

---

## 4. Leveraging GoogleTest and GoogleMock Features for Debugging

### Enabling Verbose Output

Use the `--gmock_verbose=info` flag to see detailed tracing of mock expectations and invocations:

```bash
./your_test_binary --gmock_verbose=info
```

This helps understand mock call matching and unmatched calls.

### Using Sequences

Use the `InSequence` object or the `.InSequence()` clause in expectations to assert call order, making it easier to detect unexpected call sequences:

```cpp
using ::testing::InSequence;
{
  InSequence s;
  EXPECT_CALL(mock, Foo()).Times(1);
  EXPECT_CALL(mock, Bar()).Times(1);
}
```

### Applying `.RetiresOnSaturation()`

When using multiple consecutive expectations on the same method, adding `.RetiresOnSaturation()` helps prevent sticky expectations that cause confusion during debugging:

```cpp
EXPECT_CALL(mock, GetValue())
    .WillOnce(Return(1))
    .RetiresOnSaturation();
EXPECT_CALL(mock, GetValue())
    .WillOnce(Return(2))
    .RetiresOnSaturation();
```

### Using `ON_CALL` Versus `EXPECT_CALL`

- Use `ON_CALL` to set default mock behavior without enforcing expectations.
- Use `EXPECT_CALL` when you need to verify that a call happens.

Avoid overusing `EXPECT_CALL` to keep tests less brittle.

### Verifying and Clearing Expectations Early

When dynamically managing mocks, you may want to explicitly verify expectations before the mock's destruction:

```cpp
using ::testing::Mock;
Mock::VerifyAndClearExpectations(&mock_obj);
```

### Capturing Arguments for Detailed Inspection

Use actions like `SaveArg` to capture method arguments for detailed assertions or debug output.

### Using Death Tests for Crash Debugging

Leverage GoogleTest's death tests to verify code paths that terminate with errors, catching failure conditions deterministically.

---

## 5. Best Practices for Writing Stable, Debuggable Tests

- Write tests that focus on a single behavior or property.
- Use descriptive test and expectation names.
- Avoid excessive detail in mock expectations; only verify what matters.
- Use parameterized tests to cover variations systematically.
- Keep tests isolated from each other and from environment state.
- Run your tests with flags such as `--gtest_shuffle` and `--gmock_verbose=info` during development to catch flakiness early.
- Regularly review and refactor tests and mocks to reduce brittleness.

---

## 6. Troubleshooting Common Flakiness Scenarios

### Problem: Test fails intermittently only under shuffling

**Cause:** Hidden dependencies on test execution order or unreset state.

**Solution:** Use isolation, reset shared state, and enforce explicit ordering requirements with sequences or dependencies.

### Problem: Unexpected mock function call warnings or failures

**Cause:** Missing or incorrect `EXPECT_CALL` or `ON_CALL` settings.

**Solution:** Review mock expectations, add catch-alls with `.Times(AnyNumber())` or use `NiceMock` to suppress uninteresting warnings if appropriate.

### Problem: Tests fail due to resource conflicts

**Cause:** Shared temporary files, ports, or persistent databases.

**Solution:** Use unique identifiers per test, clean up in tear-down, or mock out external resources.

### Problem: Test outcomes depend on timing or threading

**Cause:** Race conditions or timing in asynchronous code.

**Solution:** Use synchronization primitives, run tests single-threaded, or mock time-dependent behaviors.

### Problem: Consistent failure but misleading error messages

**Cause:** Deep mock call order or argument mismatches.

**Solution:** Increase verbosity, add intermediate expectations, use `InSequence` and break down expectations.

---

## 7. Additional Tools and Resources

- **GoogleTest Flags:** Use `--gtest_repeat=N` to repeat flaky tests many times.
- **GoogleMock Verbosity:** Use `--gmock_verbose=info` to trace mock calls.
- **Thread Sanitizers (TSAN):** Detect race conditions.
- **Address Sanitizers (ASAN):** Detect memory errors.
- **Valgrind:** Dynamic analysis for memory issues.

---

## Related Documentation

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) for basics on writing tests.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for advanced mock usage.
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) for assertion matching.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) for mock behaviors and expectations.
- [Assertions Reference](https://google.github.io/googletest/reference/assertions.html) for detailed assertions.
- [Best Practices: Effective Use of Matchers](https://google.github.io/googletest/guides/best-practices-patterns/effective-use-of-matchers.html) for writing clean tests.

---

<Tip>
Aim to design tests with determinism in mind from the start, using mocking and fixture isolation. When flakes appear, rely on systematic diagnosis to identify hidden dependencies or race conditions.
</Tip>

<Warning>
Avoid suppressing failure messages blindly. Fix the root causes of flaky tests rather than masking symptoms.
</Warning>