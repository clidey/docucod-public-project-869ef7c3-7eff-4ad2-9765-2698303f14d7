---
title: "Test Performance & Optimization Tips"
description: "Provides guidance on improving test execution speed and resource usage, addressing slow tests, parallel test execution, and best practices for efficient unit testing with GoogleTest and GoogleMock."
---

# Test Performance & Optimization Tips

Improve your test execution speed and resource usage with practical guidance for writing efficient unit tests using GoogleTest and GoogleMock. This page addresses common challenges such as slow-running tests, harnessing parallel test execution, and fostering best practices that maintain test reliability while optimizing performance.

---

## 1. Understanding Test Performance

Unit tests are the backbone of a reliable codebase. However, slow or resource-heavy tests can hinder rapid development cycles. This page empowers you to:

- Recognize factors that affect test speed
- Apply strategies to reduce test execution time
- Leverage GoogleTest features to run tests efficiently
- Understand GoogleMock's behavior impact on performance

### Why Test Performance Matters

Fast, efficient tests enable continuous integration, safer refactoring, and accelerated delivery. Slow tests obscure feedback, reduce developer productivity, and may increase resource costs.

---

## 2. Identifying and Addressing Slow Tests

Slow tests often emerge from external dependencies, heavyweight test setups, or excessive computation within tests.

### Common Causes

- Tests involving file I/O, databases, or network access
- Heavy initialization in test fixtures
- Large numbers of tests run serially without filtering or parallelization
- Overuse of GoogleMock expectations causing overhead

### Best Practices to Speed Up Slow Tests

- **Mock external systems:** Use GoogleMock to replace slow dependencies with lightweight mocks
- **Minimize expensive setup/teardown:** Use `SetUpTestSuite` and `TearDownTestSuite` judiciously for costly initialization
- **Reduce test scope:** Write focused tests rather than monolithic ones
- **Use default and stub behaviors:** Prefer `ON_CALL` for default behaviors instead of excessive `EXPECT_CALL`s to reduce overhead

---

## 3. Harnessing Parallel Test Execution

GoogleTest supports running tests in parallel to utilize multiple CPU cores effectively.

### Features & How to Use

- Use test filtering with the `--gtest_filter` flag to run specific subsets of tests concurrently
- Employ external test runners or build systems (like Bazel or CMake) that support parallelism
- Write independent tests without shared global state to enable safe concurrent execution

### Tips

- Design tests with no dependencies between them
- Avoid shared mutable state to prevent deadlocks or data races in parallel runs
- Use test fixtures effectively to isolate test data

---

## 4. Optimizing GoogleMock Usage for Speed

While GoogleMock is powerful for behavior verification, some usage patterns may impact performance.

### Recommendations

- Use `ON_CALL` to specify default mock action behavior instead of many `EXPECT_CALL`s unless call verification is necessary
- Avoid overly strict or excessive expectations that require complex matching for every mock call
- Choose appropriate strictness levels:
  - `NiceMock` suppresses warnings on uninteresting calls and may reduce noise
  - `StrictMock` enforces strict checking but might increase overhead

### Managing Mock Object Lifetimes

- Use `Mock::AllowLeak()` if intentionally leaking mock objects to reduce destruction overhead, but do so carefully
- Use `VerifyAndClearExpectations()` to ensure mocks verify calls early and to reset expectations if needed

---

## 5. Filtering and Selective Execution for Faster Feedback

Applying test filters combines well with parallel execution to run only relevant tests quickly.

### Using `--gtest_filter`

- Run targeted tests based on test suite and test name wildcard patterns
- Combine with repeated invocations and selective filtering for rapid iteration

Example:

```plaintext
--gtest_filter=MySuite.MyTest*
```

### Combining Filters with Parallelism

Split your test suites and instances across parallel shards or agents via your CI system

---

## 6. Best Practices for Efficient Unit Testing

Efficient unit tests are maintainable, fast, and reliable.

### Guidelines

- Isolate tests: test one thing at a time for minimal setup and clear failure points
- Avoid unnecessary global state: use local mocks with scoped lifetimes
- Prefer lighter mock behavior specifications: use `ON_CALL` defaults
- Avoid heavy data setup in each test; use fixtures wisely
- Use `RetiresOnSaturation()` on expectations to make them retire once fully satisfied, avoiding unexpected invocations

---

## 7. Troubleshooting Performance Issues

If you encounter slow test runs or flaky test behavior:

<Accordion title="Diagnosing Slow Mocks and Tests">
- Run with `--gmock_verbose=info` to trace mock calls and see overhead.
- Check for excessive `EXPECT_CALL`s with complex matchers.
- Profile test execution time per test case.
- Review if unwanted test dependencies or shared states exist.
</Accordion>

<Accordion title="Remedies for Slow Tests">
- Refactor tests to use default behavior via `ON_CALL` for non-critical mock methods.
- Use sequences or partial ordering if strict call order is required but keep it minimal.
- Break large tests into smaller focused tests.
</Accordion>

---

## 8. Additional Resources

- [GoogleTest Primer](https://github.com/google/googletest/blob/main/docs/primer.md) — foundational concepts
- [Organizing and Running Tests guide](/guides/core-workflows/organizing-and-running-tests) — best practices on test organization
- [Setting Up with CMake and Bazel](/guides/integration-best-practices/setting-up-with-cmake-and-bazel) — for build integration and parallel execution
- [Continuous Integration Workflows](/guides/integration-best-practices/continuous-integration-workflows) — for scalable test suite execution
- [Using Assertions Effectively](/guides/core-workflows/using-assertions-effectively) — writing better test validations
- [Mocking Reference](docs/reference/mocking.md) — deep dive into mocks and expectations
- [Legacy gMock FAQ](docs/gmock_faq.md) — common questions about mock usage


---

## 9. Summary

Focus on crafting fast and maintainable tests by minimizing setup overhead, leveraging default mock behaviors with `ON_CALL`, strategically applying expectations, and running tests in parallel with filtering. Follow best practices to avoid common pitfalls that slow down tests or cause flaky behavior.

<TestPerformanceOptimizationTips> enhances your ability to use GoogleTest and GoogleMock more efficiently, ensuring your testing pipeline scales with your project’s growth.

---

<Tip>
Consider running your test suite with `--gtest_filter` to isolate problem areas and combine this with parallel test runners for dramatic speed gains.
</Tip>

<Note>
Always prefer `ON_CALL` over `EXPECT_CALL` for default behaviors to reduce mock overhead and fragile tests.
</Note>

<Warning>
Beware of shared state in tests that can cause concurrency issues when running tests in parallel.
</Warning>