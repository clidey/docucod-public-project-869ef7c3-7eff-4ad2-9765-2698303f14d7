---
title: "How Do I Write and Use Mocks in C++?"
description: "Answers typical questions about defining mock classes, using mock methods, and leveraging features such as EXPECT_CALL and ON_CALL. Clarifies macro usage and shares best practices for clean mocking."
---

# How Do I Write and Use Mocks in C++?

This FAQ answers typical user questions about defining mock classes, using mock methods, setting expectations with `EXPECT_CALL`, and customizing default behaviors with `ON_CALL` in GoogleMock. It clarifies macro usage, covers common pitfalls, and shares best practices for creating clean, maintainable mocks.

---

## Frequently Asked Questions

### How do I define a mock class and its methods?

Define a mock class by inheriting from the interface (or base class) you want to mock. Use the `MOCK_METHOD` macro to declare each mocked method in the `public:` section of your mock class. The macro syntax is:

```cpp
MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));
```

- `ReturnType`: method's return type
- `MethodName`: name of the method
- `Args...`: a parenthesized list of argument types
- `Specs...`: qualifiers such as `const`, `override`, `noexcept`, `Calltype(...)`

**Important:**
- Always put mock methods in `public:` regardless of their access in the base class.
- Wrap types with commas in parentheses or use `using` aliases to prevent macro parsing errors.

Example:

```cpp
class MockFoo : public Foo {
 public:
  MOCK_METHOD(int, GetValue, (), (const, override));
  MOCK_METHOD(void, SetValue, (int value), (override));
};
```

### How do I mock overloaded methods?

Simply mock each overload separately, specifying the correct signature. If you do not mock all overloads, bring the unmocked overloads into scope with a `using` declaration to avoid compile warnings:

```cpp
class MockFoo : public Foo {
 public:
  using Foo::Add;  // Bring base class overloads into scope
  MOCK_METHOD(int, Add, (int x), (override));
  MOCK_METHOD(int, Add, (int times, int x), (override));
};
```

### Can I mock class templates?

Yes. Mock class templates just like normal classes. The `MOCK_METHOD` macros support templated classes normally.

Example:

```cpp
template <typename T>
class MockStack : public StackInterface<T> {
 public:
  MOCK_METHOD(int, Size, (), (const, override));
  MOCK_METHOD(void, Push, (const T& x), (override));
};
```

### Can I mock non-virtual methods?

Direct mocking of non-virtual methods is not supported in the usual way. Instead, use the high-performance dependency injection technique: create a mock class unrelated to the real class but defines methods of the same signature without `override`.

Pass the mock or real class as a template parameter to the code under test to choose between production and test implementation at compile time.

### How do I mock free functions or static methods?

You cannot directly mock free functions or static methods with GoogleMock. Common approaches:

- Wrap free functions in an interface (abstract class) and mock that interface.
- Use `std::function` and `MockFunction` to mock callbacks.

### What are `EXPECT_CALL` and `ON_CALL` and when should I use them?

- `EXPECT_CALL` sets an expectation that a mock method will be called with specified arguments, how many times, and optionally what it should do. The test will fail if the call doesn't happen as expected.

- `ON_CALL` defines the default behavior of a mock method when called but does *not* set any expectations that it must be called.

**Best practice:** Use `ON_CALL` to define the common default behavior, and use minimal `EXPECT_CALL` only when you want to verify a call.

### What’s the difference between uninteresting and unexpected calls?

- *Uninteresting calls:* Calls to mock methods without any `EXPECT_CALL` set. By default, they cause warnings but don't fail.
- *Unexpected calls:* Calls to a mock method with `EXPECT_CALL`s, but the arguments don't match any expectation. Always a test failure.

To suppress warnings about uninteresting calls, wrap your mock with `NiceMock<T>`; to make warnings errors, use `StrictMock<T>`.

### How can I control call order?

By default, expectations can match calls in any order. To enforce order:

- Use `::testing::InSequence` scope to specify strict call order on expectations.
- Use the `.After()` clause on `EXPECT_CALL` to specify dependencies between calls.
- Use the `.InSequence()` clause with sequences to define partial orders.

### How do I specify actions on mock methods?

Use `WillOnce()` and `WillRepeatedly()` clauses on `EXPECT_CALL` or `WillByDefault()` on `ON_CALL` to specify what happens when a mock method is called.

Examples:

- `Return(value)`: return a value
- `ReturnRef(variable)`: return a reference
- `Invoke(function)`: call a real function or lambda
- `DoAll(actions...)`: combine several actions

### How do I avoid compiler errors with complex types in `MOCK_METHOD`?

If return types or arguments contain commas (e.g., templates like `std::pair<bool,int>`), either:

- Wrap the type in parentheses:

  ```cpp
  MOCK_METHOD((std::pair<bool, int>), GetPair, ());
  ```

- Or define a type alias and use it:

  ```cpp
  using BoolIntPair = std::pair<bool, int>;
  MOCK_METHOD(BoolIntPair, GetPair, ());
  ```

### What are `NiceMock`, `NaggyMock`, and `StrictMock`?

- `NiceMock<T>`: suppresses warnings on uninteresting calls; ideal for most tests.
- `NaggyMock<T>`: default behavior; warns on uninteresting calls.
- `StrictMock<T>`: treats uninteresting calls as test failures.

Wrap your mock objects in these templates to control warning and failure behavior.

### How do I verify my mock expectations explicitly?

Mocks automatically verify expectations upon destruction. If your mock is owned by tested code and you want to verify earlier, use:

```cpp
::testing::Mock::VerifyAndClearExpectations(&mock_object);
```

### How do I handle legacy `MOCK_METHODn` macros?

They are deprecated but still supported. Prefer modern `MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...))` form.

### What are common pitfalls with mocks?

- Forgetting the destructor of base class is virtual results in undefined behavior.
- Over-specifying expectations causes brittle tests.
- Misordering calls or expectations causes unexpected failures.
- Not putting `MOCK_METHOD` declarations in `public:` section.

### How do I prevent warnings on uninteresting calls without making tests brittle?

- Use `NiceMock` instead of suppressing warnings with `EXPECT_CALL(...).Times(AnyNumber())`.
- Use `ON_CALL` for default actions without imposing expectations.

### Can I delegate mock behavior to a real or fake object?

Yes. You can write `ON_CALL(mock, Method).WillByDefault(...)` that calls the real or fake's implementation, combining verification with real logic.

Example:

```cpp
ON_CALL(*this, DoThis).WillByDefault(
    [this](int n) { return real_.DoThis(n); });
```

### How do I return move-only types from mocks?

Use lambdas or callables in `WillOnce()` or `WillRepeatedly()`:

```cpp
EXPECT_CALL(mock, MakeBuzz(_))
  .WillRepeatedly([](StringPiece s){ return std::make_unique<Buzz>(...); });
```

Avoid returning move-only types directly with `Return()` more than once.

---

## Common Issues & Troubleshooting Tips

- **Compilation errors with complex types:** Wrap return/argument types containing commas in parentheses or use type aliases.
- **Warnings on uninteresting calls:** Wrap mocks with `NiceMock` or explicitly allow calls with `EXPECT_CALL(...).Times(AnyNumber())`.
- **Test failures due to order:** Use `InSequence` or `After()` clauses to control call order.
- **Mock methods hidden due to overloading:** Use `using Base::Method;` to bring base overloads into scope.
- **Mocked methods not being called:** Ensure methods are virtual and mocked correctly.
- **Multiple expectations shadowing:** Remember expectations are matched in reverse order.
- **Unstable tests due to strict mocks:** Prefer `NiceMock` for most cases and reserve `StrictMock` for critical cases.

---

## Recommended Best Practices

- **Always define mock methods in `public:` sections.**
- **Add `override` and other qualifiers to `MOCK_METHOD` when overriding methods.**
- **Use `ON_CALL` for setting default behavior; `EXPECT_CALL` only when verifying calls.**
- **Wrap mocks in `NiceMock` to reduce unnecessary warnings.**
- **Avoid over-specifying argument matchers and call counts to keep tests maintainable.**
- **Use `RetiresOnSaturation()` and `InSequence` to handle multiple calls of the same method with ordered behaviors.**
- **For non-virtual or free functions, isolate in interfaces for mockability or use `MockFunction`.**
- **Use lambdas and `Invoke` to fine-tune mock behavior beyond simple returns.**

---

## Further Reading & Related Documentation

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — for detailed recipes and examples
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — comprehensive API details
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html) — beginner-friendly introduction
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) — quick reference
- [Nice, Naggy, and Strict Mocks](api-reference/mocking-framework/nice-strict-mocks.md) — for controlling mock verbosity and strictness
- [Mocking Best Practices](guides/mocking-techniques/best-practices-mocking.md) — tips to write clean mocks
- [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html) — answers to edge cases and legacy questions

---

**Tip:** Always verify your mocks by letting them be destroyed naturally or use `Mock::VerifyAndClearExpectations()`. Avoid setting expectations after exercising the mock.

---

This document helps you write mocks with confidence and optimize test robustness and clarity.