---
title: "Test Discovery & Assertion Usage"
description: "Explains how GoogleTest finds and executes tests, clarifies assertion behaviors, and addresses fundamental user questions about writing and executing robust unit tests."
---

# Test Discovery & Assertion Usage

This page explains how GoogleTest identifies and runs tests, clarifies how assertion macros behave, and addresses essential questions for writing and executing effective unit tests. This targeted overview helps users master the fundamentals of writing and running robust tests using GoogleTest.

---

## Table of Contents

- [How GoogleTest Discovers Tests](#how-googletest-discovers-tests)
- [Test Execution Flow](#test-execution-flow)
- [Understanding Assertions: EXPECT_ vs ASSERT_](#understanding-assertions-expect_-vs-assert_)
- [Explicit Success and Failure Assertions](#explicit-success-and-failure-assertions)
- [Common Questions About Assertion Behaviors](#common-questions-about-assertion-behaviors)
- [Troubleshooting Test Failures](#troubleshooting-test-failures)

---

## How GoogleTest Discovers Tests

GoogleTest automatically finds all test cases and test fixtures defined with its macros like `TEST` and `TEST_F`. During program initialization, each `TEST` registers itself in a global repository. When you run your test binary, GoogleTest scans this registry, filters tests based on command-line flags or environment variables (such as `--gtest_filter`), and prepares them for execution.

This automated discovery means you don’t need to manually list or invoke tests, enabling fast iteration and scalability in testing.

---

## Test Execution Flow

After discovery, tests run in sequence managed by the GoogleTest runner:

1. **Suite Setup**: Before running tests in a test suite, GoogleTest executes `SetUpTestSuite()` (optional user-defined method).
2. **Test Fixture Creation**: For each test in the suite, a fresh fixture object is instantiated and initialized.
3. **Test Setup**: If defined, the fixture’s `SetUp()` method runs.
4. **Test Body Execution**: The test function itself executes.
5. **Test Teardown**: The fixture’s `TearDown()` runs, cleaning up resources.
6. **Suite Teardown**: Once all tests in the suite have run, `TearDownTestSuite()` (if defined) is called.

Failures or skipped tests pause or influence these phases according to user flags; for example, `GTEST_SKIP()` can prematurely skip a test or a whole fixture.

---

## Understanding Assertions: EXPECT_ vs ASSERT_

Assertions are the backbone of verifying correctness in tests. GoogleTest provides two main forms:

- **`EXPECT_*` macros:** Generate *nonfatal* failures that log an error but allow the current test function to continue executing.
- **`ASSERT_*` macros:** Generate *fatal* failures that immediately abort the current function.

### What does this mean for you?

- Use `EXPECT_*` when it’s safe for the test to continue despite a failure (e.g., checking multiple properties in the same test).
- Use `ASSERT_*` when continuing the test doesn't make sense or might cause invalid memory accesses.

### Practical example:

```cpp
TEST(MyTest, Example) {
  EXPECT_EQ(CalculateX(), 10);   // Logs failure but continues
  ASSERT_TRUE(IsValid());       // Aborts test body if false
  // Code here won't run if ASSERT_TRUE fails above
}
```

### Important rules:

- Fatal assertions (`ASSERT_*`) can only appear in `void` functions.
- Non-void functions must only use non-fatal assertions (`EXPECT_*`), or handle failures in other ways.

---

## Explicit Success and Failure Assertions

GoogleTest offers three special assertions to explicitly mark success or failures under certain conditions:

- **`SUCCEED()`**
  - Marks a success point explicitly in the code.
  - Does not guarantee overall test success by itself.

- **`FAIL()`**
  - Generates a *fatal* failure that immediately aborts the current function.
  - Can only be used in `void` functions.

- **`ADD_FAILURE()`**
  - Generates a nonfatal failure; test continues afterward.
  - Useful for reporting error conditions detected dynamically during complex logic.

### Example usage of `FAIL()`:

```cpp
switch(value) {
  case 1:
    // some checks
    break;
  default:
    FAIL() << "Reached unexpected case value: " << value;
}
```

### When to use these:

- Use `SUCCEED()` sparingly for documentation or indicating explicit success paths.
- Use `FAIL()` to catch unreachable code or invalid runtime states.
- Use `ADD_FAILURE()` when you want to flag a failure but still want to continue running assertions.

---

## Common Questions About Assertion Behaviors

### Can I stream custom failure messages?

Yes, all assertions support streaming additional messages to clarify failures:

```cpp
EXPECT_TRUE(is_valid) << "Input value: " << input_value << " is invalid";
```

This makes your test outputs more meaningful and easier to debug.

### What happens if an `ASSERT_*` inside a helper function fails?

`ASSERT_*` aborts only the current function, not the entire test. If the helper is a subroutine, execution returns to the caller, which will continue running unless you check for failures explicitly. Use `ASSERT_NO_FATAL_FAILURE()` or check `HasFatalFailure()` to manage this.

### Can I use `ASSERT_*` in constructors or destructors?

No. Constructors and destructors are not `void` functions and assertions generating fatal failures require `void` return type. Use `SetUp()` or `TearDown()` methods instead.

### What if I need to verify complex predicates?

Use predicate assertions like `EXPECT_PRED*()` or `EXPECT_PRED_FORMAT*()`. These provide detailed failure messages and support unary or multi-argument predicate functions returning `bool` or `AssertionResult`.

### How are exceptions handled?

GoogleTest provides assertions to verify that code throws or does not throw exceptions, like `EXPECT_THROW()`, `EXPECT_ANY_THROW()`, and `EXPECT_NO_THROW()`. Exception assertions require exceptions to be enabled in your compiler.

---

## Troubleshooting Test Failures

When tests fail due to assertions, diagnostic messages provide detailed information:

- The **value of expressions** involved
- The **expected condition**
- Additional **failure messages** streamed by the user

GoogleTest also prints stack traces where applicable to pinpoint failure origins.

### Tips to improve failure diagnostics:
- Add custom messages to assertions to clarify intent.
- Use `SCOPED_TRACE()` to attach context when calling subroutines with assertions.
- Use predicate assertions for complex conditions to get expressive failure details.
- Review XML or JSON reports (`--gtest_output=xml:path` or `json:path`) for automated analysis.

### Common pitfalls:
- Using `ASSERT_*` in non-void functions, causing confusing compiler errors.
- Assuming `ASSERT_*` aborts the entire test rather than the current function.
- Comparing C strings with equality operators (`==`). Use string-specific assertions like `EXPECT_STREQ()`.
- Ignoring floating-point precision issues; prefer `EXPECT_FLOAT_EQ()` or `EXPECT_NEAR()` instead of `EXPECT_EQ()`.

---

## Related Documentation

- [Assertions Reference](reference/assertions.md) — Detailed list and behavior of all assertion macros.
- [Advanced GoogleTest Topics](docs/advanced.md) — In-depth usage scenarios including predicate assertions and death tests.
- [Matchers Reference](reference/matchers.md) — Use matchers for expressive value verification.
- [gMock Cookbook](docs/gmock_cook_book.md) — How to use GoogleMock alongside assertions for advanced tests.
- [Test Lifecycle and Discovery](concepts/core-architecture/test-lifecycle-and-discovery.md) — Explains the full test execution lifecycle.

---

## Summary

Mastering test discovery and assertion usage is critical for writing effective unit tests with GoogleTest. Understanding how tests are found and run, and choosing the right assertion macros ensures precise, maintainable, and reliable tests. Use explicit success/failure macros thoughtfully, add custom failure messages for clarity, and leverage predicate and exception assertions for comprehensive coverage.

---