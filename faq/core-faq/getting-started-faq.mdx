---
title: "Getting Started Questions"
description: "Clear and concise answers to fundamental questions about installing, configuring, and initiating GoogleTest and GoogleMock in a project. Targets users new to the framework or transitioning from other test systems."
---

# Getting Started Questions

This FAQ provides clear, concise answers to some of the most common beginner questions that arise when installing, configuring, and starting to use GoogleTest and GoogleMock in your C++ projects. It targets developers new to the framework as well as those transitioning from other test systems, helping you avoid common pitfalls and streamline your onboarding.

---

## Why should test suite names and test names not contain underscores (`_`)?

GoogleTest reserves underscores (`_`) for special purposes, such as the `DISABLED_` prefix to skip tests temporarily. Additionally, certain underscore patterns conflict with C++ rules that reserve identifiers starting with underscore followed by uppercase letters or containing double underscores (`__`) for the compiler and standard library, making such names invalid or prone to future breakage.

For example, `TEST(Time_Flies, Like_An_Arrow)` will cause ambiguous generated class names due to extra underscores, risking compilation or runtime errors.

**Best Practice:** Avoid using underscores in test suite names and test names altogether. Use camel case or Pascal case instead.

Reference: [docs/faq.md#Why should test suite names and test names not contain underscore?](faq.md)

---

## Why does GoogleTest support `EXPECT_EQ(NULL, ptr)` but not `EXPECT_NE(NULL, ptr)`?

GoogleTest supports `EXPECT_EQ(NULL, ptr)` to compare pointers against `NULL` because it enables better error messages in common cases. However, supporting `EXPECT_NE(NULL, ptr)` requires extra template metaprogramming for symmetrical handling, which was deemed unnecessary by the developers since `EXPECT_TRUE(ptr != nullptr)` is clearer and effective.

GoogleTest encourages using `nullptr` instead of `NULL` for pointer comparisons as `nullptr` avoids type ambiguity and is the preferred modern syntax.

---

## Should I use typed tests or value-parameterized tests to check different implementations of an interface?

Both typed tests and value-parameterized tests can verify multiple implementations:

- **Typed Tests** are preferable when your different implementations can be constructed uniformly by type. They provide type-specific output on failures.
- **Value-Parameterized Tests** are useful when different implementations require different ways of instantiation or setup, using parameters instead.

Try both and pick the approach that fits your code structure and test readability best.

Reference: [docs/faq.md#I need to test that different implementations of an interface satisfy some common requirements](faq.md)

---

## My death test modifies some state, but changes are lost after test finishes. Why?

Death tests run their test statement inside a separate child process to prevent crashing the main test runner. As a result, any in-memory state modified by the death test is local to that child process and does not propagate back to the parent. Think of running the death test as a parallel universe.

If you rely on side effects or state changes from death tests, you need to restructure your test logic accordingly.

Reference: [docs/faq.md#My death test modifies some state, but the change seems lost after the death test finishes](faq.md)

---

## What does the compiler error "void value not ignored as it ought to be" mean?

This error typically occurs if you use a fatal assertion macro `ASSERT_*()` inside a C++ function that does not return `void`. Because GoogleTest disables exceptions, `ASSERT_*()` can only be used in functions with `void` return type to facilitate flow control by immediate return on failure.

**Solution:** Use `EXPECT_*()` assertions for functions returning values, or refactor your function to return `void` if possible.

Reference: [docs/faq.md#My compiler complains "void value not ignored as it ought to be."](faq.md)

---

## Can I derive a test fixture from another? How?

Yes. GoogleTest allows test fixtures to be derived, enabling sharing of common setup and teardown logic across multiple suites.

Example pattern:

```cpp
class BaseTest : public ::testing::Test {
 protected:
  void CommonSetup();
};

class DerivedTest : public BaseTest {
 protected:
  void SetUp() override {
    BaseTest::SetUp();  // call base SetUp if overridden
    ... additional setup ...
  }
  void TearDown() override {
    ... cleanup ...
    BaseTest::TearDown();
  }
};

TEST_F(DerivedTest, Example) {
  ... test code ...
}
```

Only one test suite per fixture is allowed. Derived fixtures each have separate test suites.

Reference: [docs/faq.md#Can I derive a test fixture from another?](faq.md)

---

## What if `TEST_F(FooTest, Bar)` gives a compiler error about no matching constructor?

GoogleTest requires the test fixture to have a default constructor so it can instantiate test objects. If you declare any non-default constructors or have `const` members without initializer, you must explicitly provide a default constructor.

To fix:

```cpp
class FooTest : public testing::Test {
 public:
  FooTest() = default;  // Add explicit default constructor
  FooTest(int x);      // Your non-default constructor
  ...
};
```

---

## How do I temporarily disable or enable tests?

Add the prefix `DISABLED_` to a test suite or test name to exclude it from test runs without removing the code. For example:

```cpp
TEST(FooTest, DISABLED_BrokenTest) { ... }
```

To enable running disabled tests, use the command line flag `--gtest_also_run_disabled_tests` or set the `GTEST_ALSO_RUN_DISABLED_TESTS` environment variable.

---

## How to avoid GoogleTest output being buried under noisy LOG messages?

GoogleTest prints test output to `stdout`. Typical logging frameworks output to `stderr`. Redirect `stdout` separately from `stderr` to isolate GoogleTest test results.

Example:

```bash
./your_test > gtest_output.txt
```

This separation makes reading test results easier.

---

## Why prefer test fixtures over global variables?

- Fixtures provide fresh instances for each test to avoid side effects contaminating other tests.
- They help organize related setup/teardown code.
- Avoid polluting global namespace.
- Enable reuse via inheritance.

Global variables can cause difficult-to-debug shared state issues, reducing test reliability.

Reference: [docs/faq.md#Why should I prefer test fixtures over global variables?](faq.md)

---

## How to obtain the current test's name during test execution?

Use the GoogleTest reflection API:

```cpp
const testing::TestInfo* test_info = testing::UnitTest::GetInstance()->current_test_info();
if (test_info) {
  std::string suite = test_info->test_suite_name();
  std::string test = test_info->name();
  // Use suite and test names
}
```

This is useful for dynamic test configuration, logging, or managing test data.

Reference: [docs/reference/testing.md#Getting the Current Test's Name](reference/testing.md#Getting-the-Current-Test-s-Name)

---

## How to register tests programmatically?

GoogleTest offers `testing::RegisterTest()` to register tests dynamically at runtime when macro-based static registration is not sufficient.

Example:

```cpp
class MyFixture : public testing::Test {
  // ...
};

class MyTest : public MyFixture {
 public:
  explicit MyTest(int data) : data_(data) {}
  void TestBody() override { ... }
 private:
  int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
  for (int v : values) {
    testing::RegisterTest(
        "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr,
        std::to_string(v).c_str(), __FILE__, __LINE__,
        [=]() -> MyFixture* { return new MyTest(v); });
  }
}
```

Call `RegisterMyTests` before `RUN_ALL_TESTS()` to dynamically create parameterized tests.

Reference: [docs/advanced.md#registering-tests-programmatically](advanced.md#registering-tests-programmatically)

---

For more detailed answers, advanced topics, and usage examples, explore the following sections:

- [GoogleTest Primer](primer.md)
- [Advanced GoogleTest Topics](advanced.md)
- [Testing Reference](reference/testing.md)
- [FAQ](faq.md)

---

If you encounter issues during setup or test writing, consult the Troubleshooting section in the Getting Started guides, and consider reaching out on community forums for additional help.

---

This FAQ focuses on questions directly related to initial usage and test writing with GoogleTest and GoogleMock. For coverage of mocking, assertion details, and integration, please refer to the dedicated guide sections.