---
title: "Performance Tips & Best Practices"
description: "Practical answers to questions on optimizing test execution speed, minimizing build times, and strategies for organizing large test suites. Covers recommended practices for parallelization, resource management, and debugging slow-running tests."
---

# Performance Tips & Best Practices

Optimizing your test execution with GoogleTest is vital for maintaining a productive development workflow, especially as your codebase and test suites grow. This guide provides practical advice on speeding up test runs, minimizing build times, and organizing your tests effectively for scalability and maintainability.

---

## 1. Speeding Up Test Execution

### 1.1 Run Tests in Parallel

Running tests in parallel can drastically decrease overall execution time. Consider the following best practices:

- **Use GoogleTest Parallel Execution Features:** Utilize test runners or build tools that support parallel test execution, such as `gtest-parallel` or native Bazel/CMake test parallelism.
- **Isolate Tests:** Write tests that are independent and free from shared global state to prevent race conditions and flaky tests during parallel execution.
- **Limit Parallelism by Resources:** Adjust the number of parallel jobs based on your CPU cores, memory, and I/O capabilities to avoid oversubscription.

### 1.2 Filter and Focus Tests

Avoid running the entire suite every time during development:

- Use command-line flags like `--gtest_filter` to run specific tests or test suites.
- Mark long-running tests as disabled (`DISABLED_` prefix) and run them selectively.
- Combine filters using wildcards to target only relevant tests quickly.

### 1.3 Reduce Test Runtime

- Use mocks and fakes to substitute heavyweight dependencies (databases, network, filesystems) with light-weight stand-ins.
- Limit test scope to the minimal necessary verification.
- Use GoogleMock's ON_CALL to set default behavior to avoid verbose expectations unless needed.

### 1.4 Cache Expensive Setup

- Use test fixtures wisely to share expensive object creation across multiple tests.
- Consider global environment setup for truly global expensive resources.

---

## 2. Minimizing Build Times

### 2.1 Reduce Mock Compilation Overhead

- Move mock class constructor and destructor definitions out of header files to `.cc` files, reducing redundant instantiation across translation units.
- Avoid mocking large numbers of methods unnecessarily; mock only those relevant to your tests.
- Use type aliases or wrap complex template arguments in parentheses in `MOCK_METHOD` to ease compiler parsing and speed up compilation.

### 2.2 Modularize Test Code

- Break large test files into smaller, focused files.
- Share common code via libraries instead of header inclusions.

### 2.3 Use Precompiled Headers

- Include GoogleTest and GoogleMock headers in your precompiled header to save repeated parsing.

---

## 3. Organizing Large Test Suites

### 3.1 Group Tests Logically

- Organize tests into suites and files that reflect the structure of your code.
- Use typed or parameterized tests to reduce duplication when testing similar behavior across types or inputs.

### 3.2 Use Sequences and Partial Orders

- For tests that verify call ordering, use GoogleMock’s `InSequence` and `.After()` clauses appropriately.
- Avoid brittle tests by using partial ordering (multiple sequences) rather than strict full ordering when multiple calls can occur in flexible orders.

### 3.3 Use Nice and Strict Mocks Judiciously

- Use `NiceMock` for mocks where you want to suppress warnings about uninteresting calls.
- Use `StrictMock` only when you want to enforce exact call expectations. Excessive use can make your tests brittle and slow.

### 3.4 Manage Expectations Carefully

- Define expectations upfront, not interleaved with code under test, to allow GoogleMock to verify calls efficiently.
- Use `.RetiresOnSaturation()` for expectations that should expire as they saturate, preventing unnecessary checks afterwards.

---

## 4. Debugging and Diagnosing Performance Bottlenecks

- Run tests with `--gtest_verbose=info` or `--gmock_verbose=info` to get detailed call tracing.
- Profile test runs with system tools to find CPU or I/O bottlenecks.
- Break down slow tests by disabling or filtering smaller subsets.
- Check for shared resources or locks that might be causing contention when running tests in parallel.

---

## 5. Practical Tips and Best Practices

- **Avoid Excessive Use of EXPECT_CALL:** Use `ON_CALL` for default behaviors to keep tests maintainable and fast.
- **Use Parameterized Tests for Similar Behavior:** Reduces duplication and speeds test maintenance.
- **Reuse Common Setup in Fixtures:** Shared setup reduces redundant work.
- **Use `Mock::VerifyAndClear()` and `Mock::AllowLeak()` responsibly:** To avoid memory issues and stale expectations.
- **Leverage `DoAll()`, `Invoke()`, and other actions wisely:** To combine side effects and return values without duplicating test logic.
- **Avoid testing implementation details that lead to brittle tests:** Test the contract and expected interactions rather than the internal workings.

---

## 6. Related Tools and Integration

- Integrate with your build system's tooling for caching and parallel execution.
- Use CI pipelines with parallel test execution to optimize dev-to-feedback loops.
- Consider test sharding on large suites for highly parallel environments.

---

## References

- [GoogleTest Primer](https://google.github.io/googletest/primer.html) — Basics of writing and running tests.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Best practice patterns for mock usage.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — Detailed API for mocks.
- [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) — Quick syntax reference.
- [Performance and Maintainability Best Practices](https://google.github.io/googletest/guides/advanced_usage_best_practices/performance_best_practices.html) — More on scaling tests.

---

By following these guidelines, you can ensure that your test suites remain fast, reliable, and easy to maintain, supporting sustained productivity as your project evolves.
