---
title: "Improving Test Performance"
description: "Strategies to enhance test execution speed and reliability, including parallel execution, best practices for large test suites, and profiling tips."
---

# Improving Test Performance

Effective test performance is crucial to maintain fast development cycles, reliable results, and scalable test suites in GoogleTest. This page focuses on strategies and best practices for enhancing the speed and reliability of your C++ tests, ensuring that you get the most efficiency out of your test runs.

---

## 1. Parallel Test Execution

### Why Run Tests in Parallel?
Running tests in parallel fully leverages modern multicore CPUs, shortening total test suite runtime significantly. It is especially beneficial for large test suites where individual tests or fixtures take non-trivial time.

### How to Enable Parallelism
- Many build and test runners support parallel test execution. Configure these tools to run multiple test processes or threads concurrently.
- GoogleTest also supports sharding tests via command-line flags such as `--gtest_shard_index` and `--gtest_total_shards`.

### Best Practices
- Design tests to be independent and stateless to avoid flaky behavior in parallel runs.
- Avoid shared global state or use synchronization primitives to protect access when necessary.

<Tip>
Running tests in parallel can dramatically reduce waiting time but demands strict test isolation. Use test fixtures and correct setup/teardown techniques to avoid race conditions and inter-test contamination.
</Tip>

---

## 2. Managing Large Test Suites for Performance

### Organizing Tests
- Split large test suites into logically grouped smaller test suites.
- Use test filtering (`--gtest_filter`) to selectively run subsets of tests, speeding up development iterations.

### Test Sharding
- Running shards distributes subsets of tests across multiple machines or processes.
- Sharding helps scale test runs horizontally and is suitable in continuous integration deployments.

### Using Test Repetition and Randomization
- Use `--gtest_repeat` and `--gtest_shuffle` to detect flaky tests and ensure robustness.
- Repeating tests helps identify failures due to non-determinism.

### Avoid Over-Testing in Each Run
- For faster iteration, consider running only a relevant subset of tests locally.
- Reserve full test suite runs for pre-commit or CI stages.

---

## 3. Profiling and Diagnosing Performance Bottlenecks

### Identify Slow Tests
- Use profiling tools or test framework flags to identify tests that consume excessive time.
- Gradually refactor or isolate slow tests.

### Optimize Setup and Teardown
- Minimize expensive operations in fixture setup/teardown.
- Reuse shared expensive resources where applicable without compromising isolation.

### Cache or Mock Expensive Dependencies
- Replace slow dependencies like network calls or disk I/O with mocks or fakes using GoogleMock.

### Detect Flaky or Hanging Tests
- Detect flaky tests by repeating tests multiple times.
- Investigate and fix tests that hang or deadlock, often caused by threading issues.

<Warning>
Do not ignore flaky or hanging tests. They erode confidence in your test suite and can invalid your performance gains if not resolved.
</Warning>

---

## 4. Best Practices to Increase Test Speed and Reliability

- **Write Small, Focused Tests:** Smaller tests execute faster and isolate failures better.
- **Use Test Fixtures Wisely:** Avoid heavyweight setup in every test if possible. Use class-level setup for shared resources.
- **Disable or Isolate Slow Tests:** Use `DISABLED_` prefix or test filters on known slow or flaky tests until fixed.
- **Leverage NiceMock and StrictMock Judiciously:** Control mock strictness to reduce warnings and unexpected call errors.
- **Use `EXPECT_CALL` and `ON_CALL` Appropriately:** Limit overly strict expectations to prevent brittle tests.
- **Run Tests on Realistic But Lightweight Data:** Excessively large test inputs increase run times unnecessarily.

---

## 5. Practical Example: Running Tests in Parallel with Sharding

```shell
# Total shards: 4, running shard index 0
./my_test --gtest_total_shards=4 --gtest_shard_index=0

# Run remaining shards in separate parallel jobs
./my_test --gtest_total_shards=4 --gtest_shard_index=1 &
./my_test --gtest_total_shards=4 --gtest_shard_index=2 &
./my_test --gtest_total_shards=4 --gtest_shard_index=3 &
wait
```

This approach lets you split your test workload into four parts, executing simultaneously for faster completion.

---

## 6. Troubleshooting Performance Issues

### Tests Not Running in Parallel
- Verify your test runner or CI system supports parallelism.
- Confirm not using shared state prone to race conditions.

### Flaky Tests in Parallel Runs
- Isolate and fix shared state or deadlock issues.
- Consider using thread-safe death test style (`--death_test_style=threadsafe`).

### Tests Taking Excessive Time
- Profile tests individually.
- Optimize or stub slow external dependencies.

### Excessive Mock Warnings
- Use `NiceMock` to reduce noise on uninteresting mock calls.
- Use targeted `EXPECT_CALL` with appropriate cardinalities and `Times(AnyNumber())` to declare allowed calls.

---

## 7. Resources and Further Reading

- [GoogleTest Primer](primer.md) — Basics on writing and running tests
- [gMock Cookbook](gmock_cook_book.md) — Recipes for efficient mocking
- [Best Practices for Scalable Test Suites](guides/real-world-patterns/best-practices-patterns.md) — Strategies for large, maintainable test suites
- [Performance Optimization and Troubleshooting](guides/real-world-patterns/performance-troubleshooting.md) — Technical tips and debugging
- [Configuring Expectations and Actions](guides/mocking-advanced-testing/configuring-expectations-actions.md) — Lean mock expectations to improve test speed

<Tip>
Regularly profile and monitor your test suite’s performance and stability. Incrementally adopt parallelism and best practices for lasting gains.
</Tip>