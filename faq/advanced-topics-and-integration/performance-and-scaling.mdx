---
title: "Performance and Scaling Tips"
description: "Provides expert advice on improving test suite performance, managing large numbers of tests, using parallel execution, and optimizing mocking strategies for faster feedback cycles."
---

# Performance and Scaling Tips

This page provides expert advice on improving the performance of your test suites when using GoogleTest and GoogleMock. It covers strategies for managing large volumes of tests, using parallel execution effectively, and optimizing mocking practices to speed up feedback cycles.

---

## 1. Improving Test Suite Performance

Your goal as a test author is to achieve fast, reliable feedback from your test runs. Long-running test suites reduce your productivity and make it harder to catch issues early. Here are proven strategies to speed up your tests.

### Use Parallel Execution

GoogleTest supports running tests in parallel using test shards. Running tests in parallel across multiple CPU cores or machines reduces overall wall-clock time dramatically.

**How to use:**
- Use the `--gtest_parallel` flag or external tools that run multiple test binaries concurrently.
- Split your test suite into independent shards using test filters.
- Ensure tests are isolated and thread-safe to avoid flaky failures.

**Best Practices:**
- Avoid shared state or global resources that can cause race conditions.
- For tests requiring external resources, mock or fake those dependencies (see Mocking Strategies below).

### Filter Tests to Run Only What Matters

Running the full test suite during development is often unnecessary and slow.

- Use `--gtest_filter` to run only the affected tests related to your code changes.
- Combine filtering with parallel execution for even faster runs.

### Minimize Expensive Setup and TearDown

Shared expensive setup steps can slow down individual test executions.

- Use test fixtures carefully and avoid costly initialization in each test.
- Prefer `SetUpTestSuite()` for one-time expensive setup shared by test suite members.
- Cache external resources if possible, or mock them out to avoid real access.

### Avoid Over-Mocking or Under-Mocking

Over-mocking can introduce complexity slowing down your tests, while under-mocking might require slow real dependencies.

- Mock only dependencies that are slow, flaky, or complicated.
- Use fake implementations when the cost of creating it is less than the overhead of mocking.

---

## 2. Scaling to Large Numbers of Tests

As your project grows, managing thousands of tests can strain your development environment. Use these tips to keep test performance manageable.

### Organize Tests Logically

Group related tests into test suites with meaningful names. This enables:
- Selective execution.
- Easier parallelization.

### Use Parameterized Tests

Reduce code duplication by writing parameterized tests. This way, one test structure can cover many scenarios with varying input, improving maintainability and often performance.

### Use Efficient Matchers

Matchers affect test performance, especially inside mocks. Use simple and efficient matchers.

- Prefer simple matchers like `_` when argument matching does not need to be strict.
- Avoid heavy or complex custom matchers for per-call verification if not needed.

### Manage Expectation Ordering Wisely

Ordering calls strictly can introduce complexity and subtle bugs:

- Use `InSequence` or `Sequence` only when necessary.
- Avoid overly strict ordering for unrelated expectations.

### Monitor Test Suite Health

- Track flaky or intermittently failing tests.
- Use `--gmock_verbose=info` to gain visibility into mocks during failures.

---

## 3. Optimizing Mocking Strategies for Faster Feedback

Proper use of mocks speeds up tests by avoiding the need for real dependencies. Here are the key tips.

### Prefer `ON_CALL` for Default Behavior

Use `ON_CALL` to specify default actions for mocks, which reduces the need for many `EXPECT_CALL`s.

- `ON_CALL` sets behavior but does not enforce call expectation.
- Keep `EXPECT_CALL` for interactions you must verify.

### Use `NiceMock` to Silence Uninteresting Call Warnings

Uninteresting calls cause warnings and clutter output. Wrapping your mock in `NiceMock` suppresses these warnings.

### Use `StrictMock` to Catch Unexpected Calls

If you want stricter validation, use `StrictMock` to turn unexpected calls into errors.

Use this carefully as it may make tests more brittle.

### Avoid Retiring Expectations Unnecessarily

By default, expectations in gMock are "sticky". Use `.RetiresOnSaturation()` only when you want to retire a saturated expectation and allow fallback to other expectations.

### Delegate to Fakes or Real Objects When Possible

For complex or stable behaviors, delegate default mock actions to real or fake implementations to simplify expectations and reduce mock complexity.

### Beware of Mock Thread-Safety

When running tests concurrently, mocks are designed to be thread-safe, but ensure:

- Set expectations before multi-threaded code runs.
- Avoid setting expectations during concurrent execution.

### Profile Your Tests

Use profiling tools or `--gmock_verbose=info` and verbosity options to identify slow mocks, excessive call counts, or inefficient expectations.

---

## 4. Common Pitfalls and Troubleshooting

### Mock Methods Not Virtual

Mocks only override virtual methods (or use special techniques for non-virtual). Ensure mocked methods are declared virtual.

### Expectation Order Misuse

Expectations must be set before the mocks are exercised. Violating this leads to undefined behavior.

### Matchers Causing Overhead

Complex or numerous matchers slow down invocation matching. Simplify when possible.

### Unintentional Sticky Expectations Failures

Misunderstanding sticky expectations can cause early test failures. Use `.RetiresOnSaturation()` diligently.

### Race Conditions in Parallel Tests

Running code under test in multiple threads can expose race conditions. Use `ThreadLocal`, proper synchronization, and confirm test logic is thread-safe.

### Heapcheck Failures with Mocks

Ensure your mocked base classes have virtual destructors to avoid heap errors.

---

## Further Resources

- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html): Deep dive into mocking APIs and usage.
- [gMock for Dummies](https://google.github.io/googletest/gmock_for_dummies.html): Beginner-friendly mock tutorial.
- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html): Recipes for advanced mocking.
- [Performance Optimization Guide](https://github.com/google/googletest/blob/main/guides/advanced-and-best-practices/performance-optimization.md): Additional tips for speeding up test suites.
- [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html): Common issues and solutions.

---

For general usage, always integrate these practices progressively. Start by getting your test suite running, then apply filtering and parallelization. Introduce mocks gradually and optimize based on profiling and test run observations. This approach ensures you maintain reliability while scaling performance.

<Check>
Deploy parallel execution early in your test CI pipelines for maximal speed gains.
</Check>

<Warning>
Avoid over-specifying expectations and strict call order unless interaction order is critical. Overconstraining tests make maintenance difficult.
</Warning>