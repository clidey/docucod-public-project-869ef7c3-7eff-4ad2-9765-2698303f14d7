---
title: "Improving Test Performance"
description: "Recommendations for speeding up test execution, managing large test suites, and strategies for parallel and incremental testing."
---

# Improving Test Performance

Optimizing your test suite's performance unlocks faster feedback cycles, better resource utilization, and more scalable continuous integration. This page offers practical recommendations for speeding up test execution in GoogleTest and GoogleMock environments, strategies for managing large test suites efficiently, and techniques for parallel and incremental testing.

---

## Why Performance Matters

Imagine youâ€™re running hundreds or thousands of unit tests every time you build your code. Without optimization, test execution time can become a bottleneck, slowing development velocity and hindering rapid iteration. Improving test speed directly leads to:

- Shorter wait times between code changes and test results
- More frequent test execution in CI pipelines
- Better use of computational resources
- Improved developer productivity and confidence

---

## Key Strategies to Speed Up Test Execution

### 1. Run Tests in Parallel

GoogleTest supports running tests in parallel across multiple CPU cores, dramatically reducing wall-clock time.

**How to run tests in parallel:**

- Use test sharding to divide the test suite into shards.
- Run multiple test executables or processes in parallel, each assigned a shard.
- Use environment variables such as `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` to specify shard count and current shard.

Example:

```bash
# Total test shards = 4
# Run shard 0
./my_tests --gtest_total_shards=4 --gtest_shard_index=0 &
# Run shard 1
./my_tests --gtest_total_shards=4 --gtest_shard_index=1 &
# Run shard 2
./my_tests --gtest_total_shards=4 --gtest_shard_index=2 &
# Run shard 3
./my_tests --gtest_total_shards=4 --gtest_shard_index=3 &
wait
```

**Benefits:**

- Leverages multi-core machines effectively
- Often results in near-linear speedup depending on hardware and test design

**Tips:**

- Balance shard counts with available CPU and IO resources
- Ensure tests are independent and isolated to avoid flaky failures in parallel runs

---

### 2. Filter Tests to Run Relevant Subsets

Instead of running all tests every time, selectively run only the tests relevant to your changes.

GoogleTest supports filtering:

```bash
./my_tests --gtest_filter=MyTestSuite.MyTest
```

Supports wildcards for flexible patterns:

```bash
./my_tests --gtest_filter=MyTestSuite.*-MyTestSuite.FlakyTest
```

**Use cases:**

- Run quick smoke tests during development
- Exclude long-running or flaky tests temporarily
- Target tests affected by recent code changes

---

### 3. Use Fast and Stable Expectations in Mocks

GoogleMock's ability to mock interfaces enables speed by avoiding expensive real dependencies:

- Use `ON_CALL()` for default behaviors instead of `EXPECT_CALL()` when you don't need to verify call counts. This reduces overhead in verification.
- Avoid over-specifying expectations which can slow down matching due to excessive constraints.
- Use `NiceMock` to suppress warnings on uninteresting calls and keep logs concise.

Example:

```cpp
using ::testing::NiceMock;
NiceMock<MockFoo> mock_foo;
ON_CALL(mock_foo, Bar(_)).WillByDefault(Return(true));
```

---

### 4. Minimize Mock Construction Overheads

Mock object constructors and destructors can slow compilation:

- Define mock constructors and destructors out-of-line in `.cc` files to reduce re-compilation speed impact.

Example:

```cpp
// mock_foo.h
class MockFoo : public Foo {
 public:
  MockFoo();
  ~MockFoo();
  MOCK_METHOD(void, Bar, (), (override));
};

// mock_foo.cc
#include "mock_foo.h"
MockFoo::MockFoo() {}
MockFoo::~MockFoo() {}
```

---

## Managing Large Test Suites

### 1. Organize Tests for Parallel Execution

- Divide tests by modules or features with separate test binaries.
- Use test sharding to distribute tests evenly across shards.
- Identify and isolate slow tests in separate shards or mark them accordingly.

### 2. Apply Incremental Test Runs

- Integrate test filtering with version control hooks to run tests related to changed files only.
- Use tagging or naming conventions to classify tests by runtime or scope.

### 3. Order Tests for Efficiency

- Run quick, stable tests first to detect failures early.
- Sequentially schedule long-running or flaky tests to avoid resource contention.

---

## Best Practices for Parallel and Incremental Testing

- Use `InSequence` objects or `EXPECT_CALL(...).InSequence()` to order tests where dependencies exist.
- Avoid shared mutable state, including static or global variables, to prevent race conditions and flaky tests.
- Leverage `Mock::AllowLeak()` carefully when dealing with mocks that survive across a test suite to prevent false leak detection.
- Monitor flaky tests and address root causes; flaky tests undermine confidence in parallel runs.

---

## Troubleshooting Performance Issues

### High Test Runtime

- Profile test execution time with verbose runners or custom instrumentation to identify bottlenecks.
- Check for network calls, sleeps, or external resource accesses in unit tests.
- Consider replacing costly dependencies with mocks or fakes.

### Memory and Resource Exhaustion

- Limit parallelism to avoid exhausting CPU, memory, or IO bandwidth.
- Use job schedulers or CI infrastructure features to balance loads.

### Slow Mock Verification

- Simplify expectations to avoid complex matchers when possible.
- Use `ON_CALL` for behaviors without strict verification.

---

## Additional Tips and Tools

- Use `--gtest_shuffle` to randomize test execution order and discover hidden dependencies.
- Use `EXPECT_CALL(...).RetiresOnSaturation()` to automatically retire expectations, preventing sticky expectations from causing unnecessary failures.
- Increase `--gtest_repeat` count to expose flaky tests that may fail inconsistently.
- Combine `--gmock_verbose=info` with logging to diagnose unexpected call overhead.

---

## Related Documentation

- [Running Tests Faster Guide](https://google.github.io/googletest/guides/integration-and-optimization/running-tests-faster.html)
- [gMock Cookbook - Knowing When to Expect (Use ON_CALL)](https://google.github.io/googletest/gmock_cook_book.html#UseOnCall)
- [Mock Object Behaviors (Nice, Naggy, Strict)](https://google.github.io/googletest/api/gmock_nice_strict.html)
- [Setting Default Actions and Expectations](https://google.github.io/googletest/reference/mocking.html#ON_CALL)
- [Test Sequences and Ordering](https://google.github.io/googletest/reference/mocking.html#InSequence)

---

Optimize your test suite by combining parallel sharding, selective filtering, mock best practices, and thoughtful test organization. Implement these strategies early to keep your tests speedy, maintainable, and reliable.

---

<CardGroup cols={2}>
<Card title="Speeding Up Test Execution">
- Run tests in parallel using test shards
- Filter tests to run only subsets
- Use `NiceMock` to suppress unneeded warnings
- Define out-of-line mock constructors
</Card>
<Card title="Managing Large Suites">
- Organize tests by feature or runtime
- Incremental test runs based on changed files
- Order tests for fast failure detection
- Isolate slow/flaky tests
</Card>
</CardGroup>

<Tip>
For robust parallel testing, ensure tests are isolated and free of shared mutable global state to avoid flaky failures.
</Tip>

<Warning>
Avoid over-specifying expectations with `EXPECT_CALL` unnecessarily; use `ON_CALL` for default mock behaviors to improve test maintainability and speed.
</Warning>

<Check>
Use `EXPECT_CALL(...).RetiresOnSaturation()` to prevent expectations from staying active longer than needed, reducing verification overhead.
</Check>