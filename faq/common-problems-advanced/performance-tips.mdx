---
title: "Performance and Scalability Tips"
description: "Advice and answers related to speeding up test execution, best practices for writing efficient tests, and overcoming bottlenecks when running large test suites. Includes insights into using value-parameterized and type-parameterized tests efficiently."
---

# Performance and Scalability Tips

This page provides actionable guidance to help you speed up test execution, write efficient tests, and handle large test suites effectively. It focuses on practical best practices and strategies related to test performance, including insights into using value-parameterized and type-parameterized tests efficiently.

---

## 1. Speeding Up Test Execution

### 1.1. Use Efficient Expectations and Actions
- Avoid overly complex matchers or actions within `EXPECT_CALL` or `ON_CALL` clauses that may slow down test execution.
- Prefer simple argument matchers (`_`, `Eq`, or typed exact matches) when the specifics of an argument are not critical.
- If using actions like `WillOnce`/`WillRepeatedly`, prefer lightweight lambdas or pre-constructed return values rather than heavy computational logic.

### 1.2. Minimize Setup Overhead
- Define default behaviors with `ON_CALL` to minimize the amount of setup done during each test run when the behavior is common.
- Reuse mocks or mock configurations instead of reinitializing expensive mocks repeatedly.

### 1.3. Avoid Unnecessary Mocking
- Mock only the interfaces or functions that are directly involved in the behavior you want to test. Excess mocking introduces overhead and complexity.

### 1.4. Parallelize Test Suites
- Where possible, split your test binary into shards or partitions and run them in parallel environments to distribute load and reduce wall-clock time.

---

## 2. Writing Efficient Tests

### 2.1. Leverage Value-Parameterized Tests
- Use value-parameterized tests to run the same test logic with various input values efficiently.
- Design test parameters to cover relevant cases without redundancies that cause excessive test invocations.

### 2.2. Use Type-Parameterized Tests
- Use type-parameterized tests to validate behavior across multiple types, avoiding duplication.
- Keep type lists concise and well-targeted to avoid combinatorial explosion.

### 2.3. Use Sequences and Partial Ordering Sparingly
- While sequences (`InSequence`) and ordering constraints (`After`) enforce call order, excessive use can increase runtime due to internal complexity checks and failure diagnostics.
- Use these only when call order verification is essential to your test semantics.

### 2.4. Avoid Sticky Expectations When Not Needed
- By default, expectations in gMock remain active even after reaching their upper bounds. If you want them to retire immediately upon saturation to avoid unexpected call errors in subsequent calls, use `.RetiresOnSaturation()`.

Example:
```cpp
EXPECT_CALL(mock_obj, Foo())
    .WillOnce(Return(1))
    .RetiresOnSaturation();
```

---

## 3. Overcoming Bottlenecks in Large Test Suites

### 3.1. Group and Filter Tests
- Use GoogleTest's test filtering features to run subsets of tests during development.
- Combine with sharding to run tests efficiently in CI environments.

### 3.2. Limit Verbose Logging
- Excessive use of `--gmock_verbose=info` or detailed stack traces can slow tests.
- Use `--gmock_verbose=warning` or `--gmock_verbose=error` for faster runs when full logging isn't needed.

### 3.3. Optimize Mock Expectations
- Avoid duplicate or overlapping `EXPECT_CALL` clauses that increase matcher search overhead.
- Structure expectations so that more specific ones come last, ensuring quick match failure for irrelevant calls.

### 3.4. Verify and Clear Expectations Explicitly
- For long-running tests, periodically use `Mock::VerifyAndClearExpectations(&mock_obj)` to clear expectations and allow fresh setups, reducing accumulated complexity.

### 3.5. When Mocking Heavy Objects
- Using `Mock::AllowLeak()` can prevent overhead from verification in complex lifetime scenarios.
- Combine with explicit expectation clearings.

---

## 4. Tips for Parameterized Tests

### 4.1. Value-Parameterized Tests
- Parameterize tests with relevant, varied values but keep the number of parameters manageable.
- Avoid overly large parameter sets that increase total test execution time unnecessarily.

### 4.2. Type-Parameterized Tests
- Keep the list of types to those most essential to cover.
- Focus on testing distinct behaviors per type rather than all possible type variations.

---

## 5. Best Practices

- **Order Expectations Carefully:** More specific expectations should be declared after more general ones to ensure they take precedence.
- **Use `RetiresOnSaturation()` to Avoid Sticky Expectations:** Especially when defining sequences of expectations meant to be called in order.
- **Default Actions and `ON_CALL`:** Set a sensible default action to avoid unexpected calls causing delays in failure reporting.
- **Use `NiceMock` to Suppress Uninteresting Call Warnings:** To reduce noise and improve test speed when appropriate.
- **Control Verbosity:** Lower verbosity in CI to speed up runs.

---

## 6. Common Pitfalls

### 6.1. Overusing `EXPECT_CALL` Without `RetiresOnSaturation`
- Leads to sticky expectations that remain active and can cause tests to report failures or warnings unexpectedly.

### 6.2. Not Setting Default Actions for Mock Methods
- Causes unexpected calls to print warnings and can create overhead.

### 6.3. Using Complex Matchers for Every Call
- Increases matcher evaluation time; prefer precise matchers only where necessary.

### 6.4. Large Parameterized Tests Without Filtering
- Causes test suite to balloon in runtime.

---

## 7. Example: Efficient Use of Parameterized Tests and Expectations

```cpp
class MyMock : public SomeInterface {
 public:
  MOCK_METHOD(bool, DoWork, (int input), (override));
};

class MyTest : public ::testing::TestWithParam<int> {
 protected:
  MyMock mock_;
};

TEST_P(MyTest, ProcessVariousInputs) {
  int input = GetParam();

  EXPECT_CALL(mock_, DoWork(input))
      .WillOnce(Return(true))
      .RetiresOnSaturation();

  // Code under test using mock_ with input.
}

INSTANTIATE_TEST_SUITE_P(
    Inputs,
    MyTest,
    ::testing::Values(1, 10, 100, 1000));
```

This setup ensures:
- Tests run with different input values efficiently.
- Expectations retire upon use to avoid sticky expectation failures.

---

#### For More Information and Advanced Performance Optimization

- See the [gMock Cookbook's Performance and Test Suite Optimization](https://github.com/google/googletest/blob/main/docs/guides/advanced-patterns/performance-and-parallel.md).
- Refer to the [Mocking Reference](https://github.com/google/googletest/blob/main/docs/reference/mocking.md) for full details on `EXPECT_CALL`, `ON_CALL`, and cardinality clauses.
- Use `--gmock_verbose` flags judiciously to balance diagnostics and speed.

---

##### Related Documentation

- [gMock Cookbook](https://github.com/google/googletest/blob/main/docs/gmock_cook_book.md)
- [Expected Calls and Actions](https://github.com/google/googletest/blob/main/docs/reference/mocking.md#EXPECT_CALL)
- [Parameterized Tests Guide](https://github.com/google/googletest/blob/main/docs/guides/core-testing-workflows/parameterized-and-typed-tests.md)
- [Nice, Naggy, Strict Mocks](https://github.com/google/googletest/blob/main/docs/api-reference/mocking-api/nice-strict-mocks.md)

---

### Tips

<Tip>
Always declare your more specific expectations **after** general ones to ensure they are matched first. This avoids unexpected matches and speeds up call dispatch.
</Tip>

<Tip>
Use `.RetiresOnSaturation()` on expectations intended to be called a fixed number of times to prevent sticky expectation buildup and unexpected failures in long test runs.
</Tip>

<Tip>
Set default actions with `ON_CALL` for common behaviors to avoid uninteresting call warnings and reduce overhead.
</Tip>

<Tip>
Run large test suites in parallel shards and with filtered subsets to improve developer feedback time.
</Tip>