---
title: "Build System and Integration Issues"
description: "Guides users through resolving build system integration challenges, such as using GoogleTest/GoogleMock with CMake or Bazel, dependency management, and linking with large or legacy projects. Also touches on platform-specific quirks and third-party integrations."
---

# Build System and Integration Issues

This guide helps you resolve common challenges encountered when integrating GoogleTest and GoogleMock into build systems, including CMake and Bazel. It focuses on best practices for dependency management, linking strategies with large or legacy projects, and dealing with platform-specific quirks and third-party integration concerns.

---

## 1. Using GoogleTest and GoogleMock with CMake

### 1.1 Basic Integration

To integrate GoogleTest and GoogleMock properly in a CMake-based project:

- Add the required include directories for both GoogleTest and GoogleMock.
- Link your test target against the `gtest` and `gmock` libraries (or `gtest_main` and `gmock_main` if you rely on their default `main()` entry point).

```cmake
find_package(GTest REQUIRED)

add_executable(my_tests test_main.cc my_tests.cc)
target_include_directories(my_tests PRIVATE ${GTEST_INCLUDE_DIRS})
target_link_libraries(my_tests PRIVATE GTest::gtest GTest::gmock GTest::gmock_main)
```

<Tip>
Always use `GTest::gmock_main` to avoid writing your own `main()` unless you need custom test initialization code.
</Tip>

### 1.2 Handling Large or Legacy Projects

When integrating with large or legacy projects, linking may become complex due to multiple dependencies and possibly conflicting runtime libraries. Follow these guidelines:

- Keep GoogleTest and GoogleMock in isolated targets.
- Make sure runtime libraries are consistent across GoogleTest, GoogleMock, and your project (e.g., static vs dynamic CRT on Windows).
- Prefer static linkage where feasible to reduce external dependencies.
- For legacy build systems, consider encapsulating GoogleTest and GoogleMock build logic into standalone subprojects or libraries.

### 1.3 Platform Specific Notes

- **Windows**: Visual Studio users must be cautious about runtime library mismatches between GoogleTest and their project. Linking GoogleTest and GoogleMock statically with consistent `/MT` or `/MD` settings avoids linker errors.
- **Unix-like**: Ensure `pthread` linkage for GoogleTest as it uses threading internally.

### 1.4 Initializing GoogleMock

Remember to initialize GoogleMock in your test executable with:

```cpp
int main(int argc, char** argv) {
  ::testing::InitGoogleMock(&argc, argv);
  return RUN_ALL_TESTS();
}
```

This handles both GoogleTest and GoogleMock flag parsing and initialization. If you link against `gmock_main`, this `main()` is already provided for you.

---

## 2. Using GoogleTest and GoogleMock with Bazel

### 2.1 Setup Basics

Bazel build files should include `cc_test` or `cc_binary` rules that depend on the GoogleTest and GoogleMock libraries. An example `BUILD` file snippet:

```python
cc_test(
    name = "my_tests",
    srcs = ["my_tests.cc"],
    deps = ["@com_google_googletest//:gmock_main"],
)
```

### 2.2 Dependency Management

- Use Bazel's external repository rules to pull in GoogleTest and GoogleMock. For example, use `http_archive` to bring in googletest.
- Depend on the hosted `gmock_main` target to use the default test entry-point.
- For large projects, structure Bazel targets to separate production code from test code and mock dependencies.

### 2.3 Linking Considerations

- Link to `@com_google_googletest//:gmock_main` instead of `gmock` and `gtest` directly to avoid duplicating the `main()` entry point.
- Be aware of Bazel's strict linking rules; explicit dependencies must be declared.

### 2.4 Common Platform Quirks

- On Windows with Bazel, be mindful of MSVC runtime library conflicts;
  align Bazel toolchain with GoogleTest runtime selection.
- Embedded or constrained platforms may need special Bazel toolchain configurations.

---

## 3. Managing Third-party Integrations

Integrating GoogleTest and GoogleMock in an environment with many third-party libraries requires attention to compatibility:

- Avoid conflicting symbol definitions; GoogleMock's macros and inline functions can clash if duplicated across libraries.
- Use namespace aliasing if possible to isolate GoogleTest and GoogleMock APIs.
- For projects with custom logging or testing frameworks, consider using GoogleTest and GoogleMock as libraries only without overriding main, or use adapter patterns.

---

## 4. Platform-specific Gotchas and Workarounds

- On **Windows**, careful configuration of calling conventions in mocks may be needed. Use `Calltype()` qualifier in `MOCK_METHOD` for Windows-specific calling conventions (e.g., `STDMETHODCALLTYPE`).

```cpp
MOCK_METHOD(bool, Foo, (int n), (Calltype(STDMETHODCALLTYPE), override));
```

- For **embedded platforms** like ESP8266 or Arduino, initialization routines for GoogleMock may differ. Refer to platform-specific startup documentation.

---

## 5. Practical Tips for Build System Integration Success

<Steps>
<Step title="Verify GoogleTest and GoogleMock Installation">
Confirm successful build of GoogleTest and GoogleMock standalone before integration.
</Step>
<Step title="Use Official Targets and Libraries">
Reference GoogleTest and GoogleMock through official CMake `find_package` targets or Bazel external repositories.
</Step>
<Step title="Link Properly Against Main Libraries">
Prefer `gmock_main` or `gtest_main` where possible to avoid linker errors and duplicate `main()` functions.
</Step>
<Step title="Check Runtime Library Consistency">
Ensure matching runtime (static or dynamic CRT) across all components on Windows.
</Step>
<Step title="Initialize GoogleMock Before RUN_ALL_TESTS()">
Call `testing::InitGoogleMock()` early in your main test executable.
</Step>
<Step title="Configure Verbosity for Troubleshooting">
Use `--gmock_verbose=info` to gain detailed insight into mock behavior during test runs.
</Step>
</Steps>

<Tip>
If you encounter linkage issues involving `MOCK_METHOD`, check for macro conflicts or incompatible build flags.
</Tip>

---

## 6. Troubleshooting Common Build and Integration Issues

### Problem: Linker errors referencing multiple `main()` definitions

*Cause*: Linking both manually defined `main()` and GoogleMock's default `main()` from `gmock_main`

*Solution*: Link with either `gmock_main` (providing the default `main()`) or write your own `main()` and link with `gmock` and `gtest` only—do not do both.

### Problem: Unresolved references to pthread on Unix/Linux

*Cause*: Missing linkage to pthread library

*Solution*: Ensure linking with pthread by adding `-pthread` to compiler and linker flags or linking `Threads::Threads` in CMake.

### Problem: Runtime library conflicts on Windows

*Cause*: Some parts built with different runtime (e.g., static vs dynamic CRT)

*Solution*: Use consistent `/MT` or `/MD` flags project-wide, including GoogleTest and your project.

### Problem: Compiler errors parsing `MOCK_METHOD` in method signatures containing commas

*Cause*: Commas inside template arguments confuse macro parsing

*Solution*: Wrap complex types with parentheses or use type aliases as shown below:

```cpp
class MyMock {
 public:
  using PairType = std::pair<bool, int>;
  MOCK_METHOD(PairType, GetPair, ());
};
```

### Problem: Using non-virtual methods or free functions as mocks

*Solution*: Refactor to interfaces or use the `MOCK_METHOD` approach for non-virtual methods as covered in the [Mocking Cookbook](gmock_cook_book.md#MockingNonVirtualMethods).

---

## 7. References and Further Resources

- [Mocking Reference](docs/reference/mocking.md) — Macro and API details for mocks
- [gMock Cookbook](docs/gmock_cook_book.md) — Recipes for mocking scenarios and common problems
- [Basic Configuration](getting-started/initial-configuration-validation/basic-configuration.md) — Setup and build system integration
- [GoogleMock Main Entry Point](concepts/core-architecture/main-entry-and-execution.md) — Details on initialization and execution
- [gMock for Dummies](docs/gmock_for_dummies.md) — Beginner-friendly introduction

---

For comprehensive troubleshooting and integration workflows, always start with verifying your build system configuration step-by-step to reduce complexity and isolate issues.

<Tip>
Regularly consult known issues sections in platform-specific documentation to stay ahead of quirks and incompatibilities.
</Tip>
