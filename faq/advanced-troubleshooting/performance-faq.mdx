---
title: "Improving Test Performance"
description: "Shares best practices and answers typical questions about accelerating your test suites. Includes advice on optimizing test design, reducing overhead from excessive mocking, efficient use of parameterized tests, and running tests in parallel."
---

# Improving Test Performance

Optimizing test performance is crucial for maintaining a fast and efficient development cycle, particularly as your test suite grows. This guide provides practical tips, best practices, and common pitfalls when designing and running tests using GoogleTest and GoogleMock.

---

## 1. Design Tests for Efficiency

### Write Focused Tests

Tests should verify one behavior or unit of functionality at a time. Avoid combining unrelated assertions in a single test, as this can obscure failures and complicate debugging.

### Use Test Fixtures Wisely

If multiple tests share common setup/teardown logic or test data, use test fixtures (`TEST_F`) to reuse that code, reducing redundancy and initialization overhead.

### Minimize Expensive Operations

Avoid performing costly operations such as I/O, heavy computations, or network calls inside tests. Instead, mock or fake those dependencies to keep tests fast and reliable.

---

## 2. Manage Mocking Overhead

### Avoid Excessive or Unnecessary Mocking

While mocking is powerful, indiscriminate use can slow down tests and make them brittle. Only mock interfaces where external dependencies or side effects need to be controlled or observed.

### Prefer `ON_CALL` for Default Behavior

Use `ON_CALL` to set sane default behaviors on mocks instead of `EXPECT_CALL` if you don't need to verify call counts or arguments strictly. This reduces the number of expectations to check and improves test speed.

### Use Strictness Wrappers Judiciously

- `NiceMock`: suppresses warnings for uninteresting calls and reduces noise.
- `NaggyMock`: (default) warns about uninteresting calls.
- `StrictMock`: fails tests on uninteresting calls, increasing strictness overhead.

Choose the wrapper that balances test robustness and maintainability.

---

## 3. Efficient Parameterized Tests

### Use Parameterized Tests to Reduce Duplication

When testing the same logic with multiple inputs, employ parameterized tests (`TEST_P`) and parameter generators. This consolidates many similar tests into one, speeding up maintenance.

### Avoid Excessive Combinatorial Explosion

Be mindful of the size of your parameter spaces. Too many parameters with many values can exponentially increase test execution time.

### Cache or Share Immutable Test Data

For expensive setup related to parameters, cache or share data between test iterations to minimize repeated costs.

---

## 4. Run Tests in Parallel

### Leverage Test Framework Parallelism

GoogleTest supports running tests in parallel via sharding or external tools.

- Use test filters and sharding settings to run subsets of tests simultaneously.
- Integrate with CI systems (e.g., Jenkins, GitHub Actions) to distribute test runs.

### Isolate Tests for Parallel Safety

Ensure tests are independent, without shared mutable global state or resource conflicts, so they can run safely in parallel.

### Use Lightweight and Scoped Mocks

Mocks that have minimal overhead and are created/destroyed for each test help avoid cross-test interference in parallel runs.

---

## 5. Avoid Common Performance Pitfalls

### Overhead from Unverified Mock Expectations

Avoid setting many expectations with strict call counts on mocks when it is not critical. These add runtime checks and slow execution. Use `.Times(AnyNumber())` or `ON_CALL` where appropriate.

### Excessive Logging and Verbosity

Verbose output flags such as `--gmock_verbose=info` increase runtime overhead and log size. Use these only when debugging.

### Heavy Use of Complex Matchers and Actions

Complex or custom matchers/actions can add overhead. Test performance can often be improved by simplifying these or caching matcher objects.

---

## 6. Monitoring and Benchmarking

### Profile Your Test Suite

Measure which tests take the longest time and focus optimization efforts there.

### Use GoogleTest's Timing Features

Enable test time reporting (`--gtest_print_time`) to identify slow tests.

---

## 7. Summary Checklist

- Write small, focused tests.
- Use test fixtures to share setup/teardown.
- Mock only where necessary.
- Use `ON_CALL` for default mock behavior.
- Avoid overly strict or redundant `EXPECT_CALL`s.
- Use parameterized tests carefully.
- Run tests in parallel safely.
- Disable verbose logging in production runs.
- Profile and benchmark regularly.

---

## Additional References

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html): Practical recipes and patterns for advanced mocking and test design.
- [Mocking Reference](docs/reference/mocking.md): Comprehensive reference for mocking APIs and classes.
- [GoogleTest Primer](docs/primer.md): Foundational knowledge on writing efficient tests with GoogleTest.
- [Writing Maintainable Mocks](https://google.github.io/googletest/gmock_advanced.html#writing-maintainable-mocks): Guide on managing mock strictness and uninteresting calls.
- [Parallel Test Execution](concepts/performance-and-scalability/test-discovery-and-parallelism.mdx): Techniques for running tests in parallel to reduce total test time.

---

## Troubleshooting Tips

<AccordionGroup title="Common Performance Issues and Fixes">
<Accordion title="Tests Slow Due to Excessive Mock Expectations">
To avoid slowdowns, minimize the number of `EXPECT_CALL` statements, and prefer setting default behaviors with `ON_CALL` unless call verification is crucial.
</Accordion>
<Accordion title="Tests Fail or Hang When Running in Parallel">
Ensure tests don't share mutable state or rely on global resources without synchronization. Use fixtures to isolate state and avoid side effects.
</Accordion>
<Accordion title="Unexpected Logging Overhead in Test Runs">
Reduce `--gmock_verbose` and `--gtest_print_time` flags for regular runs. Use verbose outputs only for debugging.
</Accordion>
</AccordionGroup>

---

## Practical Example: Balancing Mocking Strictness and Speed

```cpp
using ::testing::NiceMock;
using ::testing::Return;
using ::testing::_;

class MockCalculator {
 public:
  MOCK_METHOD(int, Add, (int a, int b), (override));
};

TEST(CalculatorTest, AddReturnsSum) {
  NiceMock<MockCalculator> mock_calc;

  ON_CALL(mock_calc, Add(_, _))
      .WillByDefault(Return(0));  // Default mock behavior

  EXPECT_CALL(mock_calc, Add(1, 2))
      .Times(1)
      .WillOnce(Return(3));  // Verify this call only

  EXPECT_EQ(mock_calc.Add(1, 2), 3);
  EXPECT_EQ(mock_calc.Add(5, 6), 0);  // Uninteresting call, allowed
}
```

This approach keeps the test focused only on critical interactions, improving performance while maintaining test clarity.
