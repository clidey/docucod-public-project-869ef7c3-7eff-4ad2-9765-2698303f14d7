---
title: "Performance and Scalability Tips"
description: "Practical advice for optimizing test execution speed and resource usage, addressing slow test suites, and avoiding common performance pitfalls. Suited for teams scaling up their test coverage or working with large codebases."
---

# Performance and Scalability Tips

Practical advice for optimizing test execution speed and resource usage, addressing slow test suites, and avoiding common performance pitfalls. This guide is tailored for teams scaling up their test coverage or working with large codebases.

---

## Understanding Performance Challenges

As your test suite grows, slow tests and high resource consumption can severely impact development velocity. Common causes include:

- Extensive use of external dependencies (databases, network, file systems).
- Heavy or complicated object setups.
- Large numbers of tightly coupled mocks.
- Inefficient test organization and repeated costly initialization.

GoogleTest and GoogleMock provide tools and best practices to help mitigate these challenges and keep your tests fast and scalable.

---

## Best Practices to Optimize Test Performance

### 1. Use Mocking to Isolate Tests

Mocks keep your tests focused on the unit of work by replacing expensive or slow dependencies with fast, controllable mocks that validate behavior rather than implementation. Examples include:

- Mocking database connections to avoid actual DB calls.
- Mocking network calls to eliminate latency or flakiness.

Benefits:

- Make tests deterministic and fast.
- Avoid flaky failures due to external systems.
- Lower resource usage.

**Tip:** When defining mocks, prefer `ON_CALL()` to specify default behaviors and limit `EXPECT_CALL()` to only when you want to verify function calls, as excessive expectations can slow down verification.

### 2. Minimize Expensive Setup

Reuse fixtures and static resources where possible. GoogleTest supports per-test-suite setup (`SetUpTestSuite` / `TearDownTestSuite`), allowing you to set up expensive resources once:

```cpp
class MyTestSuite : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Expensive initialization
  }

  static void TearDownTestSuite() {
    // Clean up resources
  }
};
```

Avoid performing costly operations in each test unless you need isolated fresh state.

---

### 3. Use `NiceMock` and `StrictMock` Judiciously

By default, mocks are "naggy" and print warnings for uninteresting calls, which can slow down tests and clutter output.

- Use `NiceMock<T>` when you want to suppress warnings on uninteresting calls.
- Use `StrictMock<T>` to fail tests on unexpected calls but be aware this may increase test fragility and time.

Balancing strictness and niceness helps maintain clear, performant test suites.

---

### 4. Control Expectation Cardinality Efficiently

Excessive or improper use of `Times()` can slow test execution.

- Avoid setting excessive call expectations if unnecessary.
- Use fuzzy cardinalities like `AnyNumber()`, `AtLeast(n)` appropriately to reduce overhead.
- Leverage `WillOnce()` and `WillRepeatedly()` smartly to avoid redundant actions.

---

### 5. Reuse Mock Actions and Matchers

Matchers and actions are lightweight to copy and can be reused across expectations. For example:

```cpp
Matcher<int> in_range = AllOf(Gt(5), Le(10));
EXPECT_CALL(mock_obj, Foo(in_range));
```

Caching complex matchers/actions reduces redundant construction costs.

---

### 6. Optimize Compilation Time

Large mocks can cause slow compilation.

- Move mock class constructor and destructor definitions to `.cc` files rather than inline to reduce template instantiations per compilation unit.

Example:

```cpp
// mock_foo.h
class MockFoo : public Foo {
 public:
   MockFoo();
   ~MockFoo() override;
   MOCK_METHOD(int, DoThis, (), (override));
};

// mock_foo.cc
MockFoo::MockFoo() {}
MockFoo::~MockFoo() {}
```

---

### 7. Use `ON_CALL` to Define Default Behavior at Setup

Setting default behaviors using `ON_CALL` in mocks allows tests to avoid redundant `EXPECT_CALL` setups, speeding tests and reducing verbosity.

For example:

```cpp
ON_CALL(mock_obj, GetSize()).WillByDefault(Return(10));
```

---

## Monitoring and Diagnosing Performance Bottlenecks

### Enable Verbose Logging for Mocks

The `--gmock_verbose=info` flag prints detailed traces of mock expectations and calls, helping identify unexpected and costly interactions.

### Profile Test Execution

Use profiling tools or built-in test framework timers to locate slow tests and optimize or isolate them.

### Test Parallelization

Run tests in parallel using build system support or CI pipelines to reduce total execution time. GoogleTest supports sharding and filtering.

---

## Summary Checklist for Fast and Scalable Test Suites

- [x] Use mocks to replace slow or external dependencies
- [x] Reuse fixture setup with `SetUpTestSuite`
- [x] Control mock strictness via `NiceMock` and `StrictMock`
- [x] Use flexible expectation cardinalities
- [x] Reuse complex matchers and actions
- [x] Move mock class construction out of headers
- [x] Define default behaviors with `ON_CALL`
- [x] Profile test runtime and reduce slow tests
- [x] Leverage test parallelization and filtering

---

## Additional Resources

- [gMock Cookbook](gmock_cook_book.md) — Advanced recipes to write efficient mock code
- [Mocking Reference](docs/reference/mocking.md) — Detailed API info for expectations and behaviors
- [GoogleTest Primer](docs/primer.md) — Foundation for writing and structuring fast tests
- [Advanced GoogleTest Topics](docs/advanced.md) — Advanced debugging and performance practices

---

Feel free to explore these sections for deeper insights into maintaining efficient test suites as your project scales.
