---
title: "Performance Optimization Best Practices"
description: "Covers strategies to speed up test execution, avoid common bottlenecks, and use parallel test runs. Provides tips on using assertion macros efficiently and managing test setup/teardown for quick feedback."
---

# Performance Optimization Best Practices

GoogleTest and GoogleMock offer powerful, flexible testing frameworks, but optimal test performance depends on deliberate design and usage choices. This guide focuses on strategies to accelerate test execution, minimize bottlenecks, and use parallelism effectively while writing clear, maintainable tests. It also provides practical tips on assertion macros and managing test setup and teardown for rapid feedback.

---

## 1. Speeding Up Test Execution

Effective test performance starts with design choices that reduce unnecessary overhead and avoid slowdowns.

### 1.1 Keep Tests Small and Focused

Small, focused tests complete quickly and isolate failures effectively. Avoid overly complex tests that do excessive computation or rely on heavy dependencies.

### 1.2 Minimize Setup and Teardown Time

- Prefer using constructors and destructors in test fixtures for lightweight initialization where possible.
- Use `SetUpTestSuite` and `TearDownTestSuite` static methods to share expensive resources across tests within the same suite, eliminating repeated costly setup.
- Avoid allocating or releasing resources individually in each test when it can be shared safely.

### 1.3 Use Lightweight Fixtures

Design fixtures that hold only necessary state. Large or complex fixtures can drastically slow down tests.

### 1.4 Avoid Expensive Assertions

Only assert what you need. Complex assertions or custom matchers that do heavy computations can impact test speed.

### 1.5 Disable Logging and Debug Output in Performance Runs

Reducing logging can significantly improve runtime. Configure your test environment or use GoogleTest flags to limit output during frequent runs.

## 2. Avoiding Common Bottlenecks

### 2.1 Static Initialization and Global Variables

Static initializations that are slow or have side effects in global scope can slow down startup times. Prefer lazy initialization in `SetUpTestSuite` or fixtures.

### 2.2 Excessive Resource Allocation

Repeatedly opening files, network connections, or databases slows tests. Mock or stub out external resources where practical.

### 2.3 Heavy Use of Mock Objects

While mocks speed up integration and unit tests, overly complex mock expectations and verifications can degrade performance. Balance the use of mocks and fakes appropriately.

### 2.4 Overly Strict Expectations

Over-specifying expectations on mocks can add overhead and make tests fragile. Use `ON_CALL` for default mock behavior to reduce unnecessary complexity.

## 3. Running Tests in Parallel

Parallel execution drastically reduces total test time by leveraging multi-core processors.

### 3.1 Enable Parallel Test Runs

Use your test runner or CI system capabilities to run multiple GoogleTest binaries or test shards simultaneously. GoogleTest supports sharding through environment variables (`GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX`).

### 3.2 Splitting Tests

Organize tests in smaller binaries when possible to enable finer-grained parallelism.

### 3.3 Avoid Shared Mutable State

Tests running in parallel must be independent. Avoid global state or synchronize access.

### 3.4 Use `--gtest_break_on_failure` to Debug Parallel Tests

Stop execution on first failure for easier debugging in parallel test runs.

## 4. Using Assertion Macros Efficiently

### 4.1 Choose Between ASSERT and EXPECT Wisely

- Use `EXPECT_*` for non-fatal failures that allow other assertions to run and produce richer failure data.
- Use `ASSERT_*` when failure in one condition logically prevents further checks (e.g., pointer validity before dereferencing). Use cautiously as it aborts the test function immediately.

### 4.2 Custom Failure Messages

Add clear, actionable failure messages with `<<` to speed up debugging and reduce guesswork.

### 4.3 Avoid Expensive Expression Evaluation

Make sure assertions do not evaluate expensive computations multiple times.

### 4.4 Use Matchers for Readability and Reusability

Leverage gMock matchers (`EXPECT_THAT`) for more expressive, composable assertions, especially on container and complex types.

## 5. Managing Test Setup and Teardown for Quick Feedback

### 5.1 Efficient Fixture Setup

- Use constructors for lightweight setup, and `SetUp()` when virtual dispatch or error reporting is required.
- Prefer `SetUpTestSuite()` and `TearDownTestSuite()` for expensive setup/cleanup shared by multiple tests.

### 5.2 Avoid Setup That Depends on Other Tests

Each test must run independently. Do not rely on order or previous state for setup.

### 5.3 Use RAII and Smart Pointers

For automatic resource management and cleanup.

### 5.4 Avoid TearDown Overhead

Avoid unnecessary teardown work that doesnâ€™t benefit debugging; rely on process teardown unless cleanup matters.

## 6. Troubleshooting Common Performance Issues

### 6.1 Test Runs Are Slower Than Expected

- Check for large or numerous test fixtures.
- Look for resource contention or IO operations.
- Enable `--gtest_filter` to isolate slow tests.

### 6.2 Flaky or Intermittent Failures With Parallel Runs

- Investigate shared mutable state.
- Use synchronization primitives where needed.

### 6.3 Mock Expectation Failures

- Set expectations before exercising mocks.
- Avoid over-constraining mock calls that may be called multiple times.

<Tip>
Leverage the `--gmock_verbose=info` flag during test runs to gain detailed insight into mock method calls, matching expectations and call orders for diagnosing performance and correctness issues.
</Tip>

## 7. Best Practices Summary

- Keep tests small and focused.
- Share expensive setup using test suite fixtures.
- Use mocks judiciously; prefer `ON_CALL` for default behavior and `EXPECT_CALL` for actual verification.
- Use parallel execution via sharding and test split binaries to speed overall runs.
- Add meaningful custom assertion messages.
- Prevent side effects and shared state between tests.
- Monitor and profile test runs periodically to catch performance regressions early.

---

## Related Documentation

- [GoogleTest Primer](primer.md) for introducing test writing basics.
- [gMock for Dummies](gmock_for_dummies.md) for getting started with mocks.
- [Mocking Best Practices Guides](guides/mocking-best-practices) for mock management.
- [GoogleTest Advanced Topics](advanced.md) for fixture setup and advanced assertions.
- [GoogleTest FAQ](docs/faq.md) for common troubleshooting.
- [GoogleMock Cookbook](gmock_cook_book.md) for deep dives into mocking patterns.
- [Test Discovery and Execution](guides/getting-started/test-discovery-run.md) for parallel and filtered runs.

---

## External Resources

- GoogleTest GitHub repository: https://github.com/google/googletest
- Official GoogleTest and GoogleMock documentation website: https://google.github.io/googletest/

---

## Practical Tips

- **Run a subset of tests during active development** with `--gtest_filter` to get fast feedback.
- **Use `SetUpTestSuite()` to initialize shared heavy resources once per suite.**
- **Employ `NiceMock` to suppress warnings about uninteresting calls** during initial development.
- **Use `RetiresOnSaturation()` on expectations that should become inactive after hitting call counts** to reduce overhead.
- **Log additional information with `RecordProperty`** to help diagnose slow or failing tests.

---

## Troubleshooting Section

<AccordionGroup title="Common Performance and Mocking Issues">
<Accordion title="Test execution is unexpectedly slow">
- Check for expensive shared resource setups repeated in each test.
- Profile your test to find bottlenecks in fixtures or assertions.
- Limit expensive IO or network calls; prefer mocks.
- Run tests in parallel if supported.
</Accordion>
<Accordion title="Mock expectations not being met">
- Ensure all `EXPECT_CALL` statements are defined before exercising the mock.
- Use `--gmock_verbose=info` to diagnose mock call matching.
- Avoid over-specifying expectations to allow flexibility without flakiness.
</Accordion>
<Accordion title="Parallel test runs causing flaky tests">
- Verify tests and mocks are thread-safe.
- Avoid shared mutable globals.
- Isolate flaky tests and debug with `--gtest_break_on_failure`.
</Accordion>
</AccordionGroup>

---

By applying these strategies, you will maximize the effectiveness of GoogleTest and GoogleMock, reducing cycle times and improving confidence in your C++ code quality.
