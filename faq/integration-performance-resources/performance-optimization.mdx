---
title: "Improving Test Performance & Scalability"
description: "Tips for diagnosing slow tests and optimizing suite execution. Covers parallelization, reducing startup overhead, managing death tests, and using external tools like gtest-parallel. Helps teams scale their testing with confidence."
---

# Improving Test Performance & Scalability

This guide delivers actionable tips to diagnose slow tests and optimize the execution of your test suite in GoogleTest and GoogleMock. It focuses specifically on practical techniques such as test parallelization, minimizing startup overhead, managing resource-intensive death tests, and leveraging external tools like `gtest-parallel`. These strategies empower teams to confidently scale their testing efforts while maintaining performance and reliability.

---

## Frequently Asked Questions (FAQ)

### Why are some tests running slowly, and how can I find the cause?
Slow tests often result from expensive setup/teardown operations, excessive test dependencies, or unmanaged resource use such as I/O or global state. Start by measuring individual test durations using GoogleTest's `--gtest_output=xml` option or by adding custom timing in your tests. Profiling will highlight bottlenecks.

### How can I speed up the overall test suite execution?
Parallelize test execution across multiple CPU cores or machines to reduce wall-clock time drastically. Combine test filtering and sharding to focus on subsets of tests. Also, minimize slow fixture setup and global initialization where possible.

### What is test parallelization and how does GoogleTest support it?
Parallelization runs tests concurrently instead of sequentially. GoogleTest supports parallel execution by dividing tests into shards, controlled by the `--gtest_shard_index` and `--gtest_total_shards` flags. Each shard runs a subset of tests independently.

### How do I reduce the startup overhead for tests?
Avoid expensive global initialization in constructors or before `main()`. Use lazy initialization and avoid large static data in tests. Structured test suites help prevent repeated setup. Efficient test setup/teardown functions also reduce overhead.

### What special considerations apply to death tests?
Death tests spawn child processes to verify code termination conditions. Running many death tests sequentially can slow the suite. Parallelize them carefully to avoid resource conflicts. Use isolated fixtures and minimize the number of death tests if possible.

### How can external tools help improve test execution?
Tools like [`gtest-parallel`](https://github.com/google/gtest-parallel) facilitate running GoogleTest suites in parallel with simple command-line interfaces. They manage test distribution, failure detection, and retries, offloading complexity from your native test runner.

### Are there pitfalls when parallelizing tests?
Yes. Tests that depend on shared global state, files, or network resources can interfere if run concurrently. Ensure tests are isolated or refactor for thread safety. Use sequences or sharding to isolate problematic tests.

### How do I enable sharded test execution?
Run multiple instances of your test binary with ranges of `--gtest_shard_index` (from 0 to `--gtest_total_shards - 1`). Each instance runs a distinct portion of the test suite.

### Can I selectively exclude slow or flaky tests to improve performance?
Yes. Use test filters (`--gtest_filter`) to run only stable, faster tests during regular runs. Separate slow or flaky tests into different test suites or tags for targeted execution.

### How do I monitor test performance trends over time?
Integrate test timing outputs into your CI system. Use the XML test results reports, profiling tools, or custom instrumentation to track regressions and optimize progressively.

---

## Common Issues & Best Practices

### Managing Slow Tests
- Profile tests to identify the slowest ones.
- Break large tests into smaller, focused tests.
- Reuse fixtures and avoid unnecessary repetition.
- Cache expensive data across test runs if possible.

### Parallelization Gotchas
- Avoid tests sharing file system paths or ports.
- Use `InSequence` or `.After()` clauses cautiously when tests must be ordered.
- Balancing shard sizes to prevent uneven load.

### Startup Overhead
- Delay initialization of heavy resources.
- Minimize global/static initializations.
- Use lightweight test runners.

### Death Test Challenges
- Isolate each death test in separate processes.
- Run death tests last or in separate shards.
- Limit the number of death tests in parallel.

### Leveraging `gtest-parallel`
- `gtest-parallel` runs multiple GoogleTest binaries concurrently.
- Supports retries, crash window detection, and detailed reporting.
- Integrate into CI for scalable, efficient test runs.

---

## Step-by-Step Guide: Parallelizing Your Test Suite

<Steps>
<Step title="Measure Current Test Durations">
Use GoogleTest's XML output: run your tests with `--gtest_output=xml:results.xml` and analyze durations to spot slow tests.
</Step>
<Step title="Organize Tests Into Suites">
Group tests logically to isolate slow or flaky ones. Use test fixtures effectively to reduce overhead.
</Step>
<Step title="Enable Test Sharding">
Run your test binaries with `--gtest_total_shards=N` and `--gtest_shard_index=i` to split the suite across N shards.
</Step>
<Step title="Use External Parallel Tools">
Integrate `gtest-parallel` to manage running multiple shards or test binaries efficiently in parallel.
</Step>
<Step title="Isolate and Manage Death Tests">
Place death tests in separate test suites or shards to avoid conflicts and enable safe parallel execution.
</Step>
<Step title="Optimize Setup/Teardown Code">
Refactor slow setup to be shared or lazy. Avoid unnecessary file, database, or network operations.
</Step>
<Step title="Monitor and Iterate">
Track test execution times periodically, refine shard allocations and test structures.
</Step>
</Steps>

---

## Troubleshooting Tips

- **Tests Fail Randomly in Parallel**: Check for shared mutable state or file resource conflicts.
- **Sharding Does Not Reduce Runtime**: Verify all shards are running and tests are evenly distributed.
- **Death Tests Timing Out or Hanging**: Restrict parallel death tests or increase timeout; inspect resource contention.
- **Warnings About Uninteresting Calls in Mocks**: Use `NiceMock` or define explicit expectations, as explained in the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html#The-Nice-the-Strict-and-the-Naggy).

---

## Practical Tips & Best Practices

- Use `ON_CALL` to define default mock behaviors and `EXPECT_CALL` only when you want to verify function interaction.
- Wrap slow or resource-intensive tests in dedicated suites for selective execution.
- Avoid over-specifying expectations to minimize test fragility.
- Consider production-like resource mocks or fakes to speed up tests.
- Enable `--gtest_shuffle` to randomize test execution order and detect inter-test dependencies early.

---

## External Tools

- **gtest-parallel:** A Python-based wrapper for running tests in parallel.
  [- Repository](https://github.com/google/gtest-parallel)

---

## Related Documentation

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — Best practices and examples for mocking.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — Detailed API reference for mocks and expectations.
- [Best Practices & Integrations: Performance Optimization](https://google.github.io/googletest/guides/best-practices-integrations/performance-optimization.html) — Guide focused on large-scale test performance.
- [Death Tests Guide](https://google.github.io/googletest/concepts/advanced-testing-strategies/death-tests.html) — Writing and safely running death tests.

---

For code examples and advanced usage details, see the source code and tests in the GitHub repository:

<Source url="https://github.com/google/googletest" branch="main" paths={[{"path": "googlemock/src/gmock-spec-builders.cc", "range": "1-135"}]} />

---