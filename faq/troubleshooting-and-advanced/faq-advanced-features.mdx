---
title: "Advanced Testing, Performance, and Customization"
description: "Provides answers to frequent questions about advanced GoogleTest and GoogleMock featuresâ€”such as death tests, parameterized and type-parameterized tests, custom matchers, and optimizing test execution speed. Highlights common pitfalls and tips for maximizing test effectiveness."
---

# Advanced Testing, Performance, and Customization FAQ

This FAQ addresses frequent questions regarding advanced features in GoogleTest and GoogleMock, including death tests, parameterized and type-parameterized tests, custom matchers, and strategies for optimizing test speed and reliability. It highlights practical user concerns, common pitfalls, and recommendations to maximize test effectiveness.

---

### 1. Advanced Testing Features

#### What are death tests, and when should I use them?
Death tests verify that a program statement causes process termination under expected conditions, such as triggering an assert or an unrecoverable error. Use them to ensure your code correctly terminates when faced with invalid states.

**How to write a death test?**
Use `ASSERT_DEATH` or `EXPECT_DEATH` macros with the statement to test and a matcher for the error message on `stderr`.

```cpp
TEST(FooDeathTest, DiesOnNullPtr) {
  ASSERT_DEATH(Foo(nullptr), "null pointer exception");
}
```

**Best Practice:** Name your test suite with the suffix `DeathTest` to enable proper isolation and ordering.

---

#### What are parameterized tests and when should I use them?
Parameterized tests let you run the same test logic over multiple input values, reducing duplication and improving coverage.

- **Value-Parameterized Tests**: Use `TEST_P` and `INSTANTIATE_TEST_SUITE_P` to define tests that take varying input values.
- **Typed Tests**: Use `TYPED_TEST_SUITE` and `TYPED_TEST` to run tests across multiple types.
- **Type-Parameterized Tests**: Use `TYPED_TEST_SUITE_P`, `TYPED_TEST_P`, and `REGISTER_TYPED_TEST_SUITE_P` for tests whose type list is instantiated later.

Example of a value-parameterized test:

```cpp
class FooTest : public ::testing::TestWithParam<int> {};

TEST_P(FooTest, IsEven) {
  EXPECT_EQ(GetParam() % 2, 0);
}

INSTANTIATE_TEST_SUITE_P(EvenNumbers, FooTest, ::testing::Values(2, 4, 6));
```

**Tip:** Use descriptive parameter naming in instantiations to clarify test results.

---

#### How do I write and use custom matchers?
Custom matchers allow more expressive, reusable conditions on arguments or assertions beyond built-in ones.

You have multiple options for defining custom matchers:

- **Using MATCHER macros:** Quick and expressive for simple cases.

```cpp
MATCHER(IsDivisibleBy3, "") {
  return (arg % 3) == 0;
}
EXPECT_CALL(mock, Foo(IsDivisibleBy3()));
```

- **Defining matcher classes:** For complex state or polymorphic matching.

- **Parameterized matchers:** To pass parameters to matcher behavior.

**Use** custom matchers to:

- Validate complex object invariants
- Match combined argument conditions
- Improve failure message clarity

---

### 2. Performance Optimizations and Best Practices

#### How do I optimize test suite execution time?

- **Use test suite-level setup/teardown:** Share expensive resources among all tests in a suite using `SetUpTestSuite()` and `TearDownTestSuite()`.

- **Run tests in parallel (sharding):** Use environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` in your test runner to split tests across multiple machines.

- **Leverage parameterized and typed tests:** Reduces redundant code and improves maintainability.

- **Minimize dependencies among tests:** Avoid tests that depend on state changes from others.

- **Enable test filters and repeated runs:** Use `--gtest_filter` and `--gtest_repeat` for targeted execution.

---

#### How should I handle flaky or slow tests?

- Use `--gtest_repeat` to run tests multiple times and catch flakiness.
- Use `GTEST_FAIL_FAST` or `--gtest_fail_fast` to stop on first failure during iteration.
- Consider isolating slow tests using `DISABLED_` prefix and running separately.
- Profile and refactor tests to eliminate bottlenecks.

---

### 3. Common Pitfalls and Troubleshooting

#### What causes "uninteresting mock function call" warnings, and how to avoid them?

- These warnings occur when a mock method is called without an explicit `EXPECT_CALL` set on it.
- **Best practice:**
  - Use `ON_CALL` to specify default behaviors for mock methods.
  - Add a catch-all expectation with `EXPECT_CALL(mock, Method(_)).Times(AnyNumber())` if you want to ignore warnings for some methods.
  - Use `NiceMock` to suppress all uninteresting call warnings on a mock object.

Avoid adding unnecessary `EXPECT_CALL`s just to silence warnings as it can make tests brittle.

---

#### How do I verify that subroutine ASSERT failures abort the entire test?

Since `ASSERT_*` failures abort only the current function, the test may continue unexpectedly. To address this:

- Use `ASSERT_NO_FATAL_FAILURE(subroutine_call());` to verify subroutine does not generate fatal failures.
- Check `HasFatalFailure()` after subroutine call and return early if true.
- Alternatively, use a test event listener to throw exceptions on fatal failure.

---

#### What should I know about mocking methods with move-only types?

- Use the standard `MOCK_METHOD` macro syntax exactly as with other methods.
- For actions returning move-only types, prefer lambdas or `WillOnce` with factory functions.

```cpp
EXPECT_CALL(mock, Method()).WillOnce([]() {
  return std::make_unique<Foo>();
});
```

- For move-only arguments, you can match normally but some built-in actions may not support move-only types fully.
- Legacy workarounds include delegating calls to mock methods accepting raw pointers.

---

### 4. Useful Tips

#### How to organize expectations and actions for maintainable tests?

- Prefer setting default mock behavior in test fixture `SetUp()` using `ON_CALL`.
- Set expectations (`EXPECT_CALL`) sparingly to verify essential interactions only.
- Use `RetiresOnSaturation()` to make expectations non-sticky and avoid upper bound violations.
- Use sequences (`InSequence`) or `After` clauses to enforce call order only when necessary.
- Name test suites and tests clearly to indicate purpose, including death tests with `DeathTest` suffix.

---

#### How can I extend GoogleTest with event listeners?

- Derive from `testing::EmptyTestEventListener` or `testing::TestEventListener`.
- Override callbacks such as `OnTestStart()`, `OnTestEnd()`, and `OnTestPartResult()`.
- Add listener instances via `UnitTest::GetInstance()->listeners().Append(...)` in `main()` before running tests.

This enables capturing custom test output formats, integrating with CI, or adding logging and resource checks.


### Related Documentation
- [Death Tests](../advanced.md#death-tests)
- [Parameterized and Typed Tests](../advanced.md#value-parameterized-tests), [Typed Tests](../advanced.md#typed-tests), [Type-Parameterized Tests](../advanced.md#type-parameterized-tests)
- [Writing Custom Matchers](../gmock_cook_book.md#NewMatchers)
- [Mocking Best Practices](../guides/mocking-and-test-doubles/best-practices-for-mocking.mdx)
- [Performance and Scalability](../concepts/integration-and-performance/performance-scalability.mdx)
- [Advanced Assertions and Matchers](../guides/core-testing-workflows/advanced-assertions-and-matchers.mdx)

---

<Tip>
Maximize your testing efficiency by leveraging parameterized tests and carefully crafted mock expectations. Use death tests to assert code safety under failures and apply performance tips to scale your test suite without sacrificing reliability.
</Tip>
<Note>
This page complements foundational knowledge found in the GoogleTest Primer and Advanced Guides. For issues related to setup or build, see the Installation and Setup FAQ sections.
</Note>