---
title: "How do I write and run my first test?"
description: "Step-by-step walkthrough of writing a simple test case, compiling it, and executing it. Eliminates uncertainty for new users so they can achieve quick success."
---

# How do I write and run my first test?

Welcome to the first step on your journey with GoogleTest! This guide provides a clear, step-by-step walkthrough to help you write a simple test case, compile it, and successfully execute it with confidence. By following these instructions, you will eliminate any uncertainty and achieve quick success in building robust C++ tests.

---

## 1. Writing a Simple Test

### What is a Test in GoogleTest?

A test verifies that a piece of your program behaves as expected under certain conditions. GoogleTest organizes tests into *test suites* (groups of related tests).

### Creating Your First Test Case

You write a test using the `TEST` macro, which takes two parameters:

- The **test suite name** (a group name for your tests).
- The **test name** (the specific test's identifier).

Both should be valid C++ identifiers and should not contain underscores `_`.

```cpp
#include <gtest/gtest.h>

// A simple function to test
int Factorial(int n) {
  return n <= 1 ? 1 : n * Factorial(n - 1);
}

// Test suite: FactorialTest, Test case: HandlesZeroInput
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}

// Test suite: FactorialTest, Test case: HandlesPositiveInput
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(2), 2);
  EXPECT_EQ(Factorial(3), 6);
  EXPECT_EQ(Factorial(8), 40320);
}
```

> ‚úÖ **Tip:** Use `EXPECT_` assertions when you want your test to continue after failures, and `ASSERT_` if continuing after failure does not make sense (e.g., dereferencing a null pointer).

---

## 2. Using Test Fixtures for Shared Setup

When multiple tests share common setup, use a *test fixture* ‚Äî a class derived from `testing::Test` that lets you declare setup/teardown logic and reusable objects.

### Defining a Test Fixture

```cpp
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
    // Shared setup for each test
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  // You can define per-test setup and teardown if needed
  void SetUp() override {}
  void TearDown() override {}

  Queue<int> q0_;  // Empty queue
  Queue<int> q1_;  // One item
  Queue<int> q2_;  // Two items
};
```

### Writing Tests with Fixtures

Use `TEST_F` instead of `TEST`, and pass the fixture class name as the first argument:

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);  // Fatal failure stops test if nullptr
  EXPECT_EQ(*n, 1);
  delete n;
}
```

### What Happens When Tests Run

1. GoogleTest creates a new fixture instance for each test.
2. Calls its constructor and `SetUp()`.
3. Runs the test body.
4. Calls `TearDown()` and deletes the fixture instance.

> üîç **Note:** Test fixture instances are never shared or reused between tests to avoid dependencies.

---

## 3. Compiling Your Test Program

To compile your tests, link with the GoogleTest libraries. Example using `g++` and CMake configurations:

```bash
# Assuming googletest headers and libs are installed and accessible
# Simple command line example:
g++ -std=c++17 my_test.cc -lgtest -lgtest_main -pthread -o my_test
```

If using CMake, add the following to your CMakeLists.txt:

```cmake
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})
add_executable(my_test my_test.cc)
target_link_libraries(my_test ${GTEST_LIBRARIES} pthread)
```

### Writing a `main` Function

Most users link with the `gtest_main` library which provides a default `main()` that runs all tests. If you need custom setup, write your own:

```cpp
#include <gtest/gtest.h>

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();  // Runs all tests and returns success/fail status
}
```

> ‚úÖ **Tip:** Always return the value of `RUN_ALL_TESTS()` from `main()`. It returns `0` if all tests pass, otherwise `1`.

---

## 4. Running Your Tests

Once compiled, simply execute your test binary:

```bash
./my_test
```

The output highlights:

- Tests that pass or fail.
- Detailed error messages and source code locations on failures.

Example output snippet:

```none
[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from FactorialTest
[ RUN      ] FactorialTest.HandlesZeroInput
[       OK ] FactorialTest.HandlesZeroInput (0 ms)
[ RUN      ] FactorialTest.HandlesPositiveInput
[  FAILED  ] FactorialTest.HandlesPositiveInput (0 ms)
[----------] 2 tests from FactorialTest (0 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 1 test.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] FactorialTest.HandlesPositiveInput

 1 FAILED TEST
```

> üîç **Note:** Test order is not guaranteed; tests should be independent (idempotent setup).

---

## 5. Best Practices to Avoid Common Pitfalls

- Avoid underscores in test suite and test names; GoogleTest uses underscore specially.
- Use `ASSERT_*` when failure should abort the current test function early.
- Use `EXPECT_*` to continue after failure and catch multiple issues in one run.
- Keep tests independent; do not rely on test execution order.
- If you need shared expensive resources, use test fixtures with per-test or per-suite setup.
  - Per-suite shared setup is done by defining static `SetUpTestSuite()` and `TearDownTestSuite()`.
- Use streaming with assertions to add custom failure details, e.g., 

```cpp
EXPECT_EQ(result, expected) << "Failed on input " << input_val;
```

- Disable tests temporarily by prefixing names with `DISABLED_` if you cannot fix immediately.
- Run tests with filtering and other flags (see `--help` flag) to manage test execution.

---

## 6. Troubleshooting Your First Tests

- If tests are not discovered, verify compilation includes `gtest` and the macros are used properly.
- Make sure to call `testing::InitGoogleTest()` before `RUN_ALL_TESTS()`.
- Check that your `main()` function returns the value of `RUN_ALL_TESTS()`.
- To run a specific test:

```bash
./my_test --gtest_filter=FactorialTest.HandlesZeroInput
```

- Use `--gtest_list_tests` to list all tests.

---

## 7. Next Steps

- Explore writing tests using fixtures (`TEST_F`), parameterized tests (`TEST_P`), and typed tests.
- Learn advanced assertions for richer test validations.
- Study the [GoogleTest Primer](../overview/introduction-core-value/what-is-googletest) for foundational concepts.
- Refer to the [First Steps & Validation](../getting-started/first-steps-validation) section for setup and troubleshooting.
- Dive into mock object creation to simulate dependencies with GoogleMock.

---

## Related Documentation & Resources

- [GoogleTest Primer](overview/introduction-core-value/what-is-googletest)
- [Writing Your First Unit Test](guides/getting-started-workflows/first-cpp-test)
- [Test Macros & Assertions Reference](api-reference/core-testing-api/test-macros-assertions)
- [Building and Running Tests](guides/getting-started-workflows/building-and-running-tests)
- [Troubleshooting Setup Issues](getting-started/first-steps-validation/troubleshooting-setup)
- [FAQ on Writing and Running Tests](faq/getting_started_and_core_usage/how_do_i_write_and_run_my_first_test)

---

By following this guide, you confidently move from zero to writing and running your first GoogleTest test cases, laying the foundation for scalable, maintainable test suites.
