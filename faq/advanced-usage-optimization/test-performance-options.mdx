---
title: "How can I speed up and optimize my test runs?"
description: "Learn how to organize fast and stable test executions, including advice on parallelization, resource usage, and leveraging features like death tests and parameterized tests for thorough yet efficient validation."
---

# How can I speed up and optimize my test runs?

Efficient and stable test execution is vital to maintaining productive development cycles. This page guides you in organizing your tests to run fast and reliably by leveraging GoogleTest and GoogleMock’s capabilities—including parallel execution, resource management, selective test running, and advanced test constructs like death tests and parameterized tests.

---

## 1. Optimize Test Execution Workflow

### Leverage Parallel Test Execution
GoogleTest supports running tests in parallel to fully utilize available CPU cores. Running tests concurrently reduces total test suite execution time dramatically.

- **How to enable?**
  Use the `--gtest_parallel` or external tools integrating with the test runner.
- **Considerations:**
  - Isolate tests to avoid shared state, as parallel runs assume tests are independent.
  - Use test fixtures to reuse setup and teardown safely.

<Tip>
Parallel test execution accelerates feedback but requires careful design to avoid flaky tests due to shared resources.
</Tip>

### Selective Test Runs and Filtering
Speed up by running only relevant subsets of tests during development or CI iterations.

- Use `--gtest_filter` to specify which test suites or individual tests to run, e.g.,
  ```
  ./my_tests --gtest_filter=MyTestSuite.*
  ```
- Combine filters with wildcards to include or exclude tests.

<Tip>
Filter your tests often during iterative development to avoid waiting on the entire suite.
</Tip>

### Test Sharding
GoogleTest supports sharding large test suites into partitions to run distributed or segmented tests.

- Control shards using `--gtest_shard_index` and `--gtest_total_shards` flags.
- Use in CI to split tests across agents.

### Run Tests Repeatedly or in a Loop
Execute tests multiple times to identify flaky or intermittent failures.

- Use the `--gtest_repeat` flag.

---

## 2. Manage Resource Usage for Stable Runs

### Avoid Test Interference
Tests should be isolated and stateless to safely execute in parallel and in any order.

- Avoid global/static mutable state.
- Employ proper setup and teardown in fixtures.
- For shared resources, use synchronized access or design tests to be independent.

### Control Verbosity and Logging
Verbose logs help troubleshooting but increase runtime. Tune verbosity as follows:

- Use `--gmock_verbose=warning` (default) to limit output.
- For debugging, increase verbosity to `info` to see mock call matching.

### Mock Lifecycle Handling
Ensure mocks are properly created and destroyed to avoid memory leaks and test pollution.

- Use stack-based mocks or smart pointers.
- Leverage `Mock::VerifyAndClearExpectations()` to force verification early.

---

## 3. Use Advanced Test Features Judiciously

### Death Tests
These validate code behavior under crash or assertion failure conditions.

- Run in isolated subprocesses to avoid affecting test harness.
- Be mindful: death tests are slower due to process creation.

<Tip>
Use death tests sparingly and isolate them from the main suite if you want faster runs.
</Tip>

### Parameterized Tests
Run the same test logic with multiple input values for comprehensive coverage without duplication.

- Use `TEST_P` to define parameterized test cases.
- Helps to reduce the number of test functions while increasing coverage.

<Tip>
Use parameterized tests to balance coverage with test run time by reusing test logic.
</Tip>

### Test Sequences and Ordering
Control call order between mocks/tests using sequences (`Sequence`, `InSequence`) to enforce partial or full ordering.

- Overly strict orderings may slow down tests; balance order requirements carefully.

---

## 4. Practical Tips & Best Practices

<AccordionGroup title="Common Tips to Speed Up Test Runs">
<Accordion title="Start with Fast, Targeted Tests">
Run small, focused tests that verify critical units first. Avoid large integration tests unless necessary.
</Accordion>
<Accordion title="Use ON_CALL for Default Behavior">
Set default mock behaviors with `ON_CALL` and selectively specify `EXPECT_CALL` for verification. This minimizes unnecessary constraints and speeds set-up.
</Accordion>
<Accordion title="Leverage Mock Strictness Levels">
Use `NiceMock` to suppress warnings in noisy mocks and `StrictMock` only in critical situations to prevent flaky tests.
</Accordion>
<Accordion title="Avoid Over-Specification of Expectations">
Write expectations that verify only necessary interactions, avoiding brittle tests that fail on refactors.
</Accordion>
<Accordion title="Run `RUN_ALL_TESTS()` Only Once">
Multiple invocations of `RUN_ALL_TESTS()` conflict with advanced features and result in errors.
</Accordion>
</AccordionGroup>

---

## 5. Troubleshooting Test Performance Issues

### Common Causes

- Tests that share or mutate global state causing flakiness.
- Mock objects with unfulfilled or overly strict expectations causing hangs or delays.
- Overuse of death tests or long-running parameterized tests.

### Diagnostics

- Use `--gmock_verbose=info` to trace mock matching and expectations.
- Employ profiling tools to identify slow tests or bottlenecks.

### Resolution Steps

- Isolate flaky tests, refactor shared resources.
- Use `.RetiresOnSaturation()` to retire expectations and avoid sticky failures.
- Reduce verbosity during normal runs, increase for debugging only.

---

## 6. Example: Enabling Fast Test Runs

```bash
# Run only tests in MySuite, repeat 10 times to check stability, using 4 shards parallelism
./my_tests --gtest_filter=MySuite.* --gtest_repeat=10 --gtest_total_shards=4 --gtest_shard_index=0
```

Make sure your tests are independent and cleanly handle resources for this to work reliably.

---

## Additional Resources

- [Test Execution and Scaling Guide](concepts/flexibility-and-integration/test-execution-and-scaling.mdx)
- [GoogleMock Best Practices for Reliability & Scalability](guides/best-practices/reliability-scalability.mdx)
- [GoogleTest Primer](docs/primer.md)
- [Mocking Basics](guides/getting-started/mocking-basics.mdx)
- [Debugging and Performance Optimization Guide](guides/best-practices/performance.mdx)

---

Optimize your test runs by carefully designing your test suites with speed, isolation, and maintainability in mind. Harness GoogleTest’s filtering, parallel execution, and sharding features to get fast and thorough feedback.


