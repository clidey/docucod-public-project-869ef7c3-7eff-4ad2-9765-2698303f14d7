---
title: "How do I write custom assertions or matchers?"
description: "Guides users through the process of extending GoogleTest and GoogleMock with user-defined assertions or matchers to support domain-specific test scenarios, improving expressiveness and coverage."
---

# How do I write custom assertions or matchers?

Extending GoogleTest and GoogleMock with user-defined assertions or matchers empowers you to express domain-specific test logic cleanly and improve test expressiveness and coverage. This guide walks you through creating custom matchers and assertions tailored to your testing scenarios, using GoogleMock's flexible matcher framework.

---

## Why write custom matchers?

Built-in matchers handle common scenarios but may not cover all your domain logic. Custom matchers enable you to:

- Validate complex conditions on arguments passed to mocked methods.
- Encapsulate reusable verification logic with readable failure messages.
- Compose more expressive and maintainable tests.

Imagine you want to check if a number is divisible by 7 frequently; writing this logic inline repeatedly clutters your tests. A custom matcher `IsDivisibleBy7()` lets you write:

```cpp
EXPECT_CALL(mock, SomeMethod(IsDivisibleBy7()));
EXPECT_THAT(value, IsDivisibleBy7());
```

providing clearer intent and better diagnostics.

---

## Creating custom matchers quickly with MATCHER macros

GoogleMock provides a concise and powerful way to define new matchers using the `MATCHER` and `MATCHER_P` family of macros.

### Defining a simple matcher

The `MATCHER` macro creates a polymorphic matcher with an intuitive syntax:

```cpp
MATCHER(Name, "description") {
  // 'arg' is the value being matched.
  return (arg % 7) == 0;
}
```

Usage:

```cpp
EXPECT_CALL(mock, Func(Name()));
EXPECT_THAT(value, Name());
```

If the match fails, the error message incorporates the description string or generates one from the matcher name.

### Adding custom failure messages

You may provide more detailed failure diagnostics by streaming explanatory text to `*result_listener`:

```cpp
MATCHER(IsDivisibleBy7, "") {
  if ((arg % 7) == 0)
    return true;
  *result_listener << "the remainder is " << (arg % 7);
  return false;
}
```

Now failed assertions show exactly why the match failed.

### Parameterized matchers

Use `MATCHER_P` to define matchers with parameters for flexibility:

```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return std::abs(arg) == value;
}
```

Usage example:

```cpp
EXPECT_THAT(x, HasAbsoluteValue(10));
```

You can extend this pattern up to 10 parameters using `MATCHER_P2`, `MATCHER_P3`, ..., `MATCHER_P10`.

### Writing expressive descriptions

For parameterized matchers, include the parameter values in failure descriptions by referencing `param_name` and `negation` in the description string.

Example:

```cpp
MATCHER_P2(InClosedRange, low, high,
  absl::StrFormat("%s in range [%s, %s]", negation ? "isn't" : "is",
                  PrintToString(low), PrintToString(high))) {
  return low <= arg && arg <= high;
}
```

---

## Defining custom matcher classes

For advanced scenarios or widely reused domain matchers, define a matcher class implementing GoogleTest's matcher interface:

- Implement `bool MatchAndExplain(const T& value, std::ostream* listener) const` to define matching logic.
- Implement `void DescribeTo(std::ostream* os) const` to describe successful match expectations.
- Implement `void DescribeNegationTo(std::ostream* os) const` to describe negated expectations.
- Include typedef `using is_gtest_matcher = void;` for integration.

Example:

```cpp
class DivisibleBy7Matcher {
 public:
  using is_gtest_matcher = void;

  bool MatchAndExplain(int n, std::ostream* os) const {
    if (n % 7 != 0) {
      if (os != nullptr) {
        *os << "the remainder is " << (n % 7);
      }
      return false;
    }
    return true;
  }

  void DescribeTo(std::ostream* os) const {
    *os << "is divisible by 7";
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os << "is not divisible by 7";
  }
};

::testing::Matcher<int> IsDivisibleBy7() {
  return ::testing::Matcher<int>(new DivisibleBy7Matcher());
}
```

Use with:

```cpp
EXPECT_THAT(number, IsDivisibleBy7());
```

---

## Extending parameterized matchers to polymorphic matchers

To allow matchers to work with multiple types (polymorphic), template the matching method:

```cpp
template <typename T>
bool MatchAndExplain(const T& value, std::ostream* os) const {
  // polymorphic matching logic
}
```

This lets your matcher adapt to different types as needed.

---

## Working with complex matchers

You can compose matchers by:

- Using combinators like `AllOf()`, `AnyOf()`, `Not()`, etc.
- Validating container elements with matchers such as `ElementsAre()`, `Contains()`, and `Each()`.
- Matching object fields or properties using `Field()` and `Property()` matchers.

These are documented in the [Matchers Reference](https://google.github.io/googletest/reference/matchers.html).

---

## Best practices and tips

- **Keep matchers pure**: Custom matchers must have no side effects and deterministic results.
- **Make organized error messages**: Use detailed failure explanations with `result_listener` or `MatchAndExplain`.
- **Parameterize wisely**: Use parameterized matchers to maximize code reuse and readability.
- **Leverage GoogleMock macros**: Prefer the `MATCHER` family macros for quick matcher creation.
- **Test your matcher**: Verify your custom matcher works correctly across various input cases.
- **Consider performance impact**: Avoid heavy computations in matchers for critical test paths.

---

## Where to learn more and related topics

- [gMock Cookbook - Writing New Matchers Quickly](https://google.github.io/googletest/gmock_cook_book.html#Writing-New-Matchers-Quickly)
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html)
- [GoogleTest Primer - Using Predicates and Predicate Formatters](https://google.github.io/googletest/primer.html#predicate-assertions)
- [Writing Clear and Effective Assertions Guide](https://google.github.io/googletest/guides/integration_and_best_practices.html#writing-clear-and-effective-assertions)

By adopting custom matchers and assertions in your tests, you gain precise, expressive, and maintainable test logic tailored to your project needs, leading to better test reliability and developer productivity.
