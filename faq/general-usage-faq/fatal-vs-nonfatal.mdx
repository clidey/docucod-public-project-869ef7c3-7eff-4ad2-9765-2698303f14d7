---
title: "Fatal vs. Non-Fatal Failures"
description: "Clarifies how the framework treats fatal and non-fatal assertions, how that affects test execution, and how users can choose the right strategy for their needs."
---

# Fatal vs. Non-Fatal Failures

Understanding how GoogleTest handles fatal and non-fatal failures is key to designing tests that behave predictably and provide meaningful feedback during execution. This page clarifies the distinction between these failure types, their effect on test execution flow, and how to choose the right assertion style based on your testing needs.

---

## What Are Fatal and Non-Fatal Failures?

- **Fatal Failures:** Triggered by assertions prefixed with `ASSERT_` or macros like `FAIL()`. When a fatal failure occurs, the current test function is immediately aborted, skipping any subsequent statements within that function. This acts as a hard stop signaling that continuing the test is unsafe or unnecessary due to a critical error.

- **Non-Fatal Failures:** Triggered by assertions prefixed with `EXPECT_` or macros like `ADD_FAILURE()`. The test records the failure but continues executing the current function, allowing multiple checks to run and report all encountered problems.

These behaviors provide flexibility:

- Use **fatal failures** to protect critical assumptions that, if violated, invalidate the remainder of the test.
- Use **non-fatal failures** when you want to gather comprehensive failure information without prematurely terminating the test.

## How Failures Affect Test Execution Flow

When a test function starts executing:

1. It runs until it either returns normally or encounters a fatal failure.
2. Upon a **fatal failure**, the function returns immediately; no further code or assertions in that function run.
3. Upon a **non-fatal failure**, the failure is recorded, but execution proceeds.
4. Failures do not stop other tests from running; they are scoped to the test where they occur.

### Example Illustration

```cpp
TEST(CalculatorTest, Division) {
  int result = Divide(10, 5);
  EXPECT_EQ(result, 2);              // Non-fatal failure example
  ASSERT_NE(result, 0) << "Result should not be zero";  // Fatal failure example
  // The following line won't execute if ASSERT_NE fails
  double reciprocal = 1.0 / result;
  EXPECT_NEAR(reciprocal, 0.5, 1e-6);
}
```

- If `EXPECT_EQ` fails, the test continues to `ASSERT_NE`.
- If `ASSERT_NE` fails, the test aborts immediately, and the code after it is skipped.

## Selecting the Right Failure Type

Your choice between fatal and non-fatal assertions should reflect the desired test thoroughness and safety:

| Scenario                                   | Recommendation                      |
|--------------------------------------------|-----------------------------------|
| Verifying crucial preconditions             | Use **fatal** assertions (e.g., `ASSERT_*`) to avoid undefined behavior or cascading errors.
| Wanting to test multiple conditions independently | Use **non-fatal** assertions (e.g., `EXPECT_*`) to report all failures in one run.
| Checking side effects without aborting test | Use **non-fatal** assertions.

### Best Practices

- Prefer **fatal assertions** when further execution depends on them.
- Prefer **non-fatal assertions** when failures do not destabilize test logic.
- Avoid placing fatal assertions inside constructors or destructors since they are non-void functions and fatal assertions cause compile errors in these.
- Use helper macros like `EXPECT_NONFATAL_FAILURE()` or `EXPECT_FATAL_FAILURE()` when testing that code triggers the appropriate type of failure.

## Assertion Macros and Their Effects

GoogleTest provides pairs of macros: `EXPECT_*` and `ASSERT_*` for most assertions.

| Macro Pair                 | Failure Type       | Effect on Test Flow                         |
|-----------------------------|--------------------|---------------------------------------------|
| `EXPECT_*`                  | Non-fatal           | Records failure; test continues execution  |
| `ASSERT_*`                  | Fatal               | Aborts current function; test continues with next test |
| `FAIL()`                   | Fatal               | Triggers immediate fatal failure           |
| `ADD_FAILURE()`             | Non-fatal           | Adds non-fatal failure; continues execution |

See also the explicit success macro `SUCCEED()`, which generates an explicit success record but does not affect test flow.

## Catching Failures in Subroutines

Because fatal failures abort only the current function:

```cpp
void CheckValue(int x) {
  ASSERT_GT(x, 0);  // Fatal failure aborts CheckValue but not the caller
  // This code won't run if x <= 0
}

TEST(MyTest, UseCheckValue) {
  CheckValue(-1);     // This triggers fatal failure in CheckValue
  // Code below will still run, potentially causing undefined behavior
  DoSomethingDangerous();
}
```

To propagate fatal failures in subroutines, you have options:

- Use **exceptions** to abort the entire test on failures.
- Use `ASSERT_NO_FATAL_FAILURE()` / `EXPECT_NO_FATAL_FAILURE()` to check if a subroutine generates fatal failures.
- Check `HasFatalFailure()` after calling subroutines to decide whether to continue.

Example with `ASSERT_NO_FATAL_FAILURE()`:

```cpp
TEST(MyTest, PropagateFatalFailures) {
  ASSERT_NO_FATAL_FAILURE(CheckValue(-1));
  // Only runs if CheckValue did not abort test
  DoSomethingSafe();
}
```

## Streaming Failure Messages

All assertion macros support streaming additional failure messages with `<<` operators for greater clarity.

```cpp
EXPECT_EQ(foo, bar) << "foo and bar must match for this test.";
ASSERT_TRUE(is_ready) << "Test setup failed due to ready flag not set.";
```

This message will appear only if the assertion fails.

## Tips and Common Pitfalls

- **Don’t use fatal assertions** in constructors or destructors; instead, place fatal assertions in `SetUp()` / `TearDown()`.
- **Don’t depend** on order of test execution; each test must be independent.
- Use **non-fatal failures** to continue and collect multiple failures within a test.
- Fatal failures do **not terminate all tests**; only abort the current test function.
- When testing that a failure happens, use `EXPECT_FATAL_FAILURE()` and `EXPECT_NONFATAL_FAILURE()` macros from `gtest-spi.h`.
- Be mindful of threading when using assertions and catching failures.

## How GoogleTest Tracks Failures

GoogleTest internally records each failure's type (fatal or non-fatal), message, file, and line number. You can inspect or manipulate this via the advanced [`TestPartResult`](reference/testing.md#TestPartResult) interface if extending or writing custom reporters/listeners.

## Further Reading and Related Documentation

- [GoogleTest Assertions Reference](reference/assertions.md)
- [Catch Failures in Subroutines](advanced.md#adding-traces-to-assertions)
- [Writing Death Tests](guides/writing-effective-tests/death-tests)
- [GoogleTest FAQ: Fatal vs Non-Fatal Failures](faq/general-usage-faq/fatal-vs-nonfatal)

---

## Troubleshooting

### Assertion Fails but Test Continues
Make sure you understand the failure type:
- `EXPECT_*` failures are non-fatal — test continues.
- `ASSERT_*` failures abort the current function only.

Use `HasFatalFailure()` to check if a fatal failure has occurred.

### Compilation Errors in Constructors/Destructors
Fatal assertions are illegal in constructors/destructors (which are non-void functions).
Move such assertions to `SetUp()` or `TearDown()` methods.

### Unexpected Continuation After Fatal Failure
Remember fatal failure only abort the current function, not the entire test. Protect with `if (HasFatalFailure()) return;` if needed.

---