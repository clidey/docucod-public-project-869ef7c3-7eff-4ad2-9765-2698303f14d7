---
title: "Assertions and Matchers FAQ"
description: "Clarifies the use of built-in and custom assertions and matchers, explaining differences between fatal and non-fatal failures, matcher composition, and resolving common assertion failures."
---

# Assertions and Matchers FAQ

This FAQ clarifies the use of built-in and custom assertions and matchers in GoogleTest, helping you understand fatal vs. non-fatal failures, compose matchers effectively, and resolve common assertion failures.

---

## 1. What are the differences between fatal and non-fatal assertion failures?

- **Fatal Failures (`ASSERT_*`, `FAIL()`)** abort the current function immediately, stopping test execution inside that function to avoid undefined behavior.
- **Non-fatal Failures (`EXPECT_*`, `ADD_FAILURE()`)** report the failure but allow the function to continue running.

**Important Notes:**
- Fatal assertions can only be used in `void`-returning functions; using them in non-void functions will cause difficult-to-understand compile errors.
- To propagate fatal failures from subroutines (which only abort those functions), use `ASSERT_NO_FATAL_FAILURE()` or check `HasFatalFailure()` after calls.
- Constructors and destructors do not support fatal assertions - use `SetUp()` and `TearDown()` methods instead.

**Example:**
```cpp
void Helper() {
  ASSERT_EQ(1, 2);  // aborts Helper(), not the test
  // code below will not run
}

TEST(FooTest, Example) {
  Helper();
  if (HasFatalFailure()) return;  // abort test if helper failed
  // continue test safely
}
```

---

## 2. How do I use matchers with assertions?

Matchers provide flexible, expressive conditions to verify argument values or test results.

- Use `EXPECT_THAT(value, matcher)` to verify a value against a matcher.
- Built-in matchers include `Eq()`, `Ne()`, `StartsWith()`, `HasSubstr()`, `ElementsAre()`, etc.
- Combined matchers like `AllOf()`, `AnyOf()`, and `Not()` let you express complex conditions.

**Example:**
```cpp
EXPECT_THAT(foo_string, StartsWith("Hello"));
EXPECT_THAT(numbers, ElementsAre(1, _, Ge(5)));
```

Advanced matchers support tuples, containers, and custom types for rich testing scenarios.

---

## 3. What are predicate assertions and when should I use them?

Predicate assertions (`EXPECT_PRED*`) test conditions where typical matchers don't fit, especially for complex logic.

- Predicate assertion macros call a user-defined Boolean function and display argument values on failure.
- `EXPECT_PRED_FORMAT*` enable writing predicate-formatters that return `AssertionResult` with custom failure messages.

**Why use predicate assertions?**
- Provide clear, informative failure messages showing argument values.
- Avoid writing raw `EXPECT_TRUE()` with opaque failure information.

**Example:**
```cpp
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) return testing::AssertionSuccess();
  else return testing::AssertionFailure() << n << " is odd";
}

EXPECT_TRUE(IsEven(value));
```

On failure, you get output like:
```
Value of: IsEven(value)
  Actual: false (3 is odd)
Expected: true
```

---

## 4. How can I combine multiple matchers logically?

You can express sophisticated expectations by combining matchers:

- `AllOf(m1, m2, ...)` requires **all** matchers to succeed.
- `AnyOf(m1, m2, ...)` requires **at least one** matcher to succeed.
- `Not(m)` inverts matcher meaning.

**Example:**
```cpp
EXPECT_THAT(value, AllOf(Gt(0), Lt(10), Not(Eq(5))));
```

---

## 5. What is the meaning of `EXPECT_THAT` vs `EXPECT_EQ`?

- `EXPECT_EQ(a, b)` does an equality check using `operator==`, printing both values on failure.
- `EXPECT_THAT(value, matcher)` uses a *matcher* to specify conditions beyond simple equality, supporting compositional logic, container matching, regex, and more.

Use `EXPECT_THAT` for expressive assertions that read like English and provide better diagnostics.

---

## 6. How do I deal with floating-point comparisons?

Due to rounding, exact equality is usually inappropriate for floating-point values. Use specialized assertions:

- `EXPECT_FLOAT_EQ(val1, val2)` compares floats within 4 Units in Last Place (ULPs).
- `EXPECT_DOUBLE_EQ(val1, val2)` compares doubles within 4 ULPs.
- `EXPECT_NEAR(val1, val2, abs_error)` checks absolute difference against a tolerance.

For complex conditions, use floating-point matchers with `EXPECT_THAT`, e.g.: 
```cpp
EXPECT_PRED_FORMAT2(FloatLE, val1, val2);
```

---

## 7. What if I want to assert that a piece of code throws or does not throw exceptions?

Use exception assertions (require exceptions enabled in compiler):

- `EXPECT_THROW(statement, exception_type)` expects an exception of that type.
- `EXPECT_ANY_THROW(statement)` expects any exception.
- `EXPECT_NO_THROW(statement)` expects no exception.

Example:
```cpp
EXPECT_THROW({ Foo(); }, std::runtime_error);
```

---

## 8. How to write death tests that verify program termination?

Use death assertions to verify that code terminates in expected ways:

- `EXPECT_DEATH(statement, regex)` expects `statement` to terminate with stderr matching `regex`.
- `EXPECT_EXIT(statement, predicate, regex)` expects termination with status predicate and stderr matching.

See [Death Tests](../advanced.md#death-tests) for patterns and caveats.

---

## 9. How do I teach GoogleTest to print my custom types?

By default, GoogleTest prints values that overload `operator<<`. For custom types:

- Define a `PrintTo(const T& value, std::ostream* os)` function in the same namespace.
- Or provide an `AbslStringify` friend function if using Abseil formatting.

Example:
```cpp
namespace my_ns {
class Point {
  int x, y;
  friend void PrintTo(const Point& p, std::ostream* os) {
    *os << "(" << p.x << "," << p.y << ")";
  }
};
}
```

---

## 10. How do I get more detailed tracebacks on assertion failure for debugging?

Use `SCOPED_TRACE(message)` to add context information on assertion failures inside nested calls:

```cpp
SCOPED_TRACE("Checking subroutine with input 5");
EXPECT_EQ(Foo(5), 42);
```

GoogleTest will print the trace message with any failed assertion in the scope.

---

## 11. How to check whether a subroutine containing fatal assertions caused failure?

Use:

- `ASSERT_NO_FATAL_FAILURE(statement)` to assert no fatal failures happened inside `statement`.
- `testing::Test::HasFatalFailure()` to check if any fatal assertions occurred so far.

This helps in propagating assertion failures across function calls.

---

## 12. What are some common pitfalls with assertions?

- Fatal assertions cannot be used in non-`void` functions.
- Fatal assertions inside constructors or destructors cause compilation errors.
- Assertions that generate failure messages with side-effects can be problematic.
- Do not mix `EXPECT_CALL` and code calls; expectations must be set before invoking the mock method.

---

## 13. How do I verify mock expectations before mock object destruction?

Use `Mock::VerifyAndClearExpectations(&mock_object)` to explicitly verify that all expectations on a mock have been met and clear them. This is useful if the mock may leak or be destroyed later.

---

## 14. How do I write custom matchers?

GoogleTest allows quick custom matcher definitions using `MATCHER` macros.

**Basic example:**
```cpp
MATCHER(IsDivisibleBy7, "checks divisibility by 7") {
  return (arg % 7) == 0;
}
EXPECT_CALL(mock, Func(IsDivisibleBy7()));
```

For parameterized matchers:
```cpp
MATCHER_P(HasAbsoluteValue, value, "") {
  return abs(arg) == value;
}
EXPECT_THAT(x, HasAbsoluteValue(10));
```

You can add detailed failure information by streaming to `result_listener` inside the matcher.

---

## 15. What should I do if an assertion uses complex expressions?

If you find yourself using raw `EXPECT_TRUE()` with complex expressions:
- Use predicate assertions or `EXPECT_PRED_FORMAT*` for better error messages.
- Consider writing a custom matcher to encapsulate the logic.

Example:
```cpp
EXPECT_PRED_FORMAT2(MyComplexPredicate, arg1, arg2);
```

---

## 16. How do I handle assertions that must be skipped or result in early test exits?

Use `GTEST_SKIP()` to skip tests at runtime when preconditions are not met.

Example:
```cpp
TEST(MyTest, MaySkip) {
  if (!IsFeatureEnabled()) {
    GTEST_SKIP() << "Skipping because feature is disabled";
  }
  // test logic...
}
```

---

## 17. How do I write assertions for pointer arguments?

- Use `IsNull()`, `NotNull()` to match pointer arguments.
- Use `Pointee(matcher)` to match the value pointed to by a pointer.

Example:
```cpp
EXPECT_CALL(mock, Foo(Pointee(Ge(5))));
```

---

## 18. Where can I find detailed documentation on assertions and matchers?

- [Assertions Reference](reference/assertions.md): Detailed list of assertion macros.
- [Mocking Reference](reference/mocking.md): Detailed info about mock-related expectation syntax.
- [Matchers Reference](reference/matchers.md): All built-in and custom matcher guidelines.
- [Advanced GoogleTest Topics](docs/advanced.md): Explains advanced assertion usage and printing support.

---

## Summary
This FAQ empowers you to write effective assertions and configure matchers in GoogleTest and GoogleMock. Learn to distinguish fatal vs non-fatal failures, create rich failure messages using predicate assertions and custom matchers, control mock expectations and actions, and debug failures with contextual traces and detailed output.

---

# Related Documentation
- [GoogleTest Assertions Reference](reference/assertions.md)
- [GoogleMock Mocking Reference](reference/mocking.md)
- [GoogleTest Matchers Reference](reference/matchers.md)
- [Advanced GoogleTest Topics](docs/advanced.md)
- [gMock for Dummies](googlemock/gmock_for_dummies.md)
- [gMock Cookbook](docs/gmock_cook_book.md)

---

# Practical Tips
- Always set expectations (`EXPECT_CALL`) before invoking mock methods.
- Use `ON_CALL` to set default behaviors without imposing call count restrictions.
- Use `SCOPED_TRACE` for easier debugging of failures in nested calls.
- When testing code that should cause process termination, use death tests.
- For complex argument validations, prefer custom or parameterized matchers.
- Use `Mock::VerifyAndClearExpectations()` if you manually manage mock lifetimes.

---

For further support, use the community forums or report issues at the official repository.

