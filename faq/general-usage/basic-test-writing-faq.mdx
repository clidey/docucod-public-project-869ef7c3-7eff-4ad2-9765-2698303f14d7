---
title: "Basic Test Writing FAQ"
description: "Addresses frequently asked questions about writing simple tests, understanding test assertions, and leveraging xUnit-style testing features. Explains common assertion errors and provides best practices for writing readable and maintainable tests."
---

# Basic Test Writing FAQ

This FAQ addresses common questions about writing simple tests in GoogleTest, understanding test assertions, and leveraging xUnit-style testing features. It also explains typical assertion errors and offers best practices for writing readable and maintainable tests.

---

## 1. Writing Your First Tests

### What is the simplest way to write a test using GoogleTest?

Start with the `TEST()` macro to define a test function within a test suite:

```cpp
TEST(SampleTestSuite, SimpleTest) {
  EXPECT_EQ(1 + 1, 2);
}
```

Here, `SampleTestSuite` groups related tests, and `SimpleTest` is the individual test. Both names should be valid C++ identifiers without underscores to avoid naming clashes.

### How do I group tests that share common setup or teardown code?

Use test fixtures by subclassing `testing::Test`. Then write tests with `TEST_F()`:

```cpp
class MyFixture : public testing::Test {
 protected:
  void SetUp() override {
    // common setup
  }

  void TearDown() override {
    // common cleanup
  }
  // Shared test data
  int shared_resource_ = 0;
};

TEST_F(MyFixture, TestOne) {
  EXPECT_EQ(shared_resource_, 0);
}
```

GoogleTest creates a fresh fixture instance per test, isolating their state.

### Can I re-use test fixtures for multiple test suites?

Yes, by subclassing your base test fixture and using different derived fixture names. Alternatively, you can use `typedef` or `using` aliases for convenience.


## 2. Understanding Assertions

### What is the difference between `EXPECT_` and `ASSERT_` macros?

- `EXPECT_`: Generate _nonfatal_ failures; test continues after failure, helping reveal multiple failures in a test.
- `ASSERT_`: Generate _fatal_ failures; abort the current function immediately.

Use `ASSERT_` when continuing after failure would lead to invalid test behavior or crashes.

### How do I write custom failure messages?

You can append messages using stream operators:

```cpp
EXPECT_EQ(x, y) << "Mismatch at index " << i;
```

This helps to pinpoint failures clearly.

### How do I compare floating-point numbers?

Since exact equality is unreliable due to rounding, use:

- `EXPECT_FLOAT_EQ(val1, val2)` for `float`
- `EXPECT_DOUBLE_EQ(val1, val2)` for `double`
- `EXPECT_NEAR(val1, val2, abs_error)` for comparison within a tolerance

### Can I compare C strings?

Don't use `EXPECT_EQ` with `const char*` for content comparison; use:

- `EXPECT_STREQ(str1, str2)` for equality
- `EXPECT_STRNE(str1, str2)` for inequality

These compare string contents rather than pointer values.

### What if I want to test exceptions?

GoogleTest supports exception assertions if exceptions are enabled:

- `EXPECT_THROW(statement, exception_type)`
- `EXPECT_NO_THROW(statement)`
- `EXPECT_ANY_THROW(statement)`

Wrap multiple statements in `{}` when needed.

### How can I write complex assertions with rich failure messages?

You can use predicate assertions that print argument values automatically:

```cpp
bool IsEven(int n) {
  return (n % 2) == 0;
}
EXPECT_PRED1(IsEven, 4);
```

For even clearer failure messages, define predicate functions returning `testing::AssertionResult`.

You can also use [`EXPECT_THAT`](reference/assertions.md#EXPECT_THAT) with matcher expressions for flexible, English-like assertions.


## 3. Common Assertion Errors and How to Fix Them

### "void value not ignored as it ought to be" error when using ASSERT_ macros?

`ASSERT_*` macros generate fatal failures and must be used only in functions that return `void`. To fix this, either:

- Change the function return type to `void`, or
- Use `EXPECT_*` macros for non-fatal failures.

### Why can't I use underscores in test suite or test names?

Underscores cause naming conflicts and reserved symbol usages internally. Avoid `_` in both `TestSuiteName` and `TestName` to prevent linkage or runtime errors.

### "no matching function for call to Fixture::Fixture()" error when using `TEST_F`?

GoogleTest requires a default constructor for the test fixture class. Provide one explicitly if your fixture class defines other constructors or contains `const` members.

### Segfaults after fatal assertion failures in subroutines?

Fatal assertions abort only their current function, not the entire test. So your test continues after failure possibly leading to crashes.

Use `ASSERT_NO_FATAL_FAILURE()` to verify subroutine assertions without proceeding on failures, or check `HasFatalFailure()` to return early.

### Why do tests using `EXPECT_EQ(NULL, ptr)` but not `EXPECT_NE(NULL, ptr)`?

Support for `NULL` arguments is limited and is only implemented where most useful. Using `nullptr` is recommended and supported in both cases.


## 4. Best Practices for Writing Maintainable Tests

### Prefer test fixtures over global variables

Fixtures ensure fresh, independent test states. Global variables can leak state between tests and cause flaky results.

### Use `EXPECT_` unless failure means the test cannot continue

Nonfatal failures help expose multiple problems in one test run.

### Use custom failure messages to improve failure diagnostics

Streaming additional context into assertions aids debugging.

### Avoid complicated logic inside assertions

Use helper functions or custom predicates returning `AssertionResult` for clarity.

### Group related assertions in the same test to avoid redundant setup

Helps keep tests organized and efficient.

### Use parameterized tests when testing the same logic over multiple inputs

Reduce test duplication and improve coverage.


## 5. How to Skip Tests at Runtime

Use `GTEST_SKIP()` within tests or `SetUp()` to skip tests dynamically based on preconditions:

```cpp
TEST(MyTest, FeatureTest) {
  if (!IsFeatureSupported()) {
    GTEST_SKIP() << "Feature not supported on this platform";
  }
  // Proceed with test
}
```

Skipping prevents further test execution but registers the test as skipped.


## 6. Common User Workflows

### Writing a Simple Test

1. Use `TEST(TestSuiteName, TestName)` to define your test function.
2. Inside, use assertions like `EXPECT_EQ`, `EXPECT_TRUE` to validate outcomes.
3. Run your tests with `RUN_ALL_TESTS()` in your `main()`.

### Sharing Setup Across Tests

1. Create a fixture subclassing `testing::Test`.
2. Put shared data and setup in the fixture constructor or `SetUp()`.
3. Write tests with `TEST_F(FixtureName, TestName)`.

### Writing Parameterized Tests

1. Derive from `testing::TestWithParam<T>`.
2. Define tests using `TEST_P()`.
3. Instantiate with `INSTANTIATE_TEST_SUITE_P()` using parameter generators.

### Adding Custom Failure Messages

Chain messages using `<<` with assertions to clarify failure causes.


## 7. Troubleshooting Tips

- Always ensure test and suite names avoid underscores.
- Use `ASSERT_*` carefully knowing they abort the current function, not the entire test.
- Make sure your fixtures have default constructors.
- Use `EXPECT_NO_FATAL_FAILURE()` to handle `ASSERT_*` in subroutines.
- Check if your test skips due to unmet preconditions; use `GTEST_SKIP()` for clarity.
- For floating-point checks, prefer `EXPECT_FLOAT_EQ` or `EXPECT_NEAR` over `EXPECT_EQ`.


## 8. Additional Resources

- [GoogleTest Primer](primer.md) for introductory concepts and test writing.
- [Assertions Reference](reference/assertions.md) for comprehensive assertion macros.
- [Advanced GoogleTest Topics](advanced.md) for parameterized tests, typed tests, and more.
- [GoogleTest FAQ](faq.md) for wider question coverage.

---

This FAQ empowers you to write reliable, maintainable, and clear tests with GoogleTest. Starting from simple tests to parameterized and fixture-based tests, it guides you on assertions, custom messages, and avoiding common pitfalls.
