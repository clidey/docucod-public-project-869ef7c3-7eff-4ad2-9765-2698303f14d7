---
title: "Improving Test Performance"
description: "Provides tips and answers around speeding up tests, reducing execution time, handling slow death tests, and leveraging parallel test execution. Also points to composition patterns that minimize test overhead."
---

# Improving Test Performance

This page offers actionable tips and answers focused on **speeding up tests**, **reducing overall execution time**, **handling slow death tests**, and **leveraging parallel test execution** in GoogleTest. It also presents composition patterns that minimize test overhead to help you achieve faster, more efficient tests.

---

## Frequently Asked Questions

### How can I speed up my test suite execution?

The key to faster tests is minimizing unnecessary work per test and making best use of parallelism.

- **Reduce unnecessary initialization:** Avoid expensive setup in each test. Use test fixtures (`TEST_F`) judiciously and prefer setting up shared expensive resources only once per suite if possible.
- **Avoid slow death tests where possible:** Death tests inherently slow things down because they launch subprocesses. Only use them to test critical fatal-error scenarios and keep their scope minimal.
- **Use parameterized tests:** To cover multiple input cases efficiently without duplicating test code and overhead.
- **Leverage parallel test execution:** Run tests concurrently to distribute workload and reduce wall-clock time. GoogleTest supports parallel execution with test runners and CI systems configured accordingly.

### What are "slow death tests" and how should I handle them?

Death tests verify that your code terminates under certain conditions (using `EXPECT_DEATH` or `ASSERT_DEATH`). Because they spawn separate processes and synchronize, they are naturally slower than normal tests.

**Tips to handle slow death tests:**
- Isolate the minimal code required to trigger the death condition.
- Avoid unnecessarily complex setup inside death tests.
- Do not run death tests repeatedly if not needed.
- Use separate, selective test runs focusing only on death tests during dedicated test phases.

### How do I run tests in parallel using GoogleTest?

GoogleTest itself does not provide built-in parallelism within its executable. However, you can:

- **Run multiple test executables in parallel:** When tests are split across multiple binaries (e.g., by suite or module), run them concurrently using build system or CI pipeline parallelism.
- **Split tests within one binary for parallelism:** Use external test runners that can shard tests (e.g., Bazel, CTest with parallelism flags, or custom scripts) to distribute individual test cases across threads or processes.
- **Use environment flags:** Some test runners or CI environments allow passing filters or sharding parameters to run subsets of tests.

Parallel execution requires your tests to be independent and side-effect free or properly isolated.

### What composition patterns help minimize test overhead?

Efficient test design can minimize overhead by:

- **Using test fixtures smartly:** Reuse setup/teardown logic but keep fixture size appropriate.
- **Decoupling dependencies:** Use mocks instead of real heavy dependencies to avoid slow initialization and execution.
- **Avoiding global state:** Helps tests run safely in parallel without interference.
- **Parameterized and typed tests:** Reduce duplication and share test logic.

For detailed patterns, see the [Writing and Structuring Tests](../guides/core-testing-workflows/writing-and-structuring-tests) guide.

---

## Common Issues & Gotchas

### Tests randomly slow down over time

**Cause:** Leaked resources, heavy setup in each test, or inefficient mocks.

**Solution:**
- Profile test execution times to identify slow tests.
- Refactor tests to isolate expensive work in shared `SetUpTestSuite()` if applicable.
- Replace real dependencies with mocks.

### Death tests slow the entire suite

**Cause:** Death tests launch subprocesses and have synchronization overhead.

**Solution:**
- Run death tests separately from the main test run, if possible.
- Keep death tests minimal and focused.

### Parallel test runs fail intermittently

**Cause:** Shared state or side effects cause race conditions.

**Solution:**
- Ensure tests are isolated.
- Use mock objects to isolate dependencies.
- Avoid static or global mutable state.

---

## Tips for Performance Optimization

<Steps>
<Step title="Use Parallel Execution">
Split your test suite into multiple test binaries or shard tests and run them through CI/CD pipelines in parallel to reduce total testing time.
</Step>
<Step title="Optimize Test Fixtures">
Avoid expensive per-test setup. Use `SetUpTestSuite()` for shared setup when possible, and keep fixtures lightweight.
</Step>
<Step title="Minimize Death Test Usage">
Death tests are slower; reserve them for critical crash-related verifications and separate them from normal tests.
</Step>
<Step title="Use Mocks to Speed Up Dependencies">
Replace slow or complex dependencies with mocks to reduce test execution time.
</Step>
<Step title="Focus Each Test on One Behavior">
Smaller, focused tests run faster and fail more predictably, simplifying debugging and speeding overall run.
</Step>
</Steps>

---

## Troubleshooting Slow Tests

### How to identify which tests are slow?
- Use test profiling tools or custom timing wrappers.
- Run tests with verbose logging to get timing information.
- Use `--gtest_repeat` and timing measurements to isolate slow tests.

### What to do if mocks adversely affect performance?
- Simplify expectations.
- Prefer `NiceMock` if lots of uninteresting calls happen.
- Avoid overly strict mocks that can slow runtime checks.

### Dealing with flaky or intermittent slowdowns in parallel runs
- Check for shared state issues.
- Review test isolation.
- Use synchronization primitives carefully if threads are involved.

---

## Best Practices

- **Run death tests separately:** If your build system or CI allows, run death tests in dedicated stages.
- **Use the `RetiresOnSaturation()` clause:** On expectations to help unstick mock calls and improve performance in sequences.
- **Leverage `NiceMock` to avoid extra warnings:** This reduces overhead caused by unnecessary logging of uninteresting calls.
- **Structure tests to maximize parallelism:** Ensure there are no global dependencies or resources shared without synchronization.

---

## Related Documentation

- [Writing and Structuring Tests](../guides/core-testing-workflows/writing-and-structuring-tests) — Guidance on best test design.
- [Performance and Large-Scale Testing](../guides/real-world-testing-scenarios/performance-and-large-scale-testing) — Strategies for scaling test suites.
- [Testing Error Handling and Death Tests](../guides/real-world-testing-scenarios/testing-error-handling-and-death-tests) — Focused on death tests best practices.
- [GoogleTest Primer](../docs/primer.md) — Getting started guide.
- [Mocking Cookbook](../docs/gmock_cook_book.md) — For efficient use of mocks to speed tests.

---

## Summary

Improving test performance in GoogleTest involves minimizing individual test overhead, effectively managing slow death tests, and leveraging parallel execution strategies. With thoughtful test structuring and use of mocks, you can significantly reduce overall test suite runtime while maintaining test reliability and clarity.
