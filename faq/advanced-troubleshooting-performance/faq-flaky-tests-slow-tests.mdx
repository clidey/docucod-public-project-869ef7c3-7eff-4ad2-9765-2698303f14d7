---
title: "Dealing with Flaky or Slow Tests"
description: "Strategies and tools for identifying and mitigating flaky or slow tests, including timing tips, isolation strategies, and debugging suggestions for unstable test behavior."
---

# Dealing with Flaky or Slow Tests

Tests that intermittently fail or run slowly can be a major source of frustration and reduce confidence in your test suite. This page offers strategies and practical advice to diagnose, isolate, and fix flaky or slow tests in GoogleTest.

---

## Understanding Flaky Tests

Flaky tests are tests that sometimes pass and sometimes fail without changes to the underlying code. They often indicate underlying issues such as timing dependencies, race conditions, or shared state contamination.

### Common Causes of Flaky Tests

- **Race Conditions and Concurrency Issues:** Tests that depend on multithreaded code but lack proper synchronization.
- **Unstable External Dependencies:** Network services, file systems, or databases that arenâ€™t isolated.
- **Timing and Order Dependencies:** Tests relying on clocks, timers, or ordering of execution.
- **Shared State Pollution:** Global or static variables that are modified in one test and affect others.

### Why Flaky Tests Matter

Flaky tests reduce developer confidence, increase debugging time, and can hide real bugs. They undermine continuous integration pipelines and often lead to ignoring test failures altogether.

---

## Diagnosing Flaky Tests

### Step 1: Reproduce Consistently

- Use the `--gtest_repeat` flag to run a test multiple times (e.g., `--gtest_repeat=100`) to observe failure frequency.
- Combine with `--gtest_shuffle` to randomize test order and identify order-dependent failures.
- Employ `--gtest_break_on_failure` to stop execution immediately on a failure for debugging.

### Step 2: Use `SCOPED_TRACE` to Add Context

Use `SCOPED_TRACE` macro to add diagnostic trace messages scoped to subroutines or loops involved in flaky tests. This helps identify which iteration or invocation caused the failure.

```cpp
SCOPED_TRACE("Loop iteration " + std::to_string(i));
EXPECT_EQ(Foo(i), expected);
```

### Step 3: Inspect Shared State

Check whether static, global, or singleton objects are modified unexpectedly. If needed, apply locks or reset shared state in `SetUp()`/`TearDown()`.

### Step 4: Use Logging and Verbose Flags

Run tests with `--gmock_verbose=info` to get detailed tracing of mock call matching and actions taken.

---

## Strategies to Fix Flaky Tests

### 1. Isolate Tests Thoroughly

- Avoid dependencies on external state or resources.
- Use mock objects (GoogleMock) for external systems.
- Use test fixtures to set up and tear down state consistently.

### 2. Control Test Execution Order

- Use `InSequence` or `After` clauses in `EXPECT_CALL` to enforce call ordering where necessary.
- Avoid tests depending implicitly on order.

### 3. Avoid Timing Dependencies

- Prefer logical synchronization over time-based sleeps.
- Use condition variables, semaphores, or notifications to coordinate threads.
- Reduce use of timers or rely on abstractions that can be overridden in tests.

### 4. Handle Thread Safety

- Follow the rules in [Using gMock and Threads](reference/mocking.md#UsingThreads) to avoid data races.
- Consider running tests single-threaded when debugging.

### 5. Use `GTEST_SKIP()` for Environment Checks

Skip tests dynamically if environment requirements are not met, avoiding spurious failures.

---

## Dealing with Slow Tests

Slow tests can delay feedback loops and reduce productivity. The following can help:

### Timing and Profiling

- Profile tests to identify bottlenecks.
- Use `--gtest_brief=1` to reduce output overhead of passing tests.
- Enable detailed timing with `--gtest_print_time` to measure test durations.

### Isolation

- Move slow tests to separate suites and run them less frequently.
- Use test sharding (`GTEST_TOTAL_SHARDS`, `GTEST_SHARD_INDEX`) to distribute slow tests.

### Resource Management

- Avoid expensive setup/teardown per test; use `SetUpTestSuite` and `TearDownTestSuite` for shared resources.
- Clean up properly to avoid resource leaks that degrade performance.

---

## Debugging Tips

### Use Fail-Fast Mode

`--gtest_fail_fast=1` stops test execution on the first failure. This helps identify the root cause quicker.

### Capture and Analyze Test Output

Combine GoogleTest XML/JSON output (`--gtest_output=xml:filename`) with CI or analysis tools to identify flaky or slow tests.

### Leverage Test Event Listeners

For advanced debugging, implement custom [`TestEventListener`](reference/testing.md#TestEventListener) to monitor test progress and failure patterns.

---

## Practical Example: Detecting a Flaky Test

```bash
$ ./my_tests --gtest_repeat=100 --gtest_shuffle --gtest_break_on_failure
```

This command repeats the test 100 times in random order, breaking at the first failure for inspection.

Use `SCOPED_TRACE` in your test helper functions to find which call or iteration fails.

---

## Summary Best Practices

- Write tests that are deterministic and isolated.
- Use mocks and fixtures to control dependencies and shared state.
- Diagnose flakiness by repeating and randomizing test order.
- Control concurrency explicitly with synchronization primitives.
- Profile and isolate slow tests to maintain fast feedback.

---

## See Also

- [Using gMock and Threads](reference/mocking.md#UsingThreads)
- [SCOPED_TRACE](reference/testing.md#SCOPED_TRACE)
- [Running and Validating Tests](getting-started/first-test-experience/running-and-validating-tests)
- [Mocking Best Practices Guide](guides/core-workflows/mocking-techniques)
- [Sharding Tests for Parallel Execution](reference/testing.md#distributing-test-functions-to-multiple-machines)
- [Test Event Listeners API](reference/testing.md#TestEventListener)

---

For more on writing robust GoogleTest and gMock tests, visit the [Getting Started Guides](guides/getting-started) and [API Reference](api-reference).