---
title: "How do I use parameterized and typed tests?"
description: "Demystifies advanced test patterns, allowing users to test more cases with less code. Walks through setup and usage with clear examples."
---

# How do I use parameterized and typed tests?

GoogleTest offers powerful features to write tests that run across a broad range of inputs and types, reducing code duplication and improving test coverage. This page demystifies the use of **value-parameterized tests** and **typed tests**, guiding you on how to define, instantiate, and run these tests with practical examples and best practices.

---

## Value-Parameterized Tests

Value-parameterized tests enable you to write a single test logic executed multiple times with different parameter values.

### How to Create Value-Parameterized Tests

1. **Define a test fixture class** that inherits from [`testing::TestWithParam<T>`](../advanced.md#value-parameterized-tests), where `T` is your parameter type:

```cpp
class MyTestSuite : public testing::TestWithParam<int> {
  // Setup code, utility functions, and members can go here
};
```

2. **Write parameterized tests** using the `TEST_P` macro instead of `TEST` or `TEST_F`. Each test body can access its parameter with `GetParam()`:

```cpp
TEST_P(MyTestSuite, DoesSomething) {
  int param = GetParam();
  EXPECT_GT(param, 0);  // Example assertion using the parameter
}
```

3. **Instantiate the test suite** with specific parameters using `INSTANTIATE_TEST_SUITE_P`, providing a parameter generator:

```cpp
INSTANTIATE_TEST_SUITE_P(
    MyInstantiation, MyTestSuite,
    testing::Values(1, 2, 3));
```

This will run `DoesSomething` three times, once with each parameter: 1, 2, and 3.

### Parameter Generators

GoogleTest provides several built-in parameter generators, found in the `testing` namespace:

| Generator          | Description                                                                                 |
|--------------------|---------------------------------------------------------------------------------------------|
| `Range(begin,end)`  | Generates values from `begin` up to but not including `end`, stepping by 1 by default.     |
| `Values(v1,...,vN)`| Generates the explicitly listed values.                                                    |
| `ValuesIn(container)` or `ValuesIn(begin,end)` | Generates values from a container or iterator range.                     |
| `Bool()`           | Generates sequence `{false, true}` for boolean parameters.                                 |
| `Combine(g1,g2,...)` | Generates all combinations (Cartesian product) from the provided generators.             |
| `ConvertGenerator<T>(generator)` | Converts generated types to a custom type `T`.                                    |

Examples:

```cpp
// Using Range
INSTANTIATE_TEST_SUITE_P(NumberRange, MyTestSuite, testing::Range(1, 4));  // 1, 2, 3

// Using ValuesIn with a vector
std::vector<int> values = {10, 20, 30};
INSTANTIATE_TEST_SUITE_P(VectorValues, MyTestSuite, testing::ValuesIn(values));

// Using Combine to test permutations of two params
INSTANTIATE_TEST_SUITE_P(
    ComboParams, MyTestSuite,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

### Customizing Test Names for Parameters

You can provide a name generator function or functor as the last argument to `INSTANTIATE_TEST_SUITE_P` to customize individual test names:

```cpp
INSTANTIATE_TEST_SUITE_P(
    CustomNames, MyTestSuite, testing::Values(1, 2),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This will name the tests `CustomNames/MyTestSuite.DoesSomething/Value1` and `CustomNames/MyTestSuite.DoesSomething/Value2`.

### Notes and Best Practices

- Instantiations must have unique prefixes to avoid name collisions.
- Test names derived from parameters must contain only alphanumeric characters and underscores.
- Parameter sequences are evaluated during test framework initialization (`InitGoogleTest`) after `main()` starts, allowing runtime adjustment if needed.

---

## Typed Tests

Typed tests allow you to write test logic templates that are run for multiple types, enabling compile-time evaluation of functionality over different data types.

### Creating Typed Test Suites

1. **Define a test fixture template class**, templated on type `T`, inheriting from `testing::Test`:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  T value_;
};
```

2. **Associate a list of types** with the test suite using `TYPED_TEST_SUITE`:

```cpp
using MyTypes = testing::Types<int, double, std::string>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. **Write tests using `TYPED_TEST`**, referencing the current type as `TypeParam` inside the test:

```cpp
TYPED_TEST(MyTypedTest, HasDefaultConstructor) {
  TypeParam value = this->value_;
  // Test something with value
  (void)value;  // suppress unused warnings if any
}
```

Tests are instantiated for each type specified.

### Optional: Provide Custom Type Names

You can specify a name generator class with a static template `GetName(int)` method as the third argument to `TYPED_TEST_SUITE` to customize type names in test output:

```cpp
class MyTypeNames {
 public:
  template <typename T>
  static std::string GetName(int) {
    if constexpr (std::is_same_v<T, int>) return "int";
    if constexpr (std::is_same_v<T, double>) return "double";
    if constexpr (std::is_same_v<T, std::string>) return "string";
  }
};

TYPED_TEST_SUITE(MyTypedTest, MyTypes, MyTypeNames);
```

### Notes

- The test suite name reflects the type, e.g., `MyTypedTest/int`.
- Use `this->` to access fixture members within templated test bodies to satisfy C++ grammar.

---

## Type-Parameterized Tests

Type-parameterized tests provide an advanced pattern where you define an abstract test suite template with test bodies declared but not tied to specific types, then register and instantiate the test suite with types explicitly.

Steps:

1. **Define test suite template**:

```cpp
template <typename T>
class MyTypeParamTest : public testing::Test {};
```

2. **Declare the test pattern using `TYPED_TEST_SUITE_P` and `TYPED_TEST_P`**:

```cpp
TYPED_TEST_SUITE_P(MyTypeParamTest);

TYPED_TEST_P(MyTypeParamTest, ExampleTest) {
  TypeParam value{};
  // Test logic...
}

REGISTER_TYPED_TEST_SUITE_P(MyTypeParamTest, ExampleTest);
```

3. **Instantiate with a set of types using `INSTANTIATE_TYPED_TEST_SUITE_P`**:

```cpp
using MyTypes = testing::Types<int, double>;
INSTANTIATE_TYPED_TEST_SUITE_P(MyTypeParams, MyTypeParamTest, MyTypes);
```

This flexibility allows reuse and instantiation across translation units and projects.

---

## Summary

- **Value-Parameterized Tests:** Good for varying test inputs while focusing on a fixed behavior. Define with `TEST_P`, instantiate with `INSTANTIATE_TEST_SUITE_P`.
- **Typed Tests:** Test the same logic across different data types at compile time. Define fixtures templated on `T`, use `TYPED_TEST_SUITE` and `TYPED_TEST`.
- **Type-Parameterized Tests:** Similar to typed tests but with added flexibility to register and instantiate tests separately.

Remember to use custom name generators where helpful to produce descriptive and valid test names.

---

## Troubleshooting Tips

- **Tests not discovered or running?** Verify that parameterized tests are properly instantiated with `INSTANTIATE_TEST_SUITE_P` or `INSTANTIATE_TYPED_TEST_SUITE_P`.
- **Parameter name errors?** Ensure test name suffixes from parameters contain only alphanumeric characters or underscores.
- **Custom types for parameters not working?** Use `ConvertGenerator` to appropriately cast generator values.

---

## See Also

- [Value and Type Parameterized Tests Guide](/guides/advanced-testing-patterns/parameterized-tests)
- [Parameterized & Typed Tests API Reference](/api-reference/core-testing-api/parameterized-typed-tests)
- [Writing Your First Unit Test](/guides/getting-started-workflows/first-cpp-test)
- [Test Macros & Assertions Reference](/api-reference/core-testing-api/test-macros-assertions)

<Tip>
Explore the `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `TYPED_TEST_SUITE`, and `TYPED_TEST` macros in your test code. Use parameterized tests to expand coverage efficiently without duplicating test logic.
</Tip>
