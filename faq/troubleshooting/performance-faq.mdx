---
title: "Performance and Best Practices"
description: "Guidelines and answers about optimizing test performance, minimizing build times, efficient use of mocks, and recommended patterns for large codebases. Touches upon parallel test execution and resource-heavy scenarios."
---

# Performance and Best Practices FAQ

This page provides essential guidelines, practical tips, and answers related to optimizing the performance of your test suite using GoogleMock. It focuses on minimizing build times, efficient use of mocks, managing resource-heavy scenarios, and patterns recommended for large codebases. Additionally, it covers strategies for parallel test execution to help you scale and speed up your testing workflows.

---

## 1. How can I optimize the performance of my tests when using GoogleMock?

- **Minimize the number of expectations and mock methods:** Overusing mocks or excessive expectations can slow down test execution and compilation.
- **Group related expectations using** `InSequence` **or sequences wisely:** Enforcing strict ordering can add overhead; use only when necessary.
- **Use the default matcher** `_` **to avoid over-specifying matchers:** This reduces complexity in argument matching.
- **Avoid expensive custom matchers or actions when possible:** Keep matchers lightweight.
- **Prefer `ON_CALL` for default behavior and reserve `EXPECT_CALL` for actual verification:** This reduces unnecessary constraints and speeds up the mock setup phase.

<Tip>
Focusing expectations only on interactions critical to the behavior under test leads to faster and more maintainable test suites.
</Tip>

## 2. What are best practices for efficient use of mocks in large codebases?

- **Organize mock classes logically:** Place mock classes in dedicated directories or files clearly linked to their interfaces.
- **Define mock classes close to the production interfaces:** This prevents duplication and minimizes maintenance.
- **Use `NiceMock` for mocks not central to the test:** Suppresses noise from uninteresting calls.
- **Control mock object lifetime smartly:** Create and destroy mocks in scoped lifetimes to ensure proper verification and avoid memory leaks.
- **Avoid excessive nesting of mocks:** Deeply nested mocks can increase overhead and make tests harder to maintain.

<Note>
Using mock class wrappers like `NiceMock` and `StrictMock` appropriately helps balance strictness and performance.
</Note>

## 3. How can I reduce build times when using GoogleMock?

- **Separate mock class constructor and destructor into `.cc` files:** This prevents recompilation overhead in multiple translation units.
- **Avoid mocking very large classes with many methods in a single mock:** Split interfaces when practical.
- **Use type aliases or parentheses to manage complex argument types to prevent macro parsing overhead:**
  ```cpp
  using IntDoubleMap = std::map<int, double>;
  MOCK_METHOD(bool, CheckMap, (IntDoubleMap, bool));
  ```
- **Clean up unused mocks and remove redundant expectations:** Reduce code size and compilation units.

<Tip>
Splitting your mock implementations reduces the duplicated compilation effort and leads to better incremental build speeds.
</Tip>

## 4. How can I make the most of parallel test execution?

- **Design tests to be independent:** Avoid shared mutable state between tests to enable safe parallelization.
- **Limit shared static or global mocks:** Use isolated mocks per test to avoid concurrency issues.
- **Use GoogleTest's `--gtest_parallel` or build system tools to run tests concurrently:**
  This leverages multi-core CPUs to reduce total test times.
- **Beware of mock object synchronization:** GoogleMock handles locking internally, but designing mocks without heavyweight locks improves concurrency.

<Warning>
Parallel tests must not rely on ordering between mocks unless correctly synchronized, as GoogleMock doesn't enforce ordering across threads.
</Warning>

## 5. What strategies should I follow for resource-heavy or long-running mocks?

- **Reuse mocks carefully:** Cache or reuse mock objects if recreating them is expensive.
- **Delegate default actions to fakes or real objects:** To avoid reimplementing complex behavior in mocks that could slow down tests.
- **Avoid costly side-effects in mock actions:** Use simple return values or light-weight lambdas.
- **Use `ON_CALL` and `WillByDefault` to specify common behavior, minimizing expectations that trigger expensive checks.**

## 6. How does the "sticky expectations" rule affect test design and performance?

Expectations in GoogleMock remain active even after reaching their upper bound, which can cause confusing saturation errors if incorrectly used.

- To prevent this, use `.RetiresOnSaturation()` on expectations that are meant to be one-time or sequential.
- Or, combine a sequence (`InSequence`) with `.RetiresOnSaturation()` to express ordered interactions efficiently.

<Tip>
Being explicit about expectation retirement prevents unnecessary matching attempts and can improve test clarity and performance.
</Tip>

## 7. Why do newer expectations override older ones, and how does this impact performance?

GoogleMock searches expectations in reverse order to prioritize recently set rules. This enables overriding default mock behaviors set in constructors or fixtures with test-specific expectations.

- This design improves flexibility but can add overhead if many overlapping expectations exist.
- Avoid setting redundant or shadowed expectations to keep matching fast.

## 8. Troubleshooting: Common Performance Pitfalls

<AccordionGroup title="Common Performance Issues and Solutions">
<Accordion title="Test Execution Seems Slow">
- Check for excessive or complex mock expectations.
- Use `--gmock_verbose=info` to trace mock calls and identify bottlenecks.
- Simplify or remove unnecessary mocks.
</Accordion>
<Accordion title="Compilation Takes Too Long">
- Extract mock constructors and destructors into implementation files.
- Use type aliases for complex types to simplify macro expansions.
- Reduce the number of mocked methods in one mock class.
</Accordion>
<Accordion title="Tests Hang or Deadlock in Parallel Runs">
- Check for shared mutable state or improper synchronization between tests.
- Avoid complex expectations with side effects that block.
- Use thread-safe mocks or redesign for better concurrency.
</Accordion>
</AccordionGroup>

## 9. Recommended Patterns for Large Codebases

- Define interface abstractions and mock only those, not concrete classes, to avoid fragile tests.
- Use adaptor interfaces to encapsulate dependencies, which also improves test isolation and modularity.
- Group related mocks and expectations by feature areas.
- Use test fixtures to manage complex mock setup and teardown.
- Employ `NiceMock` and `StrictMock` wrappers judiciously to balance feedback noise and test strictness.

## 10. Additional Resources

- Read the [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) for detailed recipes on writing and optimizing mocks.
- Consult the [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) for API details.
- Use the [gMock Cheat Sheet](https://google.github.io/googletest/gmock_cheat_sheet.html) for quick syntax reminders.
- Review the [Legacy gMock FAQ](https://google.github.io/googletest/gmock_faq.html) for common user questions.

---

### Practical Example: Using `.RetiresOnSaturation()` to Improve Test Flow

```cpp
using ::testing::_;  
using ::testing::Return;
using ::testing::Sequence;

Sequence s;

EXPECT_CALL(mock_obj, MethodA())
    .Times(1)
    .RetiresOnSaturation()
    .InSequence(s)
    .WillOnce(Return(true));
EXPECT_CALL(mock_obj, MethodA())
    .Times(1)
    .InSequence(s)
    .WillOnce(Return(false));

// Calls to MethodA() will first consume the first expectation and retire it,
// then match the second, avoiding saturation errors.
```

<Tip>
In scenarios where your mock method is expected to be called multiple times with different behaviors, using `.RetiresOnSaturation()` and sequences leads to clearer tests and avoids confusing upper-bound failures.
</Tip>

---

For all performance concerns, always profile and understand where time or resources are being spent in your test runs. Tailor mock usage accordingly.
