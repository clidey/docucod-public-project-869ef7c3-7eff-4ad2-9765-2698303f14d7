---
title: "Optimizing Test Performance"
description: "Covers frequently asked questions around speeding up test execution, running in parallel, filtering slow tests, and making efficient use of GoogleTest features to minimize build/test time. Includes pointers to related tooling in the ecosystem."
---

# Optimizing Test Performance

Efficient test execution is crucial for maintaining fast feedback cycles and ensuring developer productivity. This guide focuses on strategies and features within GoogleTest that help you speed up your tests, run them in parallel, filter slow tests, and optimize overall test suite performance.

---

## 1. Parallel Test Execution

### Leveraging Multiple CPU Cores
GoogleTest itself does not include built-in parallel test execution. However, you can run multiple instances of your test binary in parallel to utilize multiple CPU cores effectively.

- Use external tools such as [`gtest-parallel`](https://github.com/google/gtest-parallel) that orchestrate running multiple test binaries or shards concurrently.
- Set up test sharding using the environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX`:

  ```shell
  export GTEST_TOTAL_SHARDS=4   # Total number of shards
  export GTEST_SHARD_INDEX=0    # 0-based index of this shard
  ./your_test_binary
  ```

Each shard runs a fraction of tests, reducing overall execution time.

### Running Tests Concurrently Safely
- Tests should avoid global or static state that could cause race conditions.
- GoogleTest ensures thread safety for test registration and execution but you must design your tests to be thread-safe.
- Do not set expectations or modify mocks from multiple threads concurrently.

## 2. Selective Test Execution

### Filtering Tests
Use `--gtest_filter` to run only a subset of tests and skip the rest, decreasing test execution time when working on focused code areas.

```shell
./your_test_binary --gtest_filter=MyTestSuite.*  # Runs all tests in MyTestSuite
./your_test_binary --gtest_filter=-*Slow*        # Runs all tests except those matching "Slow"
```

### Running Disabled Tests
To include tests marked as disabled (with `DISABLED_` prefix), use:

```shell
./your_test_binary --gtest_also_run_disabled_tests
```

### Running Tests Multiple Times
For flaky or intermittent tests, repeat executions using:

```shell
./your_test_binary --gtest_repeat=100
```

### Shuffling Test Order
Detect test interdependencies by running tests in random order:

```shell
./your_test_binary --gtest_shuffle
```

Combine shuffling and repeating to stress test the suite:

```shell
./your_test_binary --gtest_shuffle --gtest_repeat=100
```

## 3. Annotating and Managing Slow Tests

### Isolating Slow Tests
- Move long-running tests into separate test suites or mark them clearly, e.g., with names containing "Slow" or "Integration".
- Use test filters to exclude slow tests from regular runs.

### Using Test Properties
- Record properties for slow tests by overriding their entry with `RecordProperty()`:

  ```cpp
  TEST(FooTest, SlowTest) {
    RecordProperty("Category", "Slow");
    // Test code ...
  }
  ```

- Use properties metadata in CI systems to run or skip based on test categories.

## 4. Controlling Test Parallelism From Within Tests

- GoogleTest limits how tests execute internally but does not restrict external parallel runs.
- Ensure tests do not share resources unsafely when running in parallel.
- Use synchronization primitives for safe interaction in multi-threaded tests.

## 5. Build and Compilation Performance Optimization

### Splitting Mock Classes
- If your mock classes are large, split the constructor/destructor definitions into `.cc` files to reduce compile times across translation units.

### Limiting Mock Methods
- Avoid mocking unnecessary methods.
- Use simpler mocks or just interfaces if full mocks are expensive.

### Precompiled Headers
- Employ precompiled headers for GoogleTest and GoogleMock headers to improve compilation speed.

## 6. Test Execution Time Measurement

- GoogleTest reports per-test execution timing automatically.
- Use test timing data to identify slow tests.
- Combine with filtering and selective execution to iteratively improve your suite.

## 7. Tools and Ecosystem for Performance

### `gtest-parallel`
- An external Python script to run tests in parallel processes, collected, and aggregated.
- Manages flaky tests by retrying them.
- Helps reduce wall-clock time on test suites with many tests.

### Continuous Integration Optimization
- Use caching for build artifacts.
- Use sharding on CI infrastructure to spread test runs across multiple agents.
- Collect and analyze test durations to prioritize optimization.

## 8. Best Practices for Fast and Maintainable Tests

- Write fast unit tests, mock external dependencies where appropriate.
- Avoid expensive integration or system tests in the default test run.
- Separate tests logically (unit, integration, performance).
- Use `EXPECT_CALL` and `ON_CALL` judiciously to avoid overhead.
- Regularly monitor test duration data to identify regressions.

---

## Additional References

- [GoogleTest Primer](primer.md): Learn basic test writing and execution.
- [gMock Cookbook](gmock_cook_book.md): Advanced mocking techniques.
- [Guides on Parallel Test Execution and Sharding](guides/advanced-usage/scaling-and-optimization.md): Strategies to scale tests.
- [GoogleTest Flags and Environment Variables](advanced.md#running-test-programs-advanced-options): Explore flags to control test runs.
- [Troubleshooting Common Performance Issues](faq/troubleshooting/performance.mdx)

---

## Troubleshooting Common Performance Issues

<AccordionGroup title="Common Performance Pitfalls">
<Accordion title="Tests Running Too Slowly">
When tests are slow, check for:

- Unnecessary I/O operations.
- Tests that perform heavy computations or long waiting periods.
- Overly complex or large mocks.
- Shared global state causing serialization of tests.

Strategies: isolate and rewrite slow tests, mock out dependencies, or move to separate integration test suites.
</Accordion>
<Accordion title="Build and Compilation Bottlenecks">
- Large mocks causing increased compile time.
- Recompilation triggered by tangled dependencies.

Solutions include precompiled headers, moving mock definitions out-of-line, and refining include patterns.
</Accordion>
<Accordion title="Unintentional Test Serialization">
- Shared resources without proper isolation.
- Using global or static variables.

Fix by redesigning tests for isolation or employing synchronization.
</Accordion>
</AccordionGroup>

---

## Summary

Implementing these performance optimization techniques will lead to significantly shorter feedback loops, smoother CI workflows, and more scalable test suites.

Optimize continuously by profiling test execution and build times.

> **Tip:** Use `--gtest_list_tests` to see all tests and organize them by duration and category.

---

## Example: Combining Filtering and Parallel Shards

```shell
export GTEST_TOTAL_SHARDS=2
export GTEST_SHARD_INDEX=0
./your_tests --gtest_filter=-*Slow*
```

Run a fast shard excluding slow tests, while another shard handles slow tests separately.

---

## Final Notes

- Always benchmark your specific test suite; what works best can vary.
- Invest early in organizing tests to support effective use of these techniques.

---

<Check>
Remember to always run `RUN_ALL_TESTS()` only once per test binary to avoid conflicts.
</Check>

<Info>
For full control over test execution and performance, explore GoogleTest advanced flags and external parallelization tools.
</Info>
