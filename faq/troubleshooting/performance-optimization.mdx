---
title: "Performance and Test Suite Optimization"
description: "Advice for optimizing large or slow-running test suites, including best practices for managing mocks, reducing test times, efficient use of parameterized and type-parameterized tests, and tips for scaling tests as a project grows."
---

# Performance and Test Suite Optimization

This page provides practical advice and best practices for optimizing the performance of GoogleTest and GoogleMock test suites, especially as projects grow larger and encounter slow or resource-heavy test execution. It focuses on controlling mocks efficiently, reducing test overhead, and scaling parameterized tests to achieve fast and maintainable test workflows.

---

## 1. Managing Mock Objects for Speed and Reliability

### Use Default Actions and ON_CALL Pragmatically

When you create mocks, uninteresting calls (calls to mock methods without specific expectations) trigger a warning by default and can slow down test execution due to verbose logging. To improve speed and reduce noise:

- Use `ON_CALL()` to set default behaviors where appropriate instead of many `EXPECT_CALL`s.
- Avoid adding unnecessary expectations for mock methods you don't strictly validate in your test.
- Consider wrapping your mocks in `NiceMock<T>` to suppress warnings on uninteresting calls without turning them into errors.

### Declaring Expectations Efficiently

Writing a large number of `EXPECT_CALL` statements can incur compilation and runtime overhead:

- Group expectations when possible, especially with sequences or flexible cardinalities.
- Use `.Times(AnyNumber())` for calls where the number of invocations is irrelevant.
- Remove redundant or overlapping expectations that cover the same method calls.

### Clear Unused Expectations and Defaults

Use `Mock::VerifyAndClearExpectations(&mock_obj)` and `Mock::VerifyAndClear(&mock_obj)` to verify and clear expectations and default actions when mocks are no longer needed. This prevents stale expectations from lingering and affecting subsequent tests, reducing overhead and improving test isolation.

### Avoid Sticky Expectations Unless Needed

Expectations by default are "sticky" — they remain active until explicitly retired or the mock is destroyed. This can cause unexpected failures if new expectations override old ones unexpectedly:

- Use `.RetiresOnSaturation()` on expectations meant to be one-time or limited use.
- Use `InSequence` or explicit order clauses to specify call orders and retirement automatically.
- Avoid setting overlapping expectations without clear sequencing.

### Delay Mock Construction and Destruction

Mocks can incur significant cost in constructor/destructor generation, especially if mock classes have many methods. To speed up compilation and test runtime:

- Declare mock constructors and destructors separately in `.h` and `.cc` files instead of inline in headers.
- Avoid including mock-heavy headers in test compilation units that do not need them.

## 2. Reducing Test Execution Time

### Use Parameterized and Typed Tests Wisely

Parameterized tests are powerful for coverage but can slow down test execution if misused:

- Avoid deeply nested parameterizations that balloon the number of generated test cases.
- Group related test parameters to minimize the total number of test instances.
- Use value-parameterized tests for data-driven tests and type-parameterized tests for DRY-ing repeated test logic for multiple types.
- Consider filtering tests at runtime with `--gtest_filter` to run only subsets during development.

### Parallelize Tests and Use Sharding

For large test suites, consider running tests in parallel or shard tests across multiple machines or CI jobs using tooling that integrates with GoogleTest’s filtering and environment variables.

### Profile Slow Tests and Optimize

Regularly monitor test durations and investigate slow running tests:

- Identify excessive mock invocations or overly complex expectations.
- Refactor tests to reduce expensive setup or teardown.
- Replace mocks with fakes or stubs if mocks cause performance bottlenecks.

## 3. Best Practices for Mock Performance

### Minimize Mock Method Count and Complexity

Avoid mocking interfaces that have very large APIs if possible. Only mock methods relevant to your tests.

### Use Lightweight Actions and Avoid Expensive Side Effects

Actions invoked by `WillOnce` or `WillRepeatedly` should be lightweight and avoid blocking or heavy computations.

### Reuse Matcher and Action Objects

Matchers and actions in gMock are cheap to copy but consider creating reusable matcher variables for complex predicates to avoid rebuilding matcher expressions repeatedly.

### Control Verbosity for Diagnostic Output

Verbose output on expectations and mock calls (`--gmock_verbose=info`) can slow tests. Use `warning` or `error` levels in normal test runs and enable detailed info diagnostics only during debugging.

## 4. Scaling Parameterized Tests

### Balance Test Coverage and Suite Size

- Select representative parameter sets rather than exhaustive expansions.
- Use typed tests when different types follow the same test logic.
- Use parameterized tests with efficient data generators.

### Avoid Excessive Template Instantiations

Be mindful of template/gmock macro instantiations when using typed mocks or many parameterized test instantiations to reduce compile time.

## 5. Troubleshooting Test Suite Performance

### Common Pitfalls

- Excessive use of `EXPECT_CALL` and `ON_CALL` with complex matchers.
- Using `StrictMock` or too strict expectations leading to overhead.
- Not clearing expectations between tests causing leftover state.

### Tips

- Start tests with minimal expectations and add more only as needed.
- Use `NiceMock` to ignore irrelevant calls.
- Profile test runtime and memory to identify hot spots.

## 6. Reference Links

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) — recipes for advanced mocking and performance tips.
- [Mocking Reference](https://google.github.io/googletest/reference/mocking.html) — detailed syntax and usage.
- [Matchers Reference](https://google.github.io/googletest/reference/matchers.html) — efficient matchers design.
- [Test Definitions and Execution](https://google.github.io/googletest/api-reference/core-api/test-definitions.html) — optimizing test organization.
- [Writing & Running Your First Test](https://google.github.io/googletest/guides/getting-started-basic-tests.html) — for starting tests efficiently.

---

By following these guidelines, you will build test suites that scale gracefully, run quickly, and remain maintainable as your project grows.

<Tip>
To get started boosting your test performance, review your current mock usage patterns. Are you setting expectations only for the calls you want to verify? Are you using `NiceMock` where appropriate? Setting up default actions via `ON_CALL`? These straightforward practices yield immediate speed gains.
</Tip>

<Info>
Remember, performance optimization is an ongoing process. Measure, profile, and tune iteratively to keep your tests lean and fast.
</Info>
