---
title: "Defining Custom Assertions and Matchers"
description: "Answers to common questions about extending GoogleTest and GoogleMock with user-defined assertions and matchers, including typical pitfalls and code examples."
---

# Defining Custom Assertions and Matchers

GoogleTest and GoogleMock provide many built-in assertions and matchers, but real-world testing often requires you to define your own. This page answers common questions to help you extend the framework with user-defined assertions and matchers effectively.

---

## Why Define Custom Assertions and Matchers?

Sometimes you need to test complex or domain-specific conditions that built-in assertions cannot express clearly and concisely. Custom assertions and matchers help:

- Improve test readability by reflecting intent more naturally.
- Provide richer, detailed failure messages about why a check failed.
- Avoid cluttering tests with verbose manual checks and error reporting.

By enhancing the expressiveness of your tests, custom assertions and matchers help you write maintainable, robust, and diagnostic-rich test code.

---

## Custom Assertions

### Simple Predicate Assertions

The simplest form of custom assertions uses the `EXPECT_PRED*` and `ASSERT_PRED*` macros which test Boolean-returning functions or functors. These macros automatically print the function arguments when a test fails.

Example:

```cpp
// Predicate function returning bool
bool IsPositive(int n) { return n > 0; }

TEST(MyTest, PositiveCheck) {
  EXPECT_PRED1(IsPositive, 5);  // Passes
  EXPECT_PRED1(IsPositive, -3); // Fails, prints value of argument
}
```

**Pros:** Easy to write, automatically prints argument values.

**Cons:** Failure messages only say the predicate returned false; no explanation on why.

### Assertions Returning `AssertionResult`

To provide detailed messages on success or failure, define a function returning `testing::AssertionResult`. This class encapsulates whether the test passed or failed and the associated messages.

Example:

```cpp
#include <gtest/gtest.h>

// Returns success or failure with detailed explanation.
testing::AssertionResult IsEven(int n) {
  if (n % 2 == 0) {
    return testing::AssertionSuccess() << n << " is even";
  }
  return testing::AssertionFailure() << n << " is odd";
}

TEST(MyTest, EvenCheck) {
  EXPECT_TRUE(IsEven(4));  // Success message included
  EXPECT_TRUE(IsEven(3));  // Failure message with reason
}
```

This method gives richer diagnostic output when the assertion fails and can optionally give informative success messages.

---

## Custom Predicate-Format Assertions

If you want full control over the formatting of failure messages – including the ability to refer to the textual expressions for each argument – implement a predicate-formatter function compatible with the `EXPECT_PRED_FORMAT*` macros.

A predicate-formatter has the signature:

```cpp

  testing::AssertionResult MyPredicateFormatter(
      const char* expr1, const char* expr2, ...,
      T1 val1, T2 val2, ...);
```

Here, `expr1`, `expr2` are the stringified source expressions; `val1`, `val2` are the actual argument values.

Example:

```cpp
#include <gtest/gtest.h>

// Predicate-formatter: checks if the sum of two integers is even.
testing::AssertionResult AssertSumIsEven(const char* e1, const char* e2,
                                        int val1, int val2) {
  int sum = val1 + val2;
  if (sum % 2 == 0) {
    return testing::AssertionSuccess();
  }
  return testing::AssertionFailure() << "Sum of " << e1 << " and " << e2
      << " (" << val1 << " + " << val2 << " = " << sum << ") is not even.";
}

TEST(MyTest, SumEvenCheck) {
  EXPECT_PRED_FORMAT2(AssertSumIsEven, 2, 4);  // Pass
  EXPECT_PRED_FORMAT2(AssertSumIsEven, 1, 2);  // Fail with detailed message
}
```

Predicate-formatter assertions grant maximum power for custom error reporting.

---

## Writing Custom Matchers for GoogleMock

For mocking and argument verification in GoogleMock, custom matchers are often necessary when built-in matchers don't express complex or domain-specific criteria.

### Types of Custom Matchers

1. **Value Matchers:** Return `true` or `false` if the argument matches.
2. **Polymorphic Matchers:** Can match any type; templated to handle generic cases.
3. **Matcher Classes:** Implement `bool MatchAndExplain(arg_type arg, MatchResultListener* listener) const`.

### Example: Simple Custom Matcher

```cpp
#include <gmock/gmock.h>

// Matcher that matches even integers.
class IsEvenMatcher {
 public:
  bool MatchAndExplain(int n,
                       ::testing::MatchResultListener* listener) const {
    if (n % 2 == 0) return true;
    *listener << "which is odd";
    return false;
  }

  void DescribeTo(::std::ostream* os) const {
    *os << "is an even number";
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os << "is not an even number";
  }
};

inline ::testing::Matcher<int> IsEven() {
  return ::testing::MakeMatcher(new IsEvenMatcher());
}

// Usage in a test
TEST(MyTest, CustomMatcherExample) {
  EXPECT_THAT(4, IsEven());       // Succeeds
  EXPECT_THAT(3, Not(IsEven()));  // Succeeds
}
```

### Writing More Complex Matchers

For complex types, define matchers that inspect member variables, invoke helper functions, or leverage composability.

- Optionally implement `DescribeTo` and `DescribeNegationTo` for better failure messages.
- Use `MatchResultListener` to stream explanatory messages upon failure.

### Using Existing Macros to Define Matchers

GoogleMock provides helper macros like `MATCHER` and `MATCHER_P` for fast matcher creation without explicit classes:

```cpp
MATCHER(IsEven, " checks if a value is even") {
  return (arg % 2) == 0;
}

MATCHER_P(HasSize, size, " checks if container has specified size") {
  return arg.size() == size;
}
```

---

## Best Practices for Custom Assertions and Matchers

- **Fail Clearly:** Provide failure messages describing what was expected and what was received.
- **Name Intuitively:** Choose names that express intent clearly for readable tests.
- **Evaluate Arguments Once:** Avoid side effects that might cause repeated evaluation issues.
- **Leverage Existing Utilities:** Use GoogleTest `AssertionResult` and GoogleMock utilities to simplify code.
- **Compose with Built-in Matchers:** Custom matchers can be combined with existing ones for flexible checks.
- **Test Your Matchers:** Create tests for your matchers themselves to ensure correctness.

---

## Common Pitfalls and How to Avoid Them

- **Verbose Failure Messages:** Failing to provide detailed messages hurts debugging; always explain failure causes.
- **Using Predicate Assertions When Predicate-Format Is Needed:** Avoid opaque `EXPECT_TRUE(predicate())` without explanation; prefer returning `AssertionResult`.
- **Side Effects in Arguments:** Arguments to assertions may be evaluated multiple times; avoid altering external state in those expressions.
- **Incorrect Use of Matchers:** Custom matchers must implement required methods and describe themselves for correct operation.
- **Memory Leaks:** Ensure your matcher instances are managed correctly (use smart pointers or macros that handle ownership).

---

## Where to Learn More

- [GoogleTest Assertions Reference](reference/assertions.md) for complete details.
- [GoogleMock Matchers Reference](reference/matchers.md) for built-in matchers and writing custom ones.
- [Advanced GoogleTest Topics](advanced.md#predicate-assertions) for usage patterns.

---

## Summary

Crafting your own assertions and matchers unlocks the full power of GoogleTest and GoogleMock by allowing testing logic that fits your domain perfectly with rich error reporting. Utilize predicate assertions for quick checks, `AssertionResult`-returning functions for detailed output, and matcher classes or macro helpers for mocking scenarios. Follow best practices of clarity, readability, and single evaluation to build maintainable and effective tests.