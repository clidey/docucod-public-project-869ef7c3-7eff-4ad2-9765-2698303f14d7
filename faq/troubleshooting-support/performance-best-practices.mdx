---
title: "Improving Test Performance"
description: "Tips to speed up test execution, limit resource usage, and structure unit tests for scale. Includes advice for managing large suites, test discovery, and parallelization options."
---

# Improving Test Performance

This page provides practical tips to help you speed up test execution, reduce resource usage, and organize your GoogleTest unit tests for scalability. Whether working with large test suites or seeking optimal test discovery and parallel execution strategies, this guide will help you achieve efficient and maintainable testing workflows.

---

### Frequently Asked Questions

#### What are the key strategies to speed up GoogleTest execution?

- **Limit resource usage per test:** Avoid costly setup/teardown in every test where possible. Use test fixtures effectively to share setup work.
- **Structure tests for scalability:** Group related tests into test suites and consider parameterized testing to reduce duplication.
- **Control test discovery and filtering:** Use test filters to run only specific tests during development.
- **Run tests in parallel:** Leverage parallel test execution options to utilize available CPU cores.


#### How can I manage large test suites efficiently?

- Organize tests logically in suites and fixtures.
- Employ parameterized and typed tests to cover multiple scenarios with less code.
- Use `InSequence` or other ordering constraints sparingly to avoid slowdowns.
- Consider sharding your tests across multiple processes or machines for CI/CD.


#### What options exist for test discovery and execution control?

- Run specific tests using the `--gtest_filter=` flag.
- Exclude slow or flaky tests temporarily with filters.
- Use GoogleTest’s environment variables or command-line options to control output verbosity and results.


#### How does parallel test execution work with GoogleTest?

- GoogleTest supports running tests concurrently, typically via test shards or external tooling.
- You can shard tests by dividing them into non-overlapping subsets based on test names or indices.
- Ensure tests are independent and do not share mutable global state to safely parallelize.

---

### Best Practices for Test Performance Optimization

#### 1. Optimize Test Fixture Usage
- Initialize expensive resources once per test suite rather than per test, using `SetUpTestSuite` and `TearDownTestSuite`.
- Keep test fixtures lean; avoid heavy object constructions.

#### 2. Minimize External Dependencies and Shared Resources
- Mock dependencies where possible instead of using real I/O, database calls, or network access.
- Avoid shared state that requires locking or serialization.

#### 3. Use Parameterized Tests to Avoid Redundancy
- Parameterized tests (`TEST_P` with `INSTANTIATE_TEST_SUITE_P`) run the same test logic with multiple data points.
- This reduces code duplication and speeds up maintenance.

#### 4. Prune and Filter Tests for Iterative Development
- Use the `--gtest_filter=` option or environment variables to run targeted test subsets.
- Integrate filtering with your build and CI systems to optimize developer feedback cycles.

#### 5. Parallelize Test Execution Wisely
- Use build tools or CI runners that support parallel test execution.
- Maintain tests isolated to avoid races or flakiness.
- Consider explicit test sharding approaches if supported by your tooling.

---

### Managing Large and Complex Test Suites

As your project grows, your test suite may grow large and complex, which can impact test execution time and maintainability.

#### Tips for scaling test suites:

- **Organize tests in source files by feature or module.** This makes discovery and filtering easier.
- **Use test fixtures and parameterized tests to avoid boilerplate and consolidate coverage.**
- **Use `InSequence`, `Expectation`, and `Sequence` thoughtfully to control call order, but avoid over-constraining tests which can slow execution and cause fragility.**
- **Avoid running all tests for every build.** Run critical tests frequently, and full suites in CI or nightly.

---

### Controlling Test Discovery and Filtering

GoogleTest discovers tests by scanning for test case macros at runtime. Controlling which tests run can drastically speed development iterations.

- **Run specific tests:** Use `--gtest_filter=TestSuiteName.TestName` or wildcard `*` to include multiple tests.
- **Exclude tests:** Prefix filters with `-` to exclude tests.
- **Combine filters:** Use `:` to separate multiple filters.

Example:

```bash
./my_test_binary --gtest_filter=FooTest.* -BarTest.*
```

This runs all tests in `FooTest` but excludes all tests in `BarTest`.

---

### Parallel Test Execution Techniques

GoogleTest itself does not provide built-in multi-threaded test execution, but integration with build systems and CI tools enables parallelism.

#### Common approaches:

- **Test Sharding:** Split tests by test name or indices (`--gtest_shard_index` and `--gtest_total_shards`) to run in parallel processes.
- **External Parallel Test Runners:** Use tools like Bazel’s test runner, CTest, or third-party test runners that invoke test binaries concurrently.
- **Isolate shared state:** Ensure no test shares mutable state that can lead to race conditions.

Example of sharding usage:

```bash
./my_test_binary --gtest_total_shards=4 --gtest_shard_index=2
```

This runs the third shard out of four total shards.

---

### Common Pitfalls to Avoid

- **Heavy setup/teardown in each test:** Causes slow execution. Use suite-level setups when possible.
- **Overly strict ordering or dependency between tests:** Limits parallelism and adds brittleness.
- **Failing to isolate tests:** Shared globals or external state can cause flaky and slow tests.
- **Excessive logging:** May slow tests and clutter output.
- **Ignoring flaky tests:** Identify, fix, or quarantine flaky tests to keep suite reliable.

---

### Troubleshooting Performance Issues

If your test suite runs slowly or consumes too many resources:

- Profile test execution times to identify bottlenecks.
- Review tests for costly external operations or redundant setup.
- Check for unintended dependencies or global state.
- Ensure your build and test infrastructure supports parallel execution.
- Use filtering to reduce scope during development.

---

### Related Documentation

- [Scaling and Maintaining Large Test Suites](../guides/advanced-best-practices/scaling-tests.md)
- [Performance Optimization and Anti-Patterns](../guides/advanced-best-practices/performance-optimization.md)
- [Test Structure & Discovery](../concepts/core-architecture/test-structure-discovery.md)
- [Parameterized and Typed Tests](../concepts/advanced-concepts/parameterized-tests.md)
- [Integrating with Build Systems and Toolchains](../guides/advanced-best-practices/integration-tools.md)

For mocking-specific performance tips, consult the [Mocking Reference](../docs/reference/mocking.md) and the [gMock Cookbook](../docs/gmock_cook_book.md).

---

<Tip>
To optimize test speed while ensuring coverage, start by pruning the tests you run actively and use parameterized tests to reduce duplication. Use suites and fixtures to share heavy setup, and leverage sharding for parallel execution in your CI pipeline.
</Tip>

<Note>
GoogleTest expects test expectation setup (`EXPECT_CALL`) before running tested code. In large suites, make sure your expectation declarations do not cause costly or redundant computations.
</Note>

<Warning>
Running parallel tests safely requires tests to be independent and free of shared mutable state. Ignoring this can lead to intermittent failures or corrupted results.
</Warning>
