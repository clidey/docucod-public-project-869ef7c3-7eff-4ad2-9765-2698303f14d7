---
title: "Value- and Type-Parameterized Tests: Common Questions"
description: "Frequently asked questions about parameterized testing in GoogleTest, including how to use TEST_P, INSTANTIATE_TEST_SUITE_P, and combining different data types and values. Troubleshoot common misuses to unlock the full power of parameterized and typed tests."
---

# Value- and Type-Parameterized Tests: Common Questions

This FAQ page addresses common questions and practical issues encountered when using value- and type-parameterized tests in GoogleTest. It offers clear explanations and examples to help you harness the full power of parameterized testing capabilities.

---

## What are value-parameterized tests, and why should I use them?

Value-parameterized tests let you run the same test logic multiple times with different input values, minimizing test code duplication. For example, you can verify that a function behaves correctly for several inputs by writing a single test that accesses these inputs through a parameter.

This is perfect when you want to validate:
- Code behavior affected by various command-line flags or configurations
- Different implementations of the same interface
- Data-driven testing with diverse inputs


## How do I define a value-parameterized test fixture?

To create these tests, you usually inherit your test fixture from `testing::TestWithParam<T>`, where `T` is the parameter type you want to test against. This base class provides the `GetParam()` method to access the current test's parameter.

Example:

```cpp
class MyParamTest : public testing::TestWithParam<int> {
  // You can add set up and helper functions here
};

TEST_P(MyParamTest, DoesSomething) {
  int param = GetParam();
  EXPECT_TRUE(YourFunction(param));
}
```

You define as many `TEST_P` tests as you want for the fixture.


## How do I instantiate the value-parameterized tests with parameters?

You use the macro `INSTANTIATE_TEST_SUITE_P` to supply the test fixture with different parameter values. This macro takes:

1. An instantiation name, used as a prefix for test identification
2. The test fixture class name
3. A parameter generator that defines the list or range of parameters
4. Optionally, a custom name generator for the test instances

Example using simple values:

```cpp
INSTANTIATE_TEST_SUITE_P(
    ExampleInstantiation, MyParamTest,
    testing::Values(1, 2, 3, 4));
```

This creates four tests with parameters 1, 2, 3, and 4.


## What types of parameter generators does GoogleTest provide?

GoogleTest offers several built-in generators to create parameter sets easily:

| Generator                        | Description                                                            |
|---------------------------------|------------------------------------------------------------------------|
| `Range(start, end [, step])`    | Generates values `[start, start+step, ..., < end)` without including end. Defaults step to 1. |
| `Values(v1, v2, ..., vN)`       | Generates specified values as explicit list.                           |
| `ValuesIn(container)`            | Generates values extracted from an array, vector, or iterator range.  |
| `Bool()`                       | Generates Boolean values `{false, true}`.                             |
| `Combine(g1, g2, ..., gN)`      | Cartesian product of multiple generators, creating tuples of parameters. |
| `ConvertGenerator<T>(gen, func)`| Converts generated values to desired type using `func`.                |

Use these generators for flexible test parameter combinations.


## How can I combine multiple parameters for complex tests?

Use `testing::Combine()` to produce all combinations of multiple parameter sets. This creates tuples of parameter values passed to the test.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    ComboTests, MyParamTest,
    testing::Combine(testing::Values(1, 2), testing::Bool()));
```

The test will run with parameters `(1, false)`, `(1, true)`, `(2, false)`, and `(2, true)`.

Inside the test, `GetParam()` will return a `std::tuple<int, bool>`.


## How do I access parameters in a combined parameter test?

The test fixture's parameter type becomes a `std::tuple` matching the combination. You can unpack it like this:

```cpp
TEST_P(MyParamTest, CombinedTest) {
  auto [int_value, bool_value] = GetParam();  // C++17 structured binding
  EXPECT_GT(int_value, 0);
  EXPECT_TRUE(bool_value || int_value == 1);
}
```

If your compiler doesn't support structured bindings, use `std::get<index>(GetParam())`.


## How can I supply custom parameter names for instantiated tests?

By default, test names for value-parameterized tests are numeric indexes (e.g., `/0`, `/1`, etc.). You can supply a custom name generator function or functor in the last argument to `INSTANTIATE_TEST_SUITE_P`.

This function receives a `TestParamInfo<T>` object containing the parameter value and index and must return a `std::string` with valid test-name characters (alphanumeric or underscore).

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(
    NamedTests, MyParamTest,
    testing::Values(10, 20),
    [](const testing::TestParamInfo<int>& info) {
      return "Value" + std::to_string(info.param);
    });
```

This will create tests named `Value10` and `Value20` instead of `/0` and `/1`.


## Why do I sometimes get errors about invalid or duplicate parameter names?

GoogleTest requires parameter names to be:
- Non-empty
- Unique within the instantiation
- Contain only alphanumeric characters or underscores

Using default names like `PrintToString` can generate invalid names if your parameter type is a string or contains spaces or special characters.

Use custom name generators to sanitize names or use `PrintToStringParamName` for types safely printable with GoogleTest's printer.


## Can value-parameterized tests be instantiated multiple times?

Yes, you can instantiate the same test suite multiple times with different parameter sets by calling `INSTANTIATE_TEST_SUITE_P` multiple times with different instantiation names and parameter generators.

Example:

```cpp
INSTANTIATE_TEST_SUITE_P(First, MyParamTest, testing::Values(1, 2));
INSTANTIATE_TEST_SUITE_P(Second, MyParamTest, testing::Values(3, 4));
```

They will run as separate test sets.


## What are typed tests and type-parameterized tests?

Typed tests allow writing tests that run over multiple types â€” unlike value-parameterized tests which run over values. You define a test fixture template and a list of types to instantiate it with.

- **Typed tests**: You know the list of types at test definition time.
- **Type-parameterized tests**: You define the test patterns abstractly and instantiate them with types later, supporting multiple instantiations at different translation units.

Typed tests use macros like `TYPED_TEST_SUITE` and `TYPED_TEST`.


## When should I use value-parameterized tests vs typed tests?

- Use **value-parameterized tests** when your main variability is input data or parameters.
- Use **typed tests** when you want to test your code across a set of types that follow the same interface.

Value-parameterized tests give flexibility in parameter objects and custom setup, while typed tests focus on type-driven code paths.


## How do I create and instantiate typed tests?

1. Define a fixture template:

```cpp
template <typename T>
class MyTypedTest : public testing::Test {
 public:
  // fixture members
};
```

2. Provide a list of types:

```cpp
using MyTypes = ::testing::Types<int, float, double>;
TYPED_TEST_SUITE(MyTypedTest, MyTypes);
```

3. Write typed tests:

```cpp
TYPED_TEST(MyTypedTest, BehavesCorrectly) {
  TypeParam value = ...;
  EXPECT_TRUE(...);
}
```

GoogleTest will run the test suite once for each of the types.


## How do type-parameterized tests differ?

They separate test suite definition and instantiation:

- Use `TYPED_TEST_SUITE_P` and `TYPED_TEST_P` to define the test suite and tests.
- Register the tests with `REGISTER_TYPED_TEST_SUITE_P`.
- Instantiate the suite with `INSTANTIATE_TYPED_TEST_SUITE_P`.

This allows multiple instantiations across translation units with possibly different type lists.


## What if I want to test private or internal implementation using parameterized tests?

Follow best practices of black-box testing by testing public interfaces. When you must test internal code:

- Refactor into internal classes (in internal headers).
- Use friend declarations or accessors in test fixtures.

Parameterized tests work the same, just apply these access techniques inside your test fixtures.


## What are some common mistakes with value-parameterized tests?

- Forgetting to instantiate the test suite with `INSTANTIATE_TEST_SUITE_P` causes tests never to run and may get reported as errors. Use `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` if this is intended.
- Using parameter types not copyable or incorrectly managing parameter lifetimes (especially with raw pointers).
- Invalid test names caused by illegal characters in parameter names.
- Using fatal assertions in non-void returning functions inside parameterized tests.


## How can I debug unexpected parameter values or test failures?

- Use `SCOPED_TRACE` to add trace messages inside helper functions for better failure context.
- Stream parameter values in failure messages explicitly.

Example:

```cpp
SCOPED_TRACE(testing::Message() << "Current param: " << GetParam());
EXPECT_EQ(..., ...);
```


## How do I access the current test's name or parameter during a parameterized test run?

You can call:

```cpp
const testing::TestInfo* const test_info =
    testing::UnitTest::GetInstance()->current_test_info();

std::cout << "Test suite: " << test_info->test_suite_name() << std::endl;
std::cout << "Test name: " << test_info->name() << std::endl;
std::cout << "Value parameter: " << test_info->value_param() << std::endl;
```

This helps with logging and dynamic test behaviors.


## Can I register parameterized tests programmatically (at runtime)?

Yes, using `testing::RegisterTest`. This advanced API allows dynamic test creation with parameters, useful for data-driven test generation not known at compile time.


## Summary Example: Defining and Instantiating a Value-Parameterized Test

```cpp
class MyValueParamTest : public testing::TestWithParam<int> {};

TEST_P(MyValueParamTest, IsPositive) {
  int value = GetParam();
  EXPECT_GT(value, 0);
}

INSTANTIATE_TEST_SUITE_P(
    Positives, MyValueParamTest,
    testing::Values(1, 2, 5, 10),
    testing::PrintToStringParamName());
```

When running, GoogleTest will output test names like `Positives/MyValueParamTest.IsPositive/0` for parameter `1`, etc.

---

For deeper dives, best practices, and detailed API references, please consult:

- [Advanced GoogleTest Topics: Value-Parameterized Tests](docs/advanced.md#value-parameterized-tests)
- [Testing Reference: TEST_P and INSTANTIATE_TEST_SUITE_P](docs/reference/testing.md#TEST_P)
- [Typed and Type-Parameterized Tests](docs/advanced.md#typed-tests)
- [GoogleTest Primer](docs/primer.md)

See also related FAQ pages and the Parameterized Tests Sample in the source repository.

---