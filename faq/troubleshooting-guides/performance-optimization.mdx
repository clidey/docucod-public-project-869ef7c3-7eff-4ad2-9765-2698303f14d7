---
title: "Performance Tips & Best Practices"
description: "How to improve test execution speed, optimize resource use, and diagnose sources of slow test performance. Emphasizes best practices for writing efficient tests and leveraging test runner features for parallelism."
---

# Performance Tips & Best Practices

This guide focuses on optimizing the speed of test execution, efficient resource utilization, and diagnosing slow test runs in GoogleTest and GoogleMock environments. By following these recommendations, you will write faster, more maintainable tests and leverage GoogleTest features that enhance performance, especially in large codebases.

---

## 1. Understanding Test Execution Performance

Test execution time can heavily impact your development cycle. Slow tests deter frequent test runs and increase feedback latency. The causes of slow tests often include:

- Excessive setup or teardown time in test fixtures
- Inefficient or heavyweight mock object usage
- Tests with dependencies that are costly or slow
- Serial execution of tests when parallelism is possible

Addressing these issues accelerates your testing loop and keeps development agile.

## 2. Best Practices for Writing Efficient Tests

### Keep Tests Small and Focused

Write tests that verify one logical aspect per test case. Smaller tests have faster setup and teardown, are clearer in intent, and easier to debug. Avoid bloated fixtures or combining unrelated verifications.

### Use Test Fixtures Judiciously

Reusing a test fixture can reduce duplication, but heavy or complex fixtures can slow down tests. Only include setup code that is truly shared among tests. Consider lightweight fixtures or helper functions instead.

### Prefer `ON_CALL` to `EXPECT_CALL` When Possible

- `ON_CALL` configures default behavior without setting an expectation.
- `EXPECT_CALL` asserts the test will invoke the method.

By default, overly strict or excessive expectations (`EXPECT_CALL`) increase test overhead and brittleness. Use `ON_CALL` to set default mock behavior and reserve `EXPECT_CALL` for cases where call verification is essential.

### Minimize Expensive Mocking

Limit mocking of complex objects or large interfaces. Instead of mocking every method, mock only what interactions are important for the test's behavior or outcome.

### Delegate to Real or Fake Objects for Complex Behavior

To reduce effort and maintain test performance, delegate mock behavior to a real or fake object for common scenarios. This avoids duplicating logic in mocks and enhances execution efficiency.

## 3. Leveraging Parallel Test Execution

GoogleTest supports parallel test execution at the test binary or build system level. Using parallelism can dramatically reduce total test runtimes.

### Running Tests in Parallel

- Use tools like `ctest` or test runners that execute GoogleTest binaries concurrently.
- Split tests logically into smaller binaries or shards.

### Sharding and Environment Variables

- Configure `GTEST_TOTAL_SHARDS` (total number of shards) and `GTEST_SHARD_INDEX` (index of current shard) to run subsets in parallel.
- Each shard runs the full test binary but only executes a distinct subset of tests. This helps balance loads across multiple machines.

### Best Practices

- Keep tests independent to avoid side-effects that interfere when running in parallel.
- Avoid shared static state that is mutated during tests.

## 4. Mocking Practices to Improve Performance

Mimicking real behavior efficiently and avoiding unnecessary overhead in mocks can boost test speed.

### Use NiceMock for Non-critical Calls

`NiceMock<T>` suppresses warnings on uninteresting calls and avoids overhead related to excessive logging.

### Avoid Excessive `EXPECT_CALL`s

Too many expectations slow down mock verification. Write only necessary expectations.

### Use `RetiresOnSaturation()` to Release Expectations

In cases where expectations should not linger after saturation, `.RetiresOnSaturation()` on `EXPECT_CALL` lets GoogleMock retire them early, improving matching speed.

### Manage Default Actions with `ON_CALL`

Set up mock default behavior once in the test fixture or mock constructor using `ON_CALL` rather than repeatedly in tests.

## 5. Diagnosing Slow Tests

When tests run slowly, pinpointing the root cause is critical.

### Profiling Test Execution

- Use profilers or test timers to identify slow setups, teardowns, or particular tests.
- Add custom timers in your test fixtures or main test body.

### Verbose Mock Output for Debugging

Run tests with `--gmock_verbose=info` to track each mock call and expectation matching. It provides insight into unexpected or uninteresting calls, which might slow down tests.

### Watch for Overly Complex Matchers or Actions

Complex matchers or actions with side effects degrade performance. Use simpler matchers and lightweight actions whenever possible.

### Heap and Resource Analysis

Leaks or resource exhaustion can be related to slow or stalled tests. Use built-in or external tools to catch such issues early.

## 6. Advanced Performance Tips

### Test Suite Organization

Organize tests by grouping them logically and enabling selective execution via `--gtest_filter`. This avoids running slow or unrelated tests unnecessarily during development.

### Flaky Tests and Repeat Execution

Use `--gtest_repeat=N` to detect intermittent timing or resource contention issues that slow tests.

### Avoid Dynamic Allocation in Hot Paths

Reduce use of heap allocations in mocks or test helpers. Prefer stack allocation or `constexpr` data.

### Use Fast Default Values

For mock methods returning complex objects, set fast default actions with `DefaultValue<T>::Set()` to avoid expensive constructions.

## 7. Example: Speeding Up a Mock Setup

```cpp
using ::testing::NiceMock;
using ::testing::Return;

class MockDatabase {
 public:
  MOCK_METHOD(bool, Connect, (), ());
  MOCK_METHOD(int, Query, (const std::string& sql), ());
};

// Instead of repeatedly setting expectations in tests...
NiceMock<MockDatabase> mock_db;
ON_CALL(mock_db, Connect()).WillByDefault(Return(true));
ON_CALL(mock_db, Query(_)).WillByDefault(Return(0));

TEST(FooTest, UsesDatabase) {
  EXPECT_CALL(mock_db, Connect())
      .Times(1);

  MyDatabaseUser user(&mock_db);
  user.DoWork();
}
```

This setup minimizes overhead by setting default behaviors upfront and restricting expectations only when necessary, improving test clarity and speed.

---

## Helpful Flags to Control Performance Diagnostic Output

| Flag                      | Description                                                  |
|---------------------------|--------------------------------------------------------------|
| `--gmock_verbose=info`    | Shows detailed tracing of mock function calls and matches.  |
| `--gtest_repeat=N`        | Repeats all tests N times to catch flakiness or slowdowns.   |
| `--gtest_filter=PATTERN`  | Run only tests matching PATTERN to isolate slow or flaky ones.|

## References

- [gMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) - Best practices and advanced mocking
- [Mocking Reference](reference/mocking.md) - Comprehensive API details
- [GoogleTest Primer](primer.md) - For foundational test writing
- [Performance Optimization Guide](guides/real-world-integrations/performance-optimization.md) - In-depth strategies

---

## Troubleshooting

<AccordionGroup title="Common Performance Issues and Solutions">
<Accordion title="Why are some tests running very slowly?">
Often, expensive setup or teardown in test fixtures is the cause. Check for complex initializations or resource loads that can be trimmed or shared.
</Accordion>
<Accordion title="How to prevent mock warnings that might slow down tests?">
Use `NiceMock<T>` for mocks where uninteresting calls should not trigger warnings. Explicitly define expected calls with `EXPECT_CALL` where call verification is needed.
</Accordion>
<Accordion title="Tests fail or behave differently when run in parallel. Why?">
Ensure tests do not share mutable static or global state. Isolate dependencies and avoid side-effects that conflict when running concurrently.
</Accordion>
<Accordion title="My tests are slow but I can't identify why. What should I do?">
Use profilers or built-in timers to isolate slow tests or test phases. Run with `--gmock_verbose=info` to analyze mock interaction overhead.
</Accordion>
</AccordionGroup>

## Summary
By writing efficient, focused tests, clearly managing mock expectations, and leveraging GoogleTest's parallel and sharding capabilities, you can drastically improve the speed and robustness of your test suite. Monitor and profile your tests regularly to maintain high performance and diagnose issues promptly.

---

For complete mastery, combine these practices with the broader test writing and mocking documentation to build fast, maintainable, and reliable test suites.