---
title: "Integrating GoogleTest with Existing Projects"
description: "Addresses frequent hurdles when integrating GoogleTest into existing codebases, including managing dependencies, configuring test runners, and customizing test discovery."
---

# Integrating GoogleTest with Existing Projects

Integrating GoogleTest into an existing C++ codebase can be challenging due to dependencies, build configuration, test runner setup, and customizing test discovery. This guide addresses common hurdles and practical strategies to seamlessly add GoogleTest and GoogleMock to your project, enabling you to write and run tests effectively alongside your existing code.

---

## 1. Managing Dependencies

### a. Adding GoogleTest and GoogleMock Sources

You have multiple ways to include GoogleTest and GoogleMock libraries:

- **Submodule or Vendor Directory**: Clone GoogleTest as a Git submodule into your project or copy its source into a `third_party`/`external` folder. This allows you to control the version and easily update.

- **Package Managers**: Use system or third-party package managers if available to get prebuilt GoogleTest libraries.

- **FetchContent in CMake**: For CMake projects, use `FetchContent_Declare()` and `FetchContent_MakeAvailable()` to download and build GoogleTest automatically as part of your build process.

### b. Building GoogleTest Together with Your Project

Integrating GoogleTest’s source directly into your build ensures consistency:

- Use `add_subdirectory()` in your CMake to add GoogleTest.
- Link your test binaries against `gtest` and `gmock` targets to access their headers and compiled code.
- Ensure your project uses **C++17 or above**, as GoogleTest requires this standard.

<Tip>
Keep GoogleTest’s build settings in sync with yours, especially runtime libraries and debug/release configurations, to prevent linking issues.
</Tip>

### c. Handling Linking and Include Paths

- Add include directories pointing to GoogleTest and GoogleMock header folders.
- Link against `gtest`, `gtest_main`, `gmock`, and optionally `gmock_main` libraries.
- On Windows, if you experience runtime library mismatch errors, adjust GoogleTest's `gtest_force_shared_crt` option accordingly.

<Note>
If you see build or link errors, refer to the [Resolving Build and Link Errors](/faq/build-integration/build-and-link-errors) page for detailed guidance.
</Note>

---

## 2. Configuring Test Runners

### a. Using the Default `main()` Provided by GoogleTest

- In most cases, link your test executable with `gtest_main` or `gmock_main`. These provide a predefined `main()` that initializes the framework and runs all tests.

- This approach avoids boilerplate and is straightforward for existing projects.

### b. Writing a Custom `main()`

- If you need custom initialization before tests run (e.g., initializing application subsystems), write your own `main()`.

- Call `testing::InitGoogleTest(&argc, argv);` (or `InitGoogleMock` if mocks are used) to initialize GoogleTest/GoogleMock.

- Then call `RUN_ALL_TESTS()` to execute the registered test cases.

```cpp
#include <gtest/gtest.h>

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  // Custom initialization here
  return RUN_ALL_TESTS();
}
```

### c. Integrating with Existing Test Frameworks or Runners

- You can register GoogleTest tests without calling `RUN_ALL_TESTS()` immediately if your project uses a central test runner.

- Use `testing::UnitTest::GetInstance()` to query test results programmatically.

<Info>
Refer to the [Running and Configuring Tests](/api-reference/core-apis/running-tests) documentation for advanced execution scenarios.
</Info>

---

## 3. Customizing Test Discovery

### a. Registering Tests Automatically

- GoogleTest automatically discovers tests defined with macros like `TEST()`, `TEST_F()`, and `TEST_P()`, as soon as your test binary runs.

- Ensure your tests are linked into the test binary, otherwise they won’t be found.

### b. Configuring Test Namespaces and Suites

- Organize tests into suites and fixtures logically to avoid name collisions.

- Match naming conventions to your existing project structure for clarity.

### c. Filtering Tests

- Use command-line flags such as `--gtest_filter` to run specific tests.

- This lets you integrate GoogleTest selectively into existing workflows and test runners.

<Tip>
If your project uses custom macros or test registration mechanisms, ensure GoogleTest macros are properly invoked and that test object files are linked.
</Tip>

---

## 4. Writing Mocks in Existing Projects

### a. Define Mock Classes

- Derive from your interfaces or abstract base classes.

- Use `MOCK_METHOD()` macros in the `public:` section regardless of the original method’s visibility.

- Qualify with `(override)` and other specifiers as appropriate.

### b. Handling Complex Signatures

- Wrap return or argument types that include commas with parentheses or create type aliases to avoid macro parsing issues.

- See examples in the [Mocking Reference](/api-reference/mocking-apis/mocking-methods).

### c. Managing Mock Strictness

- Use `NiceMock` to suppress warnings about uninteresting calls.

- Use `StrictMock` to turn unexpected calls into errors.

### d. Delegating Calls

- Delegate to fakes, real objects, or parent class methods if needed to maintain behavior consistency.

### e. Avoid Mocking Non-virtual Methods When Possible

- Instead, use interfaces or the high-performance dependency injection pattern when needed.

<Warning>
Avoid mocking classes you do not own directly. Consider designing adapters or interfaces to improve testability.
</Warning>

---

## 5. Best Practices & Common Pitfalls

- **Set Expectations Before Exercise:** Always define `EXPECT_CALL()` before the code under test executes.

- **Sync Build Configurations:** Ensure your project and GoogleTest use the same compiler flags, especially for exception handling, RTTI, and C++ standard.

- **Avoid Over-Specifying:** Set only necessary expectations to avoid brittle tests.

- **Manage Test Dependencies:** Keep GoogleTest dependencies isolated to test targets; don’t leak them into production code.

- **Regularly Update GoogleTest:** Keep the GoogleTest version in sync with your project to leverage bug fixes and improvements.

- **Use Diagnostic Flags:** Enable `--gmock_verbose=info` for debugging test failures related to mocks.

---

## 6. Troubleshooting

<AccordionGroup title="Common Issues When Integrating GoogleTest">
<Accordion title="Build and Link Failures">
Ensure correct include paths and link dependencies. Confirm that GoogleTest libraries are properly built with your compiler and linked into your test binary.
</Accordion>
<Accordion title="Test Cases Not Found or Run">
Verify that test source files are compiled and linked into the test executable. Check that macros like `TEST()` are used properly and that tests are not excluded by preprocessor conditions.
</Accordion>
<Accordion title="Uninteresting Mock Call Warnings">
Use `NiceMock` or add `EXPECT_CALL(mock, Method).Times(AnyNumber())` to suppress harmless warnings for mock calls you’re not verifying.
</Accordion>
<Accordion title="Runtime Failures in Tests">
Use the `--gmock_verbose=info` flag to trace mock method calls and diagnose test failures related to expectations.
</Accordion>
</AccordionGroup>

---

## 7. Additional Resources

- [GoogleTest Primer](/docs/primer.md) – introduction and basic usage.
- [Mocking Reference](/docs/reference/mocking.md) – detailed guide to mocks.
- [GoogleMock Cookbook](https://google.github.io/googletest/gmock_cook_book.html) – advanced mocking recipes.
- [Resolving Build and Link Errors](/faq/build-integration/build-and-link-errors) – troubleshooting build issues.
- [Running Tests and CI Integration](/gtest-guides/integration-scaling/ci_integration) – executing tests in automated pipelines.

---

Integrating GoogleTest into your existing codebase elevates your testing capabilities with minimal friction. Proper dependency management, build and runner configuration, and mock design harmonize to deliver a robust and maintainable test environment that fits smoothly within your development workflow.