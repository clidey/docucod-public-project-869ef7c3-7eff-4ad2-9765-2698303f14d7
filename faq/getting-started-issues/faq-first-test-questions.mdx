---
title: "First Test: Typical Pitfalls and Tips"
description: "Answers to the most common questions when writing and running your first test cases, including test discovery, assertion usage, and understanding test failures. This page helps users build confidence as they validate their initial tests."
---

# First Test: Typical Pitfalls and Tips

This FAQ page addresses the most common questions and challenges you will face when writing and running your first test cases using GoogleTest. It covers test discovery, assertions usage, error interpretations, and test naming best practices to help you avoid issues and gain confidence in validating your tests.

---

## Why shouldn't test suite names and test names contain underscores?

GoogleTest reserves the underscore (`_`) character for special purposes such as prefixes like `DISABLED_`, and the use of underscores in test names can cause naming collisions or reserved identifier violations in C++.

- Identifiers starting with an underscore followed by an uppercase letter or containing consecutive underscores anywhere are reserved by C++ and cannot be used.
- Since GoogleTest internally generates class names of the form `TestSuiteName_TestName_Test`, underscores in either `TestSuiteName` or `TestName` can lead to invalid or colliding names.

**Best Practice:** Avoid underscores at the beginning, the end, or within the test suite and test names.

```cpp
// Avoid this:
TEST(Time_Flies, Like_An_Arrow) { ... }  // Can cause collisions

// Instead:
TEST(TimeFlies, LikeAnArrow) { ... }
```

Violations may not cause immediate failures but can break tests with certain compilers or future versions of GoogleTest.

## How do I compare pointers to NULL safely in assertions?

GoogleTest supports using `nullptr` in assertions like `EXPECT_EQ` and `ASSERT_EQ` for clarity and type safety. For example:

```cpp
EXPECT_EQ(ptr, nullptr);
ASSERT_EQ(ptr, nullptr);
```

While `EXPECT_EQ(NULL, ptr)` works, `EXPECT_NE(NULL, ptr)` is not supported due to implementation complexity and limited utility. Instead, prefer:

```cpp
EXPECT_TRUE(ptr != nullptr);
```

Consider using `nullptr` as it avoids C++ type issues with `NULL`.

## Typed tests or value-parameterized tests — which should I use for interface implementations?

Both typed tests and value-parameterized tests help you verify that different implementations of an interface satisfy common requirements. Your choice depends on convenience:

- **Typed tests** are simpler if all implementations can be instantiated uniformly (e.g., default constructor).
- **Value-parameterized tests** offer flexibility if different implementations require different construction patterns (e.g., via factory functions).

Typed tests include type information in failure messages, which can be very helpful;
Value-parameterized tests show iteration count by default but allow custom naming functions for more clarity.

Try both and decide which suits your case better.

## Why does state modified during a death test seem lost afterwards?

Death tests run in a **separate sub-process** to isolate crashes and prevent killing the main test runner process. Any in-memory side effects, like modifying variables or calling mocks, occur only in the child process and are not visible to the parent process.

**Workaround:** Keep `EXPECT_CALL` statements inside the death test macro to ensure mocks behave as expected.

## Why should I return the value of `RUN_ALL_TESTS()`?

`RUN_ALL_TESTS()` returns an integer indicating success (`0`) or failure (`1`). Not returning this value from your `main()` function can cause misleading results, making the test runner think all tests passed even when failures occurred.

Example:

```cpp
int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();  // Important to return this!
}
```

Ignoring this return value now causes compiler errors to help enforce correct usage.

## How to derive a test fixture from another?

GoogleTest allows test fixtures to inherit from base fixtures.

- Share common setup/teardown logic by putting it in a base class.
- Derive specialized fixtures from that base to extend or override behavior.
- Use `TEST_F()` with each derived fixture as usual.

Example:

```cpp
class BaseTest : public ::testing::Test {
 protected:
  // Common setup code
};

class FooTest : public BaseTest {
 protected:
  void SetUp() override {
    BaseTest::SetUp(); // Call base setup
    // Additional setup
  }
};

TEST_F(FooTest, Bar) { ... }
```

There is no limit on the inheritance depth.

## Can I temporarily disable a test?

Yes. Prefix the test or test suite name with `DISABLED_` to exclude it from execution without removing the code or commenting out:

```cpp
TEST(FooTest, DISABLED_BrokenTest) {
  // This test will be compiled but not run.
}
```

Run disabled tests using the flag `--gtest_also_run_disabled_tests`.

## What causes "undefined references" to static const members?

If you declare a static const member in a class but do **not** define it in a `.cc` file, you may get linker errors.

Proper usage:

```cpp
// In header
class Foo {
  static const int kBar = 100;
};

// In .cc file
const int Foo::kBar;  // Define without initializer
```

For `constexpr` members, the inline definition suffices, no external definition needed.

## What does "void value not ignored as it ought to be" mean?

This compiler error often occurs when using `ASSERT_*()` macros in functions that do not return `void`.

Since `ASSERT_*()` can abort the current function on failure, but C++ language restrictions prohibit using them in non-void functions, you must:

- Use `ASSERT_*()` only in `void` functions.
- Or replace `ASSERT_*()` with `EXPECT_*()` in non-void functions.

Alternatively, restructure your code to separate assertions and return values.

## Why isn’t my `SetUp()` function called?

GoogleTest is case-sensitive. If you spell `SetUp()` as `Setup()`, it won't be called. Similarly, `SetUpTestSuite()` must be spelled exactly with capital `U` and `S`.

## Why is GoogleTest output mixed with LOG messages?

GoogleTest prints its output to `stdout` to separate it from `LOG` messages which go to `stderr`. You can redirect the test output to a file to separate these:

```shell
$ ./my_test > gtest_output.txt
```

This cleanly separates GoogleTest output (`stdout`) from `LOG` messages (`stderr`).

## How can I get the name of the currently running test?

Use `current_test_info()` from the `UnitTest` singleton:

```cpp
const testing::TestInfo* const test_info =
    testing::UnitTest::GetInstance()->current_test_info();

if (test_info) {
  std::cout << "Test Suite: " << test_info->test_suite_name() << std::endl;
  std::cout << "Test Name: " << test_info->name() << std::endl;
}
```

This is useful for generating logs or dynamic behavior depending on test name.

## Common pitfalls

- Test suite and test names containing underscores can cause name collisions.
- `ASSERT_*` macros must be used with care as they abort the current function.
- Death tests modify state only in subprocesses.
- Always return the result of `RUN_ALL_TESTS()` in `main()`.
- Correctly use `SetUp()` casing to ensure fixtures initialize.

---

## Additional Tips

- Use `TEST_F` to write tests that share common setup in fixtures.
- Use `GTEST_SKIP()` inside tests or fixtures to skip tests gracefully.
- Use `SCOPED_TRACE` to add context to assertion failures inside helper functions.
- Use `EXPECT_FATAL_FAILURE` and `EXPECT_NONFATAL_FAILURE` macros to test that your code produces expected test failures (useful for developing test utilities).

---

## Troubleshooting

<AccordionGroup title="Troubleshooting Common Scenarios">
<Accordion title="Test Not Running - Likely Causes and Fixes">
- Check that test and suite names do not contain underscores.
- Ensure `SetUp()` is spelled correctly.
- Confirm no `DISABLED_` prefix is accidentally disabling the test.
- Make sure test filter (`--gtest_filter`) is not excluding your test.
</Accordion>
<Accordion title="Death Test Issues">
- Death tests run in subprocesses — side effects are isolated.
- Ensure mock expectations for death tests are inside the death test statement.
- Use the `threadsafe` death test style if multi-threading causes hangs.
</Accordion>
<Accordion title="Assertion Placement Errors">
- Fatal assertions (`ASSERT_*`) only allowed in void-returning functions.
- Fatal assertions in constructors and destructors are not allowed.
- Use `SetUp()`/`TearDown()` for complex setup/teardown that may fail.
</Accordion>
<Accordion title="Linker Errors with Static Constants">
- Define static const members outside class in `.cc` files.
- Use inline `constexpr` if supported to avoid separate definition.
</Accordion>
</AccordionGroup>

---

## Further Learning and References

- [GoogleTest Primer](primer.md) - Start here for simple tests and concepts
- [Assertions Reference](reference/assertions.md) - Comprehensive assertion macros
- [Advanced GoogleTest Topics](advanced.md) - For advanced testing techniques
- [GoogleTest FAQ](faq.md) - For detailed answers including pitfalls
- [Core Testing APIs](reference/testing.md) - API details and macros

Explore these to deepen your mastery of GoogleTest and improve your testing workflow.

---

## Real-World Example

Here is a simple example demonstrating a typical first test and common assertion usage:

```cpp
#include <gtest/gtest.h>

// Function to test
int Add(int a, int b) {
  return a + b;
}

// Test suite and test
TEST(AdditionTest, AddsTwoPositiveNumbers) {
  EXPECT_EQ(Add(2, 3), 5);  // Passes
  EXPECT_NE(Add(2, 2), 5);  // Passes
  EXPECT_TRUE(Add(1, 1) == 2);
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

Run this with:

```shell
./your_test_binary
```

If this test fails, check test and suite names, correct use of assertions, and ensure you returned the value of `RUN_ALL_TESTS()` in `main()`.
