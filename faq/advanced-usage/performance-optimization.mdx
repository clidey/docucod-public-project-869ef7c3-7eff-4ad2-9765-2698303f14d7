---
title: "Performance and Scaling Tests"
description: "Tips and techniques for running tests efficiently on large projects, including parallel test execution, optimizing test discovery, and reducing test suite run times."
---

# Performance and Scaling Tests

Efficiently running tests on large C++ projects is crucial to maintaining rapid development cycles and ensuring quality. This page equips you with practical strategies to optimize your GoogleTest test suites for performance and scalability. Whether you're dealing with thousands of tests or complex integrations, these tips will help you reduce execution time, leverage parallelism, and streamline test discovery.

---

## Why Focus on Performance and Scaling?

As your test suite grows, test execution times can become a bottleneck that impedes developer productivity and continuous integration (CI) throughput. Long-running tests may delay feedback, causing frustration and slowing down release cycles.

GoogleTest is designed for fast, reliable testing, but large projects require careful attention to performance optimization. This page guides you through techniques to minimize runtimes without sacrificing test coverage or reliability.

## Key Strategies for Efficient Testing

### 1. Parallel Test Execution

GoogleTest supports running tests in parallel, distributing the workload across multiple CPU cores or machines.

**How to Use:**

- **Test Sharding:** Use environment variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` to divide your test suite across multiple machines or processes. Each shard runs a disjoint subset of tests once, allowing massive scale-out.

- **Concurrent Test Workers:** Many build systems and CI platforms allow you to launch multiple test processes in parallel. Use `--gtest_filter` to split tests manually, or use sharding to automate.

**Benefits:**

- Shortens total execution time proportionally to hardware resources.
- Improves CI pipeline throughput.

**Example:**

```bash
# On machine 1
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=0
./my_tests

# On machine 2
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=1
./my_tests

# On machine 3
export GTEST_TOTAL_SHARDS=3
export GTEST_SHARD_INDEX=2
./my_tests
```

---

### 2. Optimize Test Discovery and Filtering

GoogleTest automatically discovers tests via registration macros. However, configuring how the tests are filtered and selected can greatly affect the time it takes to decide what to run.

**Tips:**

- Use `--gtest_filter` to run only a subset of tests relevant to your current work.
- Exclude slow or flaky tests temporarily with `DISABLED_` prefix, and include them in longer CI cycles with `--gtest_also_run_disabled_tests`.
- Generate a list of tests using `--gtest_list_tests` to plan targeted runs.

**Example:**

```bash
./my_tests --gtest_filter=MyModule*  # Run all tests with prefix MyModule
./my_tests --gtest_filter=-*Slow*   # Skip all 'Slow' tests
```

---

### 3. Share Expensive Resources with Per-Test-Suite Setup

Some tests use costly resources such as database connections, file system setups, or large in-memory data structures.

**GoogleTest Solution:** Use `SetUpTestSuite()` and `TearDownTestSuite()` to initialize and tear down shared resources once per test suite instead of per test.

This reduces needless repetitive work and accelerates test runs.

**Example:**

```cpp
class DatabaseTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Initialize shared database fixture here
    db_connection_ = ConnectToDB();
  }

  static void TearDownTestSuite() {
    // Clean up database fixture
    DisconnectDB(db_connection_);
    db_connection_ = nullptr;
  }

  static DBConnection* db_connection_;
};

DBConnection* DatabaseTest::db_connection_ = nullptr;
```

---

### 4. Profiling and Identifying Slow Tests

Before optimizing, identify the slowest tests to focus your efforts.

Use GoogleTest's XML or JSON output reports to extract per-test execution times.

- Generate an XML report with `--gtest_output=xml:report.xml`.
- Analyze which tests consume the most time.
- Refactor or split long-running tests into faster, focused units.

---

### 5. Reduce Test Suite Run Times

- **Avoid Global Variables:** Use test fixtures rather than global state to prevent state contamination that causes retries and debugging overhead.
- **Limit External Dependencies:** Use mocks or fakes to replace slow or flaky dependencies like databases or network calls.
- **Batch Assertions Where Possible:** In test bodies, prefer non-fatal assertions (e.g., `EXPECT_*`) for more failures per run instead of stopping on the first failure.

---

## Advanced Performance Flags and Controls

GoogleTest offers several runtime flags that influence test execution performance.

| Flag | Description |
|-------|-------------|
| `--gtest_repeat=N` | Repeat all tests N times. Useful for flaky test detection and performance benchmarking. |
| `--gtest_shuffle` | Run tests in random order to detect inter-test dependencies. Use with seed output to reproduce failures. |
| `--gtest_break_on_failure` | Stops test execution on the first failure; useful with repeat and debugging but can reduce overall test coverage. |
| `--gtest_fail_fast` | Fail test run immediately on first failure, cutting test time but losing failures summary. |

Combine these flags with parallel sharding for powerful performance diagnostics.

---

## Common Pitfalls and How to Avoid Them

### Pitfall: Test-Order Dependencies

Tests that depend on the side effects of other tests can appear slower and less reliable.

**Best Practice:** Maintain test isolation by:

- Using fresh fixtures for each test
- Avoiding shared mutable global state
- Employing `--gtest_shuffle` to detect order-dependent tests


### Pitfall: Excessive Setup/TearDown Overhead

Avoid expensive setup/teardown at the per-test level if possible.

**Fix:** Use per-test-suite setup and teardown methods, or global environment setup.


### Pitfall: Running Tests That Are Not Relevant

Running irrelevant tests causes wasted time.

**Fix:** Use filtering flags extensively to target work-specific tests during development.

---

## Workflow for Performance Optimization

<Steps>
<Step title="Profile Your Test Suite">
Generate detailed test timing information using XML/JSON reports and identify slow tests.
</Step>
<Step title="Run Tests in Parallel">
Use sharding or multiple test worker processes to run tests concurrently.
</Step>
<Step title="Filter and Isolate">
Use `--gtest_filter` to run subsets during debug cycles, focusing on affected areas.
</Step>
<Step title="Use Shared Fixtures">
Refactor expensive resources to shared fixtures with `SetUpTestSuite()`.
</Step>
<Step title="Mock External Dependencies">
Replace real external services with mocks to reduce test latency and increase reliability.
</Step>
<Step title="Apply Advanced Flags and Iteratively Improve">
Utilize flags like `--gtest_repeat`, `--gtest_shuffle`, and `--gtest_fail_fast` to catch flaky tests and improve tests.
</Step>
</Steps>

---

## Troubleshooting Performance Issues

<AccordionGroup title="Common Performance Issues and Solutions">
<Accordion title="Tests Are Running Sequentially Despite Multiple Cores">
If tests are not running in parallel, verify your test runner or CI is correctly configured.

- Use sharding variables `GTEST_TOTAL_SHARDS` and `GTEST_SHARD_INDEX` properly.
- Confirm your build or CI system supports launching multiple test instances.
- Manually split tests with `--gtest_filter` as a fallback.
</Accordion>
<Accordion title="Test Discovery Is Slow">
Large numbers of tests can slow startup.

- Avoid unnecessarily large numbers of tests per binary.
- Break tests into smaller binaries if needed.
- Use explicit filtering to reduce search space.
</Accordion>
<Accordion title="Tests Depend on External Systems Causing Slowness or Flakiness">
Use mocking techniques from GoogleMock to replace slow dependencies with stable mocks.

See [gMock for Dummies](../../guides/core-workflows/introduction-to-mocking) for how to get started.
</Accordion>
</AccordionGroup>

---

## Additional Resources

- [Sharding Tests (Test Distribution)](https://github.com/google/googletest/blob/main/docs/advanced.md#distributing-test-functions-to-multiple-machines)
- [Running a Subset of Tests](../../getting-started/first-test-setup/test-discovery-execution.md#running-a-subset-of-the-tests)
- [Shared Test Fixtures (SetUpTestSuite)](../../docs/advanced.md#sharing-resources-between-tests-in-the-same-test-suite)
- [GoogleMock Introduction](../../guides/core-workflows/introduction-to-mocking.md)
- [Optimizing GoogleTest Performance](../../guides/real-world-mocking/organizing-large-test-suites.md#performance-optimization-tips)

## Summary

The techniques discussed here empower you to manage large GoogleTest test suites, reduce test run times, and maintain test suite health and developer productivity. Start with profiling and parallel execution, refine with test filtering and fixture sharing, and leverage mocks to speed tests and improve test reliability.

---

## Related Documentation

- [Getting Started with Test Discovery and Execution](../../getting-started/first-test-setup/test-discovery-execution.md)
- [Test Suite Structure & Execution Flow](../../concepts/architecture-core-models/test-suite-and-execution-flow.md)
- [Organizing and Scaling Large Test Suites](../../guides/real-world-mocking/organizing-large-test-suites.md)
- [GoogleTest Primer](../../docs/primer.md)

---

For further help, explore our FAQ sections on [Test Execution Problems](../../faq/common-issues/test-execution-failures.md) and [Performance and Scaling Optimization](../../faq/advanced-usage/performance-optimization.md).

---

_Last Updated: main branch_

