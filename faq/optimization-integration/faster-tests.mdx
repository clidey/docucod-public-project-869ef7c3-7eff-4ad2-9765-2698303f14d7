---
title: "How can I optimize performance and run tests faster?"
description: "Covers techniques for speeding up test execution, including parallelization, filtering test runs, and leveraging external tools. Explains when and how to use advanced test runners and suites."
---

# How can I optimize performance and run tests faster?

Efficient test execution is crucial for maintaining developer productivity and ensuring rapid feedback cycles, especially as your test suite grows. This document explores proven techniques and practical strategies for optimizing test performance using GoogleTest. It focuses on test parallelization, filtering, sharding, and test design best practices that enable faster test runs without compromising reliability.

---

## 1. Parallel Test Execution

Running tests in parallel is the most straightforward way to reduce overall test execution time. GoogleTest supports parallel test runs at several levels.

### Benefits of Parallelization
- Utilizes multiple CPU cores efficiently to speed up test execution.
- Shortens feedback time during development and CI runs.

### Strategies

- **Process-Level Parallelism:** Most common method where multiple test binaries or instances run concurrently, each handling different subsets of tests.
- **Thread-Level Parallelism:** GoogleTest is thread-safe and supports test execution in multi-threaded environments, though this requires careful control of shared state.

### Implementing Parallel Test Runs

*CI Integration:* Use your CI system (e.g., Jenkins, GitHub Actions, GitLab CI) capabilities to split tests and run them in parallel shards.

*Command-Line:* Manually run multiple test executables concurrently or use shell scripting to parallelize.

### Best Practices
- Avoid shared mutable state or protect it carefully to prevent races.
- Use fixtures sparingly for heavy setup that serializes tests.
- Prefer tests that are independent and contain no hidden dependencies.

---

## 2. Test Filtering and Selective Execution

GoogleTest provides powerful filtering options to run only a subset of tests, which saves time during development cycles.

### Using `--gtest_filter`

You can specify which tests to run by pattern matching:

```bash
./my_tests --gtest_filter=SuiteName.TestName
// Or use wildcards
./my_tests --gtest_filter=MySuite.*
```

### Excluding Tests

Exclude tests using a minus sign:

```bash
./my_tests --gtest_filter=-SlowTests.*
```

This is useful when you want to skip long-running or flaky tests.

### Common Filtering Use Cases

- Run tests related to recent code changes.
- Skip integration or slow tests during quick iterations.
- Isolate flaky tests for separate investigation.

### Tips
- Use `--gtest_list_tests` to see the available test names.
- Combine with environment variables or scripts to automate selective testing.

---

## 3. Test Sharding

Sharding splits your test suite into multiple, disjoint subsets or shards, which can be run independently and in parallel.

### How Test Sharding Works

- Divide your tests among shards by index.
- Use flags `--gtest_total_shards=<N>` and `--gtest_shard_index=<i>`.

Example:

```bash
# Run the first shard of 3
./my_tests --gtest_total_shards=3 --gtest_shard_index=0

# Run the second shard
./my_tests --gtest_total_shards=3 --gtest_shard_index=1
```

### Use Cases
- Distribute tests across multiple machines or executors.
- Reduce per-run time and improve continuous integration throughput.

### Important Notes
- Test ordering is not guaranteed within shards.
- Make sure tests do not depend on order or tests in other shards.

---

## 4. Per-Test and Per-Suite Setup Optimization

Heavy setup and teardown operations can significantly impact test performance.

### Best Practices

- Move expensive setup to global or suite-level fixture `SetUpTestSuite()` and `TearDownTestSuite()`, instead of per-test `SetUp()` and `TearDown()`.
- Cache and reuse resources where possible.
- Keep test fixtures minimal and avoid unnecessary allocations inside them.

---

## 5. Writing Focused and Efficient Tests

Avoid bloated and overlapping tests to improve speed and maintainability.

### Test Design Tips

- Write small, focused tests that check a single behavior.
- Avoid interacting with external dependencies unless necessary—mock where possible.
- Prefer using `EXPECT_*` assertions over `ASSERT_*` to allow multiple checks in one run.

---

## 6. Using Mocks and Stubbing Effectively

Mocks help isolate code under test and reduce test execution time by replacing slow or unreliable dependencies.

### Guidelines

- Use mocks to eliminate dependencies on slow resources like databases or network.
- Set expectations and default behaviors properly to avoid unnecessary failures and retries.
- Prefer `NiceMock` when you want to suppress warnings about uninteresting calls.

---

## 7. Troubleshooting Flaky and Slow Tests

Flaky tests cause intermittent failures and slow tests increase the feedback loop.

### Diagnosis

- Run tests with verbose output (`--gtest_verbose=info`) to get detailed insights.
- Isolate slow tests using filtering and profile them individually.
- Check for shared global states or external resource contention.

### Solutions

- Refactor tests to be deterministic.
- Parallelize or shard tests to isolate flaky ones.
- Use appropriate timeouts and teardown mechanisms.

---

## 8. Leveraging External Tools and Integrations

Integrate GoogleTest with your build and CI systems to maximize performance.

### Examples

- Use CMake or Bazel test runners with parallel execution support.
- Integrate XML test reports to track flaky or slow tests over time.
- Use custom scripts or tools to distribute and schedule test shards.

---

## Additional Resources

- [GoogleTest Primer](primer.md) — Fundamental test writing strategies.
- [Scaling Test Suites and Optimizing Performance Guide](guides/advanced-and-best-practices/scaling-and-performance.md) — Detailed techniques for test scalability.
- [Integration with Build Systems](overview/integrations/integration-with-build-systems.md) — Setup parallel runs in your build.
- [Mocking and Using Mocks](guides/core-testing-workflows/using-mocks.md) — Best practices for mocks to speed tests.

---

By applying these strategies progressively, you will optimize your test runs effectively, enabling faster iterations and more maintainable test suites across your projects.

<Check>
Remember to always verify that your tests remain reliable and meaningful after optimizations. Performance gains should never come at the expense of test correctness or coverage.
</Check>
